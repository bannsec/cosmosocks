#ifndef COSMOPOLITAN_H_
#define COSMOPOLITAN_H_


/*!BEGIN libc/integral/normalize.inc */

#define __COSMOPOLITAN__ 1

#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#if __GNUC__ + 0 < 2
#undef __GNUC__
#elif defined(__GNUC__) && defined(SWIG) /* lool */
#undef __GNUC__
#elif defined(__GNUC__) && defined(__NVCC__) /* lool */
#undef __GNUC__
#elif !defined(__GNUC__) && defined(__APPLE__) /* modesty */
#define __GNUC__            4
#define __GNUC_MINOR__      2
#define __GNUC_PATCHLEVEL__ 1
#elif !defined(__GNUC__) && defined(__TINYC__)
#define __GNUC__            2
#define __GNUC_MINOR__      0
#define __GNUC_PATCHLEVEL__ 0
#endif

#if !defined(__x86_64__) && \
    (defined(__amd64__) || (defined(_M_AMD64) && defined(_M_X64)))
#define __x86_64__ 1
#elif !defined(__i386__) && ((defined(__i486__) || defined(__i586__) ||  \
                              defined(__i686__) || defined(__i786__)) || \
                             _M_IX86 + 0 >= 400)
#define __i386__ 1
#elif !defined(__ia16__) && (defined(__MSDOS__) || defined(__BCC__))
#define __ia16__ 1
#endif
#if __ia16__ + __i386__ + __x86_64__ + 0
#define __x86__ 1
#endif

#ifdef _MSC_VER
#define __STRICT_ANSI__
#ifndef __STDC__
#define __STDC__
#endif
#endif

#ifndef __has_attribute
#define __has_attribute(x) 0
#endif
#ifndef __has_builtin
#define __has_builtin(x) 0
#endif
#ifndef __has_cpp_attribute
#define __has_cpp_attribute(x) 0
#endif
#ifndef __has_extension
#define __has_extension(x) 0
#endif

#ifdef unix
#undef unix
#endif

#ifdef linux
#undef linux
#endif

#ifndef __BIGGEST_ALIGNMENT__
#define __BIGGEST_ALIGNMENT__ 16
#endif

#define BIGPAGESIZE 0x200000
#define STACKSIZE   0x20000
#define FRAMESIZE   0x10000 /* 8086 */
#define PAGESIZE    0x1000  /* i386+ */
#define BUFSIZ      0x1000  /* best stdio default */
#define CACHELINE   0x40    /* nexgen32e */
#define CHAR_BIT    8       /* b/c von neumann */
#define ARG_MAX     0xfffe  /* for argv and envp; see CreateProcess (32767*2) */
#define PATH_MAX    1024    /* b/c _XOPEN_PATH_MAX */
#define NAME_MAX    63      /* b/c dns */
#define CHILD_MAX   16      /* only if malloc isn't linked */
#define OPEN_MAX    16      /* only if malloc isn't linked */
#define ATEXIT_MAX  32      /* only if malloc isn't linked */
#define NSIG        128     /* b/c freebsd */

#if defined(__LP64__) && !defined(__INT64_TYPE__)


/*!BEGIN libc/integral/lp64.inc */

#define __INT8_MAX__    0x7f
#define __UINT8_MAX__   0xff
#define __INT16_MAX__   0x7fff
#define __UINT16_MAX__  0xffff
#define __SHRT_MAX__    0x7fff
#define __INT_MAX__     0x7fffffff
#define __INT32_MAX__   0x7fffffff
#define __UINT32_MAX__  0xffffffffu
#define __INT64_MAX__   0x7fffffffffffffffl
#define __UINT64_MAX__  0xfffffffffffffffful
#define __SIZE_MAX__    0xfffffffffffffffful
#define __INTPTR_MAX__  0x7fffffffffffffffl
#define __UINTPTR_MAX__ 0xfffffffffffffffful
#define __WINT_MAX__    0xffffffffu
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __INTMAX_MAX__  0x7fffffffffffffffL

#define __SIZEOF_SHORT__       2
#define __SIZEOF_INT__         4
#define __SIZEOF_LONG__        8
#define __SIZEOF_LONG_LONG__   8
#define __SIZEOF_POINTER__     8
#define __SIZEOF_PTRDIFF_T__   8
#define __SIZEOF_SIZE_T__      8
#define __SIZEOF_WCHAR_T__     4
#define __SIZEOF_WINT_T__      4
#define __SIZEOF_FLOAT__       4
#define __SIZEOF_FLOAT128__    16
#define __SIZEOF_DOUBLE__      8
#define __SIZEOF_FLOAT80__     16
#define __SIZEOF_LONG_DOUBLE__ 16

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define __CHAR16_TYPE__  short unsigned int
#define __CHAR32_TYPE__  unsigned int
#define __INT16_TYPE__   short int
#define __INT32_TYPE__   int
#define __INT64_TYPE__   long int
#define __INT8_TYPE__    signed char
#define __INTMAX_TYPE__  long int
#define __INTPTR_TYPE__  long int
#define __PTRDIFF_TYPE__ long int
#define __SIZE_TYPE__    long unsigned int
#define __UINT16_TYPE__  short unsigned int
#define __UINT32_TYPE__  unsigned int
#define __UINT64_TYPE__  long unsigned int
#define __UINT8_TYPE__   unsigned char
#define __UINTMAX_TYPE__ long unsigned int
#define __UINTPTR_TYPE__ long unsigned int
#define __WCHAR_TYPE__   int
#define __WINT_TYPE__    unsigned int

#define __INT_LEAST8_TYPE__   __INT8_TYPE__
#define __UINT_LEAST8_TYPE__  __UINT8_TYPE__
#define __INT_LEAST16_TYPE__  __INT32_TYPE__
#define __UINT_LEAST16_TYPE__ __UINT16_TYPE__
#define __INT_LEAST32_TYPE__  __INT16_TYPE__
#define __UINT_LEAST32_TYPE__ __UINT32_TYPE__
#define __INT_LEAST64_TYPE__  __INT64_TYPE__
#define __UINT_LEAST64_TYPE__ __UINT64_TYPE__
#define __INT_FAST8_TYPE__    __INT8_TYPE__
#define __UINT_FAST8_TYPE__   __UINT8_TYPE__
#define __INT_FAST16_TYPE__   __INT32_TYPE__
#define __UINT_FAST16_TYPE__  __UINT32_TYPE__
#define __INT_FAST32_TYPE__   __INT32_TYPE__
#define __UINT_FAST32_TYPE__  __UINT32_TYPE__
#define __INT_FAST64_TYPE__   __INT64_TYPE__
#define __UINT_FAST64_TYPE__  __UINT64_TYPE__

#endif
#elif defined(_MSC_VER) && !defined(__INT64_TYPE__)


/*!BEGIN libc/integral/llp64.inc */

#define __INT8_MAX__    0x7f
#define __UINT8_MAX__   0xff
#define __INT16_MAX__   0x7fff
#define __UINT16_MAX__  0xffff
#define __SHRT_MAX__    0x7fff
#define __INT_MAX__     0x7fffffff
#define __INT32_MAX__   0x7fffffff
#define __UINT32_MAX__  0xffffffffu
#define __INT64_MAX__   0x7fffffffffffffffl
#define __UINT64_MAX__  0xffffffffffffffffull
#define __SIZE_MAX__    0xffffffffffffffffull
#define __INTPTR_MAX__  0x7fffffffffffffffll
#define __UINTPTR_MAX__ 0xffffffffffffffffull
#define __WINT_MAX__    0xffffffffu

#define __SIZEOF_SHORT__       2
#define __SIZEOF_INT__         4
#define __SIZEOF_LONG__        4
#define __SIZEOF_LONG_LONG__   8
#define __SIZEOF_POINTER__     8
#define __SIZEOF_PTRDIFF_T__   8
#define __SIZEOF_SIZE_T__      4
#define __SIZEOF_WCHAR_T__     4
#define __SIZEOF_WINT_T__      4
#define __SIZEOF_FLOAT__       4
#define __SIZEOF_FLOAT128__    16
#define __SIZEOF_DOUBLE__      8
#define __SIZEOF_FLOAT80__     16
#define __SIZEOF_LONG_DOUBLE__ 16

#define __INT8_C(c)   c
#define __UINT8_C(c)  c
#define __INT16_C(c)  c
#define __UINT16_C(c) c
#define __INT32_C(c)  c
#define __UINT32_C(c) c##U
#define __INT64_C(c)  c##LL
#define __UINT64_C(c) c##ULL

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define __INT8_TYPE__    signed char
#define __UINT8_TYPE__   unsigned char
#define __INT16_TYPE__   short int
#define __UINT16_TYPE__  short unsigned int
#define __INT32_TYPE__   int
#define __UINT32_TYPE__  unsigned int
#define __INT64_TYPE__   long long int
#define __UINT64_TYPE__  long long unsigned int
#define __INTPTR_TYPE__  long long int
#define __UINTPTR_TYPE__ long long unsigned int
#define __PTRDIFF_TYPE__ long long int
#define __SIZE_TYPE__    unsigned int
#define __WCHAR_TYPE__   int
#define __CHAR16_TYPE__  short unsigned int
#define __CHAR32_TYPE__  unsigned int
#define __WINT_TYPE__    unsigned int

#define __INT_LEAST8_TYPE__   __INT8_TYPE__
#define __UINT_LEAST8_TYPE__  __UINT8_TYPE__
#define __INT_LEAST16_TYPE__  __INT32_TYPE__
#define __UINT_LEAST16_TYPE__ __UINT16_TYPE__
#define __INT_LEAST32_TYPE__  __INT16_TYPE__
#define __UINT_LEAST32_TYPE__ __UINT32_TYPE__
#define __INT_LEAST64_TYPE__  __INT64_TYPE__
#define __UINT_LEAST64_TYPE__ __UINT64_TYPE__
#define __INT_FAST8_TYPE__    __INT8_TYPE__
#define __UINT_FAST8_TYPE__   __UINT8_TYPE__
#define __INT_FAST16_TYPE__   __INT32_TYPE__
#define __UINT_FAST16_TYPE__  __UINT32_TYPE__
#define __INT_FAST32_TYPE__   __INT32_TYPE__
#define __UINT_FAST32_TYPE__  __UINT32_TYPE__
#define __INT_FAST64_TYPE__   __INT64_TYPE__
#define __UINT_FAST64_TYPE__  __UINT64_TYPE__

#endif
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
#ifdef __STDC__


/*!BEGIN libc/integral/c.inc */

#if __GNUC__ + 0 < 2
#define __attribute__(x)
#endif

#ifndef __cplusplus
#define COSMOPOLITAN_C_START_
#define COSMOPOLITAN_C_END_
#define COSMOPOLITAN_CXX_START_
#define COSMOPOLITAN_CXX_END_
#define COSMOPOLITAN_CXX_USING_
#endif

#ifndef __ia16__
#define __far
#endif

#if !defined(__GNUC__) && __cplusplus + 0 >= 201103L
#define typeof(x) decltype(x)
#elif (defined(__STRICT_ANSI__) || !defined(__GNUC__)) && \
    __STDC_VERSION__ + 0 < 201112
#define typeof(x) __typeof(x)
#endif

#ifdef __cplusplus
#if __cplusplus >= 201103L
#define _Alignof(x) alignof(x)
#endif /* C++11 */
#else  /* __cplusplus */
#define alignof(x) _Alignof(x)
#if __STDC_VERSION__ + 0 < 201112
#if __GNUC__ + _MSC_VER + 0 && !defined(__STRICT_ANSI__)
#define _Alignof(x) __alignof(x)
#else
#define _Alignof(x) /* basically all it ever did lool */ sizeof(x)
#endif /* GNU/MSVC/!ANSI */
#endif /* C11 */
#endif /* __cplusplus */

#if !defined(__cplusplus) && !defined(inline) && __STDC_VERSION__ + 0 < 199901
#if !defined(__STRICT_ANSI__) && (defined(__GNUC__) || defined(_MSC_VER))
#define inline __inline
#else
#define inline
#define __inline
#endif
#endif

#if __STDC_VERSION__ + 0 < 201112
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define _Alignas(x) __attribute__((__aligned__(x)))
#elif defined(_MSC_VER)
#define _Alignas(x) __declspec(align(x))
#endif
#endif

#if defined(__STRICT_ANSI__) || \
    (!defined(__GNUC__) && !__has_builtin(unreachable))
#define __builtin_unreachable() \
  for (;;) {                    \
  }
#endif

#if defined(__STRICT_ANSI__) || (!defined(__llvm__) && !__has_builtin(assume))
#define __builtin_assume(x)            \
  do {                                 \
    if (!(x)) __builtin_unreachable(); \
  } while (0)
#endif

#if __STDC_VERSION__ + 0 < 201112
#define _Atomic(TYPE) TYPE volatile
#endif

#ifdef __llvm__
#define __gnu_printf__ __printf__
#define __gnu_scanf__  __scanf__
#endif

#if __cplusplus + 0 >= 201103L
#define NULL nullptr
#elif !defined(__cplusplus)
#define NULL ((void *)0)
#else
#define NULL 0
#endif

#ifndef __cplusplus
#if __STDC_VERSION__ + 0 >= 201112
typedef _Bool bool;
#define true ((bool)+1)
#define false ((bool)+0)
#else
#define bool int
#define true 1
#define false 0
#endif
#endif

#ifndef __cplusplus
typedef __WCHAR_TYPE__ wchar_t;
typedef __CHAR16_TYPE__ char16_t;
typedef __CHAR32_TYPE__ char32_t;
#endif

#define _LIBCPP_STDINT_H

typedef int errno_t;
typedef __SIZE_TYPE__ size_t;
typedef __PTRDIFF_TYPE__ ssize_t;
typedef __INTPTR_TYPE__ intptr_t;
typedef __UINTPTR_TYPE__ uintptr_t;
typedef __PTRDIFF_TYPE__ ptrdiff_t;
typedef __WINT_TYPE__ wint_t; /* uint32_t on linux but int32_t on xnu */
typedef __INT32_TYPE__ bool32;
typedef __INT8_TYPE__ int8_t;
typedef __UINT8_TYPE__ uint8_t;
typedef __INT16_TYPE__ int16_t;
typedef __UINT16_TYPE__ uint16_t;
typedef __INT32_TYPE__ int32_t;
typedef __UINT32_TYPE__ uint32_t;
typedef __INT64_TYPE__ int64_t;
typedef __UINT64_TYPE__ uint64_t;
typedef __INTMAX_TYPE__ intmax_t;
typedef __UINTMAX_TYPE__ uintmax_t;

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 406 || defined(__llvm__)
typedef signed __int128 int128_t;
typedef unsigned __int128 uint128_t;
#endif

typedef struct {
  intptr_t ax, dx;
} axdx_t;

#ifndef __chibicc__
#define va_list            __builtin_va_list
#define va_arg(ap, type)   __builtin_va_arg(ap, type)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#define va_end(ap)         __builtin_va_end(ap)
#define va_start(ap, last) __builtin_va_start(ap, last)
#else


/*!BEGIN libc/integral/lp64arg.inc */

/* variadic arguments for chibicc */

/* <sync libc/runtime/valist.c> */
struct __va_list {
  uint32_t gp_offset;
  uint32_t fp_offset;
  void *overflow_arg_area;
  void *reg_save_area;
};
/* </sync libc/runtime/valist.c> */

void *__va_arg(struct __va_list *, size_t, unsigned, unsigned);

#define __GNUC_VA_LIST 1
#define __gnuc_va_list va_list

#define va_end(AP)
#define va_copy(DST, SRC) ((DST)[0] = (SRC)[0])
#define va_start(AP, LAST)                    \
  do {                                        \
    *(AP) = *(struct __va_list *)__va_area__; \
  } while (0)

#define va_arg(AP, TYPE)                               \
  (*(TYPE *)__va_arg(AP, sizeof(TYPE), _Alignof(TYPE), \
                     __builtin_reg_class(TYPE)))

typedef struct __va_list va_list[1];
#endif

#define libcesque   dontthrow nocallback
#define memcpyesque libcesque
#define strlenesque libcesque nosideeffect paramsnonnull()
#define vallocesque \
  libcesque dontdiscard returnsaligned((PAGESIZE)) returnspointerwithnoaliases
#define reallocesque libcesque returnsaligned((16))
#define mallocesque  reallocesque returnspointerwithnoaliases
#define interruptfn  nocallersavedregisters forcealignargpointer

#ifndef pureconst
#ifndef __STRICT_ANSI__
#define pureconst __attribute__((__const__))
#else
#define pureconst
#endif
#endif

#ifndef forcealign
#ifndef __STRICT_ANSI__
#define forcealign(bytes) __attribute__((__aligned__(bytes)))
#else
#define forcealign(bytes)
#endif
#endif

#ifndef __STRICT_ANSI__
#define thatispacked __attribute__((__packed__))
#else
#define thatispacked
#endif

#ifndef __STRICT_ANSI__
#define printfesque(n)   __attribute__((__format__(__gnu_printf__, n, n + 1)))
#define scanfesque(n)    __attribute__((__format__(__gnu_scanf__, n, n + 1)))
#define strftimeesque(n) __attribute__((__format__(__strftime__, n, 0)))
#else
#define printfesque(n)
#define scanfesque(n)
#define strftimeesque(n)
#endif

#ifndef hidden
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__visibility__) || defined(__GNUC__)) && !defined(_WIN32)
#define hidden __attribute__((__visibility__("hidden")))
#else
#define hidden
#endif
#endif

#ifndef privileged
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__visibility__) || defined(__GNUC__))
#define privileged _Section(".privileged")
#else
#define privileged _Section(".privileged")
#endif
#endif

#ifndef noinstrument
#if !defined(__STRICT_ANSI__) &&                    \
    (__has_attribute(__no_instrument_function__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 204)
#define noinstrument __attribute__((__no_instrument_function__))
#else
#define noinstrument
#endif
#endif

#ifndef wontreturn
#if !defined(__STRICT_ANSI__) &&      \
    (__has_attribute(__noreturn__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 208)
#define wontreturn __attribute__((__noreturn__))
#else
#define wontreturn
#endif
#endif

#ifndef nosideeffect
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__pure__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 296)
#define nosideeffect __attribute__((__pure__))
#else
#define nosideeffect
#endif
#endif

#ifndef dontinline
#if !defined(__STRICT_ANSI__) &&      \
    (__has_attribute(__noinline__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 301)
#define dontinline __attribute__((__noinline__))
#else
#define dontinline
#endif
#endif

#ifndef noclone
#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__noclone__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 405)
#define noclone __attribute__((__noclone__))
#else
#define noclone
#endif
#endif

#ifndef forceinline
#ifdef __cplusplus
#define forceinline inline
#else
#if !defined(__STRICT_ANSI__) && \
    (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 302
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403 || \
    !defined(__cplusplus) ||                              \
    (defined(__clang__) &&                                \
     (defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__)))
#if defined(__GNUC_STDC_INLINE__) || defined(__cplusplus)
#define forceinline                                                 \
  static __inline __attribute__((__always_inline__, __gnu_inline__, \
                                 __no_instrument_function__, __unused__))
#else
#define forceinline              \
  static __inline __attribute__( \
      (__always_inline__, __no_instrument_function__, __unused__))
#endif /* __GNUC_STDC_INLINE__ */
#endif /* GCC >= 4.3 */
#elif defined(_MSC_VER)
#define forceinline __forceinline
#else
#define forceinline static inline
#endif /* !ANSI && GCC >= 3.2 */
#endif /* __cplusplus */
#endif /* forceinline */

#ifndef mayalias
#if !defined(__STRICT_ANSI__) &&       \
    (__has_attribute(__may_alias__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 303)
#define mayalias __attribute__((__may_alias__))
#else
#define mayalias
#endif
#endif

#ifndef dontdiscard
#if !defined(__STRICT_ANSI__) &&                           \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 304 || \
     __has_attribute(__warn_unused_result__))
#define dontdiscard __attribute__((__warn_unused_result__))
#else
#define dontdiscard
#endif
#endif

#ifndef nullterminated
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__sentinel__) || __GNUC__ + 0 >= 4)
#define nullterminated(x) __attribute__((__sentinel__ x))
#else
#define nullterminated(x)
#endif
#endif

#ifndef flattenout
#if __has_attribute(__flatten__) || \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 401 && !defined(__llvm__))
#define flattenout __attribute__((__flatten__))
#else
#define flattenout
#endif
#endif

#ifndef externinline
#if !defined(__STRICT_ANSI__) &&                           \
    (!defined(__cplusplus) ||                              \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403 || \
     (defined(__clang__) &&                                \
      (defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__))))
#if defined(__GNUC_STDC_INLINE__) || defined(__cplusplus)
#define externinline extern __inline __attribute__((__gnu_inline__))
#else
#define externinline extern __inline __attribute__((__always_inline__))
#endif
#else
#define externinline inline
#endif
#endif

#ifndef relegated
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__cold__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define relegated __attribute__((__cold__))
#else
#define relegated
#endif
#endif

#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__warning__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define warnifused(s) __attribute__((__warning__(s)))
#else
#define warnifused(s)
#endif

#ifndef firstclass
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__hot__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define firstclass __attribute__((__hot__))
#else
#define firstclass
#endif
#endif

#ifndef paramsnonnull
#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__nonnull__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define paramsnonnull(opt_1idxs) __attribute__((__nonnull__ opt_1idxs))
#else
#define paramsnonnull(opt_1idxs)
#endif
#endif

#if __STDC_VERSION__ + 0 >= 199901L
#define hasatleast static
#else
#define hasatleast
#endif

#if __STDC_VERSION__ + 0 < 199901L && !defined(restrict)
#if !defined(__STRICT_ANSI__) && !defined(__cplusplus) && \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 301 || defined(_MSC_VER))
#define restrict __restrict__
#else
#define restrict
#define __restrict
#endif
#endif

#ifndef nocallback
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__leaf__) || \
     (!defined(__llvm__) &&       \
      (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 406))
#define nocallback __attribute__((__leaf__))
#else
#define nocallback
#endif
#endif

#ifndef dontthrow
#if defined(__cplusplus) && !defined(__STRICT_ANSI__) && \
    (__has_attribute(dontthrow) ||                       \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 303)
#define dontthrow __attribute__((__nothrow__))
#elif defined(_MSC_VER)
#define dontthrow __declspec(nothrow)
#else
#define dontthrow
#endif
#endif

#ifndef nooptimize
#ifndef __STRICT_ANSI__
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
    __has_attribute(__optimize__)
#define nooptimize __attribute__((__optimize__(1)))
#elif defined(__llvm__) || __has_attribute(__optnone__)
#define nooptimize __attribute__((__optnone__))
#endif
#else
#define nooptimize
#endif
#endif

#ifndef optimizesize
#ifndef __STRICT_ANSI__
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
    __has_attribute(__optimize__)
#define optimizesize __attribute__((__optimize__("s")))
#elif defined(__llvm__) || __has_attribute(__optnone__)
#define optimizesize __attribute__((__optnone__))
#endif
#else
#define optimizesize
#endif
#endif

#ifndef optimizespeed
#if !defined(__STRICT_ANSI__) &&                           \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
     __has_attribute(__optimize__))
#define optimizespeed __attribute__((__optimize__(3)))
#else
#define optimizespeed
#endif
#endif

#ifndef returnstwice
#if !defined(__STRICT_ANSI__) &&           \
    (__has_attribute(__returns_twice__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 402)
#define returnstwice __attribute__((__returns_twice__))
#else
#define returnstwice
#endif
#endif

#ifndef nodebuginfo
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__nodebug__) || defined(__llvm__))
#define nodebuginfo __attribute__((__nodebug__))
#else
#define nodebuginfo
#endif
#endif

#ifndef artificial
#if !defined(__STRICT_ANSI__) &&        \
    (__has_attribute(__artificial__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define artificial __attribute__((__artificial__))
#else
#define artificial
#endif
#endif

#ifndef microarchitecture
#if !defined(__STRICT_ANSI__) &&    \
    (__has_attribute(__target__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 404)
#define microarchitecture(march) __attribute__((__target__(march)))
#else
#define microarchitecture(march)
#endif
#endif

#ifndef targetclones
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__target_clones__) || __GNUC__ >= 6)
#define targetclones(archs) __attribute__((__target_clones__(archs)))
#else
#define targetclones(archs)
#endif
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 408 || \
    __has_attribute(__force_align_arg_pointer__)
#define forcealignargpointer __attribute__((__force_align_arg_pointer__))
#else
#define forcealignargpointer "need modern compiler"
#endif

#ifndef returnsnonnull
#if !defined(__STRICT_ANSI__) &&             \
    (__has_attribute(__returns_nonnull__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnsnonnull __attribute__((__returns_nonnull__))
#else
#define returnsnonnull
#endif
#endif

#if !defined(__STRICT_ANSI__) &&            \
    (__has_attribute(__assume_aligned__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnsaligned(x) __attribute__((__assume_aligned__ x))
#else
#define returnsaligned(x)
#endif

#ifndef returnspointerwithnoaliases
#if !defined(__STRICT_ANSI__) &&    \
    (__has_attribute(__malloc__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnspointerwithnoaliases __attribute__((__malloc__))
#elif defined(_MSC_VER)
#define returnspointerwithnoaliases __declspec(allocator)
#else
#define returnspointerwithnoaliases
#endif
#endif

#ifndef attributeallocsize
#if !defined(__STRICT_ANSI__) &&        \
    (__has_attribute(__alloc_size__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define attributeallocsize(x) __attribute__((__alloc_size__ x))
#else
#define attributeallocsize(x)
#endif
#endif

#ifndef attributeallocalign
#if !defined(__STRICT_ANSI__) &&         \
    (__has_attribute(__alloc_align__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define attributeallocalign(x) __attribute__((__alloc_align__ x))
#else
#define attributeallocalign(x)
#endif
#endif

#if __cplusplus + 0 >= 201103L
#define autotype(x) auto
#elif ((__has_builtin(auto_type) || defined(__llvm__) ||       \
        (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409) && \
       !defined(__chibicc__))
#define autotype(x) __auto_type
#else
#define autotype(x) typeof(x)
#endif

#if __GNUC__ >= 7 || __has_attribute(__no_caller_saved_registers__)
#define nocallersavedregisters __attribute__((__no_caller_saved_registers__))
#else
#define nocallersavedregisters "need modern compiler"
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 408 || \
    __has_attribute(__no_sanitize_address__)
#define noasan __attribute__((__no_sanitize_address__))
#else
#define noasan
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 408 || \
    __has_attribute(__no_sanitize_undefined__)
#define noubsan __attribute__((__no_sanitize_undefined__))
#else
#define noubsan
#endif

#ifndef unreachable
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define unreachable __builtin_unreachable()
#else
#define unreachable \
  do {              \
  } while (1)
#endif
#endif

#define donothing \
  do {            \
  } while (0)

#ifndef __STRICT_ANSI__
#define testonly    dontinline _Section(".test")
#define textstartup _Section(".text.startup") noinstrument
#define textexit    _Section(".text.exit") noinstrument
#define textreal    _Section(".text.real")
#define texthead    _Section(".text.head")
#define textwindows _Section(".text.windows")
#define antiquity   _Section(".text.antiquity")
#else
#define testonly
#define textstartup
#define textexit
#define textreal
#define texthead
#define textwindows
#define antiquity
#endif

#ifndef compatfn
#define compatfn
#endif

#ifndef frownedupon
#define frownedupon(alternative)
#endif

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define _Vector_size(k) __attribute__((__vector_size__(k)))
#else
#define _Vector_size(k) [k]
#endif

#if defined(__STRICT_ANSI__) || \
    (!defined(__GNUC__) && !defined(__builtin_offsetof))
#define offsetof(type, member) ((unsigned long)&((type *)0)->member)
#else
#define offsetof(type, member) __builtin_offsetof(type, member)
#endif

#ifdef __llvm__
#define __builtin_ia32_movntdq(x, y) (*(x) = (y))
#endif

#ifndef _Section
#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define _Section(s) __attribute__((__section__(s)))
#else
#define _Section(s)
#endif
#endif

#ifndef __llvm__
#define initarray _Section(".init_array,\"a\",@init_array #")
#else
#define initarray _Section(".init_array")
#endif

#ifndef __STRICT_ANSI__
#if defined(__GNUC__) || defined(__llvm__)
#pragma GCC diagnostic ignored "-Wundef" /* complaints about __ASSEMBLER__/__LINKER__  */
#pragma GCC diagnostic ignored "-Wsign-compare" /* lint needs to change  */
#pragma GCC diagnostic ignored "-Wtype-limits" /* makes macros unsafe  */
#pragma GCC diagnostic ignored "-Woverflow" /* also breaks macros  */
#pragma GCC diagnostic ignored "-Wformat" /* forces only gnu pf */
#pragma GCC diagnostic ignored "-Wunused-parameter" /* extreme prejudice */
#pragma GCC diagnostic ignored "-Wunused-function" /* contradicts dce! */
#pragma GCC diagnostic ignored "-Wunused-const-variable" /* let me dce */
#pragma GCC diagnostic ignored "-Wunused-variable" /* belongs in tidy */
#pragma GCC diagnostic ignored "-Wformat-extra-args" /* is also broken */
#pragma GCC diagnostic ignored "-Wparentheses" /* annoying tidy */
#pragma GCC diagnostic ignored "-Wdangling-else" /* come on tidy */
#pragma GCC diagnostic ignored "-Wformat-security" /* come on tidy */
#pragma GCC diagnostic ignored "-Wunused-value" /* breaks macros */
#pragma GCC diagnostic ignored "-Wdeprecated-declarations" /* libcxx */
#ifndef __cplusplus
#pragma GCC diagnostic ignored "-Wimplicit-int"
#pragma GCC diagnostic ignored "-Wc++-compat"
#endif /* C++ */
#endif /* GCC || LLVM */
#if defined(__GNUC__) && !defined(__llvm__)
/* why we need authorization to name a variable `yn' */
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"
#pragma GCC diagnostic ignored "-Wfree-nonheap-object" /* broken #54202 */
#ifndef __cplusplus
#if __GNUC__ >= 6
#pragma GCC diagnostic ignored /* wut */ "-Wdiscarded-qualifiers"
#pragma GCC diagnostic ignored /* tidy */ "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored /* tidy */ "-Wunused-but-set-parameter"
#endif /* GCC6+ */
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wstringop-truncation"
#pragma GCC diagnostic ignored "-Wstringop-overflow" /* breaks strndup */
#endif /* GCC8+ */
#if __GNUC__ + 0 >= 9
#pragma GCC diagnostic ignored /* "always true" breaks dce */ "-Waddress"
#endif /* GCC9+ */
#endif /* !C++ */
#endif /* GCC && !LLVM */
#ifdef __llvm__
#pragma clang diagnostic ignored \
    "-Wincompatible-pointer-types-discards-qualifiers"
#pragma clang diagnostic ignored "-Wbuiltin-requires-header"
#pragma clang diagnostic ignored "-Wparentheses-equality" /*-save-temps*/
#pragma clang diagnostic ignored "-Wunused-value" /*({-save-temps})*/
#pragma clang diagnostic ignored "-Wstring-plus-int" /* special ed */
#pragma clang diagnostic ignored "-Wunused-value" /* extreme prejudice */
#pragma clang diagnostic ignored "-Wbuiltin-requires-header"
#pragma clang diagnostic ignored \
    "-Wincompatible-pointer-types-discards-qualifiers"
#endif /* !GCC && LLVM */
#endif /* ANSI */

#ifndef __W__
#ifndef __STRICT_ANSI__
#if defined(__GNUC__) || defined(__llvm__)
#pragma GCC diagnostic error "-Wpointer-arith"
#pragma GCC diagnostic error "-Wnonnull"
#pragma GCC diagnostic error "-Wunused-result"
#pragma GCC diagnostic error "-Wuninitialized"
#pragma GCC diagnostic error "-Wstrict-aliasing"
#pragma GCC diagnostic error "-Wshift-negative-value"
#ifndef __cplusplus
#pragma GCC diagnostic error "-Wimplicit-function-declaration"
#if __GNUC__ >= 6
#pragma GCC diagnostic error "-Wincompatible-pointer-types"
#if __GNUC__ >= 8
#pragma GCC diagnostic error "-Wmultistatement-macros"
#pragma GCC diagnostic error "-Wpacked-not-aligned"
#pragma GCC diagnostic error "-Wcast-align=strict"
#pragma GCC diagnostic error "-Wif-not-aligned"
#endif /* GCC 8+ */
#endif /* GCC 6+ */
#endif /* __cplusplus */
#endif /* GCC || LLVM */
#if defined(__GNUC__) && !defined(__llvm__)
#pragma GCC diagnostic error "-Wwrite-strings"
#pragma GCC diagnostic error "-Wtrampolines"
#pragma GCC diagnostic error "-Wmaybe-uninitialized"
#pragma GCC diagnostic error "-Wredundant-decls"
#if __GNUC__ >= 6
#pragma GCC diagnostic error "-Wnonnull-compare"
#if defined(COSMO) && !defined(MODE_DBG) && !defined(STACK_FRAME_UNLIMITED)
#pragma GCC diagnostic error "-Wframe-larger-than=4096"
#if __GNUC__ >= 9
#pragma GCC diagnostic error "-Walloca-larger-than=1024"
#pragma GCC diagnostic error "-Wvla-larger-than=1024"
#endif /* GCC 9+ */
#endif /* STACK_FRAME_UNLIMITED */
#elif __GNUC__ >= 9
#pragma GCC diagnostic error /* e.g. fabs not abs */ "-Wabsolute-value"
#endif /* GCC 6+ */
#endif /* GCC && !LLVM */
#ifdef __llvm__
#pragma clang diagnostic error "-Wassume"
#endif /* !GCC && LLVM */
#endif /* ANSI */
#endif /* -w */

#ifndef __STRICT_ANSI__
#define DebugBreak() asm("int3")
#else
#define DebugBreak() (void)0
#endif

#ifndef __STRICT_ANSI__
#define VEIL(CONSTRAINT, EXPRESSION)                             \
  ({                                                             \
    autotype(EXPRESSION) VeiledValue = (EXPRESSION);             \
    asm("" : "=" CONSTRAINT ""(VeiledValue) : "0"(VeiledValue)); \
    VeiledValue;                                                 \
  })
#else
#define VEIL(CONSTRAINT, EXPRESSION) (EXPRESSION)
#endif

#ifndef __STRICT_ANSI__
#define CONCEAL(CONSTRAINT, EXPRESSION)                                   \
  ({                                                                      \
    autotype(EXPRESSION) VeiledValue = (EXPRESSION);                      \
    asm volatile("" : "=" CONSTRAINT ""(VeiledValue) : "0"(VeiledValue)); \
    VeiledValue;                                                          \
  })
#else
#define CONCEAL(CONSTRAINT, EXPRESSION) (EXPRESSION)
#endif

#ifndef __STRICT_ANSI__
#define EXPROPRIATE(EXPRESSION)                    \
  ({                                               \
    asm volatile("" ::"g"(EXPRESSION) : "memory"); \
    0;                                             \
  })
#else
#define EXPROPRIATE(EXPRESSION) (EXPRESSION)
#endif

#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define YOINK(SYMBOL) \
  asm(".section .yoink\n\tnopl\t%a0\n\t.previous" : : "X"(SYMBOL))
#else
#define YOINK(SYMBOL) (void)0
#endif

#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define STATIC_YOINK(SYMBOLSTR) \
  asm(".section .yoink\n\tnopl\t\"" SYMBOLSTR "\"\n\t.previous")
#else
#define STATIC_YOINK(SYMBOLSTR)
#endif

#if !defined(IM_FEELING_NAUGHTY)
#define STATIC_YOINK_SOURCE(PATH) STATIC_YOINK(PATH)
#else
#define STATIC_YOINK_SOURCE(PATH)
#endif

#define MACHINE_CODE_ANALYSIS_BEGIN_
#define MACHINE_CODE_ANALYSIS_END_
#else
#define const
#define volatile
#endif
#ifdef __cplusplus


/*!BEGIN libc/integral/cxx.inc */

#define COSMOPOLITAN_CXX_START_ namespace cosmo {
#define COSMOPOLITAN_CXX_END_   }
#define COSMOPOLITAN_CXX_USING_ using namespace cosmo;
#define COSMOPOLITAN_C_START_   extern "C" {
#define COSMOPOLITAN_C_END_     }

#if !defined(__builtin_types_compatible_p) && !__has_builtin(types_compatible_p)
#if 0 /* todo jart whyyyy */


/*!BEGIN libc/integral/cxxtypescompat.inc */

#define NAME __cxx_types_compatible
#define QUALIFIED(Q1, Q2)       \
  template <class _T, class _U> \
  struct NAME<_T Q1, _U Q2> : NAME<_T, _U> {}

template <class, class>
struct NAME {
  enum { _value = 0 };
};

template <class _T>
struct NAME<_T, _T> {
  enum { _value = 1 };
};

template <class _T, size_t N>
struct NAME<_T[], _T[N]> {
  enum { _value = 1 };
};

template <class _T, size_t N>
struct NAME<_T[N], _T[]> {
  enum { _value = 1 };
};

QUALIFIED(const volatile, );
QUALIFIED(const volatile, const);
QUALIFIED(const, const volatile);
QUALIFIED(volatile, const volatile);
QUALIFIED(const volatile, volatile);
QUALIFIED(const, volatile);
QUALIFIED(volatile, const);
QUALIFIED(, const);
QUALIFIED(const, );
QUALIFIED(, volatile);
QUALIFIED(volatile, );

#undef QUALIFIED
#undef NAME
#define __builtin_types_compatible_p(A, B) \
  (__cxx_types_compatible<A, B>::_value)
#else
#define __builtin_types_compatible_p(A, B) 0
#endif
#endif

#if !defined(__builtin_choose_expr) && !__has_builtin(choose_expr)
#if 1
template <bool _P, typename _T, typename _U>
struct __cxx_choose_expr {
  __cxx_choose_expr(_T _a, _U _b) : _value(_a) {}
  const _T _value;
};
template <typename _T, typename _U>
struct __cxx_choose_expr<false, _T, _U> {
  __cxx_choose_expr(_T _a, _U _b) : _value(_b) {}
  const _U _value;
};
#define __builtin_choose_expr(X, A, B) \
  (__cxx_choose_expr<X, typeof(A), typeof(B)>(A, B)._value)
#else
#define __builtin_choose_expr(X, A, B) ((X) ? (A) : (B))
#endif
#endif
#endif
#endif


/*!BEGIN ape/config.h */

#define COSMOPOLITAN_APE_CONFIG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define STATIC_SYMBOL(NAME, VALUE)   \
  asm(".equ\t" NAME "," VALUE "\n\t" \
      ".globl\t" NAME)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN ape/loader.h */

#define COSMOPOLITAN_APE_LOADER_H_

#define APE_LOADER_BASE  0x200000
#define APE_LOADER_SIZE  0x200000
#define APE_LOADER_ENTRY 0x200400
#define APE_LOADER_BSS   (PAGESIZE * 2)
#define APE_LOADER_STACK 0x7f0000000000
#define APE_BLOCK_BASE   0x7e0000000000
#define APE_BLOCK_SIZE   0x000200000000

struct ApeLoader {
  int fd;
  int os;
  char *prog;
  char *page;
  void *syscall;
};



/*!BEGIN ape/relocations.h */

#define COSMOPOLITAN_APE_RELOCATIONS_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ αcτµαlly pδrταblε εxεcµταblε § relocations                                   │
╚──────────────────────────────────────────────────────────────────────────────╝
  One of the things αcτµαlly pδrταblε εxεcµταblε does a good job
  abstracting, is how a program needs to exist at three addresses
  simultaneously during the early stages of the loading process.

  By default, the linker calculates all symbols using virtual addresses.
  In some cases it's necessary to use addend macros that change virtual
  addresses into the other two types: physical and real. */

#define IMAGE_BASE_REAL 0x2000

#ifndef IMAGE_BASE_VIRTUAL
#define IMAGE_BASE_VIRTUAL 0x400000
#endif

#ifndef IMAGE_BASE_PHYSICAL
#define IMAGE_BASE_PHYSICAL 0x100000
#endif

/**
 * Returns Relative Virtual Address.
 */
#define RVA(x) ((x) - (IMAGE_BASE_VIRTUAL))

/**
 * Adjusts virtual address so it's relative to load address.
 */
#define PHYSICAL(x) ((x) - (IMAGE_BASE_VIRTUAL - IMAGE_BASE_PHYSICAL))

/**
 * Makes high-entropy read-only addresses relocatable in real mode.
 */
#define REAL(x) ((x) - (IMAGE_BASE_VIRTUAL - IMAGE_BASE_REAL))

#if IMAGE_BASE_VIRTUAL % 0x200000 != 0
#error "IMAGE_BASE_VIRTUAL must be 2mb aligned"
#endif
#if IMAGE_BASE_PHYSICAL % 0x1000 != 0
#error "IMAGE_BASE_PHYSICAL must be 4kb aligned"
#endif
#if IMAGE_BASE_REAL % 0x1000 != 0
#error "IMAGE_BASE_REAL must be 4kb aligned"
#endif



/*!BEGIN libc/assert.h */

#define COSMOPOLITAN_LIBC_ASSERT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern bool __assert_disable;
void __assert_fail(const char *, const char *, int) hidden relegated;

#ifdef NDEBUG
#define assert(EXPR) ((void)0)
#else
#define assert(EXPR) \
  ((void)((EXPR) || (__assert_fail(#EXPR, __FILE__, __LINE__), 0)))
#endif

#ifndef __cplusplus
#define static_assert _Static_assert
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/atomic.h */

#define COSMOPOLITAN_LIBC_ATOMIC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview C11 Atomic Types
 *
 * We supoprt C++ and old C compilers. It's recommended you use macros
 * like `_Atomic(int)` rather than `_Atomic int` or `atomic_int` since
 * we only define a portability macro for the syntax `_Atomic(T)`.
 *
 * @see libc/integral/c.inc
 * @see libc/intrin/atomic.h
 */

#define atomic_bool           _Atomic(_Bool)
#define atomic_bool32         atomic_int32
#define atomic_char           _Atomic(char)
#define atomic_schar          _Atomic(signed char)
#define atomic_uchar          _Atomic(unsigned char)
#define atomic_short          _Atomic(short)
#define atomic_ushort         _Atomic(unsigned short)
#define atomic_int            _Atomic(int)
#define atomic_uint           _Atomic(unsigned int)
#define atomic_long           _Atomic(long)
#define atomic_ulong          _Atomic(unsigned long)
#define atomic_llong          _Atomic(long long)
#define atomic_ullong         _Atomic(unsigned long long)
#define atomic_char16_t       _Atomic(char16_t)
#define atomic_char32_t       _Atomic(char32_t)
#define atomic_wchar_t        _Atomic(wchar_t)
#define atomic_intptr_t       _Atomic(intptr_t)
#define atomic_uintptr_t      _Atomic(uintptr_t)
#define atomic_size_t         _Atomic(size_t)
#define atomic_ptrdiff_t      _Atomic(ptrdiff_t)
#define atomic_int_fast8_t    _Atomic(int_fast8_t)
#define atomic_uint_fast8_t   _Atomic(uint_fast8_t)
#define atomic_int_fast16_t   _Atomic(int_fast16_t)
#define atomic_uint_fast16_t  _Atomic(uint_fast16_t)
#define atomic_int_fast32_t   _Atomic(int_fast32_t)
#define atomic_uint_fast32_t  _Atomic(uint_fast32_t)
#define atomic_int_fast64_t   _Atomic(int_fast64_t)
#define atomic_uint_fast64_t  _Atomic(uint_fast64_t)
#define atomic_int_least8_t   _Atomic(int_least8_t)
#define atomic_uint_least8_t  _Atomic(uint_least8_t)
#define atomic_int_least16_t  _Atomic(int_least16_t)
#define atomic_uint_least16_t _Atomic(uint_least16_t)
#define atomic_int_least32_t  _Atomic(int_least32_t)
#define atomic_uint_least32_t _Atomic(uint_least32_t)
#define atomic_int_least64_t  _Atomic(int_least64_t)
#define atomic_uint_least64_t _Atomic(uint_least64_t)

#ifdef __CLANG_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_BOOL_LOCK_FREE     __CLANG_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE     __CLANG_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __CLANG_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __CLANG_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE  __CLANG_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE    __CLANG_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE      __CLANG_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE     __CLANG_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE    __CLANG_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE  __CLANG_ATOMIC_POINTER_LOCK_FREE
#else
#define ATOMIC_BOOL_LOCK_FREE     __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE     __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE  __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE    __GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE      __GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE     __GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE    __GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE  __GCC_ATOMIC_POINTER_LOCK_FREE
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/complex.h */

#define COSMOPOLITAN_LIBC_COMPLEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
#if __STDC_VERSION__ + 0 >= 201112 && !defined(__STDC_NO_COMPLEX__)

#define complex   _Complex
#define imaginary _Imaginary

double cabs(complex double);
double carg(complex double);
double cimag(complex double);
double creal(complex double);

float cabsf(complex float);
float cargf(complex float);
float cimagf(complex float);
float crealf(complex float);

long double cabsl(complex long double);
long double cargl(complex long double);
long double cimagl(complex long double);
long double creall(complex long double);

complex double cacos(complex double);
complex double cacosh(complex double);
complex double casin(complex double);
complex double casinh(complex double);
complex double catan(complex double);
complex double catanh(complex double);
complex double ccos(complex double);
complex double ccosh(complex double);
complex double cexp(complex double);
complex double cexp2(complex double);
complex double clog(complex double);
complex double conj(complex double);
complex double cpow(complex double, complex double);
complex double cproj(complex double);
complex double csin(complex double);
complex double csinh(complex double);
complex double csqrt(complex double);
complex double ctan(complex double);
complex double ctanh(complex double);

complex float cacosf(complex float);
complex float cacoshf(complex float);
complex float casinf(complex float);
complex float casinhf(complex float);
complex float catanf(complex float);
complex float catanhf(complex float);
complex float ccosf(complex float);
complex float ccoshf(complex float);
complex float cexpf(complex float);
complex float cexp2f(complex float);
complex float clogf(complex float);
complex float conjf(complex float);
complex float cpowf(complex float, complex float);
complex float cprojf(complex float);
complex float csinf(complex float);
complex float csinhf(complex float);
complex float csqrtf(complex float);
complex float ctanf(complex float);
complex float ctanhf(complex float);

complex long double cprojl(complex long double);
complex long double csinhl(complex long double);
complex long double csinl(complex long double);
complex long double csqrtl(complex long double);
complex long double ctanhl(complex long double);
complex long double ctanl(complex long double);
complex long double cacoshl(complex long double);
complex long double cacosl(complex long double);
complex long double casinhl(complex long double);
complex long double casinl(complex long double);
complex long double catanhl(complex long double);
complex long double catanl(complex long double);
complex long double ccoshl(complex long double);
complex long double ccosl(complex long double);
complex long double cexpl(complex long double);
complex long double cexp2l(complex long double);
complex long double clogl(complex long double);
complex long double conjl(complex long double);
complex long double cpowl(complex long double, complex long double);

#ifndef __cplusplus
#define __CIMAG(x, t)   \
  (+(union {            \
      _Complex t __z;   \
      t __xy[2];        \
    }){(_Complex t)(x)} \
        .__xy[1])
#define creal(x)  ((double)(x))
#define crealf(x) ((float)(x))
#define creall(x) ((long double)(x))
#define cimag(x)  __CIMAG(x, double)
#define cimagf(x) __CIMAG(x, float)
#define cimagl(x) __CIMAG(x, long double)
#endif

#ifdef __GNUC__
#define _Complex_I (__extension__(0.0f + 1.0fi))
#else
#define _Complex_I (0.0f + 1.0fi)
#endif

#ifdef _Imaginary_I
#define __CMPLX(x, y, t) ((t)(x) + _Imaginary_I * (t)(y))
#elif defined(__clang__)
#define __CMPLX(x, y, t) (+(_Complex t){(t)(x), (t)(y)})
#else
#define __CMPLX(x, y, t) (__builtin_complex((t)(x), (t)(y)))
#endif

#define CMPLX(x, y)  __CMPLX(x, y, double)
#define CMPLXF(x, y) __CMPLX(x, y, float)
#define CMPLXL(x, y) __CMPLX(x, y, long double)

#endif /* C11 */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dce.h */

#define COSMOPOLITAN_LIBC_DCE_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § autotune » dead code elimination                              │
╚─────────────────────────────────────────────────────────────────────────────*/

#ifndef SUPPORT_VECTOR
/**
 * Supported Platforms Tuning Knob (Runtime & Compile-Time)
 * Tuning this bitmask will remove platform polyfills at compile-time.
 */
#define SUPPORT_VECTOR 255
#endif

#define LINUX   1
#define METAL   2
#define WINDOWS 4
#define XNU     8
#define OPENBSD 16
#define FREEBSD 32
#define NETBSD  64

#ifdef NDEBUG
#define NoDebug() 1
#else
#define NoDebug() 0
#endif

#ifdef MODE_DBG
#define IsModeDbg() 1
#else
#define IsModeDbg() 0
#endif

#ifdef __MFENTRY__
#define HaveFentry() 1
#else
#define HaveFentry() 0
#endif

#ifdef TRUSTWORTHY
#define IsTrustworthy() 1
#else
#define IsTrustworthy() 0
#endif

#ifdef TINY
#define IsTiny() 1
#else
#define IsTiny() 0
#endif

#ifdef __OPTIMIZE__
#define IsOptimized() 1
#else
#define IsOptimized() 0
#endif

#ifdef __SANITIZE_ADDRESS__
#define IsAsan() 1
#else
#define IsAsan() 0
#endif

#if defined(__PIE__) || defined(__PIC__)
#define IsPositionIndependent() 1
#else
#define IsPositionIndependent() 0
#endif

#define SupportsLinux()   ((SUPPORT_VECTOR & LINUX) == LINUX)
#define SupportsMetal()   ((SUPPORT_VECTOR & METAL) == METAL)
#define SupportsWindows() ((SUPPORT_VECTOR & WINDOWS) == WINDOWS)
#define SupportsXnu()     ((SUPPORT_VECTOR & XNU) == XNU)
#define SupportsFreebsd() ((SUPPORT_VECTOR & FREEBSD) == FREEBSD)
#define SupportsOpenbsd() ((SUPPORT_VECTOR & OPENBSD) == OPENBSD)
#define SupportsNetbsd()  ((SUPPORT_VECTOR & NETBSD) == NETBSD)
#define SupportsBsd()     (!!(SUPPORT_VECTOR & (XNU | FREEBSD | OPENBSD | NETBSD)))
#define SupportsSystemv() \
  (!!(SUPPORT_VECTOR & (LINUX | XNU | OPENBSD | FREEBSD | NETBSD)))

#ifndef __ASSEMBLER__
#define IsLinux()   (SupportsLinux() && (__hostos & LINUX))
#define IsMetal()   (SupportsMetal() && (__hostos & METAL))
#define IsWindows() (SupportsWindows() && (__hostos & WINDOWS))
#define IsXnu()     (SupportsXnu() && (__hostos & XNU))
#define IsFreebsd() (SupportsFreebsd() && (__hostos & FREEBSD))
#define IsOpenbsd() (SupportsOpenbsd() && (__hostos & OPENBSD))
#define IsNetbsd()  (SupportsNetbsd() && (__hostos & NETBSD))
#define IsBsd()     (IsXnu() || IsFreebsd() || IsOpenbsd() || IsNetbsd())
#else
/* clang-format off */
#define IsLinux() $LINUX,__hostos(%rip)
#define IsMetal() $METAL,__hostos(%rip)
#define IsWindows() $WINDOWS,__hostos(%rip)
#define IsBsd() $XNU|FREEBSD|OPENBSD|NETBSD,__hostos(%rip)
#define IsXnu() $XNU,__hostos(%rip)
#define IsFreebsd() $FREEBSD,__hostos(%rip)
#define IsOpenbsd() $OPENBSD,__hostos(%rip)
#define IsNetbsd() $NETBSD,__hostos(%rip)
/* clang-format on */
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int __hostos;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dos.h */

#define COSMOPOLITAN_LIBC_DOS_H_

#define DOS_DATE(YEAR, MONTH_IDX1, DAY_IDX1) \
  (((YEAR)-1980) << 9 | (MONTH_IDX1) << 5 | (DAY_IDX1))
#define DOS_TIME(HOUR, MINUTE, SECOND) \
  ((HOUR) << 11 | (MINUTE) << 5 | (SECOND) >> 1)



/*!BEGIN libc/errno.h */

#define COSMOPOLITAN_LIBC_ERRNO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview System error codes.
 * @see libc/sysv/consts.sh for numbers
 */

#define errno (*__errno_location())

/**
 * System call unavailable.
 * @note kNtErrorInvalidFunction on NT
 */
extern const errno_t ENOSYS;

/**
 * Operation not permitted.
 * @note kNtErrorInvalidAccess on NT
 */
extern const errno_t EPERM;

/**
 * No such file or directory.
 */
extern const errno_t ENOENT;

/**
 * No such process.
 */
extern const errno_t ESRCH;

/**
 * The greatest of all errnos.
 */
extern const errno_t EINTR;

/**
 * Unix consensus.
 */
extern const errno_t EIO;

/**
 * No such device or address.
 */
extern const errno_t ENXIO;

/**
 * Argument list too errno_t.
 */
extern const errno_t E2BIG;

/**
 * Exec format error.
 */
extern const errno_t ENOEXEC;

/**
 * Bad file descriptor.
 */
extern const errno_t EBADF;

/**
 * No child process.
 */
extern const errno_t ECHILD;

/**
 * Resource temporarily unavailable (e.g. SO_RCVTIMEO expired, too many
 * processes, too much memory locked, read or write with O_NONBLOCK needs
 * polling, etc.).
 */
extern const errno_t EAGAIN;

/**
 * We require more vespene gas.
 */
extern const errno_t ENOMEM;

/**
 * Permission denied.
 */
extern const errno_t EACCES;

/**
 * Pointer passed to system call that would otherwise segfault.
 */
extern const errno_t EFAULT;

/**
 * Block device required.
 */
extern const errno_t ENOTBLK;

/**
 * Device or resource busy.
 */
extern const errno_t EBUSY;

/**
 * File exists.
 */
extern const errno_t EEXIST;

/**
 * Improper link.
 */
extern const errno_t EXDEV;

/**
 * No such device.
 */
extern const errno_t ENODEV;

/**
 * Not a directory.
 */
extern const errno_t ENOTDIR;

/**
 * Is a a directory.
 */
extern const errno_t EISDIR;

/**
 * Invalid argument.
 */
extern const errno_t EINVAL;

/**
 * Too many open files in system.
 */
extern const errno_t ENFILE;

/**
 * Too many open files.
 */
extern const errno_t EMFILE;

/**
 * Inappropriate i/o control operation.
 */
extern const errno_t ENOTTY;

/**
 * Won't open executable that's executing in write mode.
 */
extern const errno_t ETXTBSY;

/**
 * File too large.
 */
extern const errno_t EFBIG;

/**
 * No space left on device.
 */
extern const errno_t ENOSPC;

/**
 * Disk quota exceeded.
 */
extern const errno_t EDQUOT;

/**
 * Invalid seek.
 */
extern const errno_t ESPIPE;

/**
 * Read-only filesystem.
 */
extern const errno_t EROFS;

/**
 * Too many links.
 */
extern const errno_t EMLINK;

/**
 * Broken pipe.
 */
extern const errno_t EPIPE;

/**
 * Mathematics argument out of domain of function.
 */
extern const errno_t EDOM;

/**
 * Result too large.
 */
extern const errno_t ERANGE;

/**
 * Resource deadlock avoided.
 */
extern const errno_t EDEADLK;

/**
 * Filename too errno_t.
 */
extern const errno_t ENAMETOOLONG;

/**
 * No locks available.
 */
extern const errno_t ENOLCK;

/**
 * Directory not empty.
 */
extern const errno_t ENOTEMPTY;

/**
 * Too many levels of symbolic links.
 */
extern const errno_t ELOOP;

/**
 * No message error.
 */
extern const errno_t ENOMSG;

/**
 * Identifier removed.
 */
extern const errno_t EIDRM;

/**
 * Timer expired.
 */
extern const errno_t ETIME;

/**
 * Protocol error.
 */
extern const errno_t EPROTO;

/**
 * Overflow error.
 */
extern const errno_t EOVERFLOW;

/**
 * Unicode decoding error.
 */
extern const errno_t EILSEQ;

/**
 * Too many users.
 */
extern const errno_t EUSERS;

/**
 * Not a socket.
 */
extern const errno_t ENOTSOCK;

/**
 * Destination address required.
 */
extern const errno_t EDESTADDRREQ;

/**
 * Message too errno_t.
 */
extern const errno_t EMSGSIZE;

/**
 * Protocol wrong type for socket.
 */
extern const errno_t EPROTOTYPE;

/**
 * Protocol not available.
 */
extern const errno_t ENOPROTOOPT;

/**
 * Protocol not supported.
 */
extern const errno_t EPROTONOSUPPORT;

/**
 * Socket type not supported.
 */
extern const errno_t ESOCKTNOSUPPORT;

/**
 * Operation not supported.
 */
extern const errno_t ENOTSUP;

/**
 * Socket operation not supported.
 */
extern const errno_t EOPNOTSUPP;

/**
 * Protocol family not supported.
 */
extern const errno_t EPFNOSUPPORT;

/**
 * Address family not supported.
 */
extern const errno_t EAFNOSUPPORT;

/**
 * Address already in use.
 */
extern const errno_t EADDRINUSE;

/**
 * Address not available.
 */
extern const errno_t EADDRNOTAVAIL;

/**
 * Network is down.
 */
extern const errno_t ENETDOWN;

/**
 * Host is unreachable.
 */
extern const errno_t ENETUNREACH;

/**
 * Connection reset by network.
 */
extern const errno_t ENETRESET;

/**
 * Connection reset before accept.
 */
extern const errno_t ECONNABORTED;

/**
 * Connection reset by client.
 */
extern const errno_t ECONNRESET;

/**
 * No buffer space available.
 */
extern const errno_t ENOBUFS;

/**
 * Socket is connected.
 */
extern const errno_t EISCONN;

/**
 * Socket is not connected.
 */
extern const errno_t ENOTCONN;

/**
 * Cannot send after transport endpoint shutdown.
 */
extern const errno_t ESHUTDOWN;

/**
 * Too many references: cannot splice.
 */
extern const errno_t ETOOMANYREFS;

/**
 * Connection timed out.
 */
extern const errno_t ETIMEDOUT;

/**
 * Connection refused error.
 */
extern const errno_t ECONNREFUSED;

/**
 * Host down error.
 */
extern const errno_t EHOSTDOWN;

/**
 * Host unreachable error.
 */
extern const errno_t EHOSTUNREACH;

/**
 * Connection already in progress.
 */
extern const errno_t EALREADY;

/**
 * Operation already in progress.
 */
extern const errno_t EINPROGRESS;

/**
 * Stale error.
 */
extern const errno_t ESTALE;

/**
 * Remote error.
 */
extern const errno_t EREMOTE;

/**
 * Bad message.
 */
extern const errno_t EBADMSG;

/**
 * Operation canceled.
 */
extern const errno_t ECANCELED;

/**
 * Owner died.
 */
extern const errno_t EOWNERDEAD;

/**
 * State not recoverable.
 */
extern const errno_t ENOTRECOVERABLE;

/**
 * No network.
 */
extern const errno_t ENONET;

/**
 * Please restart syscall.
 */
extern const errno_t ERESTART;

/**
 * Out of streams resources.
 */
extern const errno_t ENOSR;

/**
 * No string.
 */
extern const errno_t ENOSTR;

/**
 * No data.
 */
extern const errno_t ENODATA;

/**
 * Multihop attempted.
 */
extern const errno_t EMULTIHOP;

/**
 * Link severed.
 */
extern const errno_t ENOLINK;

/**
 * No medium found.
 */
extern const errno_t ENOMEDIUM;

/**
 * Wrong medium type.
 */
extern const errno_t EMEDIUMTYPE;

/**
 * Inappropriate file type or format. (BSD only)
 */
extern const errno_t EFTYPE;

extern const errno_t EAUTH;
extern const errno_t EBADARCH;
extern const errno_t EBADEXEC;
extern const errno_t EBADMACHO;
extern const errno_t EBADRPC;
extern const errno_t EDEVERR;
extern const errno_t ENEEDAUTH;
extern const errno_t ENOATTR;
extern const errno_t ENOPOLICY;
extern const errno_t EPROCLIM;
extern const errno_t EPROCUNAVAIL;
extern const errno_t EPROGMISMATCH;
extern const errno_t EPROGUNAVAIL;
extern const errno_t EPWROFF;
extern const errno_t ERPCMISMATCH;
extern const errno_t ESHLIBVERS;

extern const errno_t EADV;
extern const errno_t EBADE;
extern const errno_t EBADFD;
extern const errno_t EBADR;
extern const errno_t EBADRQC;
extern const errno_t EBADSLT;
extern const errno_t ECHRNG;
extern const errno_t ECOMM;
extern const errno_t EDOTDOT;
extern const errno_t EHWPOISON;
extern const errno_t EISNAM;
extern const errno_t EKEYEXPIRED;
extern const errno_t EKEYREJECTED;
extern const errno_t EKEYREVOKED;
extern const errno_t EL2HLT;
extern const errno_t EL2NSYNC;
extern const errno_t EL3HLT;
extern const errno_t EL3RST;
extern const errno_t ELIBACC;
extern const errno_t ELIBBAD;
extern const errno_t ELIBEXEC;
extern const errno_t ELIBMAX;
extern const errno_t ELIBSCN;
extern const errno_t ELNRNG;
extern const errno_t ENAVAIL;
extern const errno_t ENOANO;
extern const errno_t ENOCSI;
extern const errno_t ENOKEY;
extern const errno_t ENOPKG;
extern const errno_t ENOTNAM;
extern const errno_t ENOTUNIQ;
extern const errno_t EREMCHG;
extern const errno_t EREMOTEIO;
extern const errno_t ERFKILL;
extern const errno_t ESRMNT;
extern const errno_t ESTRPIPE;
extern const errno_t EUCLEAN;
extern const errno_t EUNATCH;
extern const errno_t EXFULL;

#define E2BIG           E2BIG
#define EACCES          EACCES
#define EADDRINUSE      EADDRINUSE
#define EADDRNOTAVAIL   EADDRNOTAVAIL
#define EADV            EADV
#define EAFNOSUPPORT    EAFNOSUPPORT
#define EAGAIN          EAGAIN
#define EALREADY        EALREADY
#define EAUTH           EAUTH
#define EBADARCH        EBADARCH
#define EBADE           EBADE
#define EBADEXEC        EBADEXEC
#define EBADF           EBADF
#define EBADFD          EBADFD
#define EBADMACHO       EBADMACHO
#define EBADMSG         EBADMSG
#define EBADR           EBADR
#define EBADRPC         EBADRPC
#define EBADRQC         EBADRQC
#define EBADSLT         EBADSLT
#define EBUSY           EBUSY
#define ECANCELED       ECANCELED
#define ECHILD          ECHILD
#define ECHRNG          ECHRNG
#define ECOMM           ECOMM
#define ECONNABORTED    ECONNABORTED
#define ECONNREFUSED    ECONNREFUSED
#define ECONNRESET      ECONNRESET
#define EDEADLK         EDEADLK
#define EDESTADDRREQ    EDESTADDRREQ
#define EDEVERR         EDEVERR
#define EDOM            EDOM
#define EDOTDOT         EDOTDOT
#define EDQUOT          EDQUOT
#define EEXIST          EEXIST
#define EFAULT          EFAULT
#define EFBIG           EFBIG
#define EFTYPE          EFTYPE
#define EHOSTDOWN       EHOSTDOWN
#define EHOSTUNREACH    EHOSTUNREACH
#define EHWPOISON       EHWPOISON
#define EIDRM           EIDRM
#define EILSEQ          EILSEQ
#define EINPROGRESS     EINPROGRESS
#define EINTR           EINTR
#define EINVAL          EINVAL
#define EIO             EIO
#define EISCONN         EISCONN
#define EISDIR          EISDIR
#define EISNAM          EISNAM
#define EKEYEXPIRED     EKEYEXPIRED
#define EKEYREJECTED    EKEYREJECTED
#define EKEYREVOKED     EKEYREVOKED
#define EL2HLT          EL2HLT
#define EL2NSYNC        EL2NSYNC
#define EL3HLT          EL3HLT
#define EL3RST          EL3RST
#define ELIBACC         ELIBACC
#define ELIBBAD         ELIBBAD
#define ELIBEXEC        ELIBEXEC
#define ELIBMAX         ELIBMAX
#define ELIBSCN         ELIBSCN
#define ELNRNG          ELNRNG
#define ELOOP           ELOOP
#define EMEDIUMTYPE     EMEDIUMTYPE
#define EMFILE          EMFILE
#define EMLINK          EMLINK
#define EMSGSIZE        EMSGSIZE
#define EMULTIHOP       EMULTIHOP
#define ENAMETOOLONG    ENAMETOOLONG
#define ENAVAIL         ENAVAIL
#define ENEEDAUTH       ENEEDAUTH
#define ENETDOWN        ENETDOWN
#define ENETRESET       ENETRESET
#define ENETUNREACH     ENETUNREACH
#define ENFILE          ENFILE
#define ENOANO          ENOANO
#define ENOATTR         ENOATTR
#define ENOBUFS         ENOBUFS
#define ENOCSI          ENOCSI
#define ENODATA         ENODATA
#define ENODEV          ENODEV
#define ENOENT          ENOENT
#define ENOEXEC         ENOEXEC
#define ENOKEY          ENOKEY
#define ENOLCK          ENOLCK
#define ENOLINK         ENOLINK
#define ENOMEDIUM       ENOMEDIUM
#define ENOMEM          ENOMEM
#define ENOMSG          ENOMSG
#define ENONET          ENONET
#define ENOPKG          ENOPKG
#define ENOPOLICY       ENOPOLICY
#define ENOPROTOOPT     ENOPROTOOPT
#define ENOSPC          ENOSPC
#define ENOSR           ENOSR
#define ENOSTR          ENOSTR
#define ENOSYS          ENOSYS
#define ENOTBLK         ENOTBLK
#define ENOTCONN        ENOTCONN
#define ENOTDIR         ENOTDIR
#define ENOTEMPTY       ENOTEMPTY
#define ENOTNAM         ENOTNAM
#define ENOTRECOVERABLE ENOTRECOVERABLE
#define ENOTSOCK        ENOTSOCK
#define ENOTSUP         ENOTSUP
#define ENOTTY          ENOTTY
#define ENOTUNIQ        ENOTUNIQ
#define ENXIO           ENXIO
#define EOPNOTSUPP      EOPNOTSUPP
#define EOVERFLOW       EOVERFLOW
#define EOWNERDEAD      EOWNERDEAD
#define EPERM           EPERM
#define EPFNOSUPPORT    EPFNOSUPPORT
#define EPIPE           EPIPE
#define EPROCLIM        EPROCLIM
#define EPROCUNAVAIL    EPROCUNAVAIL
#define EPROGMISMATCH   EPROGMISMATCH
#define EPROGUNAVAIL    EPROGUNAVAIL
#define EPROTO          EPROTO
#define EPROTONOSUPPORT EPROTONOSUPPORT
#define EPROTOTYPE      EPROTOTYPE
#define EPWROFF         EPWROFF
#define ERANGE          ERANGE
#define EREMCHG         EREMCHG
#define EREMOTE         EREMOTE
#define EREMOTEIO       EREMOTEIO
#define ERESTART        ERESTART
#define ERFKILL         ERFKILL
#define EROFS           EROFS
#define ERPCMISMATCH    ERPCMISMATCH
#define ESHLIBVERS      ESHLIBVERS
#define ESHUTDOWN       ESHUTDOWN
#define ESOCKTNOSUPPORT ESOCKTNOSUPPORT
#define ESPIPE          ESPIPE
#define ESRCH           ESRCH
#define ESRMNT          ESRMNT
#define ESTALE          ESTALE
#define ESTRPIPE        ESTRPIPE
#define ETIME           ETIME
#define ETIMEDOUT       ETIMEDOUT
#define ETOOMANYREFS    ETOOMANYREFS
#define ETXTBSY         ETXTBSY
#define EUCLEAN         EUCLEAN
#define EUNATCH         EUNATCH
#define EUSERS          EUSERS
#define EWOULDBLOCK     EAGAIN
#define EXDEV           EXDEV
#define EXFULL          EXFULL

extern errno_t __errno;

errno_t *__errno_location(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/inttypes.h */

#define COSMOPOLITAN_LIBC_INTTYPES_H_

typedef __INT_LEAST8_TYPE__ int_least8_t;
typedef __UINT_LEAST8_TYPE__ uint_least8_t;
typedef __INT_LEAST16_TYPE__ int_least16_t;
typedef __UINT_LEAST16_TYPE__ uint_least16_t;
typedef __INT_LEAST32_TYPE__ int_least32_t;
typedef __UINT_LEAST32_TYPE__ uint_least32_t;
typedef __INT_LEAST64_TYPE__ int_least64_t;
typedef __UINT_LEAST64_TYPE__ uint_least64_t;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define __PRI8 "hh"

#if __SIZEOF_INT__ == 2
#define __PRI16 ""
#elif __SIZEOF_SHORT__ == 2
#define __PRI16 "h"
#elif __SIZEOF_LONG__ == 2
#define __PRI16 "l"
#endif

#if __SIZEOF_INT__ == 4
#define __PRI32 ""
#elif __SIZEOF_LONG__ == 4
#define __PRI32 "l"
#elif __SIZEOF_LONG_LONG__ == 4
#define __PRI32 "ll"
#endif

#if __SIZEOF_INT__ == 8
#define __PRI64 ""
#elif __SIZEOF_LONG__ == 8
#define __PRI64 "l"
#elif __SIZEOF_LONG_LONG__ == 8
#define __PRI64 "ll"
#endif

#if __SIZEOF_INT__ == 16
#define __PRI128 ""
#elif __SIZEOF_LONG__ == 16
#define __PRI128 "l"
#elif __SIZEOF_LONG_LONG__ == 16
#define __PRI128 "ll"
#elif __SIZEOF_INTMAX__ == 16
#define __PRI128 "j"
#else
#define __PRI128 "jj"
#endif

#if __SIZEOF_POINTER__ == __SIZEOF_INT__
#define __PRIPTR ""
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG__
#define __PRIPTR "l"
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__
#define __PRIPTR "ll"
#endif

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » decimal                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRId8   __PRI8 "d"
#define PRId16  __PRI16 "d"
#define PRId32  __PRI32 "d"
#define PRId64  __PRI64 "d"
#define PRId128 __PRI128 "d"

#define PRIdLEAST8   __PRI8 "d"
#define PRIdLEAST16  __PRI16 "d"
#define PRIdLEAST32  __PRI32 "d"
#define PRIdLEAST64  __PRI64 "d"
#define PRIdLEAST128 __PRI128 "d"

#define PRIdFAST8   __PRI8 "d"
#define PRIdFAST16  __PRI16 "d"
#define PRIdFAST32  __PRI32 "d"
#define PRIdFAST64  __PRI64 "d"
#define PRIdFAST128 __PRI128 "d"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » unsigned decimal        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIu8   __PRI8 "u"
#define PRIu16  __PRI16 "u"
#define PRIu32  __PRI32 "u"
#define PRIu64  __PRI64 "u"
#define PRIu128 __PRI128 "u"

#define PRIuLEAST8   __PRI8 "u"
#define PRIuLEAST16  __PRI16 "u"
#define PRIuLEAST32  __PRI32 "u"
#define PRIuLEAST64  __PRI64 "u"
#define PRIuLEAST128 __PRI128 "u"

#define PRIuFAST8   __PRI8 "u"
#define PRIuFAST16  __PRI16 "u"
#define PRIuFAST32  __PRI32 "u"
#define PRIuFAST64  __PRI64 "u"
#define PRIuFAST128 __PRI128 "u"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » wut                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIi8   __PRI8 "i"
#define PRIi16  __PRI16 "i"
#define PRIi32  __PRI32 "i"
#define PRIi64  __PRI64 "i"
#define PRIi128 __PRI128 "i"

#define PRIiLEAST8   __PRI8 "i"
#define PRIiLEAST16  __PRI16 "i"
#define PRIiLEAST32  __PRI32 "i"
#define PRIiLEAST64  __PRI64 "i"
#define PRIiLEAST128 __PRI128 "i"

#define PRIiFAST8   __PRI8 "i"
#define PRIiFAST16  __PRI16 "i"
#define PRIiFAST32  __PRI32 "i"
#define PRIiFAST64  __PRI64 "i"
#define PRIiFAST128 __PRI128 "i"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » octal                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIo8   __PRI8 "o"
#define PRIo16  __PRI16 "o"
#define PRIo32  __PRI32 "o"
#define PRIo64  __PRI64 "o"
#define PRIo128 __PRI128 "o"

#define PRIoLEAST8   __PRI8 "o"
#define PRIoLEAST16  __PRI16 "o"
#define PRIoLEAST32  __PRI32 "o"
#define PRIoLEAST64  __PRI64 "o"
#define PRIoLEAST128 __PRI128 "o"

#define PRIoFAST8   __PRI8 "o"
#define PRIoFAST16  __PRI16 "o"
#define PRIoFAST32  __PRI32 "o"
#define PRIoFAST64  __PRI64 "o"
#define PRIoFAST128 __PRI128 "o"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » hexadecimal             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIx8   __PRI8 "x"
#define PRIx16  __PRI16 "x"
#define PRIx32  __PRI32 "x"
#define PRIx64  __PRI64 "x"
#define PRIx128 __PRI128 "x"

#define PRIxLEAST8   __PRI8 "x"
#define PRIxLEAST16  __PRI16 "x"
#define PRIxLEAST32  __PRI32 "x"
#define PRIxLEAST64  __PRI64 "x"
#define PRIxLEAST128 __PRI128 "x"

#define PRIxFAST8   __PRI8 "x"
#define PRIxFAST16  __PRI16 "x"
#define PRIxFAST32  __PRI32 "x"
#define PRIxFAST64  __PRI64 "x"
#define PRIxFAST128 __PRI128 "x"

#define PRIX8   __PRI8 "X"
#define PRIX16  __PRI16 "X"
#define PRIX32  __PRI32 "X"
#define PRIX64  __PRI64 "X"
#define PRIX128 __PRI128 "X"

#define PRIXLEAST8   __PRI8 "X"
#define PRIXLEAST16  __PRI16 "X"
#define PRIXLEAST32  __PRI32 "X"
#define PRIXLEAST64  __PRI64 "X"
#define PRIXLEAST128 __PRI128 "X"

#define PRIXFAST8   __PRI8 "X"
#define PRIXFAST16  __PRI16 "X"
#define PRIXFAST32  __PRI32 "X"
#define PRIXFAST64  __PRI64 "X"
#define PRIXFAST128 __PRI128 "X"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » binary                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIb8   __PRI8 "b"
#define PRIb16  __PRI16 "b"
#define PRIb32  __PRI32 "b"
#define PRIb64  __PRI64 "b"
#define PRIb128 __PRI128 "b"

#define PRIbLEAST8   __PRI8 "b"
#define PRIbLEAST16  __PRI16 "b"
#define PRIbLEAST32  __PRI32 "b"
#define PRIbLEAST64  __PRI64 "b"
#define PRIbLEAST128 __PRI128 "b"

#define PRIbFAST8   __PRI8 "b"
#define PRIbFAST16  __PRI16 "b"
#define PRIbFAST32  __PRI32 "b"
#define PRIbFAST64  __PRI64 "b"
#define PRIbFAST128 __PRI128 "b"

#define PRIB8   __PRI8 "B"
#define PRIB16  __PRI16 "B"
#define PRIB32  __PRI32 "B"
#define PRIB64  __PRI64 "B"
#define PRIB128 __PRI128 "B"

#define PRIBLEAST8   __PRI8 "B"
#define PRIBLEAST16  __PRI16 "B"
#define PRIBLEAST32  __PRI32 "B"
#define PRIBLEAST64  __PRI64 "B"
#define PRIBLEAST128 __PRI128 "B"

#define PRIBFAST8   __PRI8 "B"
#define PRIBFAST16  __PRI16 "B"
#define PRIBFAST32  __PRI32 "B"
#define PRIBFAST64  __PRI64 "B"
#define PRIBFAST128 __PRI128 "B"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » miscellaneous           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIdMAX "jd"
#define PRIiMAX "ji"
#define PRIoMAX "jo"
#define PRIuMAX "ju"
#define PRIxMAX "jx"
#define PRIXMAX "jX"

#define PRIdPTR __PRIPTR "d"
#define PRIiPTR __PRIPTR "i"
#define PRIoPTR __PRIPTR "o"
#define PRIuPTR __PRIPTR "u"
#define PRIxPTR __PRIPTR "x"
#define PRIXPTR __PRIPTR "X"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » decimal                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNd8   __PRI8 "d"
#define SCNd16  __PRI16 "d"
#define SCNd32  __PRI32 "d"
#define SCNd64  __PRI64 "d"
#define SCNd128 __PRI128 "d"

#define SCNdLEAST8   __PRI8 "d"
#define SCNdLEAST16  __PRI16 "d"
#define SCNdLEAST32  __PRI32 "d"
#define SCNdLEAST64  __PRI64 "d"
#define SCNdLEAST128 __PRI128 "d"

#define SCNdFAST8   __PRI8 "d"
#define SCNdFAST16  __PRI16 "d"
#define SCNdFAST32  __PRI32 "d"
#define SCNdFAST64  __PRI64 "d"
#define SCNdFAST128 __PRI128 "d"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » flexidecimal             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNi8   __PRI8 "i"
#define SCNi16  __PRI16 "i"
#define SCNi32  __PRI32 "i"
#define SCNi64  __PRI64 "i"
#define SCNi128 __PRI128 "i"

#define SCNiLEAST8   __PRI8 "i"
#define SCNiLEAST16  __PRI16 "i"
#define SCNiLEAST32  __PRI32 "i"
#define SCNiLEAST64  __PRI64 "i"
#define SCNiLEAST128 __PRI128 "i"

#define SCNiFAST8   __PRI8 "i"
#define SCNiFAST16  __PRI16 "i"
#define SCNiFAST32  __PRI32 "i"
#define SCNiFAST64  __PRI64 "i"
#define SCNiFAST128 __PRI128 "i"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » unsigned decimal         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNu8   __PRI8 "u"
#define SCNu16  __PRI16 "u"
#define SCNu32  __PRI32 "u"
#define SCNu64  __PRI64 "u"
#define SCNu128 __PRI128 "u"

#define SCNuLEAST8   __PRI8 "u"
#define SCNuLEAST16  __PRI16 "u"
#define SCNuLEAST32  __PRI32 "u"
#define SCNuLEAST64  __PRI64 "u"
#define SCNuLEAST128 __PRI128 "u"

#define SCNuFAST8   __PRI8 "u"
#define SCNuFAST16  __PRI16 "u"
#define SCNuFAST32  __PRI32 "u"
#define SCNuFAST64  __PRI64 "u"
#define SCNuFAST128 __PRI128 "u"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » octal                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNo8   __PRI8 "o"
#define SCNo16  __PRI16 "o"
#define SCNo32  __PRI32 "o"
#define SCNo64  __PRI64 "o"
#define SCNo128 __PRI128 "o"

#define SCNoLEAST8   __PRI8 "o"
#define SCNoLEAST16  __PRI16 "o"
#define SCNoLEAST32  __PRI32 "o"
#define SCNoLEAST64  __PRI64 "o"
#define SCNoLEAST128 __PRI128 "o"

#define SCNoFAST8   __PRI8 "o"
#define SCNoFAST16  __PRI16 "o"
#define SCNoFAST32  __PRI32 "o"
#define SCNoFAST64  __PRI64 "o"
#define SCNoFAST128 __PRI128 "o"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » hexadecimal              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNx8   __PRI8 "x"
#define SCNx16  __PRI16 "x"
#define SCNx32  __PRI32 "x"
#define SCNx64  __PRI64 "x"
#define SCNx128 __PRI128 "x"

#define SCNxLEAST8   __PRI8 "x"
#define SCNxLEAST16  __PRI16 "x"
#define SCNxLEAST32  __PRI32 "x"
#define SCNxLEAST64  __PRI64 "x"
#define SCNxLEAST128 __PRI128 "x"

#define SCNxFAST8   __PRI8 "x"
#define SCNxFAST16  __PRI16 "x"
#define SCNxFAST32  __PRI32 "x"
#define SCNxFAST64  __PRI64 "x"
#define SCNxFAST128 __PRI128 "x"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » binary                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNb8   __PRI8 "b"
#define SCNb16  __PRI16 "b"
#define SCNb32  __PRI32 "b"
#define SCNb64  __PRI64 "b"
#define SCNb128 __PRI128 "b"

#define SCNbLEAST8   __PRI8 "b"
#define SCNbLEAST16  __PRI16 "b"
#define SCNbLEAST32  __PRI32 "b"
#define SCNbLEAST64  __PRI64 "b"
#define SCNbLEAST128 __PRI128 "b"

#define SCNbFAST8   __PRI8 "b"
#define SCNbFAST16  __PRI16 "b"
#define SCNbFAST32  __PRI32 "b"
#define SCNbFAST64  __PRI64 "b"
#define SCNbFAST128 __PRI128 "b"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » miscellaneous            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNdMAX "jd"
#define SCNiMAX "ji"
#define SCNoMAX "jo"
#define SCNuMAX "ju"
#define SCNxMAX "jx"

#define SCNdPTR __PRIPTR "d"
#define SCNiPTR __PRIPTR "i"
#define SCNoPTR __PRIPTR "o"
#define SCNuPTR __PRIPTR "u"
#define SCNxPTR __PRIPTR "x"



/*!BEGIN libc/limits.h */

#define COSMOPOLITAN_LIBC_LIMITS_H_
#define __STDC_LIMIT_MACROS

#define UCHAR_MIN 0
#define UCHAR_MAX 255

#if '\200' < 0
#define CHAR_MIN '\200'
#define CHAR_MAX '\177'
#else
#define CHAR_MIN '\0'
#define CHAR_MAX '\377'
#endif

#define SCHAR_MAX     __SCHAR_MAX__
#define SHRT_MAX      __SHRT_MAX__
#define INT_MAX       __INT_MAX__
#define LONG_MAX      __LONG_MAX__
#define LLONG_MAX     LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__
#define SIZE_MAX      __SIZE_MAX__
#define INT8_MAX      __INT8_MAX__
#define INT16_MAX     __INT16_MAX__
#define INT32_MAX     __INT32_MAX__
#define INT64_MAX     __INT64_MAX__
#define WINT_MAX      __WCHAR_MAX__
#define WCHAR_MAX     __WCHAR_MAX__
#define INTPTR_MAX    __INTPTR_MAX__
#define PTRDIFF_MAX   __PTRDIFF_MAX__
#define UINTPTR_MAX   __UINTPTR_MAX__
#define UINT8_MAX     __UINT8_MAX__
#define UINT16_MAX    __UINT16_MAX__
#define UINT32_MAX    __UINT32_MAX__
#define UINT64_MAX    __UINT64_MAX__
#define INTMAX_MAX    __INTMAX_MAX__
#define UINTMAX_MAX   __UINTMAX_MAX__

#define SCHAR_MIN     (-SCHAR_MAX - 1)
#define SHRT_MIN      (-SHRT_MAX - 1)
#define INT_MIN       (-INT_MAX - 1)
#define LONG_MIN      (-LONG_MAX - 1)
#define LLONG_MIN     (-LLONG_MAX - 1)
#define LONG_LONG_MIN (-LONG_LONG_MAX - 1)
#define SIZE_MIN      (-SIZE_MAX - 1)
#define INT8_MIN      (-INT8_MAX - 1)
#define INT16_MIN     (-INT16_MAX - 1)
#define INT32_MIN     (-INT32_MAX - 1)
#define INT64_MIN     (-INT64_MAX - 1)
#define INTMAX_MIN    (-INTMAX_MAX - 1)
#define INTPTR_MIN    (-INTPTR_MAX - 1)
#define WINT_MIN      (-WINT_MAX - 1)
#define WCHAR_MIN     (-WCHAR_MAX - 1)
#define PTRDIFF_MIN   (-PTRDIFF_MAX - 1)

#define USHRT_MAX 65535
#define UINT_MAX  0xffffffffu
#if __SIZEOF_LONG__ == 8
#define ULONG_MAX 0xfffffffffffffffful
#else
#define ULONG_MAX 0xfffffffful
#endif
#define ULLONG_MAX     0xffffffffffffffffull
#define ULONG_LONG_MAX 0xffffffffffffffffull

#define USHRT_MIN      0
#define UINT_MIN       0u
#define ULONG_MIN      0ul
#define ULLONG_MIN     0ull
#define ULONG_LONG_MIN 0ull
#define UINT8_MIN      0
#define UINT16_MIN     0
#define UINT32_MIN     0u
#define UINT64_MIN     0ull
#define UINTPTR_MIN    0ull
#define UINTMAX_MIN    ((uintmax_t)0)

#define MB_CUR_MAX 4
#define MB_LEN_MAX 4

#if __GNUC__ * 100 + __GNUC_MINOR__ >= 406 || defined(__llvm__)
#define INT128_MIN  (-INT128_MAX - 1)
#define UINT128_MIN ((uint128_t)0)
#define INT128_MAX \
  ((int128_t)0x7fffffffffffffff << 64 | (int128_t)0xffffffffffffffff)
#define UINT128_MAX \
  ((uint128_t)0xffffffffffffffff << 64 | (uint128_t)0xffffffffffffffff)
#endif /* GCC 4.6+ */



/*!BEGIN libc/literal.h */

#define COSMOPOLITAN_LIBC_LITERAL_H_
#define __STDC_CONSTANT_MACROS

#ifdef __INT8_C
#define INT8_C(c)   __INT8_C(c)
#define UINT8_C(c)  __UINT8_C(c)
#define INT16_C(c)  __INT16_C(c)
#define UINT16_C(c) __UINT16_C(c)
#define INT32_C(c)  __INT32_C(c)
#define UINT32_C(c) __UINT32_C(c)
#define INT64_C(c)  __INT64_C(c)
#define UINT64_C(c) __UINT64_C(c)
#else
#define INT8_C(c)   c
#define UINT8_C(c)  c
#define INT16_C(c)  c
#define UINT16_C(c) c
#define INT32_C(c)  c
#define UINT32_C(c) c##U
#define INT64_C(c)  c##L
#define UINT64_C(c) c##UL
#endif

#if __SIZEOF_INTMAX__ == 16
#define INT128_C(c)  ((intmax_t)(c))
#define UINT128_C(c) ((uintmax_t)(c))
#elif __SIZEOF_INTMAX__ == 8
#define INT128_C(c)  __INT64_C(c)
#define UINT128_C(c) __UINT64_C(c)
#endif



/*!BEGIN libc/mach.h */

#define COSMOPOLITAN_LIBC_MACH_H_
/*                                            ▄▄███▄
                                          ▄▄████████▄
                                       ▄█████████████▄
                                   ▄▄███▓▓▓▓▓▓▓▓▓▓▓███▄
                               ▄▄█████▓▓▓█████████▓▓▓██▄
                           ▄▄████████▓▓▓███████▓▓▓▓▓████▄
                        ▄█████░░░████▓▓█████▓▓▓▓█████████▄
                    ▄▄█████████░░░███▓▓█▓▓▓▓▒███████▓▓▒███▄
                 ▄██████████████░░░██▓▓▓▓███████████▓▓█████▄
               ██████████████████░░░██▓▓▓█████████▓▓▓███████▄
                ███░░░░░░█████████▓░░███▓▓▓▓▓▓▓▓▓▓▓█████▒▒▒██▄
               █░███░░░██░░░░░░░░░██░░██████████████▒▒▒▒██████▄
              ███████░░░█████████░░░░░░█████████▒▒▒▒▒██████████▄
              █████ ██░░░███████████████████▒▒▒▒▒██░▒▒██████████▄
              ██████ ██░░░██████████████░███▒████████▒▒██████████▄
             ████████ ███░░█████████████░░████████████▒▒███████████
             █████████ ███░░███████████░░██████████████▒▒███████████
            ▄██████████ ██████████████ ░░███████████████▒▒███████████
            ████████████ ███░░░░░█████░░█████████████████▒▒██████  █
            █████████████ ██████░░░░░░░▒█████████████████████  ████▀
             █████████████ ██████████░░░░░░░░░███████████  ████████
              █████████████ ████████░░███████░░░██████ ▓██████████
               █████████████ ██████░░░████████████  █████████████
╔────────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § xnu's not unix! » carnegie mellon mach microkernel        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define XNU_SYSCALL_MASK_MACH     0x1000000
#define XNU_SYSCALL_MASK_UNIX     0x2000000
#define XNU_SYSCALL_MASK_MACH_IPC 0x5000000

#define kXnuCommonPage   0x00007fffffe00000
#define kXnuNtTscBase    0x050 /* uint64_t */
#define kXnuNtScale      0x058 /* uint32_t */
#define kXnuNtShift      0x05c /* uint32_t */
#define kXnuNtNsBase     0x060 /* uint64_t */
#define kXnuNtGeneration 0x068 /* uint32_t */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool swtch(void);
bool swtch_pri(int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/math.h */

#define COSMOPOLITAN_LIBC_MATH_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § mathematics                                                   │
╚─────────────────────────────────────────────────────────────────────────────*/

#define M_E        2.7182818284590452354 /* 𝑒 */
#define M_LOG2_10  0xd.49a784bcd1b8afep-2 /* log₂10 ≈ 3.3219280948873623478 */
#define M_LOG10_2  0x9.a209a84fbcff799p-5 /* log₁₀2 ≈ 0.301029995663981195 */
#define M_LOG2E    0xb.8aa3b295c17f0bcp-3 /* log₂𝑒 ≈ 1.4426950408889634074 */
#define M_LOG10E   0.43429448190325182765  /* log₁₀𝑒 */
#define M_LN2      0xb.17217f7d1cf79acp-4  /* logₑ2 ≈ */
#define M_LN10     2.30258509299404568402  /* logₑ10 */
#define M_TAU      0x1.921fb54442d1846ap+2 /* τ = 2π */
#define M_PI       0x1.921fb54442d1846ap+1 /* π ≈ 3.14159265358979323846 */
#define M_PI_2     1.57079632679489661923  /* π/2 */
#define M_PI_4     0.78539816339744830962  /* π/4 */
#define M_1_PI     0.31830988618379067154  /* 1/π */
#define M_2_PI     0.63661977236758134308  /* 2/π */
#define M_2_SQRTPI 1.12837916709551257390  /* 2/sqrtπ */
#define M_SQRT2    1.41421356237309504880  /* sqrt2 */
#define M_SQRT1_2  0.70710678118654752440  /* 1/sqrt2 */

#define DBL_DECIMAL_DIG  __DBL_DECIMAL_DIG__
#define DBL_DIG          __DBL_DIG__
#define DBL_EPSILON      __DBL_EPSILON__
#define DBL_MANT_DIG     __DBL_MANT_DIG__
#define DBL_MANT_DIG     __DBL_MANT_DIG__
#define DBL_MAX          __DBL_MAX__
#define DBL_MAX_10_EXP   __DBL_MAX_10_EXP__
#define DBL_MAX_EXP      __DBL_MAX_EXP__
#define DBL_MIN          __DBL_MIN__ /* 2.23e–308 ↔ 1.79e308 */
#define DBL_MIN_10_EXP   __DBL_MIN_10_EXP__
#define DBL_MIN_EXP      __DBL_MIN_EXP__
#define DECIMAL_DIG      __LDBL_DECIMAL_DIG__
#define FLT_DECIMAL_DIG  __FLT_DECIMAL_DIG__
#define FLT_RADIX        __FLT_RADIX__
#define FLT_DIG          __FLT_DIG__
#define FLT_EPSILON      __FLT_EPSILON__
#define FLT_MANT_DIG     __FLT_MANT_DIG__
#define FLT_MANT_DIG     __FLT_MANT_DIG__
#define FLT_MAX          __FLT_MAX__
#define FLT_MAX_10_EXP   __FLT_MAX_10_EXP__
#define FLT_MAX_EXP      __FLT_MAX_EXP__
#define FLT_MIN          __FLT_MIN__ /* 1.18e–38 ↔ 3.40e38 */
#define FLT_MIN_10_EXP   __FLT_MIN_10_EXP__
#define FLT_MIN_EXP      __FLT_MIN_EXP__
#define HLF_MAX          6.50e4f
#define HLF_MIN          3.10e-5f
#define LDBL_DECIMAL_DIG __LDBL_DECIMAL_DIG__
#define LDBL_DIG         __LDBL_DIG__
#define LDBL_EPSILON     __LDBL_EPSILON__
#define LDBL_MANT_DIG    __LDBL_MANT_DIG__
#define LDBL_MANT_DIG    __LDBL_MANT_DIG__
#define LDBL_MAX         __LDBL_MAX__
#define LDBL_MAX_10_EXP  __LDBL_MAX_10_EXP__
#define LDBL_MAX_EXP     __LDBL_MAX_EXP__
#define LDBL_MIN         __LDBL_MIN__ /* 3.37e–4932 ↔ 1.18e4932 */
#define LDBL_MIN_10_EXP  __LDBL_MIN_10_EXP__
#define LDBL_MIN_EXP     __LDBL_MIN_EXP__

#define FP_NAN       0
#define FP_INFINITE  1
#define FP_ZERO      2
#define FP_SUBNORMAL 3
#define FP_NORMAL    4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define NAN       __builtin_nanf("")
#define INFINITY  __builtin_inff()
#define HUGE_VAL  __builtin_inf()
#define HUGE_VALF __builtin_inff()
#define HUGE_VALL __builtin_infl()

#if __FLT_EVAL_METHOD__ + 0 == 2
typedef long double float_t;
typedef long double double_t;
#else
typedef float float_t;
typedef double double_t;
#endif

#define isinf(x)             __builtin_isinf(x)
#define isnan(x)             __builtin_isnan(x)
#define isfinite(x)          __builtin_isfinite(x)
#define isnormal(x)          __builtin_isnormal(x)
#define signbit(x)           __builtin_signbit(x)
#define isgreater(x, y)      __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y)         __builtin_isless(x, y)
#define islessequal(x, y)    __builtin_islessequal(x, y)
#define islessgreater(x, y)  __builtin_islessgreater(x, y)
#define isunordered(x, y)    __builtin_isunordered(x, y)

#define fpclassify(x) \
  __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)

double acos(double);
double acosh(double);
double asin(double);
double asinh(double);
double atan(double);
double atan2(double, double);
double atanh(double);
double cbrt(double);
double ceil(double);
double copysign(double, double);
double cos(double);
double cosh(double);
double drem(double, double);
double erf(double);
double erfc(double);
double exp(double);
double exp10(double);
double exp2(double);
double expm1(double);
double fabs(double);
double fdim(double, double);
double floor(double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double fmod(double, double);
double hypot(double, double);
double ldexp(double, int);
double log(double);
double log10(double);
double log1p(double);
double log2(double);
double logb(double);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double pow(double, double);
double pow10(double);
double powi(double, int);
double remainder(double, double);
double rint(double);
double round(double);
double scalb(double, double);
double scalbln(double, long int);
double scalbn(double, int);
double significand(double);
double sin(double);
double sinh(double);
double sqrt(double);
double tan(double);
double tanh(double);
double trunc(double);
double tgamma(double);
double lgamma(double);
double lgamma_r(double, int *);
int finite(double);

float acosf(float);
float acoshf(float);
float asinf(float);
float asinhf(float);
float atan2f(float, float);
float atanf(float);
float atanhf(float);
float cbrtf(float);
float ceilf(float);
float copysignf(float, float);
float cosf(float);
float coshf(float);
float dremf(float, float);
float erfcf(float);
float erff(float);
float exp10f(float);
float exp2f(float);
float expf(float);
float expm1f(float);
float fabsf(float);
float fdimf(float, float);
float floorf(float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float fmodf(float, float);
float hypotf(float, float);
float ldexpf(float, int);
float lgammaf(float);
float lgammaf_r(float, int *);
float log10f(float);
float log1pf(float);
float log2f(float);
float logbf(float);
float logf(float);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float pow10f(float);
float powf(float, float);
float powif(float, int);
float remainderf(float, float);
float rintf(float);
float roundf(float);
float scalbf(float, float);
float scalblnf(float, long int);
float scalbnf(float, int);
float significandf(float);
float sinf(float);
float sinhf(float);
float sqrtf(float);
float tanf(float);
float tanhf(float);
float tgammaf(float);
float truncf(float);
int finitef(float);

int finitel(long double);
long double acoshl(long double);
long double acosl(long double);
long double asinhl(long double);
long double asinl(long double);
long double atan2l(long double, long double);
long double atanhl(long double);
long double atanl(long double);
long double cbrtl(long double);
long double ceill(long double);
long double copysignl(long double, long double);
long double coshl(long double);
long double cosl(long double);
long double dreml(long double, long double);
long double erfcl(long double);
long double erfl(long double);
long double exp10l(long double);
long double exp2l(long double);
long double expl(long double);
long double expm1l(long double);
long double fabsl(long double);
long double fdiml(long double, long double);
long double floorl(long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double fmodl(long double, long double);
long double hypotl(long double, long double);
long double ldexpl(long double, int);
long double lgammal(long double);
long double lgammal_r(long double, int *);
long double log10l(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long double logl(long double);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double pow10l(long double);
long double powil(long double, int);
long double powl(long double, long double);
long double remainderl(long double, long double);
long double rintl(long double);
long double roundl(long double);
long double scalbl(long double, long double);
long double scalblnl(long double, long int);
long double scalbnl(long double, int);
long double significandl(long double);
long double sinhl(long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanhl(long double);
long double tanl(long double);
long double tgammal(long double);
long double truncl(long double);

long lrint(double);
long lrintf(float);
long lrintl(long double);
long lround(double);
long lroundf(float);
long lroundl(long double);

int ilogbf(float);
int ilogb(double);
int ilogbl(long double);

long long llrint(double);
long long llrintf(float);
long long llrintl(long double);
long long llround(double);
long long llroundf(float);
long long llroundl(long double);

double frexp(double, int *);
double modf(double, double *);
double nan(const char *);
double remquo(double, double, int *);
float frexpf(float, int *);
float modff(float, float *);
float nanf(const char *);
float remquof(float, float, int *);
long double frexpl(long double, int *);
long double modfl(long double, long double *);
long double nanl(const char *);
long double remquol(long double, long double, int *);
void sincos(double, double *, double *);
void sincosf(float, float *, float *);
void sincosl(long double, long double *, long double *);

float fsumf(const float *, size_t);
double fsum(const double *, size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/paths.h */

#define COSMOPOLITAN_LIBC_PATHS_H_

#define _PATH_DEFPATH "/usr/local/bin:/bin:/usr/bin"
#define _PATH_STDPATH "/bin:/usr/bin:/sbin:/usr/sbin"

#define _PATH_BSHELL "/bin/sh"
#define _PATH_CONSOLE "/dev/console"
#define _PATH_DEVNULL "/dev/null"
#define _PATH_KLOG "/proc/kmsg"
#define _PATH_LASTLOG "/var/log/lastlog"
#define _PATH_MAILDIR "/var/mail"
#define _PATH_MAN "/usr/share/man"
#define _PATH_MNTTAB "/etc/fstab"
#define _PATH_MOUNTED "/etc/mtab"
#define _PATH_NOLOGIN "/etc/nologin"
#define _PATH_SENDMAIL "/usr/sbin/sendmail"
#define _PATH_SHADOW "/etc/shadow"
#define _PATH_SHELLS "/etc/shells"
#define _PATH_TTY "/dev/tty"
#define _PATH_UTMP "/dev/null/utmp"
#define _PATH_VI "/usr/bin/vi"
#define _PATH_WTMP "/dev/null/wtmp"

#define _PATH_DEV "/dev/"
#define _PATH_TMP "/tmp/"
#define _PATH_VARDB "/var/lib/misc/"
#define _PATH_VARRUN "/var/run/"
#define _PATH_VARTMP "/var/tmp/"



/*!BEGIN libc/type2str.h */

#define COSMOPOLITAN_LIBC_TYPE2STR_H_
#if __STDC_VERSION__ + 0 >= 201112
/* clang-format off */

#define _TYPE2STR(X)                          \
  _Generic(X,                                 \
    _Bool:              "_Bool",              \
    signed char:        "signed char",        \
    unsigned char:      "unsigned char",      \
    char:               "char",               \
    short:              "short",              \
    unsigned short:     "unsigned short",     \
    int:                "int",                \
    unsigned:           "unsigned",           \
    long:               "long",               \
    unsigned long:      "unsigned long",      \
    long long:          "long long",          \
    unsigned long long: "unsigned long long", \
    float:              "float",              \
    double:             "double",             \
    long double:        "long double")

#define _PRINTF_GENERIC(X, D, U) \
  _Generic(X,                    \
    _Bool:              "hhh" U, \
    signed char:        "hh" D,  \
    unsigned char:      "hh" U,  \
    char:               "hh" D,  \
    short:              "h" D,   \
    unsigned short:     "h" U,   \
    int:                D,       \
    unsigned:           U,       \
    long:               "l" D,   \
    unsigned long:      "l" U,   \
    long long:          "ll" D,  \
    unsigned long long: "ll" U,  \
    float:              "f",     \
    double:             "f",     \
    long double:        "Lf")

/* clang-format on */
#endif /* C11 */


/*!BEGIN libc/zip.h */

#define COSMOPOLITAN_LIBC_ZIP_H_


/*!BEGIN libc/intrin/bits.h */

#define COSMOPOLITAN_LIBC_BITS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define CheckUnsigned(x) ((x) / !((typeof(x))(-1) < 0))

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits                                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

extern const uint8_t kReverseBits[256];

uint32_t gray(uint32_t) pureconst;
uint32_t ungray(uint32_t) pureconst;
int bitreverse8(int) libcesque pureconst;
int bitreverse16(int) libcesque pureconst;
uint32_t bitreverse32(uint32_t) libcesque pureconst;
uint64_t bitreverse64(uint64_t) libcesque pureconst;
unsigned long roundup2pow(unsigned long) libcesque pureconst;
unsigned long roundup2log(unsigned long) libcesque pureconst;
unsigned long rounddown2pow(unsigned long) libcesque pureconst;
unsigned long hamming(unsigned long, unsigned long) pureconst;
unsigned bextra(const unsigned *, size_t, char);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » no assembly required                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define BITREVERSE8(X) (kReverseBits[255 & (X)])
#define BITREVERSE16(X) \
  (kReverseBits[0x00FF & (X)] << 8 | kReverseBits[(0xFF00 & (X)) >> 8])

#ifdef __STRICT_ANSI__
#define READ16LE(S) ((255 & (S)[1]) << 8 | (255 & (S)[0]))
#define READ16BE(S) ((255 & (S)[0]) << 8 | (255 & (S)[1]))
#define READ32LE(S)                                                    \
  ((uint32_t)(255 & (S)[3]) << 030 | (uint32_t)(255 & (S)[2]) << 020 | \
   (uint32_t)(255 & (S)[1]) << 010 | (uint32_t)(255 & (S)[0]) << 000)
#define READ32BE(S)                                                    \
  ((uint32_t)(255 & (S)[0]) << 030 | (uint32_t)(255 & (S)[1]) << 020 | \
   (uint32_t)(255 & (S)[2]) << 010 | (uint32_t)(255 & (S)[3]) << 000)
#define READ64LE(S)                                                    \
  ((uint64_t)(255 & (S)[7]) << 070 | (uint64_t)(255 & (S)[6]) << 060 | \
   (uint64_t)(255 & (S)[5]) << 050 | (uint64_t)(255 & (S)[4]) << 040 | \
   (uint64_t)(255 & (S)[3]) << 030 | (uint64_t)(255 & (S)[2]) << 020 | \
   (uint64_t)(255 & (S)[1]) << 010 | (uint64_t)(255 & (S)[0]) << 000)
#define READ64BE(S)                                                    \
  ((uint64_t)(255 & (S)[0]) << 070 | (uint64_t)(255 & (S)[1]) << 060 | \
   (uint64_t)(255 & (S)[2]) << 050 | (uint64_t)(255 & (S)[3]) << 040 | \
   (uint64_t)(255 & (S)[4]) << 030 | (uint64_t)(255 & (S)[5]) << 020 | \
   (uint64_t)(255 & (S)[6]) << 010 | (uint64_t)(255 & (S)[7]) << 000)
#else /* gcc needs help knowing above are mov if s isn't a variable */
#define READ16LE(S)                            \
  ({                                           \
    const uint8_t *Ptr = (const uint8_t *)(S); \
    Ptr[1] << 8 | Ptr[0];                      \
  })
#define READ16BE(S)                            \
  ({                                           \
    const uint8_t *Ptr = (const uint8_t *)(S); \
    Ptr[0] << 8 | Ptr[1];                      \
  })
#define READ32LE(S)                                      \
  ({                                                     \
    const uint8_t *Ptr = (const uint8_t *)(S);           \
    ((uint32_t)Ptr[3] << 030 | (uint32_t)Ptr[2] << 020 | \
     (uint32_t)Ptr[1] << 010 | (uint32_t)Ptr[0] << 000); \
  })
#define READ32BE(S)                                      \
  ({                                                     \
    const uint8_t *Ptr = (const uint8_t *)(S);           \
    ((uint32_t)Ptr[0] << 030 | (uint32_t)Ptr[1] << 020 | \
     (uint32_t)Ptr[2] << 010 | (uint32_t)Ptr[3] << 000); \
  })
#define READ64LE(S)                                      \
  ({                                                     \
    const uint8_t *Ptr = (const uint8_t *)(S);           \
    ((uint64_t)Ptr[7] << 070 | (uint64_t)Ptr[6] << 060 | \
     (uint64_t)Ptr[5] << 050 | (uint64_t)Ptr[4] << 040 | \
     (uint64_t)Ptr[3] << 030 | (uint64_t)Ptr[2] << 020 | \
     (uint64_t)Ptr[1] << 010 | (uint64_t)Ptr[0] << 000); \
  })
#define READ64BE(S)                                      \
  ({                                                     \
    const uint8_t *Ptr = (const uint8_t *)(S);           \
    ((uint64_t)Ptr[0] << 070 | (uint64_t)Ptr[1] << 060 | \
     (uint64_t)Ptr[2] << 050 | (uint64_t)Ptr[3] << 040 | \
     (uint64_t)Ptr[4] << 030 | (uint64_t)Ptr[5] << 020 | \
     (uint64_t)Ptr[6] << 010 | (uint64_t)Ptr[7] << 000); \
  })
#endif

#define WRITE16LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF & (V)) >> 000, \
   (P)[1] = (0x000000000000FF00 & (V)) >> 010, (P) + 2)
#define WRITE16BE(P, V)                        \
  ((P)[0] = (0x000000000000FF00 & (V)) >> 010, \
   (P)[1] = (0x00000000000000FF & (V)) >> 000, (P) + 2)
#define WRITE32LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF & (V)) >> 000, \
   (P)[1] = (0x000000000000FF00 & (V)) >> 010, \
   (P)[2] = (0x0000000000FF0000 & (V)) >> 020, \
   (P)[3] = (0x00000000FF000000 & (V)) >> 030, (P) + 4)
#define WRITE32BE(P, V)                        \
  ((P)[0] = (0x00000000FF000000 & (V)) >> 030, \
   (P)[1] = (0x0000000000FF0000 & (V)) >> 020, \
   (P)[2] = (0x000000000000FF00 & (V)) >> 010, \
   (P)[3] = (0x00000000000000FF & (V)) >> 000, (P) + 4)
#define WRITE64LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF & (V)) >> 000, \
   (P)[1] = (0x000000000000FF00 & (V)) >> 010, \
   (P)[2] = (0x0000000000FF0000 & (V)) >> 020, \
   (P)[3] = (0x00000000FF000000 & (V)) >> 030, \
   (P)[4] = (0x000000FF00000000 & (V)) >> 040, \
   (P)[5] = (0x0000FF0000000000 & (V)) >> 050, \
   (P)[6] = (0x00FF000000000000 & (V)) >> 060, \
   (P)[7] = (0xFF00000000000000 & (V)) >> 070, (P) + 8)
#define WRITE64BE(P, V)                        \
  ((P)[0] = (0xFF00000000000000 & (V)) >> 070, \
   (P)[1] = (0x00FF000000000000 & (V)) >> 060, \
   (P)[2] = (0x0000FF0000000000 & (V)) >> 050, \
   (P)[3] = (0x000000FF00000000 & (V)) >> 040, \
   (P)[4] = (0x00000000FF000000 & (V)) >> 030, \
   (P)[5] = (0x0000000000FF0000 & (V)) >> 020, \
   (P)[6] = (0x000000000000FF00 & (V)) >> 010, \
   (P)[7] = (0x00000000000000FF & (V)) >> 000, (P) + 8)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » some assembly required                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define lockinc(MEM) __ArithmeticOp1("lock inc", MEM)
#define lockdec(MEM) __ArithmeticOp1("lock dec", MEM)
#define locknot(MEM) __ArithmeticOp1("lock not", MEM)
#define lockneg(MEM) __ArithmeticOp1("lock neg", MEM)

#define lockaddeq(MEM, VAL) __ArithmeticOp2("lock add", VAL, MEM)
#define locksubeq(MEM, VAL) __ArithmeticOp2("lock sub", VAL, MEM)
#define lockxoreq(MEM, VAL) __ArithmeticOp2("lock xor", VAL, MEM)
#define lockandeq(MEM, VAL) __ArithmeticOp2("lock and", VAL, MEM)
#define lockoreq(MEM, VAL)  __ArithmeticOp2("lock or", VAL, MEM)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » implementation details                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define __ArithmeticOp1(OP, MEM)                               \
  ({                                                           \
    asm(OP "%z0\t%0" : "+m"(*(MEM)) : /* no inputs */ : "cc"); \
    MEM;                                                       \
  })

#define __ArithmeticOp2(OP, VAL, MEM)                          \
  ({                                                           \
    asm(OP "%z0\t%1,%0" : "+m,m"(*(MEM)) : "i,r"(VAL) : "cc"); \
    MEM;                                                       \
  })

#endif /* __GNUC__ && !__STRICT_ANSI__ */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/timespec.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TIMESPEC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct timespec {
  int64_t tv_sec;
  int64_t tv_nsec; /* nanoseconds */
};

int clock_getres(int, struct timespec *);
int clock_gettime(int, struct timespec *);
int futimens(int, const struct timespec[2]);
int nanosleep(const struct timespec *, struct timespec *);
int sys_futex(int *, int, int, const struct timespec *, int *);
int utimensat(int, const char *, const struct timespec[2], int);

bool _timespec_eq(struct timespec, struct timespec) pureconst;
bool _timespec_gte(struct timespec, struct timespec) pureconst;
int64_t _timespec_tomicros(struct timespec) pureconst;
int64_t _timespec_tomillis(struct timespec) pureconst;
int64_t _timespec_tonanos(struct timespec) pureconst;
struct timespec _timespec_add(struct timespec, struct timespec) pureconst;
struct timespec _timespec_frommicros(int64_t) pureconst;
struct timespec _timespec_frommillis(int64_t) pureconst;
struct timespec _timespec_mono(void);
struct timespec _timespec_real(void);
struct timespec _timespec_sub(struct timespec, struct timespec) pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/str.h */

#define COSMOPOLITAN_LIBC_STR_STR_H_

#define INVALID_CODEPOINT 0xfffd

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int8_t kHexToInt[256];
extern const uint8_t gperf_downcase[256];
extern const uint8_t kToLower[256];
extern const uint8_t kToUpper[256];
extern const uint8_t kBase36[256];
extern const char16_t kCp437[256];

int isascii(int);
int isspace(int);
int isalpha(int);
int isdigit(int);
int isalnum(int);
int isxdigit(int);
int isprint(int);
int islower(int);
int isupper(int);
int isblank(int);
int iscntrl(int);
int isgraph(int);
int tolower(int);
int ispunct(int);
int toupper(int);
int hextoint(int);
int cescapec(int);

int iswalnum(wint_t);
int iswalpha(wint_t);
int iswblank(wint_t);
int iswcntrl(wint_t);
int iswdigit(wint_t);
int iswgraph(wint_t);
int iswlower(wint_t);
int iswspace(wint_t);
int iswupper(wint_t);
int iswxdigit(wint_t);
int iswpunct(wint_t);
int iswprint(wint_t);
int iswseparator(wint_t);
wint_t towlower(wint_t);
wint_t towupper(wint_t);

void bzero(void *, size_t) memcpyesque;
void *memset(void *, int, size_t) memcpyesque;
void *memmove(void *, const void *, size_t) memcpyesque;
void *memcpy(void *restrict, const void *restrict, size_t) memcpyesque;
void *mempcpy(void *restrict, const void *restrict, size_t) memcpyesque;
void *memccpy(void *restrict, const void *restrict, int, size_t) memcpyesque;
void bcopy(const void *, void *, size_t) memcpyesque;
void explicit_bzero(void *, size_t);

int bcmp(const void *, const void *, size_t) strlenesque;
int memcmp(const void *, const void *, size_t) strlenesque;
int timingsafe_bcmp(const void *, const void *, size_t);
int timingsafe_memcmp(const void *, const void *, size_t);

size_t strlen(const char *) strlenesque;
size_t strnlen(const char *, size_t) strlenesque;
size_t strnlen_s(const char *, size_t);
char *strchr(const char *, int) strlenesque;
char *index(const char *, int) strlenesque;
void *memchr(const void *, int, size_t) strlenesque;
char *strchrnul(const char *, int) strlenesque returnsnonnull;
void *rawmemchr(const void *, int) strlenesque returnsnonnull;
size_t strlen16(const char16_t *) strlenesque;
size_t strnlen16(const char16_t *, size_t) strlenesque;
size_t strnlen16_s(const char16_t *, size_t);
char16_t *strchr16(const char16_t *, int) strlenesque;
void *memchr16(const void *, int, size_t) strlenesque;
char16_t *strchrnul16(const char16_t *, int) strlenesque returnsnonnull;
void *rawmemchr16(const void *, int) strlenesque returnsnonnull;
size_t wcslen(const wchar_t *) strlenesque;
size_t wcsnlen(const wchar_t *, size_t) strlenesque;
size_t wcsnlen_s(const wchar_t *, size_t);
wchar_t *wcschr(const wchar_t *, wchar_t) strlenesque;
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t) strlenesque;
wchar_t *wcschrnul(const wchar_t *, wchar_t) strlenesque returnsnonnull;
char *strstr(const char *, const char *) strlenesque;
char *strcasestr(const char *, const char *) strlenesque;
char16_t *strstr16(const char16_t *, const char16_t *) strlenesque;
wchar_t *wcsstr(const wchar_t *, const wchar_t *) strlenesque;
void *rawwmemchr(const void *, wchar_t) strlenesque returnsnonnull;
int strcmp(const char *, const char *) strlenesque;
int strncmp(const char *, const char *, size_t) strlenesque;
int strcmp16(const char16_t *, const char16_t *) strlenesque;
int strncmp16(const char16_t *, const char16_t *, size_t) strlenesque;
int wcscmp(const wchar_t *, const wchar_t *) strlenesque;
int wcsncmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
int wmemcmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
int strcasecmp(const char *, const char *) strlenesque;
int memcasecmp(const void *, const void *, size_t) strlenesque;
int strcasecmp16(const char16_t *, const char16_t *) strlenesque;
int wcscasecmp(const wchar_t *, const wchar_t *) strlenesque;
int strncasecmp(const char *, const char *, size_t) strlenesque;
int strncasecmp16(const char16_t *, const char16_t *, size_t) strlenesque;
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
char *strrchr(const char *, int) strlenesque;
void *memrchr(const void *, int, size_t) strlenesque;
char16_t *strrchr16(const char16_t *, int) strlenesque;
void *memrchr16(const void *, int, size_t) strlenesque;
wchar_t *wcsrchr(const wchar_t *, int) strlenesque;
void *wmemrchr(const void *, wchar_t, size_t) strlenesque;
char *strpbrk(const char *, const char *) strlenesque;
char16_t *strpbrk16(const char16_t *, const char16_t *) strlenesque;
wchar_t *wcspbrk(const wchar_t *, const wchar_t *) strlenesque;
size_t strspn(const char *, const char *) strlenesque;
size_t strspn16(const char16_t *, const char16_t *) strlenesque;
size_t wcsspn(const wchar_t *, const wchar_t *) strlenesque;
size_t strcspn(const char *, const char *) strlenesque;
size_t strcspn16(const char16_t *, const char16_t *) strlenesque;
size_t wcscspn(const wchar_t *, const wchar_t *) strlenesque;
void *memfrob(void *, size_t) memcpyesque;
int strcoll(const char *, const char *) strlenesque;
char *strsep(char **, const char *) paramsnonnull();
int strcmpzbw(const uint16_t *, const char *) strlenesque;
int strcasecmpzbw(const uint16_t *, const char *) strlenesque;
char *stpcpy(char *, const char *) memcpyesque;
char *stpncpy(char *, const char *, size_t) memcpyesque;
char *strcat(char *, const char *) memcpyesque;
char16_t *strcat16(char16_t *, const char16_t *) memcpyesque;
wchar_t *wcscat(wchar_t *, const wchar_t *) memcpyesque;
size_t strlcpy(char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strxfrm(char *, const char *, size_t);
char *strcpy(char *, const char *) memcpyesque;
char16_t *strcpy16(char16_t *, const char16_t *) memcpyesque;
wchar_t *wcscpy(wchar_t *, const wchar_t *) memcpyesque;
char *strncat(char *, const char *, size_t) memcpyesque;
char16_t *strncat16(char16_t *, const char16_t *, size_t) memcpyesque;
wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t) memcpyesque;
char *strncpy(char *, const char *, size_t) memcpyesque;
char *strtok(char *, const char *) paramsnonnull((2)) libcesque;
char *strtok_r(char *, const char *, char **) paramsnonnull((2, 3));
wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **) paramsnonnull((2, 3));
char *wstrtrunc(uint16_t *) memcpyesque;
char *wstrntrunc(uint16_t *, size_t) memcpyesque;
bool startswith(const char *, const char *) strlenesque;
bool startswithi(const char *, const char *) strlenesque;
bool startswith16(const char16_t *, const char16_t *) strlenesque;
bool wcsstartswith(const wchar_t *, const wchar_t *) strlenesque;
bool endswith(const char *, const char *) strlenesque;
bool endswith16(const char16_t *, const char16_t *) strlenesque;
bool wcsendswith(const wchar_t *, const wchar_t *) strlenesque;
const char *IndexDoubleNulString(const char *, unsigned) strlenesque;
int strverscmp(const char *, const char *);
wchar_t *wmemset(wchar_t *, wchar_t, size_t) memcpyesque;
char16_t *memset16(char16_t *, char16_t, size_t) memcpyesque;
wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t) memcpyesque;
wchar_t *wmempcpy(wchar_t *, const wchar_t *, size_t) memcpyesque;
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t) memcpyesque;
void *tinymemccpy(void *, const void *, int, size_t) memcpyesque;
void *memmem(const void *, size_t, const void *, size_t) libcesque nosideeffect;
long a64l(const char *);
char *l64a(long);

char *strntolower(char *, size_t) libcesque;
char *strtolower(char *) libcesque paramsnonnull();
char *strntoupper(char *, size_t) libcesque;
char *strtoupper(char *) libcesque paramsnonnull();
char *_chomp(char *) libcesque;
char16_t *_chomp16(char16_t *) libcesque;
wchar_t *_wchomp(wchar_t *) libcesque;
bool _istext(const void *, size_t) libcesque;
bool _isutf8(const void *, size_t) libcesque;
bool _escapedos(char16_t *, unsigned, const char16_t *, unsigned) libcesque;

typedef unsigned mbstate_t;

axdx_t tprecode8to16(char16_t *, size_t, const char *);
axdx_t tprecode16to8(char *, size_t, const char16_t *);
wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
size_t mbstowcs(wchar_t *, const char *, size_t);
size_t wcrtomb(char *, wchar_t, mbstate_t *);
size_t c32rtomb(char *, char32_t, mbstate_t *);
size_t mbrtoc32(char32_t *, const char *, size_t, mbstate_t *);
size_t c16rtomb(char *, char16_t, mbstate_t *);
size_t mbrtoc16(char16_t *, const char *, size_t, mbstate_t *);
size_t mbrlen(const char *, size_t, mbstate_t *);
size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
size_t wcstombs(char *, const wchar_t *, size_t);
int mbsinit(const mbstate_t *);
int mblen(const char *, size_t);
int wctomb(char *, wchar_t);
int wctob(wint_t);
wint_t btowc(int);

size_t strclen(const char *) nosideeffect;
size_t strnclen(const char *, size_t) nosideeffect;
size_t strclen16(const char16_t *) nosideeffect;
size_t strnclen16(const char16_t *, size_t) nosideeffect;

typedef unsigned wctype_t;
wctype_t wctype(const char *) strlenesque;
int iswctype(wint_t, wctype_t) pureconst;

typedef const int *wctrans_t;
wctrans_t wctrans(const char *);
wint_t towctrans(wint_t, wctrans_t);

char *strsignal(int) returnsnonnull libcesque;
char *strerror(int) returnsnonnull dontthrow nocallback;
char *strerrno(int) nosideeffect libcesque;
char *strerdoc(int) nosideeffect libcesque;
int strerror_r(int, char *, size_t) dontthrow nocallback;
int strerror_wr(int, uint32_t, char *, size_t) dontthrow nocallback;
int __xpg_strerror_r(int, char *, size_t) dontthrow nocallback;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/**
 * @fileoverview PKZIP Data Structures.
 */

#define kZipAlign 2

#define kZipCosmopolitanVersion kZipEra2001

#define kZipOsDos         0
#define kZipOsAmiga       1
#define kZipOsOpenvms     2
#define kZipOsUnix        3
#define kZipOsVmcms       4
#define kZipOsAtarist     5
#define kZipOsOs2hpfs     6
#define kZipOsMacintosh   7
#define kZipOsZsystem     8
#define kZipOsCpm         9
#define kZipOsWindowsntfs 10
#define kZipOsMvsos390zos 11
#define kZipOsVse         12
#define kZipOsAcornrisc   13
#define kZipOsVfat        14
#define kZipOsAltmvs      15
#define kZipOsBeos        16
#define kZipOsTandem      17
#define kZipOsOs400       18
#define kZipOsOsxdarwin   19

#define kZipEra1989 10 /* PKZIP 1.0 */
#define kZipEra1993 20 /* PKZIP 2.0: deflate/subdir/etc. support */
#define kZipEra2001 45 /* PKZIP 4.5: kZipExtraZip64 support */

#define kZipIattrBinary 0 /* first bit not set */
#define kZipIattrText   1 /* first bit set */

#define kZipCompressionNone    0
#define kZipCompressionDeflate 8

#define kZipCdirHdrMagic        0x06054b50 /* PK♣♠ "PK\5\6" */
#define kZipCdirHdrMinSize      22
#define kZipCdirAlign           kZipAlign
#define kZipCdirHdrLinkableSize 294

#define kZipCdir64HdrMagic     0x06064b50 /* PK♣♠ "PK\6\6" */
#define kZipCdir64HdrMinSize   56
#define kZipCdir64LocatorMagic 0x07064b50 /* PK♠• "PK\6\7" */
#define kZipCdir64LocatorSize  20

#define kZipCfileHdrMagic                 0x02014b50 /* PK☺☻ "PK\1\2" */
#define kZipCfileHdrMinSize               46
#define kZipCfileOffsetGeneralflag        8
#define kZipCfileOffsetCompressionmethod  10
#define kZipCfileOffsetLastmodifiedtime   12
#define kZipCfileOffsetLastmodifieddate   14
#define kZipCfileOffsetCrc32              16
#define kZipCfileOffsetCompressedsize     20
#define kZipCfileOffsetUncompressedsize   24
#define kZipCfileOffsetExternalattributes 38
#define kZipCfileOffsetOffset             42

#define kZipLfileHdrMagic                0x04034b50 /* PK♥♦ "PK\3\4" */
#define kZipLfileHdrMinSize              30
#define kZipLfileOffsetGeneralflag       6
#define kZipLfileOffsetCompressionmethod 8
#define kZipLfileOffsetLastmodifiedtime  10
#define kZipLfileOffsetLastmodifieddate  12
#define kZipLfileOffsetCrc32             14
#define kZipLfileOffsetCompressedsize    18
#define kZipLfileOffsetUncompressedsize  22

#define kZipGflagUtf8 0x800

#define kZipExtraHdrSize             4
#define kZipExtraZip64               0x0001
#define kZipExtraNtfs                0x000a
#define kZipExtraUnix                0x000d
#define kZipExtraExtendedTimestamp   0x5455
#define kZipExtraInfoZipNewUnixExtra 0x7875

#define kZipCfileMagic "PK\001\002"

#if !(__ASSEMBLER__ + __LINKER__ + 0)

/* end of central directory record */
#define ZIP_CDIR_MAGIC(P)         READ32LE(P)
#define ZIP_CDIR_DISK(P)          READ16LE((P) + 4)
#define ZIP_CDIR_STARTINGDISK(P)  READ16LE((P) + 6)
#define ZIP_CDIR_RECORDSONDISK(P) READ16LE((P) + 8)
#define ZIP_CDIR_RECORDS(P)       READ16LE((P) + 10)
#define ZIP_CDIR_SIZE(P)          READ32LE((P) + 12)
#define ZIP_CDIR_OFFSET(P)        READ32LE((P) + 16)
#define ZIP_CDIR_COMMENTSIZE(P)   READ16LE((P) + 20)
#define ZIP_CDIR_COMMENT(P)       ((P) + 22) /* recommend stopping at nul */
#define ZIP_CDIR_HDRSIZE(P)       (ZIP_CDIR_COMMENTSIZE(P) + kZipCdirHdrMinSize)

/* zip64 end of central directory record */
#define ZIP_CDIR64_MAGIC(P)         READ32LE(P)
#define ZIP_CDIR64_HDRSIZE(P)       (READ64LE((P) + 4) + 12)
#define ZIP_CDIR64_VERSIONMADE(P)   READ16LE((P) + 12)
#define ZIP_CDIR64_VERSIONNEED(P)   READ16LE((P) + 14)
#define ZIP_CDIR64_DISK(P)          READ32LE((P) + 16)
#define ZIP_CDIR64_STARTINGDISK(P)  READ32LE((P) + 20)
#define ZIP_CDIR64_RECORDSONDISK(P) READ64LE((P) + 24)
#define ZIP_CDIR64_RECORDS(P)       READ64LE((P) + 32)
#define ZIP_CDIR64_SIZE(P)          READ64LE((P) + 40)
#define ZIP_CDIR64_OFFSET(P)        READ64LE((P) + 48)
#define ZIP_CDIR64_COMMENTSIZE(P) \
  (ZIP_CDIR64_HDRSIZE(P) >= 56 ? ZIP_CDIR64_HDRSIZE(P) - 56 : 0)
#define ZIP_CDIR64_COMMENT(P)        ((P) + 56) /* recommend stopping at nul */
#define ZIP_LOCATE64_MAGIC(P)        READ32LE(P)
#define ZIP_LOCATE64_STARTINGDISK(P) READ32LE((P) + 4)
#define ZIP_LOCATE64_OFFSET(P)       READ64LE((P) + 8)
#define ZIP_LOCATE64_TOTALDISKS(P)   READ32LE((P) + 12)

/* central directory file header */
#define ZIP_CFILE_MAGIC(P)          READ32LE(P)
#define ZIP_CFILE_VERSIONMADE(P)    (255 & (P)[4])
#define ZIP_CFILE_FILEATTRCOMPAT(P) (255 & (P)[5])
#define ZIP_CFILE_VERSIONNEED(P)    (255 & (P)[6])
#define ZIP_CFILE_OSNEED(P)         (255 & (P)[7])
#define ZIP_CFILE_GENERALFLAG(P)    READ16LE((P) + kZipCfileOffsetGeneralflag)
#define ZIP_CFILE_COMPRESSIONMETHOD(P) \
  READ16LE((P) + kZipCfileOffsetCompressionmethod)
#define ZIP_CFILE_LASTMODIFIEDTIME(P) \
  READ16LE((P) + kZipCfileOffsetLastmodifiedtime) /* @see DOS_TIME() */
#define ZIP_CFILE_LASTMODIFIEDDATE(P) \
  READ16LE((P) + kZipCfileOffsetLastmodifieddate) /* @see DOS_DATE() */
#define ZIP_CFILE_CRC32(P)          READ32LE((P) + kZipCfileOffsetCrc32)
#define ZIP_CFILE_COMPRESSEDSIZE(P) READ32LE(P + kZipCfileOffsetCompressedsize)
#define ZIP_CFILE_UNCOMPRESSEDSIZE(P) \
  READ32LE((P) + kZipCfileOffsetUncompressedsize)
#define ZIP_CFILE_NAMESIZE(P)           READ16LE((P) + 28)
#define ZIP_CFILE_EXTRASIZE(P)          READ16LE((P) + 30)
#define ZIP_CFILE_COMMENTSIZE(P)        READ16LE((P) + 32)
#define ZIP_CFILE_DISK(P)               READ16LE((P) + 34)
#define ZIP_CFILE_INTERNALATTRIBUTES(P) READ16LE((P) + 36)
#define ZIP_CFILE_EXTERNALATTRIBUTES(P) \
  READ32LE((P) + kZipCfileOffsetExternalattributes)
#define ZIP_CFILE_OFFSET(P) READ32LE((P) + kZipCfileOffsetOffset)
#define ZIP_CFILE_NAME(P)   ((const char *)((P) + 46)) /* not nul-terminated */
#define ZIP_CFILE_EXTRA(P)  ((P) + 46 + ZIP_CFILE_NAMESIZE(P))
#define ZIP_CFILE_COMMENT(P)                         \
  ((const char *)((P) + 46 + ZIP_CFILE_NAMESIZE(P) + \
                  ZIP_CFILE_EXTRASIZE(P))) /* recommend stopping at nul */
#define ZIP_CFILE_HDRSIZE(P)                                                   \
  (ZIP_CFILE_NAMESIZE(P) + ZIP_CFILE_EXTRASIZE(P) + ZIP_CFILE_COMMENTSIZE(P) + \
   kZipCfileHdrMinSize)

/* local file header */
#define ZIP_LFILE_MAGIC(P)       READ32LE(P)
#define ZIP_LFILE_VERSIONNEED(P) (255 & (P)[4])
#define ZIP_LFILE_OSNEED(P)      (255 & (P)[5])
#define ZIP_LFILE_GENERALFLAG(P) READ16LE((P) + kZipLfileOffsetGeneralflag)
#define ZIP_LFILE_COMPRESSIONMETHOD(P) \
  READ16LE((P) + kZipLfileOffsetCompressionmethod)
#define ZIP_LFILE_LASTMODIFIEDTIME(P) \
  READ16LE((P) + kZipLfileOffsetLastmodifiedtime) /* @see DOS_TIME() */
#define ZIP_LFILE_LASTMODIFIEDDATE(P) \
  READ16LE((P) + kZipLfileOffsetLastmodifieddate) /* @see DOS_DATE() */
#define ZIP_LFILE_CRC32(P) READ32LE((P) + kZipLfileOffsetCrc32)
#define ZIP_LFILE_COMPRESSEDSIZE(P) \
  READ32LE((P) + kZipLfileOffsetCompressedsize)
#define ZIP_LFILE_UNCOMPRESSEDSIZE(P) \
  READ32LE((P) + kZipLfileOffsetUncompressedsize)
#define ZIP_LFILE_NAMESIZE(P)  READ16LE((P) + 26)
#define ZIP_LFILE_EXTRASIZE(P) READ16LE((P) + 28)
#define ZIP_LFILE_NAME(P)      ((const char *)((P) + 30))
#define ZIP_LFILE_EXTRA(P)     ((P) + 30 + ZIP_LFILE_NAMESIZE(P))
#define ZIP_LFILE_HDRSIZE(P) \
  (ZIP_LFILE_NAMESIZE(P) + ZIP_LFILE_EXTRASIZE(P) + kZipLfileHdrMinSize)
#define ZIP_LFILE_CONTENT(P) ((P) + ZIP_LFILE_HDRSIZE(P))
#define ZIP_LFILE_SIZE(P)    (ZIP_LFILE_HDRSIZE(P) + ZIP_LFILE_COMPRESSEDSIZE(P))

#define ZIP_EXTRA_HEADERID(P)    READ16LE(P)
#define ZIP_EXTRA_CONTENTSIZE(P) READ16LE((P) + 2)
#define ZIP_EXTRA_CONTENT(P)     ((P) + 4)
#define ZIP_EXTRA_SIZE(P)        (ZIP_EXTRA_CONTENTSIZE(P) + kZipExtraHdrSize)

void *GetZipCdir(const uint8_t *, size_t);
uint8_t *FindEmbeddedApe(const uint8_t *, size_t);
bool IsZipCdir32(const uint8_t *, size_t, size_t);
bool IsZipCdir64(const uint8_t *, size_t, size_t);
int GetZipCfileMode(const uint8_t *);
uint64_t GetZipCdirOffset(const uint8_t *);
uint64_t GetZipCdirRecords(const uint8_t *);
void *GetZipCdirComment(const uint8_t *);
uint64_t GetZipCdirSize(const uint8_t *);
uint64_t GetZipCdirCommentSize(const uint8_t *);
uint64_t GetZipCfileUncompressedSize(const uint8_t *);
uint64_t GetZipCfileCompressedSize(const uint8_t *);
uint64_t GetZipCfileOffset(const uint8_t *);
uint64_t GetZipLfileUncompressedSize(const uint8_t *);
uint64_t GetZipLfileCompressedSize(const uint8_t *);
void GetZipCfileTimestamps(const uint8_t *, struct timespec *,
                           struct timespec *, struct timespec *, int);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/typedef/u.h */

#define COSMOPOLITAN_LIBC_CALLS_TYPEDEF_U_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/bpf.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_BPF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define BPF_MAXINSNS 4096

#define BPF_CLASS(code) ((code)&0x07)
#define BPF_LD          0x00 /* load into accumulator */
#define BPF_LDX         0x01 /* load into index register */
#define BPF_ST          0x02 /* store from immediate */
#define BPF_STX         0x03 /* store from register */
#define BPF_ALU         0x04 /* 32-bit arithmetic */
#define BPF_JMP         0x05
#define BPF_RET         0x06
#define BPF_MISC        0x07

#define BPF_SIZE(code) ((code)&0x18)
#define BPF_W          0x00 /* 32-bit */
#define BPF_H          0x08 /* 16-bit */
#define BPF_B          0x10 /*  8-bit */
#define BPF_DW         0x18 /* 64-bit (eBPF only) */

#define BPF_MODE(code) ((code)&0xe0)
#define BPF_IMM        0x00 /* 64-bit immediate */
#define BPF_ABS        0x20
#define BPF_IND        0x40
#define BPF_MEM        0x60
#define BPF_LEN        0x80
#define BPF_MSH        0xa0

#define BPF_OP(code) ((code)&0xf0)
#define BPF_ADD      0x00
#define BPF_SUB      0x10
#define BPF_MUL      0x20
#define BPF_DIV      0x30
#define BPF_OR       0x40
#define BPF_AND      0x50
#define BPF_LSH      0x60
#define BPF_RSH      0x70
#define BPF_NEG      0x80
#define BPF_MOD      0x90
#define BPF_XOR      0xa0

#define BPF_SRC(code) ((code)&0x08)
#define BPF_JA        0x00
#define BPF_JEQ       0x10
#define BPF_JGT       0x20
#define BPF_JGE       0x30
#define BPF_JSET      0x40
#define BPF_K         0x00
#define BPF_X         0x08

#define BPF_JMP32   0x06
#define BPF_ALU64   0x07
#define BPF_ATOMIC  0xc0
#define BPF_XADD    0xc0
#define BPF_MOV     0xb0
#define BPF_ARSH    0xc0
#define BPF_END     0xd0
#define BPF_TO_LE   0x00
#define BPF_TO_BE   0x08
#define BPF_FROM_LE BPF_TO_LE
#define BPF_FROM_BE BPF_TO_BE
#define BPF_JNE     0x50 /* != */
#define BPF_JLT     0xa0 /* unsigned < */
#define BPF_JLE     0xb0 /* unsigned <= */
#define BPF_JSGT    0x60 /* signed > */
#define BPF_JSGE    0x70 /* signed >= */
#define BPF_JSLT    0xc0 /* signed < */
#define BPF_JSLE    0xd0 /* signed <= */
#define BPF_CALL    0x80 /* call */
#define BPF_EXIT    0x90 /* ret */
#define BPF_FETCH   0x01
#define BPF_XCHG    (0xe0 | BPF_FETCH)
#define BPF_CMPXCHG (0xf0 | BPF_FETCH)
#define MAX_BPF_REG __MAX_BPF_REG

#define BPF_REG_0     0
#define BPF_REG_1     1
#define BPF_REG_2     2
#define BPF_REG_3     3
#define BPF_REG_4     4
#define BPF_REG_5     5
#define BPF_REG_6     6
#define BPF_REG_7     7
#define BPF_REG_8     8
#define BPF_REG_9     9
#define BPF_REG_10    10
#define __MAX_BPF_REG 11

#define BPF_MAP_CREATE                  0
#define BPF_MAP_LOOKUP_ELEM             1
#define BPF_MAP_UPDATE_ELEM             2
#define BPF_MAP_DELETE_ELEM             3
#define BPF_MAP_GET_NEXT_KEY            4
#define BPF_PROG_LOAD                   5
#define BPF_OBJ_PIN                     6
#define BPF_OBJ_GET                     7
#define BPF_PROG_ATTACH                 8
#define BPF_PROG_DETACH                 9
#define BPF_PROG_TEST_RUN               10
#define BPF_PROG_GET_NEXT_ID            11
#define BPF_MAP_GET_NEXT_ID             12
#define BPF_PROG_GET_FD_BY_ID           13
#define BPF_MAP_GET_FD_BY_ID            14
#define BPF_OBJ_GET_INFO_BY_FD          15
#define BPF_PROG_QUERY                  16
#define BPF_RAW_TRACEPOINT_OPEN         17
#define BPF_BTF_LOAD                    18
#define BPF_BTF_GET_FD_BY_ID            19
#define BPF_TASK_FD_QUERY               20
#define BPF_MAP_LOOKUP_AND_DELETE_ELEM  21
#define BPF_MAP_FREEZE                  22
#define BPF_BTF_GET_NEXT_ID             23
#define BPF_MAP_LOOKUP_BATCH            24
#define BPF_MAP_LOOKUP_AND_DELETE_BATCH 25
#define BPF_MAP_UPDATE_BATCH            26
#define BPF_MAP_DELETE_BATCH            27
#define BPF_LINK_CREATE                 28
#define BPF_LINK_UPDATE                 29
#define BPF_LINK_GET_FD_BY_ID           30
#define BPF_LINK_GET_NEXT_ID            31
#define BPF_ENABLE_STATS                32
#define BPF_ITER_CREATE                 33
#define BPF_LINK_DETACH                 34
#define BPF_PROG_BIND_MAP               35
#define BPF_PROG_RUN                    BPF_PROG_TEST_RUN

#define BPF_MAP_TYPE_UNSPEC                0
#define BPF_MAP_TYPE_HASH                  1
#define BPF_MAP_TYPE_ARRAY                 2
#define BPF_MAP_TYPE_PROG_ARRAY            3
#define BPF_MAP_TYPE_PERF_EVENT_ARRAY      4
#define BPF_MAP_TYPE_PERCPU_HASH           5
#define BPF_MAP_TYPE_PERCPU_ARRAY          6
#define BPF_MAP_TYPE_STACK_TRACE           7
#define BPF_MAP_TYPE_CGROUP_ARRAY          8
#define BPF_MAP_TYPE_LRU_HASH              9
#define BPF_MAP_TYPE_LRU_PERCPU_HASH       10
#define BPF_MAP_TYPE_LPM_TRIE              11
#define BPF_MAP_TYPE_ARRAY_OF_MAPS         12
#define BPF_MAP_TYPE_HASH_OF_MAPS          13
#define BPF_MAP_TYPE_DEVMAP                14
#define BPF_MAP_TYPE_SOCKMAP               15
#define BPF_MAP_TYPE_CPUMAP                16
#define BPF_MAP_TYPE_XSKMAP                17
#define BPF_MAP_TYPE_SOCKHASH              18
#define BPF_MAP_TYPE_CGROUP_STORAGE        19
#define BPF_MAP_TYPE_REUSEPORT_SOCKARRAY   20
#define BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE 21
#define BPF_MAP_TYPE_QUEUE                 22
#define BPF_MAP_TYPE_STACK                 23
#define BPF_MAP_TYPE_SK_STORAGE            24
#define BPF_MAP_TYPE_DEVMAP_HASH           25
#define BPF_MAP_TYPE_STRUCT_OPS            26
#define BPF_MAP_TYPE_RINGBUF               27
#define BPF_MAP_TYPE_INODE_STORAGE         28
#define BPF_MAP_TYPE_TASK_STORAGE          29

#define BPF_PROG_TYPE_UNSPEC                  0
#define BPF_PROG_TYPE_SOCKET_FILTER           1
#define BPF_PROG_TYPE_KPROBE                  2
#define BPF_PROG_TYPE_SCHED_CLS               3
#define BPF_PROG_TYPE_SCHED_ACT               4
#define BPF_PROG_TYPE_TRACEPOINT              5
#define BPF_PROG_TYPE_XDP                     6
#define BPF_PROG_TYPE_PERF_EVENT              7
#define BPF_PROG_TYPE_CGROUP_SKB              8
#define BPF_PROG_TYPE_CGROUP_SOCK             9
#define BPF_PROG_TYPE_LWT_IN                  10
#define BPF_PROG_TYPE_LWT_OUT                 11
#define BPF_PROG_TYPE_LWT_XMIT                12
#define BPF_PROG_TYPE_SOCK_OPS                13
#define BPF_PROG_TYPE_SK_SKB                  14
#define BPF_PROG_TYPE_CGROUP_DEVICE           15
#define BPF_PROG_TYPE_SK_MSG                  16
#define BPF_PROG_TYPE_RAW_TRACEPOINT          17
#define BPF_PROG_TYPE_CGROUP_SOCK_ADDR        18
#define BPF_PROG_TYPE_LWT_SEG6LOCAL           19
#define BPF_PROG_TYPE_LIRC_MODE2              20
#define BPF_PROG_TYPE_SK_REUSEPORT            21
#define BPF_PROG_TYPE_FLOW_DISSECTOR          22
#define BPF_PROG_TYPE_CGROUP_SYSCTL           23
#define BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE 24
#define BPF_PROG_TYPE_CGROUP_SOCKOPT          25
#define BPF_PROG_TYPE_TRACING                 26
#define BPF_PROG_TYPE_STRUCT_OPS              27
#define BPF_PROG_TYPE_EXT                     28
#define BPF_PROG_TYPE_LSM                     29
#define BPF_PROG_TYPE_SK_LOOKUP               30
#define BPF_PROG_TYPE_SYSCALL                 31

#define BPF_CGROUP_INET_INGRESS            0
#define BPF_CGROUP_INET_EGRESS             1
#define BPF_CGROUP_INET_SOCK_CREATE        2
#define BPF_CGROUP_SOCK_OPS                3
#define BPF_SK_SKB_STREAM_PARSER           4
#define BPF_SK_SKB_STREAM_VERDICT          5
#define BPF_CGROUP_DEVICE                  6
#define BPF_SK_MSG_VERDICT                 7
#define BPF_CGROUP_INET4_BIND              8
#define BPF_CGROUP_INET6_BIND              9
#define BPF_CGROUP_INET4_CONNECT           10
#define BPF_CGROUP_INET6_CONNECT           11
#define BPF_CGROUP_INET4_POST_BIND         12
#define BPF_CGROUP_INET6_POST_BIND         13
#define BPF_CGROUP_UDP4_SENDMSG            14
#define BPF_CGROUP_UDP6_SENDMSG            15
#define BPF_LIRC_MODE2                     16
#define BPF_FLOW_DISSECTOR                 17
#define BPF_CGROUP_SYSCTL                  18
#define BPF_CGROUP_UDP4_RECVMSG            19
#define BPF_CGROUP_UDP6_RECVMSG            20
#define BPF_CGROUP_GETSOCKOPT              21
#define BPF_CGROUP_SETSOCKOPT              22
#define BPF_TRACE_RAW_TP                   23
#define BPF_TRACE_FENTRY                   24
#define BPF_TRACE_FEXIT                    25
#define BPF_MODIFY_RETURN                  26
#define BPF_LSM_MAC                        27
#define BPF_TRACE_ITER                     28
#define BPF_CGROUP_INET4_GETPEERNAME       29
#define BPF_CGROUP_INET6_GETPEERNAME       30
#define BPF_CGROUP_INET4_GETSOCKNAME       31
#define BPF_CGROUP_INET6_GETSOCKNAME       32
#define BPF_XDP_DEVMAP                     33
#define BPF_CGROUP_INET_SOCK_RELEASE       34
#define BPF_XDP_CPUMAP                     35
#define BPF_SK_LOOKUP                      36
#define BPF_XDP                            37
#define BPF_SK_SKB_VERDICT                 38
#define BPF_SK_REUSEPORT_SELECT            39
#define BPF_SK_REUSEPORT_SELECT_OR_MIGRATE 40
#define __MAX_BPF_ATTACH_TYPE              41

#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE

#define BPF_LINK_TYPE_UNSPEC         0
#define BPF_LINK_TYPE_RAW_TRACEPOINT 1
#define BPF_LINK_TYPE_TRACING        2
#define BPF_LINK_TYPE_CGROUP         3
#define BPF_LINK_TYPE_ITER           4
#define BPF_LINK_TYPE_NETNS          5
#define BPF_LINK_TYPE_XDP            6
#define MAX_BPF_LINK_TYPE            7

#define BPF_F_ALLOW_OVERRIDE     (1U << 0)
#define BPF_F_ALLOW_MULTI        (1U << 1)
#define BPF_F_REPLACE            (1U << 2)
#define BPF_F_STRICT_ALIGNMENT   (1U << 0)
#define BPF_F_ANY_ALIGNMENT      (1U << 1)
#define BPF_F_TEST_RND_HI32      (1U << 2)
#define BPF_F_TEST_STATE_FREQ    (1U << 3)
#define BPF_F_SLEEPABLE          (1U << 4)
#define BPF_PSEUDO_MAP_FD        1
#define BPF_PSEUDO_MAP_IDX       5
#define BPF_PSEUDO_MAP_VALUE     2
#define BPF_PSEUDO_MAP_IDX_VALUE 6
#define BPF_PSEUDO_BTF_ID        3
#define BPF_PSEUDO_FUNC          4
#define BPF_PSEUDO_CALL          1
#define BPF_PSEUDO_KFUNC_CALL    2

#define BPF_ANY               0
#define BPF_NOEXIST           1
#define BPF_EXIST             2
#define BPF_F_LOCK            4
#define BPF_F_NO_PREALLOC     (1U << 0)
#define BPF_F_NO_COMMON_LRU   (1U << 1)
#define BPF_F_NUMA_NODE       (1U << 2)
#define BPF_F_RDONLY          (1U << 3)
#define BPF_F_WRONLY          (1U << 4)
#define BPF_F_STACK_BUILD_ID  (1U << 5)
#define BPF_F_ZERO_SEED       (1U << 6)
#define BPF_F_RDONLY_PROG     (1U << 7)
#define BPF_F_WRONLY_PROG     (1U << 8)
#define BPF_F_CLONE           (1U << 9)
#define BPF_F_MMAPABLE        (1U << 10)
#define BPF_F_PRESERVE_ELEMS  (1U << 11)
#define BPF_F_INNER_MAP       (1U << 12)
#define BPF_F_QUERY_EFFECTIVE (1U << 0)
#define BPF_F_TEST_RUN_ON_CPU (1U << 0)

#define BPF_STATS_RUN_TIME       0
#define BPF_STACK_BUILD_ID_EMPTY 0
#define BPF_STACK_BUILD_ID_VALID 1
#define BPF_STACK_BUILD_ID_IP    2
#define BPF_BUILD_ID_SIZE        20
#define BPF_OBJ_NAME_LEN         16U

#define BPF_F_RECOMPUTE_CSUM  (1ULL << 0)
#define BPF_F_INVALIDATE_HASH (1ULL << 1)
#define BPF_F_HDR_FIELD_MASK  0xfULL
#define BPF_F_PSEUDO_HDR      (1ULL << 4)
#define BPF_F_MARK_MANGLED_0  (1ULL << 5)
#define BPF_F_MARK_ENFORCE    (1ULL << 6)
#define BPF_F_INGRESS         (1ULL << 0)
#define BPF_F_TUNINFO_IPV6    (1ULL << 0)
#define BPF_F_SKIP_FIELD_MASK 0xffULL
#define BPF_F_USER_STACK      (1ULL << 8)
#define BPF_F_FAST_STACK_CMP  (1ULL << 9)
#define BPF_F_REUSE_STACKID   (1ULL << 10)
#define BPF_F_USER_BUILD_ID   (1ULL << 11)
#define BPF_F_ZERO_CSUM_TX    (1ULL << 1)
#define BPF_F_DONT_FRAGMENT   (1ULL << 2)
#define BPF_F_SEQ_NUMBER      (1ULL << 3)
#define BPF_F_INDEX_MASK      0xffffffffULL
#define BPF_F_CURRENT_CPU     BPF_F_INDEX_MASK
#define BPF_F_CTXLEN_MASK     (0xfffffULL << 32)
#define BPF_F_CURRENT_NETNS   (-1L)

#define BPF_CSUM_LEVEL_QUERY 0
#define BPF_CSUM_LEVEL_INC   1
#define BPF_CSUM_LEVEL_DEC   2
#define BPF_CSUM_LEVEL_RESET 3

#define BPF_F_ADJ_ROOM_FIXED_GSO     (1ULL << 0)
#define BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 (1ULL << 1)
#define BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 (1ULL << 2)
#define BPF_F_ADJ_ROOM_ENCAP_L4_GRE  (1ULL << 3)
#define BPF_F_ADJ_ROOM_ENCAP_L4_UDP  (1ULL << 4)
#define BPF_F_ADJ_ROOM_NO_CSUM_RESET (1ULL << 5)
#define BPF_F_ADJ_ROOM_ENCAP_L2_ETH  (1ULL << 6)
#define BPF_ADJ_ROOM_ENCAP_L2_MASK   0xff
#define BPF_ADJ_ROOM_ENCAP_L2_SHIFT  56

#define BPF_F_ADJ_ROOM_ENCAP_L2(len) \
  (((uint64_t)len & BPF_ADJ_ROOM_ENCAP_L2_MASK) << BPF_ADJ_ROOM_ENCAP_L2_SHIFT)

#define BPF_F_SYSCTL_BASE_NAME         (1ULL << 0)
#define BPF_LOCAL_STORAGE_GET_F_CREATE (1ULL << 0)
#define BPF_SK_STORAGE_GET_F_CREATE    BPF_LOCAL_STORAGE_GET_F_CREATE
#define BPF_F_GET_BRANCH_RECORDS_SIZE  (1ULL << 0)
#define BPF_RB_NO_WAKEUP               (1ULL << 0)
#define BPF_RB_FORCE_WAKEUP            (1ULL << 1)
#define BPF_RB_AVAIL_DATA              0
#define BPF_RB_RING_SIZE               1
#define BPF_RB_CONS_POS                2
#define BPF_RB_PROD_POS                3
#define BPF_RINGBUF_BUSY_BIT           (1U << 31)
#define BPF_RINGBUF_DISCARD_BIT        (1U << 30)
#define BPF_RINGBUF_HDR_SZ             8
#define BPF_SK_LOOKUP_F_REPLACE        (1ULL << 0)
#define BPF_SK_LOOKUP_F_NO_REUSEPORT   (1ULL << 1)

#define BPF_ADJ_ROOM_NET          0
#define BPF_ADJ_ROOM_MAC          1
#define BPF_HDR_START_MAC         0
#define BPF_HDR_START_NET         1
#define BPF_LWT_ENCAP_SEG6        0
#define BPF_LWT_ENCAP_SEG6_INLINE 1
#define BPF_LWT_ENCAP_IP          2
#define BPF_F_BPRM_SECUREEXEC     (1ULL << 0)
#define BPF_F_BROADCAST           (1ULL << 3)
#define BPF_F_EXCLUDE_INGRESS     (1ULL << 4)

#define XDP_PACKET_HEADROOM 256
#define BPF_TAG_SIZE        8

#define BPF_SOCK_OPS_RTO_CB_FLAG                   (1 << 0)
#define BPF_SOCK_OPS_RETRANS_CB_FLAG               (1 << 1)
#define BPF_SOCK_OPS_STATE_CB_FLAG                 (1 << 2)
#define BPF_SOCK_OPS_RTT_CB_FLAG                   (1 << 3)
#define BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG     (1 << 4)
#define BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG (1 << 5)
#define BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG         (1 << 6)
#define BPF_SOCK_OPS_ALL_CB_FLAGS                  0x7F

#define BPF_SOCK_OPS_VOID                   0
#define BPF_SOCK_OPS_TIMEOUT_INIT           1
#define BPF_SOCK_OPS_RWND_INIT              2
#define BPF_SOCK_OPS_TCP_CONNECT_CB         3
#define BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB  4
#define BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB 5
#define BPF_SOCK_OPS_NEEDS_ECN              6
#define BPF_SOCK_OPS_BASE_RTT               7
#define BPF_SOCK_OPS_RTO_CB                 8
#define BPF_SOCK_OPS_RETRANS_CB             9
#define BPF_SOCK_OPS_STATE_CB               10
#define BPF_SOCK_OPS_TCP_LISTEN_CB          11
#define BPF_SOCK_OPS_RTT_CB                 12
#define BPF_SOCK_OPS_PARSE_HDR_OPT_CB       13
#define BPF_SOCK_OPS_HDR_OPT_LEN_CB         14
#define BPF_SOCK_OPS_WRITE_HDR_OPT_CB       15

#define BPF_TCP_ESTABLISHED  1
#define BPF_TCP_SYN_SENT     2
#define BPF_TCP_SYN_RECV     3
#define BPF_TCP_FIN_WAIT1    4
#define BPF_TCP_FIN_WAIT2    5
#define BPF_TCP_TIME_WAIT    6
#define BPF_TCP_CLOSE        7
#define BPF_TCP_CLOSE_WAIT   8
#define BPF_TCP_LAST_ACK     9
#define BPF_TCP_LISTEN       10
#define BPF_TCP_CLOSING      11
#define BPF_TCP_NEW_SYN_RECV 12
#define BPF_TCP_MAX_STATES   13

#define TCP_BPF_IW                      1001
#define TCP_BPF_SNDCWND_CLAMP           1002
#define TCP_BPF_DELACK_MAX              1003
#define TCP_BPF_RTO_MIN                 1004
#define TCP_BPF_SYN                     1005
#define TCP_BPF_SYN_IP                  1006
#define TCP_BPF_SYN_MAC                 1007
#define BPF_LOAD_HDR_OPT_TCP_SYN        (1ULL << 0)
#define BPF_WRITE_HDR_TCP_CURRENT_MSS   1
#define BPF_WRITE_HDR_TCP_SYNACK_COOKIE 2

#define BPF_DEVCG_ACC_MKNOD (1ULL << 0)
#define BPF_DEVCG_ACC_READ  (1ULL << 1)
#define BPF_DEVCG_ACC_WRITE (1ULL << 2)
#define BPF_DEVCG_DEV_BLOCK (1ULL << 0)
#define BPF_DEVCG_DEV_CHAR  (1ULL << 1)

#define BPF_FIB_LOOKUP_DIRECT (1U << 0)
#define BPF_FIB_LOOKUP_OUTPUT (1U << 1)

#define BPF_FIB_LKUP_RET_SUCCESS      0
#define BPF_FIB_LKUP_RET_BLACKHOLE    1
#define BPF_FIB_LKUP_RET_UNREACHABLE  2
#define BPF_FIB_LKUP_RET_PROHIBIT     3
#define BPF_FIB_LKUP_RET_NOT_FWDED    4
#define BPF_FIB_LKUP_RET_FWD_DISABLED 5
#define BPF_FIB_LKUP_RET_UNSUPP_LWT   6
#define BPF_FIB_LKUP_RET_NO_NEIGH     7
#define BPF_FIB_LKUP_RET_FRAG_NEEDED  8

#define BPF_MTU_CHK_SEGS                        (1U << 0)
#define BPF_MTU_CHK_RET_SUCCESS                 0
#define BPF_MTU_CHK_RET_FRAG_NEEDED             1
#define BPF_MTU_CHK_RET_SEGS_TOOBIG             2
#define BPF_FD_TYPE_RAW_TRACEPOINT              0
#define BPF_FD_TYPE_TRACEPOINT                  1
#define BPF_FD_TYPE_KPROBE                      2
#define BPF_FD_TYPE_KRETPROBE                   3
#define BPF_FD_TYPE_UPROBE                      4
#define BPF_FD_TYPE_URETPROBE                   5
#define BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG     (1U << 0)
#define BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL (1U << 1)
#define BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP      (1U << 2)

#define BPF_LINE_INFO_LINE_NUM(line_col) ((line_col) >> 10)
#define BPF_LINE_INFO_LINE_COL(line_col) ((line_col)&0x3ff)

#define BTF_F_COMPACT (1ULL << 0)
#define BTF_F_NONAME  (1ULL << 1)
#define BTF_F_PTR_RAW (1ULL << 2)
#define BTF_F_ZERO    (1ULL << 3)

#define BPF_OK          0
#define BPF_DROP        2
#define BPF_REDIRECT    7
#define BPF_LWT_REROUTE 128

#define BPF_FUNC_unspec                         0
#define BPF_FUNC_map_lookup_elem                1
#define BPF_FUNC_map_update_elem                2
#define BPF_FUNC_map_delete_elem                3
#define BPF_FUNC_probe_read                     4
#define BPF_FUNC_ktime_get_ns                   5
#define BPF_FUNC_trace_printk                   6
#define BPF_FUNC_get_prandom_u32                7
#define BPF_FUNC_get_smp_processor_id           8
#define BPF_FUNC_skb_store_bytes                9
#define BPF_FUNC_l3_csum_replace                10
#define BPF_FUNC_l4_csum_replace                11
#define BPF_FUNC_tail_call                      12
#define BPF_FUNC_clone_redirect                 13
#define BPF_FUNC_get_current_pid_tgid           14
#define BPF_FUNC_get_current_uid_gid            15
#define BPF_FUNC_get_current_comm               16
#define BPF_FUNC_get_cgroup_classid             17
#define BPF_FUNC_skb_vlan_push                  18
#define BPF_FUNC_skb_vlan_pop                   19
#define BPF_FUNC_skb_get_tunnel_key             20
#define BPF_FUNC_skb_set_tunnel_key             21
#define BPF_FUNC_perf_event_read                22
#define BPF_FUNC_redirect                       23
#define BPF_FUNC_get_route_realm                24
#define BPF_FUNC_perf_event_output              25
#define BPF_FUNC_skb_load_bytes                 26
#define BPF_FUNC_get_stackid                    27
#define BPF_FUNC_csum_diff                      28
#define BPF_FUNC_skb_get_tunnel_opt             29
#define BPF_FUNC_skb_set_tunnel_opt             30
#define BPF_FUNC_skb_change_proto               31
#define BPF_FUNC_skb_change_type                32
#define BPF_FUNC_skb_under_cgroup               33
#define BPF_FUNC_get_hash_recalc                34
#define BPF_FUNC_get_current_task               35
#define BPF_FUNC_probe_write_user               36
#define BPF_FUNC_current_task_under_cgroup      37
#define BPF_FUNC_skb_change_tail                38
#define BPF_FUNC_skb_pull_data                  39
#define BPF_FUNC_csum_update                    40
#define BPF_FUNC_set_hash_invalid               41
#define BPF_FUNC_get_numa_node_id               42
#define BPF_FUNC_skb_change_head                43
#define BPF_FUNC_xdp_adjust_head                44
#define BPF_FUNC_probe_read_str                 45
#define BPF_FUNC_get_socket_cookie              46
#define BPF_FUNC_get_socket_uid                 47
#define BPF_FUNC_set_hash                       48
#define BPF_FUNC_setsockopt                     49
#define BPF_FUNC_skb_adjust_room                50
#define BPF_FUNC_redirect_map                   51
#define BPF_FUNC_sk_redirect_map                52
#define BPF_FUNC_sock_map_update                53
#define BPF_FUNC_xdp_adjust_meta                54
#define BPF_FUNC_perf_event_read_value          55
#define BPF_FUNC_perf_prog_read_value           56
#define BPF_FUNC_getsockopt                     57
#define BPF_FUNC_override_return                58
#define BPF_FUNC_sock_ops_cb_flags_set          59
#define BPF_FUNC_msg_redirect_map               60
#define BPF_FUNC_msg_apply_bytes                61
#define BPF_FUNC_msg_cork_bytes                 62
#define BPF_FUNC_msg_pull_data                  63
#define BPF_FUNC_bind                           64
#define BPF_FUNC_xdp_adjust_tail                65
#define BPF_FUNC_skb_get_xfrm_state             66
#define BPF_FUNC_get_stack                      67
#define BPF_FUNC_skb_load_bytes_relative        68
#define BPF_FUNC_fib_lookup                     69
#define BPF_FUNC_sock_hash_update               70
#define BPF_FUNC_msg_redirect_hash              71
#define BPF_FUNC_sk_redirect_hash               72
#define BPF_FUNC_lwt_push_encap                 73
#define BPF_FUNC_lwt_seg6_store_bytes           74
#define BPF_FUNC_lwt_seg6_adjust_srh            75
#define BPF_FUNC_lwt_seg6_action                76
#define BPF_FUNC_rc_repeat                      77
#define BPF_FUNC_rc_keydown                     78
#define BPF_FUNC_skb_cgroup_id                  79
#define BPF_FUNC_get_current_cgroup_id          80
#define BPF_FUNC_get_local_storage              81
#define BPF_FUNC_sk_select_reuseport            82
#define BPF_FUNC_skb_ancestor_cgroup_id         83
#define BPF_FUNC_sk_lookup_tcp                  84
#define BPF_FUNC_sk_lookup_udp                  85
#define BPF_FUNC_sk_release                     86
#define BPF_FUNC_map_push_elem                  87
#define BPF_FUNC_map_pop_elem                   88
#define BPF_FUNC_map_peek_elem                  89
#define BPF_FUNC_msg_push_data                  90
#define BPF_FUNC_msg_pop_data                   91
#define BPF_FUNC_rc_pointer_rel                 92
#define BPF_FUNC_spin_lock                      93
#define BPF_FUNC_spin_unlock                    94
#define BPF_FUNC_sk_fullsock                    95
#define BPF_FUNC_tcp_sock                       96
#define BPF_FUNC_skb_ecn_set_ce                 97
#define BPF_FUNC_get_listener_sock              98
#define BPF_FUNC_skc_lookup_tcp                 99
#define BPF_FUNC_tcp_check_syncookie            100
#define BPF_FUNC_sysctl_get_name                101
#define BPF_FUNC_sysctl_get_current_value       102
#define BPF_FUNC_sysctl_get_new_value           103
#define BPF_FUNC_sysctl_set_new_value           104
#define BPF_FUNC_strtol                         105
#define BPF_FUNC_strtoul                        106
#define BPF_FUNC_sk_storage_get                 107
#define BPF_FUNC_sk_storage_delete              108
#define BPF_FUNC_send_signal                    109
#define BPF_FUNC_tcp_gen_syncookie              110
#define BPF_FUNC_skb_output                     111
#define BPF_FUNC_probe_read_user                112
#define BPF_FUNC_probe_read_kernel              113
#define BPF_FUNC_probe_read_user_str            114
#define BPF_FUNC_probe_read_kernel_str          115
#define BPF_FUNC_tcp_send_ack                   116
#define BPF_FUNC_send_signal_thread             117
#define BPF_FUNC_jiffies64                      118
#define BPF_FUNC_read_branch_records            119
#define BPF_FUNC_get_ns_current_pid_tgid        120
#define BPF_FUNC_xdp_output                     121
#define BPF_FUNC_get_netns_cookie               122
#define BPF_FUNC_get_current_ancestor_cgroup_id 123
#define BPF_FUNC_sk_assign                      124
#define BPF_FUNC_ktime_get_boot_ns              125
#define BPF_FUNC_seq_printf                     126
#define BPF_FUNC_seq_write                      127
#define BPF_FUNC_sk_cgroup_id                   128
#define BPF_FUNC_sk_ancestor_cgroup_id          129
#define BPF_FUNC_ringbuf_output                 130
#define BPF_FUNC_ringbuf_reserve                131
#define BPF_FUNC_ringbuf_submit                 132
#define BPF_FUNC_ringbuf_discard                133
#define BPF_FUNC_ringbuf_query                  134
#define BPF_FUNC_csum_level                     135
#define BPF_FUNC_skc_to_tcp6_sock               136
#define BPF_FUNC_skc_to_tcp_sock                137
#define BPF_FUNC_skc_to_tcp_timewait_sock       138
#define BPF_FUNC_skc_to_tcp_request_sock        139
#define BPF_FUNC_skc_to_udp6_sock               140
#define BPF_FUNC_get_task_stack                 141
#define BPF_FUNC_load_hdr_opt                   142
#define BPF_FUNC_store_hdr_opt                  143
#define BPF_FUNC_reserve_hdr_opt                144
#define BPF_FUNC_inode_storage_get              145
#define BPF_FUNC_inode_storage_delete           146
#define BPF_FUNC_d_path                         147
#define BPF_FUNC_copy_from_user                 148
#define BPF_FUNC_snprintf_btf                   149
#define BPF_FUNC_seq_printf_btf                 150
#define BPF_FUNC_skb_cgroup_classid             151
#define BPF_FUNC_redirect_neigh                 152
#define BPF_FUNC_per_cpu_ptr                    153
#define BPF_FUNC_this_cpu_ptr                   154
#define BPF_FUNC_redirect_peer                  155
#define BPF_FUNC_task_storage_get               156
#define BPF_FUNC_task_storage_delete            157
#define BPF_FUNC_get_current_task_btf           158
#define BPF_FUNC_bprm_opts_set                  159
#define BPF_FUNC_ktime_get_coarse_ns            160
#define BPF_FUNC_ima_inode_hash                 161
#define BPF_FUNC_sock_from_file                 162
#define BPF_FUNC_check_mtu                      163
#define BPF_FUNC_for_each_map_elem              164
#define BPF_FUNC_snprintf                       165
#define BPF_FUNC_sys_bpf                        166
#define BPF_FUNC_btf_find_by_name_kind          167
#define BPF_FUNC_sys_close                      168
#define __BPF_FUNC_MAX_ID                       169

#define __bpf_md_ptr(type, name) \
  union {                        \
    type name;                   \
    uint64_t : 64;               \
  } forcealign(8)

struct bpf_insn {
  uint8_t code;
  uint8_t dst_reg : 4;
  uint8_t src_reg : 4;
  int16_t off;
  int32_t imm;
};

struct bpf_lpm_trie_key {
  uint32_t prefixlen;
  uint8_t data[0];
};

struct bpf_cgroup_storage_key {
  uint64_t cgroup_inode_id;
  uint32_t attach_type;
};

union bpf_iter_link_info {
  struct {
    uint32_t map_fd;
  } map;
};

struct bpf_stack_build_id {
  int32_t status;
  unsigned char build_id[BPF_BUILD_ID_SIZE];
  union {
    uint64_t offset;
    uint64_t ip;
  };
};

union bpf_attr {
  struct {
    uint32_t map_type;
    uint32_t key_size;
    uint32_t value_size;
    uint32_t max_entries;
    uint32_t map_flags;
    uint32_t inner_map_fd;
    uint32_t numa_node;
    char map_name[BPF_OBJ_NAME_LEN];
    uint32_t map_ifindex;
    uint32_t btf_fd;
    uint32_t btf_key_type_id;
    uint32_t btf_value_type_id;
    uint32_t btf_vmlinux_value_type_id;
  };
  struct {
    uint32_t map_fd;
    uint64_t key;
    union {
      uint64_t value;
      uint64_t next_key;
    };
    uint64_t flags;
  };
  struct {
    uint64_t in_batch;
    uint64_t out_batch;
    uint64_t keys;
    uint64_t values;
    uint32_t count;
    uint32_t map_fd;
    uint64_t elem_flags;
    uint64_t flags;
  } batch;
  struct {
    uint32_t prog_type;
    uint32_t insn_cnt;
    uint64_t insns;
    uint64_t license;
    uint32_t log_level;
    uint32_t log_size;
    uint64_t log_buf;
    uint32_t kern_version;
    uint32_t prog_flags;
    char prog_name[BPF_OBJ_NAME_LEN];
    uint32_t prog_ifindex;
    uint32_t expected_attach_type;
    uint32_t prog_btf_fd;
    uint32_t func_info_rec_size;
    uint64_t func_info;
    uint32_t func_info_cnt;
    uint32_t line_info_rec_size;
    uint64_t line_info;
    uint32_t line_info_cnt;
    uint32_t attach_btf_id;
    union {
      uint32_t attach_prog_fd;
      uint32_t attach_btf_obj_fd;
    };
    uint32_t : 32;
    uint64_t fd_array;
  };
  struct {
    uint64_t pathname;
    uint32_t bpf_fd;
    uint32_t file_flags;
  };
  struct {
    uint32_t target_fd;
    uint32_t attach_bpf_fd;
    uint32_t attach_type;
    uint32_t attach_flags;
    uint32_t replace_bpf_fd;
  };
  struct {
    uint32_t prog_fd;
    uint32_t retval;
    uint32_t data_size_in;
    uint32_t data_size_out;
    uint64_t data_in;
    uint64_t data_out;
    uint32_t repeat;
    uint32_t duration;
    uint32_t ctx_size_in;
    uint32_t ctx_size_out;
    uint64_t ctx_in;
    uint64_t ctx_out;
    uint32_t flags;
    uint32_t cpu;
  } test;
  struct {
    union {
      uint32_t start_id;
      uint32_t prog_id;
      uint32_t map_id;
      uint32_t btf_id;
      uint32_t link_id;
    };
    uint32_t next_id;
    uint32_t open_flags;
  };
  struct {
    uint32_t bpf_fd;
    uint32_t info_len;
    uint64_t info;
  } info;
  struct {
    uint32_t target_fd;
    uint32_t attach_type;
    uint32_t query_flags;
    uint32_t attach_flags;
    uint64_t prog_ids;
    uint32_t prog_cnt;
  } query;
  struct {
    uint64_t name;
    uint32_t prog_fd;
  } raw_tracepoint;
  struct {
    uint64_t btf;
    uint64_t btf_log_buf;
    uint32_t btf_size;
    uint32_t btf_log_size;
    uint32_t btf_log_level;
  };
  struct {
    uint32_t pid;
    uint32_t fd;
    uint32_t flags;
    uint32_t buf_len;
    uint64_t buf;
    uint32_t prog_id;
    uint32_t fd_type;
    uint64_t probe_offset;
    uint64_t probe_addr;
  } task_fd_query;
  struct {
    uint32_t prog_fd;
    union {
      uint32_t target_fd;
      uint32_t target_ifindex;
    };
    uint32_t attach_type;
    uint32_t flags;
    union {
      uint32_t target_btf_id;
      struct {
        uint64_t iter_info;
        uint32_t iter_info_len;
      };
    };
  } link_create;
  struct {
    uint32_t link_fd;
    uint32_t new_prog_fd;
    uint32_t flags;
    uint32_t old_prog_fd;
  } link_update;
  struct {
    uint32_t link_fd;
  } link_detach;
  struct {
    uint32_t type;
  } enable_stats;
  struct {
    uint32_t link_fd;
    uint32_t flags;
  } iter_create;
  struct {
    uint32_t prog_fd;
    uint32_t map_fd;
    uint32_t flags;
  } prog_bind_map;
} forcealign(8);

struct __sk_buff {
  uint32_t len;
  uint32_t pkt_type;
  uint32_t mark;
  uint32_t queue_mapping;
  uint32_t protocol;
  uint32_t vlan_present;
  uint32_t vlan_tci;
  uint32_t vlan_proto;
  uint32_t priority;
  uint32_t ingress_ifindex;
  uint32_t ifindex;
  uint32_t tc_index;
  uint32_t cb[5];
  uint32_t hash;
  uint32_t tc_classid;
  uint32_t data;
  uint32_t data_end;
  uint32_t napi_id;
  uint32_t family;
  uint32_t remote_ip4;
  uint32_t local_ip4;
  uint32_t remote_ip6[4];
  uint32_t local_ip6[4];
  uint32_t remote_port;
  uint32_t local_port;
  uint32_t data_meta;
  __bpf_md_ptr(struct bpf_flow_keys *, flow_keys);
  uint64_t tstamp;
  uint32_t wire_len;
  uint32_t gso_segs;
  __bpf_md_ptr(struct bpf_sock *, sk);
  uint32_t gso_size;
};

struct bpf_tunnel_key {
  uint32_t tunnel_id;
  union {
    uint32_t remote_ipv4;
    uint32_t remote_ipv6[4];
  };
  uint8_t tunnel_tos;
  uint8_t tunnel_ttl;
  uint16_t tunnel_ext;
  uint32_t tunnel_label;
};

struct bpf_xfrm_state {
  uint32_t reqid;
  uint32_t spi;
  uint16_t family;
  uint16_t ext;
  union {
    uint32_t remote_ipv4;
    uint32_t remote_ipv6[4];
  };
};

struct bpf_sock {
  uint32_t bound_dev_if;
  uint32_t family;
  uint32_t type;
  uint32_t protocol;
  uint32_t mark;
  uint32_t priority;
  uint32_t src_ip4;
  uint32_t src_ip6[4];
  uint32_t src_port;
  uint32_t dst_port;
  uint32_t dst_ip4;
  uint32_t dst_ip6[4];
  uint32_t state;
  int32_t rx_queue_mapping;
};

struct bpf_tcp_sock {
  uint32_t snd_cwnd;
  uint32_t srtt_us;
  uint32_t rtt_min;
  uint32_t snd_ssthresh;
  uint32_t rcv_nxt;
  uint32_t snd_nxt;
  uint32_t snd_una;
  uint32_t mss_cache;
  uint32_t ecn_flags;
  uint32_t rate_delivered;
  uint32_t rate_interval_us;
  uint32_t packets_out;
  uint32_t retrans_out;
  uint32_t total_retrans;
  uint32_t segs_in;
  uint32_t data_segs_in;
  uint32_t segs_out;
  uint32_t data_segs_out;
  uint32_t lost_out;
  uint32_t sacked_out;
  uint64_t bytes_received;
  uint64_t bytes_acked;
  uint32_t dsack_dups;
  uint32_t delivered;
  uint32_t delivered_ce;
  uint32_t icsk_retransmits;
};

struct bpf_sock_tuple {
  union {
    struct {
      uint32_t saddr; /* big endian */
      uint32_t daddr; /* big endian */
      uint16_t sport; /* big endian */
      uint16_t dport; /* big endian */
    } ipv4;
    struct {
      uint32_t saddr[4]; /* big endian */
      uint32_t daddr[4]; /* big endian */
      uint16_t sport;    /* big endian */
      uint16_t dport;    /* big endian */
    } ipv6;
  };
};

struct bpf_xdp_sock {
  uint32_t queue_id;
};

enum xdp_action {
  XDP_ABORTED = 0,
  XDP_DROP,
  XDP_PASS,
  XDP_TX,
  XDP_REDIRECT,
};

struct xdp_md {
  uint32_t data;
  uint32_t data_end;
  uint32_t data_meta;
  uint32_t ingress_ifindex;
  uint32_t rx_queue_index;
  uint32_t egress_ifindex;
};

struct bpf_devmap_val {
  uint32_t ifindex;
  union {
    int fd;
    uint32_t id;
  } bpf_prog;
};

struct bpf_cpumap_val {
  uint32_t qsize;
  union {
    int fd;
    uint32_t id;
  } bpf_prog;
};

enum sk_action {
  SK_DROP = 0,
  SK_PASS,
};

struct sk_msg_md {
  __bpf_md_ptr(void *, data);
  __bpf_md_ptr(void *, data_end);
  uint32_t family;
  uint32_t remote_ip4;
  uint32_t local_ip4;
  uint32_t remote_ip6[4];
  uint32_t local_ip6[4];
  uint32_t remote_port;
  uint32_t local_port;
  uint32_t size;
  __bpf_md_ptr(struct bpf_sock *, sk);
};

struct sk_reuseport_md {
  __bpf_md_ptr(void *, data);
  __bpf_md_ptr(void *, data_end);
  uint32_t len;
  uint32_t eth_protocol;
  uint32_t ip_protocol;
  uint32_t bind_inany;
  uint32_t hash;
  __bpf_md_ptr(struct bpf_sock *, sk);
  __bpf_md_ptr(struct bpf_sock *, migrating_sk);
};

struct bpf_prog_info {
  uint32_t type;
  uint32_t id;
  uint8_t tag[BPF_TAG_SIZE];
  uint32_t jited_prog_len;
  uint32_t xlated_prog_len;
  uint64_t jited_prog_insns;
  uint64_t xlated_prog_insns;
  uint64_t load_time;
  uint32_t created_by_uid;
  uint32_t nr_map_ids;
  uint64_t map_ids;
  char name[BPF_OBJ_NAME_LEN];
  uint32_t ifindex;
  uint32_t gpl_compatible : 1;
  uint32_t : 31;
  uint64_t netns_dev;
  uint64_t netns_ino;
  uint32_t nr_jited_ksyms;
  uint32_t nr_jited_func_lens;
  uint64_t jited_ksyms;
  uint64_t jited_func_lens;
  uint32_t btf_id;
  uint32_t func_info_rec_size;
  uint64_t func_info;
  uint32_t nr_func_info;
  uint32_t nr_line_info;
  uint64_t line_info;
  uint64_t jited_line_info;
  uint32_t nr_jited_line_info;
  uint32_t line_info_rec_size;
  uint32_t jited_line_info_rec_size;
  uint32_t nr_prog_tags;
  uint64_t prog_tags;
  uint64_t run_time_ns;
  uint64_t run_cnt;
  uint64_t recursion_misses;
} forcealign(8);

struct bpf_map_info {
  uint32_t type;
  uint32_t id;
  uint32_t key_size;
  uint32_t value_size;
  uint32_t max_entries;
  uint32_t map_flags;
  char name[BPF_OBJ_NAME_LEN];
  uint32_t ifindex;
  uint32_t btf_vmlinux_value_type_id;
  uint64_t netns_dev;
  uint64_t netns_ino;
  uint32_t btf_id;
  uint32_t btf_key_type_id;
  uint32_t btf_value_type_id;
} forcealign(8);

struct bpf_btf_info {
  uint64_t btf;
  uint32_t btf_size;
  uint32_t id;
  uint64_t name;
  uint32_t name_len;
  uint32_t kernel_btf;
} forcealign(8);

struct bpf_link_info {
  uint32_t type;
  uint32_t id;
  uint32_t prog_id;
  union {
    struct {
      uint64_t tp_name;
      uint32_t tp_name_len;
    } raw_tracepoint;
    struct {
      uint32_t attach_type;
      uint32_t target_obj_id;
      uint32_t target_btf_id;
    } tracing;
    struct {
      uint64_t cgroup_id;
      uint32_t attach_type;
    } cgroup;
    struct {
      uint64_t target_name;
      uint32_t target_name_len;
      union {
        struct {
          uint32_t map_id;
        } map;
      };
    } iter;
    struct {
      uint32_t netns_ino;
      uint32_t attach_type;
    } netns;
    struct {
      uint32_t ifindex;
    } xdp;
  };
} forcealign(8);

struct bpf_sock_addr {
  uint32_t user_family;
  uint32_t user_ip4;
  uint32_t user_ip6[4];
  uint32_t user_port;
  uint32_t family;
  uint32_t type;
  uint32_t protocol;
  uint32_t msg_src_ip4;
  uint32_t msg_src_ip6[4];
  __bpf_md_ptr(struct bpf_sock *, sk);
};

struct bpf_sock_ops {
  uint32_t op;
  union {
    uint32_t args[4];
    uint32_t reply;
    uint32_t replylong[4];
  };
  uint32_t family;
  uint32_t remote_ip4;
  uint32_t local_ip4;
  uint32_t remote_ip6[4];
  uint32_t local_ip6[4];
  uint32_t remote_port;
  uint32_t local_port;
  uint32_t is_fullsock;
  uint32_t snd_cwnd;
  uint32_t srtt_us;
  uint32_t bpf_sock_ops_cb_flags;
  uint32_t state;
  uint32_t rtt_min;
  uint32_t snd_ssthresh;
  uint32_t rcv_nxt;
  uint32_t snd_nxt;
  uint32_t snd_una;
  uint32_t mss_cache;
  uint32_t ecn_flags;
  uint32_t rate_delivered;
  uint32_t rate_interval_us;
  uint32_t packets_out;
  uint32_t retrans_out;
  uint32_t total_retrans;
  uint32_t segs_in;
  uint32_t data_segs_in;
  uint32_t segs_out;
  uint32_t data_segs_out;
  uint32_t lost_out;
  uint32_t sacked_out;
  uint32_t sk_txhash;
  uint64_t bytes_received;
  uint64_t bytes_acked;
  __bpf_md_ptr(struct bpf_sock *, sk);
  __bpf_md_ptr(void *, skb_data);
  __bpf_md_ptr(void *, skb_data_end);
  uint32_t skb_len;
  uint32_t skb_tcp_flags;
};

struct bpf_perf_event_value {
  uint64_t counter;
  uint64_t enabled;
  uint64_t running;
};

struct bpf_cgroup_dev_ctx {
  uint32_t access_type;
  uint32_t major;
  uint32_t minor;
};

struct bpf_raw_tracepoint_args {
  uint64_t args[0];
};

struct bpf_fib_lookup {
  uint8_t family;
  uint8_t l4_protocol;
  uint16_t sport; /* big endian */
  uint16_t dport; /* big endian */
  union {
    uint16_t tot_len;
    uint16_t mtu_result;
  };
  uint32_t ifindex;
  union {
    uint8_t tos;
    uint32_t flowinfo; /* big endian */
    uint32_t rt_metric;
  };
  union {
    uint32_t ipv4_src; /* big endian */
    uint32_t ipv6_src[4];
  };
  union {
    uint32_t ipv4_dst; /* big endian */
    uint32_t ipv6_dst[4];
  };
  uint16_t h_vlan_proto; /* big endian */
  uint16_t h_vlan_TCI;   /* big endian */
  uint8_t smac[6];
  uint8_t dmac[6];
};

struct bpf_redir_neigh {
  uint32_t nh_family;
  union {
    uint32_t ipv4_nh; /* big endian */
    uint32_t ipv6_nh[4];
  };
};

struct bpf_flow_keys {
  uint16_t nhoff;
  uint16_t thoff;
  uint16_t addr_proto;
  uint8_t is_frag;
  uint8_t is_first_frag;
  uint8_t is_encap;
  uint8_t ip_proto;
  uint16_t n_proto; /* big endian */
  uint16_t sport;   /* big endian */
  uint16_t dport;   /* big endian */
  union {
    struct {
      uint32_t ipv4_src; /* big endian */
      uint32_t ipv4_dst; /* big endian */
    };
    struct {
      uint32_t ipv6_src[4];
      uint32_t ipv6_dst[4];
    };
  };
  uint32_t flags;
  uint32_t flow_label;
};

struct bpf_func_info {
  uint32_t insn_off;
  uint32_t type_id;
};

struct bpf_line_info {
  uint32_t insn_off;
  uint32_t file_name_off;
  uint32_t line_off;
  uint32_t line_col;
};

struct bpf_spin_lock {
  uint32_t val;
};

struct bpf_sysctl {
  uint32_t write_;
  uint32_t file_pos;
};

struct bpf_sockopt {
  __bpf_md_ptr(struct bpf_sock *, sk);
  __bpf_md_ptr(void *, optval);
  __bpf_md_ptr(void *, optval_end);
  int32_t level;
  int32_t optname;
  int32_t optlen;
  int32_t retval;
};

struct bpf_pidns_info {
  uint32_t pid;
  uint32_t tgid;
};

struct bpf_sk_lookup {
  union {
    __bpf_md_ptr(struct bpf_sock *, sk);
    uint64_t cookie;
  };
  uint32_t family;
  uint32_t protocol;
  uint32_t remote_ip4;
  uint32_t remote_ip6[4];
  uint32_t remote_port;
  uint32_t local_ip4;
  uint32_t local_ip6[4];
  uint32_t local_port;
};

struct btf_ptr {
  void *ptr;
  uint32_t type_id;
  uint32_t flags;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/dirent.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_DIRENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct dirent {      /* linux getdents64 abi */
  uint64_t d_ino;    /* inode number */
  int64_t d_off;     /* implementation-dependent location number */
  uint16_t d_reclen; /* byte length of this whole struct and string */
  uint8_t d_type;    /* DT_REG, DT_DIR, DT_UNKNOWN, DT_BLK, etc. */
  char d_name[256];  /* NUL-terminated basename */
};

struct dirstream;
typedef struct dirstream DIR;

DIR *fdopendir(int) dontdiscard;
DIR *opendir(const char *) dontdiscard;
int closedir(DIR *);
int dirfd(DIR *);
long telldir(DIR *);
struct dirent *readdir(DIR *);
void rewinddir(DIR *);
void seekdir(DIR *, long);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/filter.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FILTER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define BPF_MAJOR_VERSION 1
#define BPF_MINOR_VERSION 1

struct sock_filter {
  uint16_t code;
  uint8_t jt;
  uint8_t jf;
  uint32_t k;
};

struct sock_fprog {
  unsigned short len;
  struct sock_filter *filter;
};

#define BPF_RVAL(code)   ((code)&0x18)
#define BPF_A            0x10
#define BPF_MISCOP(code) ((code)&0xf8)
#define BPF_TAX          0x00
#define BPF_TXA          0x80

#define BPF_STMT(code, k) \
  { (unsigned short)(code), 0, 0, k }
#define BPF_JUMP(code, k, jumptrue, jumpfalse) \
  { (unsigned short)(code), jumptrue, jumpfalse, k }

#define BPF_MEMWORDS 16

#define SKF_AD_OFF              (-0x1000)
#define SKF_AD_PROTOCOL         0
#define SKF_AD_PKTTYPE          4
#define SKF_AD_IFINDEX          8
#define SKF_AD_NLATTR           12
#define SKF_AD_NLATTR_NEST      16
#define SKF_AD_MARK             20
#define SKF_AD_QUEUE            24
#define SKF_AD_HATYPE           28
#define SKF_AD_RXHASH           32
#define SKF_AD_CPU              36
#define SKF_AD_ALU_XOR_X        40
#define SKF_AD_VLAN_TAG         44
#define SKF_AD_VLAN_TAG_PRESENT 48
#define SKF_AD_PAY_OFFSET       52
#define SKF_AD_RANDOM           56
#define SKF_AD_VLAN_TPID        60
#define SKF_AD_MAX              64
#define SKF_NET_OFF             (-0x100000)
#define SKF_LL_OFF              (-0x200000)
#define BPF_NET_OFF             SKF_NET_OFF
#define BPF_LL_OFF              SKF_LL_OFF

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/flock.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct flock {      /* cosmopolitan abi */
  int16_t l_type;   /* F_RDLCK, F_WRLCK, F_UNLCK */
  int16_t l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */
  int64_t l_start;  /* starting offset */
  int64_t l_len;    /* 0 means until end of file */
  int32_t l_pid;    /* lock owner */
  int32_t l_sysid;  /* remote system id or zero for local */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/framebufferfixedscreeninfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FRAMEBUFFERFIXEDSCREENINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FrameBufferFixedScreenInfo {
  char id[16];
  uint64_t smem_start;
  uint32_t smem_len;
  uint32_t type;
  uint32_t type_aux;
  uint32_t visual;
  uint16_t xpanstep;
  uint16_t ypanstep;
  uint16_t ywrapstep;
  uint32_t line_length;
  uint64_t mmio_start;
  uint32_t mmio_len;
  uint32_t accel;
  uint16_t capabilities;
  uint16_t reserved[2];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/framebuffervirtualscreeninfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FRAMEBUFFERVIRTUALSCREENINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FrameBufferBitField {
  uint32_t offset;
  uint32_t length;
  uint32_t msb_right;
};

struct FrameBufferVirtualScreenInfo {
  uint32_t xres;
  uint32_t yres;
  uint32_t xres_virtual;
  uint32_t yres_virtual;
  uint32_t xoffset;
  uint32_t yoffset;
  uint32_t bits_per_pixel;
  uint32_t grayscale;
  struct FrameBufferBitField red;
  struct FrameBufferBitField green;
  struct FrameBufferBitField blue;
  struct FrameBufferBitField transp;
  uint32_t nonstd;
  uint32_t activate;
  uint32_t height;
  uint32_t width;
  uint32_t accel_flags;
  uint32_t pixclock;
  uint32_t left_margin;
  uint32_t right_margin;
  uint32_t upper_margin;
  uint32_t lower_margin;
  uint32_t hsync_len;
  uint32_t vsync_len;
  uint32_t sync;
  uint32_t vmode;
  uint32_t rotate;
  uint32_t colorspace;
  uint32_t reserved[4];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/iovec.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_IOVEC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct iovec {
  void *iov_base;
  size_t iov_len;
};

ssize_t preadv(int, struct iovec *, int, int64_t);
ssize_t pwritev(int, const struct iovec *, int, int64_t);
ssize_t readv(int, const struct iovec *, int);
ssize_t vmsplice(int, const struct iovec *, int64_t, uint32_t);
ssize_t writev(int, const struct iovec *, int);
void DescribeIov(const struct iovec *, int, ssize_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/itimerval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_ITIMERVAL_H_


/*!BEGIN libc/calls/struct/timeval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TIMEVAL_H_


/*!BEGIN libc/time/struct/timezone.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_TIMEZONE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct timezone {
  int32_t tz_minuteswest;
  int32_t tz_dsttime;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct timeval {
  int64_t tv_sec;
  int64_t tv_usec; /* microseconds */
};

int futimes(int, const struct timeval[2]);
int futimesat(int, const char *, const struct timeval[2]);
int gettimeofday(struct timeval *, struct timezone *);
int lutimes(const char *, const struct timeval[2]);
int utimes(const char *, const struct timeval[2]);

struct timeval _timeval_add(struct timeval, struct timeval);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct itimerval {
  struct timeval it_interval; /* {0,0} means singleshot */
  struct timeval it_value;    /* {0,0} means disarm */
};

int getitimer(int, struct itimerval *);
int setitimer(int, const struct itimerval *, struct itimerval *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/metasigaltstack.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_METASIGALTSTACK_H_


/*!BEGIN libc/calls/struct/sigaltstack.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGALTSTACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sigaltstack {
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
};

typedef struct sigaltstack stack_t;

int sigaltstack(const struct sigaltstack *, struct sigaltstack *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sigaltstack_bsd {
  void *ss_sp;
  uint64_t ss_size;
  int32_t ss_flags;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/rlimit.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_RLIMIT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct rlimit {
  uint64_t rlim_cur; /* current (soft) limit in bytes */
  uint64_t rlim_max; /* maximum limit in bytes */
};

int getrlimit(int, struct rlimit *);
int setrlimit(int, const struct rlimit *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/rusage.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_RUSAGE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct rusage {
  struct timeval ru_utime; /* user CPU time used */
  struct timeval ru_stime; /* system CPU time used */
  int64_t ru_maxrss;       /* maximum resident set size in (kb) */
  int64_t ru_ixrss;        /* shared memory size (integral kb CLK_TCK) */
  int64_t ru_idrss;        /* unshared data size (integral kb CLK_TCK) */
  int64_t ru_isrss;        /* unshared stack size (integral kb CLK_TCK) */
  int64_t ru_minflt;       /* page reclaims */
  int64_t ru_majflt;       /* page faults */
  int64_t ru_nswap;        /* swaps */
  int64_t ru_inblock;      /* block input operations */
  int64_t ru_oublock;      /* block output operations */
  int64_t ru_msgsnd;       /* IPC messages sent */
  int64_t ru_msgrcv;       /* IPC messages received */
  int64_t ru_nsignals;     /* signals received */
  int64_t ru_nvcsw;        /* voluntary context switches */
  int64_t ru_nivcsw;       /* involuntary context switches */
};

int getrusage(int, struct rusage *);
int wait3(int *, int, struct rusage *);
int wait4(int, int *, int, struct rusage *);
void _addrusage(struct rusage *, const struct rusage *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sched_param.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SCHED_PARAM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sched_param {
  int32_t sched_priority;
};

int sched_get_priority_max(int);
int sched_get_priority_min(int);
int sched_getparam(int, struct sched_param *);
int sched_getscheduler(int);
int sched_rr_get_interval(int, struct timespec *);
int sched_setparam(int, const struct sched_param *);
int sched_setscheduler(int, int, const struct sched_param *);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/seccomp.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SECCOMP_H_

#define SECCOMP_SET_MODE_STRICT          0
#define SECCOMP_SET_MODE_FILTER          1
#define SECCOMP_GET_ACTION_AVAIL         2
#define SECCOMP_GET_NOTIF_SIZES          3
#define SECCOMP_FILTER_FLAG_TSYNC        (1UL << 0)
#define SECCOMP_FILTER_FLAG_LOG          (1UL << 1)
#define SECCOMP_FILTER_FLAG_SPEC_ALLOW   (1UL << 2)
#define SECCOMP_FILTER_FLAG_NEW_LISTENER (1UL << 3)
#define SECCOMP_FILTER_FLAG_TSYNC_ESRCH  (1UL << 4)
#define SECCOMP_RET_KILL_PROCESS         0x80000000U
#define SECCOMP_RET_KILL_THREAD          0x00000000U
#define SECCOMP_RET_KILL                 SECCOMP_RET_KILL_THREAD
#define SECCOMP_RET_TRAP                 0x00030000U
#define SECCOMP_RET_ERRNO                0x00050000U
#define SECCOMP_RET_USER_NOTIF           0x7fc00000U
#define SECCOMP_RET_TRACE                0x7ff00000U
#define SECCOMP_RET_LOG                  0x7ffc0000U
#define SECCOMP_RET_ALLOW                0x7fff0000U
#define SECCOMP_RET_ACTION_FULL          0xffff0000U
#define SECCOMP_RET_ACTION               0x7fff0000U
#define SECCOMP_RET_DATA                 0x0000ffffU
#define SECCOMP_USER_NOTIF_FLAG_CONTINUE (1UL << 0)
#define SECCOMP_ADDFD_FLAG_SETFD         (1UL << 0)
#define SECCOMP_ADDFD_FLAG_SEND          (1UL << 1)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define SECCOMP_IOC_MAGIC      '!'
#define SECCOMP_IO(nr)         _IO(SECCOMP_IOC_MAGIC, nr)
#define SECCOMP_IOR(nr, type)  _IOR(SECCOMP_IOC_MAGIC, nr, type)
#define SECCOMP_IOW(nr, type)  _IOW(SECCOMP_IOC_MAGIC, nr, type)
#define SECCOMP_IOWR(nr, type) _IOWR(SECCOMP_IOC_MAGIC, nr, type)

#define SECCOMP_IOCTL_NOTIF_RECV     SECCOMP_IOWR(0, struct seccomp_notif)
#define SECCOMP_IOCTL_NOTIF_SEND     SECCOMP_IOWR(1, struct seccomp_notif_resp)
#define SECCOMP_IOCTL_NOTIF_ID_VALID SECCOMP_IOW(2, __u64)
#define SECCOMP_IOCTL_NOTIF_ADDFD    SECCOMP_IOW(3, struct seccomp_notif_addfd)

struct seccomp_data {
  int32_t nr;
  uint32_t arch;
  uint64_t instruction_pointer;
  uint64_t args[6];
};

struct seccomp_notif_sizes {
  uint16_t seccomp_notif;
  uint16_t seccomp_notif_resp;
  uint16_t seccomp_data;
};

struct seccomp_notif {
  uint64_t id;
  uint32_t pid;
  uint32_t flags;
  struct seccomp_data data;
};

struct seccomp_notif_resp {
  uint64_t id;
  int64_t val;
  int32_t error;
  uint32_t flags;
};

struct seccomp_notif_addfd {
  uint64_t id;
  uint32_t flags;
  uint32_t srcfd;
  uint32_t newfd;
  uint32_t newfd_flags;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigaction-netbsd.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGACTION_NETBSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sigset_netbsd {
  uint32_t sig[4];
};

struct sigaction_netbsd {
  intptr_t sa_handler;
  struct sigset_netbsd sa_mask;
  uint32_t sa_flags;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigaction.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGACTION_H_


/*!BEGIN libc/calls/struct/siginfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGINFO_H_


/*!BEGIN libc/calls/struct/sigval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGVAL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

union sigval {
  int32_t sival_int;
  void *sival_ptr;
};

int sigqueue(int, int, const union sigval);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct siginfo {
  int32_t si_signo;
  int32_t si_errno;
  int32_t si_code; /* {SICODE,SEGV,ILL,FPE,POLL}_xxx */
  union {
    struct {
      union {
        struct {
          int32_t si_pid;
          uint32_t si_uid;
        };
        struct {
          int32_t si_timerid; /* SIGALRM */
          int32_t si_overrun;
        };
      };
      union {
        union sigval si_value; /* provided by third arg of sigqueue(2) */
        struct {
          int32_t si_status;
          int64_t si_utime;
          int64_t si_stime;
        };
      };
    };
    struct {
      void *si_addr;
      int16_t si_addr_lsb;
      union {
        struct {
          void *si_lower;
          void *si_upper;
        };
        uint32_t si_pkey;
      };
    };
    struct {
      int64_t si_band; /* SIGPOLL */
      int32_t si_fd;
    };
    struct {
      void *si_call_addr;
      int32_t si_syscall;
      uint32_t si_arch;
    };
    char __ignoreme[128 - 2 * sizeof(int32_t) - sizeof(int64_t)];
  };
};

typedef struct siginfo siginfo_t;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigset.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGSET_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef struct sigset {
  uint64_t __bits[2];
} sigset_t;

int sigaddset(sigset_t *, int) paramsnonnull();
int sigdelset(sigset_t *, int) paramsnonnull();
int sigemptyset(sigset_t *) paramsnonnull();
int sigfillset(sigset_t *) paramsnonnull();
int sigismember(const sigset_t *, int) paramsnonnull() nosideeffect;
int sigprocmask(int, const sigset_t *, sigset_t *);
int sigsuspend(const sigset_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ucontext.h */

#define COSMOPOLITAN_LIBC_CALLS_UCONTEXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct XmmRegister {
  uint64_t u64[2];
};

struct FpuStackEntry {
  uint16_t significand[4];
  uint16_t exponent;
  uint16_t padding[3];
};

struct thatispacked FpuState {
  uint16_t cwd;
  uint16_t swd;
  uint16_t ftw;
  uint16_t fop;
  uint64_t rip;
  uint64_t rdp;
  uint32_t mxcsr;
  uint32_t mxcr_mask;
  struct FpuStackEntry st[8];
  struct XmmRegister xmm[16];
  uint32_t __padding[24];
};

typedef uint64_t greg_t;
typedef greg_t gregset_t[23];
typedef struct FpuState *fpregset_t;

struct MachineContext {
  union {
    struct {
      uint64_t r8;
      uint64_t r9;
      uint64_t r10;
      uint64_t r11;
      uint64_t r12;
      uint64_t r13;
      uint64_t r14;
      uint64_t r15;
      uint64_t rdi;
      uint64_t rsi;
      uint64_t rbp;
      uint64_t rbx;
      uint64_t rdx;
      uint64_t rax;
      uint64_t rcx;
      uint64_t rsp;
      uint64_t rip;
      uint64_t eflags;
      uint16_t cs;
      uint16_t gs;
      uint16_t fs;
      uint16_t __pad0;
      uint64_t err;
      uint64_t trapno;
      uint64_t oldmask;
      uint64_t cr2;
    };
    gregset_t gregs;
  };
  struct FpuState *fpregs;
  uint64_t __pad1[8];
};

typedef struct MachineContext mcontext_t;

struct ucontext {
  uint64_t uc_flags;
  struct ucontext *uc_link;
  stack_t uc_stack;
  mcontext_t uc_mcontext; /* use this */
  sigset_t uc_sigmask;
  struct FpuState __fpustate; /* for cosmo on non-linux */
};

typedef struct ucontext ucontext_t;

int getcontext(ucontext_t *);
int setcontext(const ucontext_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sig.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SIG_H_


/*!BEGIN libc/runtime/symbolic.h */

#define COSMOPOLITAN_LIBC_RUNTIME_SYMBOLIC_H_

#ifdef __ASSEMBLER__
/* clang-format off */
#define SYMBOLIC(NAME) NAME(%rip)
#define LITERALLY(NAME) $NAME
/* clang-format on */
#else
#define SYMBOLIC(NAME) NAME
#define LITERALLY(NAME) NAME
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SIGABRT;
extern const int SIGALRM;
extern const int SIGBUS;
extern const int SIGCHLD;
extern const int SIGCONT;
extern const int SIGEMT;
extern const int SIGFPE;
extern const int SIGHUP;
extern const int SIGILL;
extern const int SIGINFO;
extern const int SIGINT;
extern const int SIGIO;
extern const int SIGIOT;
extern const int SIGKILL;
extern const int SIGPIPE;
extern const int SIGPOLL;
extern const int SIGPROF;
extern const int SIGPWR;
extern const int SIGQUIT;
extern const int SIGRTMAX;
extern const int SIGRTMIN;
extern const int SIGSEGV;
extern const int SIGSTKFLT;
extern const int SIGSTOP;
extern const int SIGSYS;
extern const int SIGTERM;
extern const int SIGTRAP;
extern const int SIGTSTP;
extern const int SIGTTIN;
extern const int SIGTTOU;
extern const int SIGUNUSED;
extern const int SIGURG;
extern const int SIGUSR1;
extern const int SIGUSR2;
extern const int SIGVTALRM;
extern const int SIGWINCH;
extern const int SIGXCPU;
extern const int SIGXFSZ;

extern const int SIG_ATOMIC_MIN;
extern const int SIG_BLOCK;
extern const int SIG_SETMASK;
extern const int SIG_UNBLOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SIGABRT   LITERALLY(6)
#define SIGALRM   LITERALLY(14)
#define SIGFPE    LITERALLY(8)
#define SIGHUP    LITERALLY(1)
#define SIGILL    LITERALLY(4)
#define SIGINT    LITERALLY(2)
#define SIGIOT    LITERALLY(6)
#define SIGKILL   LITERALLY(9)
#define SIGPIPE   LITERALLY(13)
#define SIGPROF   LITERALLY(27)
#define SIGQUIT   LITERALLY(3)
#define SIGSEGV   LITERALLY(11)
#define SIGTERM   LITERALLY(15)
#define SIGTRAP   LITERALLY(5)
#define SIGTTIN   LITERALLY(21)
#define SIGTTOU   LITERALLY(22)
#define SIGVTALRM LITERALLY(26)
#define SIGWINCH  LITERALLY(28)
#define SIGXCPU   LITERALLY(24)
#define SIGXFSZ   LITERALLY(25)

#define SIGBUS    SYMBOLIC(SIGBUS)
#define SIGCHLD   SYMBOLIC(SIGCHLD)
#define SIGCONT   SYMBOLIC(SIGCONT)
#define SIGEMT    SYMBOLIC(SIGEMT)
#define SIGINFO   SYMBOLIC(SIGINFO)
#define SIGIO     SYMBOLIC(SIGIO)
#define SIGPOLL   SYMBOLIC(SIGPOLL)
#define SIGPWR    SYMBOLIC(SIGPWR)
#define SIGRTMAX  SYMBOLIC(SIGRTMAX)
#define SIGRTMIN  SYMBOLIC(SIGRTMIN)
#define SIGSTKFLT SYMBOLIC(SIGSTKFLT)
#define SIGSTOP   SYMBOLIC(SIGSTOP)
#define SIGSYS    SYMBOLIC(SIGSYS)
#define SIGTSTP   SYMBOLIC(SIGTSTP)
#define SIGUNUSED SYMBOLIC(SIGUNUSED)
#define SIGURG    SYMBOLIC(SIGURG)
#define SIGUSR1   SYMBOLIC(SIGUSR1)
#define SIGUSR2   SYMBOLIC(SIGUSR2)

#define SIG_ATOMIC_MIN SYMBOLIC(SIG_ATOMIC_MIN)
#define SIG_BLOCK      SYMBOLIC(SIG_BLOCK)
#define SIG_SETMASK    SYMBOLIC(SIG_SETMASK)
#define SIG_UNBLOCK    SYMBOLIC(SIG_UNBLOCK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef void (*sighandler_t)(int);
typedef void (*sigaction_f)(int, struct siginfo *, struct ucontext *);

struct sigaction { /* cosmo abi */
  union {
    sighandler_t sa_handler;
    sigaction_f sa_sigaction;
  };
  uint64_t sa_flags;
  void (*sa_restorer)(void);
  struct sigset sa_mask;
  int64_t __pad;
};

sighandler_t signal(int, sighandler_t);
int sigaction(int, const struct sigaction *, struct sigaction *);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

void _init_onntconsoleevent(void);
void _init_wincrash(void);
void _check_sigwinch();

#ifndef __SIGACTION_YOINK
#define __SIGACTION_YOINK(SIG)             \
  do {                                     \
    if (SupportsWindows()) {               \
      if (__builtin_constant_p(SIG)) {     \
        switch (SIG) {                     \
          case SIGINT:                     \
          case SIGQUIT:                    \
          case SIGHUP:                     \
          case SIGTERM:                    \
            YOINK(_init_onntconsoleevent); \
            break;                         \
          case SIGTRAP:                    \
          case SIGILL:                     \
          case SIGSEGV:                    \
          case SIGABRT:                    \
          case SIGFPE:                     \
            YOINK(_init_wincrash);         \
            break;                         \
          case SIGWINCH:                   \
            YOINK(_check_sigwinch);        \
            break;                         \
          default:                         \
            break;                         \
        }                                  \
      } else {                             \
        YOINK(_init_onntconsoleevent);     \
        YOINK(_init_wincrash);             \
        YOINK(_check_sigwinch);            \
      }                                    \
    }                                      \
  } while (0)
#endif

#define sigaction(SIG, ACT, OLD) \
  ({                             \
    __SIGACTION_YOINK(SIG);      \
    sigaction(SIG, (ACT), OLD);  \
  })

#define signal(SIG, HAND)   \
  ({                        \
    __SIGACTION_YOINK(SIG); \
    signal(SIG, HAND);      \
  })

#endif /* GNU && !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/stat.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_STAT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct stat {              /* cosmo abi */
  uint64_t st_dev;         /* 0: id of device with file */
  uint64_t st_ino;         /* 8: inode number in disk b-tree */
  uint64_t st_nlink;       /* 16: hard link count */
  uint32_t st_mode;        /* 24: octal file mask thing */
  uint32_t st_uid;         /* 28: user id of owner */
  uint32_t st_gid;         /* group id of owning group */
  uint32_t st_flags;       /* nt/xnu/bsd-only */
  uint64_t st_rdev;        /* id of device if a special file */
  int64_t st_size;         /* bytes in file */
  int64_t st_blksize;      /* preferred chunking for underlying filesystem */
  int64_t st_blocks;       /* number of 512-byte pages allocated to file */
  struct timespec st_atim; /* access time */
  struct timespec st_mtim; /* modified time */
  struct timespec st_ctim; /* complicated time */
  struct timespec st_birthtim;
  uint64_t st_gen; /* xnu/bsd only */
};

int stat(const char *, struct stat *);
int lstat(const char *, struct stat *);
int fstat(int, struct stat *);
int fstatat(int, const char *, struct stat *, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/stat.macros.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_STAT_MACROS_H_

#define STAT_HAVE_NSEC 1

#define st_atime st_atim.tv_sec
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec

#define st_atime_nsec st_atim.tv_nsec
#define st_mtime_nsec st_mtim.tv_nsec
#define st_ctime_nsec st_ctim.tv_nsec

#define st_atimensec     st_atim.tv_nsec
#define st_mtimensec     st_mtim.tv_nsec
#define st_ctimensec     st_ctim.tv_nsec
#define st_birthtime     st_birthtim.tv_sec
#define st_birthtimensec st_birthtim.tv_nsec

#define st_file_attributes st_flags

#define INIT_STRUCT_STAT_PADDING(st) (void)st



/*!BEGIN libc/calls/struct/statfs.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_STATFS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct statfs {
  int64_t f_type;    /* type of filesystem */
  int64_t f_bsize;   /* optimal transfer block size */
  int64_t f_blocks;  /* total data blocks in filesystem */
  int64_t f_bfree;   /* free blocks in filesystem */
  int64_t f_bavail;  /* free blocks available to */
  int64_t f_files;   /* total file nodes in filesystem */
  int64_t f_ffree;   /* free file nodes in filesystem */
  int64_t f_fsid;    /* filesystem id */
  int64_t f_namelen; /* maximum length of filenames */
  int64_t f_frsize;  /* fragment size */
  int64_t f_flags;   /* mount flags of filesystem 2.6.36 */
  int64_t f_spare[4];
};

int statfs(const char *, struct statfs *);
int fstatfs(int, struct statfs *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sysinfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SYSINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sysinfo {
  int64_t uptime;     /* seconds since boot */
  uint64_t loads[3];  /* 1-5-15 min active process averages */
  uint64_t totalram;  /* system physical memory */
  uint64_t freeram;   /* amount of ram currently going to waste */
  uint64_t sharedram; /* bytes w/ pages mapped into multiple progs */
  uint64_t bufferram; /* lingering disk pages; see fadvise */
  uint64_t totalswap; /* size of emergency memory */
  uint64_t freeswap;  /* hopefully equal to totalswap */
  int16_t procs;      /* number of processes */
  int16_t __ignore;   /* padding */
  uint64_t totalhigh; /* wut */
  uint64_t freehigh;  /* wut */
  uint32_t mem_unit;  /* ram stuff above is multiples of this */
};

int sysinfo(struct sysinfo *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/termios.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct termios {     /* GNU/Systemd ABI */
  uint32_t c_iflag;  /* input modes */
  uint32_t c_oflag;  /* output modes */
  uint32_t c_cflag;  /* control modes */
  uint32_t c_lflag;  /* local modes */
  uint8_t c_cc[20];  /* code mappings */
  uint32_t c_ispeed; /* input speed */
  uint32_t c_ospeed; /* output speed */
};

#define c_line c_cc[0] /* line discipline */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/tms.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TMS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct tms {
  int64_t tms_utime;  /* userspace time */
  int64_t tms_stime;  /* kernelspace time */
  int64_t tms_cutime; /* children userspace time */
  int64_t tms_cstime; /* children kernelspace time */
};

long times(struct tms *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/user_regs_struct.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_USER_REGS_STRUCT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Linux Kernel user registers.
 *
 * @note superset of struct pt_regs
 * @see ptrace() w/ PTRACE_SYSCALL
 */
struct user_regs_struct {
  uint64_t r15;
  uint64_t r14;
  uint64_t r13;
  uint64_t r12;
  uint64_t rbp;
  uint64_t rbx;
  uint64_t r11;
  uint64_t r10;
  uint64_t r9;
  uint64_t r8;
  uint64_t rax;
  uint64_t rcx;
  uint64_t rdx;
  uint64_t rsi;
  uint64_t rdi;
  uint64_t orig_rax;
  uint64_t rip;
  uint64_t cs;
  uint64_t eflags;
  uint64_t rsp;
  uint64_t ss;
  uint64_t fs_base;
  uint64_t gs_base;
  uint64_t ds;
  uint64_t es;
  uint64_t fs;
  uint64_t gs;
};

struct useregs_struct_freebsd {
  int64_t r15;
  int64_t r14;
  int64_t r13;
  int64_t r12;
  int64_t r11;
  int64_t r10;
  int64_t r9;
  int64_t r8;
  int64_t rdi;
  int64_t rsi;
  int64_t rbp;
  int64_t rbx;
  int64_t rdx;
  int64_t rcx;
  int64_t rax;
  uint32_t trapno;
  uint16_t fs;
  uint16_t gs;
  uint32_t err;
  uint16_t es;
  uint16_t ds;
  int64_t rip;
  int64_t cs;
  int64_t rflags;
  int64_t rsp;
  int64_t ss;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/utsname.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_UTSNAME_H_

#define SYS_NMLN 321

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct utsname {
  char sysname[SYS_NMLN];
  char nodename[SYS_NMLN];
  char release[SYS_NMLN];
  char version[SYS_NMLN];
  char machine[SYS_NMLN];
  char domainname[SYS_NMLN];
};

int uname(struct utsname *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/winsize.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_WINSIZE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct winsize {
  uint16_t ws_row;
  uint16_t ws_col;
  uint16_t ws_xpixel;
  uint16_t ws_ypixel;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/calls.h */

#define COSMOPOLITAN_LIBC_CALLS_SYSCALLS_H_

#define _POSIX_VERSION  200809L
#define _POSIX2_VERSION _POSIX_VERSION
#define _XOPEN_VERSION  700

#define EOF      -1         /* end of file */
#define WEOF     -1u        /* end of file (multibyte) */
#define _IOFBF   0          /* fully buffered */
#define _IOLBF   1          /* line buffered */
#define _IONBF   2          /* no buffering */
#define SEEK_SET 0          /* relative to beginning */
#define SEEK_CUR 1          /* relative to current position */
#define SEEK_END 2          /* relative to end */
#define __WALL   0x40000000 /* Wait on all children, regardless of type */
#define __WCLONE 0x80000000 /* Wait only on non-SIGCHLD children */

#define SIG_ERR ((void (*)(int))(-1))
#define SIG_DFL ((void *)0)
#define SIG_IGN ((void *)1)

#define MAP_FAILED ((void *)-1)

#define ARCH_SET_GS 0x1001
#define ARCH_SET_FS 0x1002
#define ARCH_GET_FS 0x1003
#define ARCH_GET_GS 0x1004

#define MAP_HUGE_2MB (21 << MAP_HUGE_SHIFT)
#define MAP_HUGE_1GB (30 << MAP_HUGE_SHIFT)

#define WCOREDUMP(s)    (0x80 & (s))
#define WEXITSTATUS(s)  ((0xff00 & (s)) >> 8)
#define WIFCONTINUED(s) ((s) == 0xffff)
#define WIFEXITED(s)    (!WTERMSIG(s))
#define WIFSIGNALED(s)  ((0xffff & (s)) - 1u < 0xffu)
#define WIFSTOPPED(s) \
  ((short)(((0xffff & (unsigned)(s)) * 0x10001) >> 8) > 0x7f00)
#define WSTOPSIG(s)   WEXITSTATUS(s)
#define WTERMSIG(s)   (127 & (s))
#define W_STOPCODE(s) ((s) << 8 | 0177)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef int sig_atomic_t;

bool fileexists(const char *);
bool isdirectory(const char *);
bool isexecutable(const char *);
bool isregularfile(const char *);
bool issymlink(const char *);
bool32 isatty(int) nosideeffect;
bool32 ischardev(int) nosideeffect;
char *commandv(const char *, char *, size_t);
char *get_current_dir_name(void) dontdiscard;
char *getcwd(char *, size_t);
char *realpath(const char *, char *);
char *replaceuser(const char *) dontdiscard;
char *ttyname(int);
int access(const char *, int) dontthrow;
int arch_prctl();
int chdir(const char *);
int chmod(const char *, uint32_t);
int chown(const char *, uint32_t, uint32_t);
int chroot(const char *);
int clone(void *, void *, size_t, int, void *, int *, void *, int *);
int close(int);
int close_range(unsigned, unsigned, unsigned);
int closefrom(int);
int creat(const char *, uint32_t);
int dup(int);
int dup2(int, int);
int dup3(int, int, int);
int eaccess(const char *, int);
int euidaccess(const char *, int);
int execl(const char *, const char *, ...) nullterminated();
int execle(const char *, const char *, ...) nullterminated((1));
int execlp(const char *, const char *, ...) nullterminated();
int execv(const char *, char *const[]);
int execve(const char *, char *const[], char *const[]);
int execvp(const char *, char *const[]);
int execvpe(const char *, char *const[], char *const[]);
int faccessat(int, const char *, int, uint32_t);
int fadvise(int, uint64_t, uint64_t, int);
int fchdir(int);
int fchmod(int, uint32_t) dontthrow;
int fchmodat(int, const char *, uint32_t, int);
int fchown(int, uint32_t, uint32_t);
int fchownat(int, const char *, uint32_t, uint32_t, int);
int fcntl(int, int, ...);
int fdatasync(int);
int filecmp(const char *, const char *);
int flock(int, int);
int fork(void);
int fsync(int);
int ftruncate(int, int64_t);
int getdents(unsigned, void *, unsigned, long *);
int getdomainname(char *, size_t);
int getegid(void) nosideeffect;
int geteuid(void) nosideeffect;
int getgid(void) nosideeffect;
int gethostname(char *, size_t);
int getloadavg(double *, int);
int getpgid(int) libcesque;
int getpgrp(void) nosideeffect;
int getpid(void) nosideeffect libcesque;
int getppid(void);
int getpriority(int, unsigned);
int getresgid(uint32_t *, uint32_t *, uint32_t *);
int getresuid(uint32_t *, uint32_t *, uint32_t *);
int getsid(int) nosideeffect libcesque;
int gettid(void) libcesque;
int getuid(void) libcesque;
int iopl(int);
int ioprio_get(int, int);
int ioprio_set(int, int, int);
int issetugid(void);
int kill(int, int);
int killpg(int, int);
int link(const char *, const char *) dontthrow;
int linkat(int, const char *, int, const char *, int);
int madvise(void *, uint64_t, int);
int memfd_create(const char *, unsigned int);
int mincore(void *, size_t, unsigned char *);
int mkdir(const char *, uint32_t);
int mkdirat(int, const char *, uint32_t);
int mkfifo(const char *, uint32_t);
int mkfifoat(int, const char *, uint32_t);
int mknod(const char *, uint32_t, uint64_t);
int mknodat(int, const char *, int32_t, uint64_t);
int mlock(const void *, size_t);
int mlock2(const void *, size_t, int);
int mlockall(int);
int munlock(const void *, size_t);
int munlockall(void);
int nice(int);
int open(const char *, int, ...);
int openat(int, const char *, int, ...);
int pause(void);
int personality(uint64_t);
int pipe(int[hasatleast 2]);
int pipe2(int[hasatleast 2], int);
int pivot_root(const char *, const char *);
int pledge(const char *, const char *);
int posix_fadvise(int, uint64_t, uint64_t, int);
int posix_madvise(void *, uint64_t, int);
int prctl(int, ...);
int raise(int);
int reboot(int);
int remove(const char *);
int rename(const char *, const char *);
int renameat(int, const char *, int, const char *);
int renameat2(long, const char *, long, const char *, int);
int rmdir(const char *);
int sched_getaffinity(int, uint64_t, void *);
int sched_setaffinity(int, uint64_t, const void *);
int sched_yield(void);
int seccomp(unsigned, unsigned, void *);
int setegid(uint32_t);
int seteuid(uint32_t);
int setfsgid(int);
int setfsuid(int);
int setgid(int);
int setpgid(int, int);
int setpgrp(void);
int setpriority(int, unsigned, int);
int setregid(uint32_t, uint32_t);
int setresgid(uint32_t, uint32_t, uint32_t);
int setresuid(uint32_t, uint32_t, uint32_t);
int setreuid(uint32_t, uint32_t);
int setsid(void);
int setuid(int);
int sigignore(int);
int siginterrupt(int, int);
int symlink(const char *, const char *);
int symlinkat(const char *, int, const char *);
int sync_file_range(int, int64_t, int64_t, unsigned);
int sys_ptrace(int, ...);
int sysctl(const int *, unsigned, void *, size_t *, void *, size_t);
int tgkill(int, int, int);
int tkill(int, int);
int touch(const char *, uint32_t);
int truncate(const char *, uint64_t);
int ttyname_r(int, char *, size_t);
int umask(int);
int unlink(const char *);
int unlink_s(const char **);
int unlinkat(int, const char *, int);
int unveil(const char *, const char *);
int vfork(void) returnstwice;
int wait(int *);
int waitpid(int, int *, int);
intptr_t syscall(int, ...);
long ptrace(int, ...);
ssize_t copy_file_range(int, long *, int, long *, size_t, uint32_t);
ssize_t copyfd(int, int64_t *, int, int64_t *, size_t, uint32_t);
ssize_t getfiledescriptorsize(int);
ssize_t lseek(int, int64_t, unsigned);
ssize_t pread(int, void *, size_t, int64_t);
ssize_t pwrite(int, const void *, size_t, int64_t);
ssize_t read(int, void *, size_t);
ssize_t readansi(int, char *, size_t);
ssize_t readlink(const char *, char *, size_t);
ssize_t readlinkat(int, const char *, char *, size_t);
ssize_t splice(int, int64_t *, int, int64_t *, size_t, uint32_t);
ssize_t write(int, const void *, size_t);
void sync(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/copyfile.h */

#define COSMOPOLITAN_LIBC_CALLS_COPYFILE_H_

#define COPYFILE_NOCLOBBER           1
#define COPYFILE_PRESERVE_OWNER      2
#define COPYFILE_PRESERVE_TIMESTAMPS 4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int copyfile(const char *, const char *, int) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/dprintf.h */

#define COSMOPOLITAN_LIBC_CALLS_DPRINTF_H_


/*!BEGIN libc/fmt/pflink.h */

#define COSMOPOLITAN_LIBC_FMT_PFLINK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview builtin+preprocessor+linker tricks for printf/scanf.
 *
 * Your printf() function only requires that you pay for what you use.
 * These macros ensure that its code size starts at under 4kb, growing
 * to about 40kb for a fully-loaded implementation. This works best when
 * format strings are constexprs that only contain directives.
 */

#define PFLINK(...) _PFLINK(__VA_ARGS__)
#define _PFLINK(FMT, ...)                                             \
  ({                                                                  \
    if (___PFLINK(FMT, strpbrk, "faAeg")) STATIC_YOINK("__fmt_dtoa"); \
    if (___PFLINK(FMT, strpbrk, "cmrqs")) {                           \
      if (___PFLINK(FMT, strstr, "%m")) STATIC_YOINK("strerror");     \
      if (___PFLINK(FMT, strstr, "%*") ||                             \
          ___PFLINK(FMT, strpbrk, "0123456789")) {                    \
        STATIC_YOINK("strnwidth");                                    \
        STATIC_YOINK("strnwidth16");                                  \
        STATIC_YOINK("wcsnwidth");                                    \
      }                                                               \
    }                                                                 \
    FMT;                                                              \
  })

#define SFLINK(...) _SFLINK(__VA_ARGS__)
#define _SFLINK(FMT)                   \
  ({                                   \
    if (___PFLINK(FMT, strchr, 'm')) { \
      STATIC_YOINK("malloc");          \
      STATIC_YOINK("calloc");          \
      STATIC_YOINK("free");            \
      STATIC_YOINK("__grow");          \
    }                                  \
    FMT;                               \
  })

#if __GNUC__ + 0 < 4 || defined(__llvm__)
#define ___PFLINK(FMT, FN, C) 1
#else
#define ___PFLINK(FMT, FN, C) \
  !__builtin_constant_p(FMT) || ((FMT) && __builtin_##FN(FMT, C) != NULL)
#endif

#if defined(__GNUC__) && __GNUC__ < 6
/*
 * Compilers don't understand the features we've added to the format
 * string DSL, such as c string escaping, therefore we can't use it.
 * Ideally compilers should grant us more flexibility to define DSLs
 *
 * The recommended approach to turning this back on is `CFLAGS=-std=c11`
 * which puts the compiler in __STRICT_ANSI__ mode, which Cosmopolitan
 * respects by disabling all the esoteric tuning in headers like this.
 */
#pragma GCC diagnostic ignored "-Wformat-security"
#endif /* __GNUC__ + 0 < 6 */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int dprintf(int, const char *, ...) printfesque(2) paramsnonnull((2));
int vdprintf(int, const char *, va_list) paramsnonnull();

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define dprintf(FD, FMT, ...) (dprintf)(FD, PFLINK(FMT), ##__VA_ARGS__)
#define vdprintf(FD, FMT, VA) (vdprintf)(FD, PFLINK(FMT), VA)

#endif /* GNU && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ioctl.h */

#define COSMOPOLITAN_LIBC_CALLS_IOCTL_H_


/*!BEGIN libc/sysv/consts/fio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FIO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t FIOASYNC;
extern const uint64_t FIOCLEX;
extern const uint64_t FIONBIO;
extern const uint64_t FIONCLEX;
extern const uint64_t FIONREAD;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FIOASYNC SYMBOLIC(FIOASYNC)
#define FIOCLEX  SYMBOLIC(FIOCLEX)
#define FIONBIO  SYMBOLIC(FIONBIO)
#define FIONCLEX SYMBOLIC(FIONCLEX)
#define FIONREAD SYMBOLIC(FIONREAD)



/*!BEGIN libc/sysv/consts/sio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SIO_H_

#define SIOCADDDLCI SYMBOLIC(SIOCADDDLCI)
#define SIOCADDMULTI SYMBOLIC(SIOCADDMULTI)
#define SIOCADDRT SYMBOLIC(SIOCADDRT)
#define SIOCATMARK SYMBOLIC(SIOCATMARK)
#define SIOCDARP SYMBOLIC(SIOCDARP)
#define SIOCDELDLCI SYMBOLIC(SIOCDELDLCI)
#define SIOCDELMULTI SYMBOLIC(SIOCDELMULTI)
#define SIOCDELRT SYMBOLIC(SIOCDELRT)
#define SIOCDEVPRIVATE SYMBOLIC(SIOCDEVPRIVATE)
#define SIOCDIFADDR SYMBOLIC(SIOCDIFADDR)
#define SIOCDRARP SYMBOLIC(SIOCDRARP)
#define SIOCGARP SYMBOLIC(SIOCGARP)
#define SIOCGIFADDR SYMBOLIC(SIOCGIFADDR)
#define SIOCGIFBR SYMBOLIC(SIOCGIFBR)
#define SIOCGIFBRDADDR SYMBOLIC(SIOCGIFBRDADDR)
#define SIOCGIFCONF SYMBOLIC(SIOCGIFCONF)
#define SIOCGIFCOUNT SYMBOLIC(SIOCGIFCOUNT)
#define SIOCGIFDSTADDR SYMBOLIC(SIOCGIFDSTADDR)
#define SIOCGIFENCAP SYMBOLIC(SIOCGIFENCAP)
#define SIOCGIFFLAGS SYMBOLIC(SIOCGIFFLAGS)
#define SIOCGIFHWADDR SYMBOLIC(SIOCGIFHWADDR)
#define SIOCGIFINDEX SYMBOLIC(SIOCGIFINDEX)
#define SIOCGIFMAP SYMBOLIC(SIOCGIFMAP)
#define SIOCGIFMEM SYMBOLIC(SIOCGIFMEM)
#define SIOCGIFMETRIC SYMBOLIC(SIOCGIFMETRIC)
#define SIOCGIFMTU SYMBOLIC(SIOCGIFMTU)
#define SIOCGIFNAME SYMBOLIC(SIOCGIFNAME)
#define SIOCGIFNETMASK SYMBOLIC(SIOCGIFNETMASK)
#define SIOCGIFPFLAGS SYMBOLIC(SIOCGIFPFLAGS)
#define SIOCGIFSLAVE SYMBOLIC(SIOCGIFSLAVE)
#define SIOCGIFTXQLEN SYMBOLIC(SIOCGIFTXQLEN)
#define SIOCGPGRP SYMBOLIC(SIOCGPGRP)
#define SIOCGRARP SYMBOLIC(SIOCGRARP)
#define SIOCGSTAMP SYMBOLIC(SIOCGSTAMP)
#define SIOCGSTAMPNS SYMBOLIC(SIOCGSTAMPNS)
#define SIOCPROTOPRIVATE SYMBOLIC(SIOCPROTOPRIVATE)
#define SIOCRTMSG SYMBOLIC(SIOCRTMSG)
#define SIOCSARP SYMBOLIC(SIOCSARP)
#define SIOCSIFADDR SYMBOLIC(SIOCSIFADDR)
#define SIOCSIFBR SYMBOLIC(SIOCSIFBR)
#define SIOCSIFBRDADDR SYMBOLIC(SIOCSIFBRDADDR)
#define SIOCSIFDSTADDR SYMBOLIC(SIOCSIFDSTADDR)
#define SIOCSIFENCAP SYMBOLIC(SIOCSIFENCAP)
#define SIOCSIFFLAGS SYMBOLIC(SIOCSIFFLAGS)
#define SIOCSIFHWADDR SYMBOLIC(SIOCSIFHWADDR)
#define SIOCSIFHWBROADCAST SYMBOLIC(SIOCSIFHWBROADCAST)
#define SIOCSIFLINK SYMBOLIC(SIOCSIFLINK)
#define SIOCSIFMAP SYMBOLIC(SIOCSIFMAP)
#define SIOCSIFMEM SYMBOLIC(SIOCSIFMEM)
#define SIOCSIFMETRIC SYMBOLIC(SIOCSIFMETRIC)
#define SIOCSIFMTU SYMBOLIC(SIOCSIFMTU)
#define SIOCSIFNAME SYMBOLIC(SIOCSIFNAME)
#define SIOCSIFNETMASK SYMBOLIC(SIOCSIFNETMASK)
#define SIOCSIFPFLAGS SYMBOLIC(SIOCSIFPFLAGS)
#define SIOCSIFSLAVE SYMBOLIC(SIOCSIFSLAVE)
#define SIOCSIFTXQLEN SYMBOLIC(SIOCSIFTXQLEN)
#define SIOCSPGRP SYMBOLIC(SIOCSPGRP)
#define SIOCSRARP SYMBOLIC(SIOCSRARP)
#define SIOGIFINDEX SYMBOLIC(SIOGIFINDEX)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t SIOCADDDLCI;
extern const uint64_t SIOCADDMULTI;
extern const uint64_t SIOCADDRT;
extern const uint64_t SIOCATMARK;
extern const uint64_t SIOCDARP;
extern const uint64_t SIOCDELDLCI;
extern const uint64_t SIOCDELMULTI;
extern const uint64_t SIOCDELRT;
extern const uint64_t SIOCDEVPRIVATE;
extern const uint64_t SIOCDIFADDR;
extern const uint64_t SIOCDRARP;
extern const uint64_t SIOCGARP;
extern const uint64_t SIOCGIFADDR;
extern const uint64_t SIOCGIFBR;
extern const uint64_t SIOCGIFBRDADDR;
extern const uint64_t SIOCGIFCONF;
extern const uint64_t SIOCGIFCOUNT;
extern const uint64_t SIOCGIFDSTADDR;
extern const uint64_t SIOCGIFENCAP;
extern const uint64_t SIOCGIFFLAGS;
extern const uint64_t SIOCGIFHWADDR;
extern const uint64_t SIOCGIFINDEX;
extern const uint64_t SIOCGIFMAP;
extern const uint64_t SIOCGIFMEM;
extern const uint64_t SIOCGIFMETRIC;
extern const uint64_t SIOCGIFMTU;
extern const uint64_t SIOCGIFNAME;
extern const uint64_t SIOCGIFNETMASK;
extern const uint64_t SIOCGIFPFLAGS;
extern const uint64_t SIOCGIFSLAVE;
extern const uint64_t SIOCGIFTXQLEN;
extern const uint64_t SIOCGPGRP;
extern const uint64_t SIOCGRARP;
extern const uint64_t SIOCGSTAMP;
extern const uint64_t SIOCGSTAMPNS;
extern const uint64_t SIOCPROTOPRIVATE;
extern const uint64_t SIOCRTMSG;
extern const uint64_t SIOCSARP;
extern const uint64_t SIOCSIFADDR;
extern const uint64_t SIOCSIFBR;
extern const uint64_t SIOCSIFBRDADDR;
extern const uint64_t SIOCSIFDSTADDR;
extern const uint64_t SIOCSIFENCAP;
extern const uint64_t SIOCSIFFLAGS;
extern const uint64_t SIOCSIFHWADDR;
extern const uint64_t SIOCSIFHWBROADCAST;
extern const uint64_t SIOCSIFLINK;
extern const uint64_t SIOCSIFMAP;
extern const uint64_t SIOCSIFMEM;
extern const uint64_t SIOCSIFMETRIC;
extern const uint64_t SIOCSIFMTU;
extern const uint64_t SIOCSIFNAME;
extern const uint64_t SIOCSIFNETMASK;
extern const uint64_t SIOCSIFPFLAGS;
extern const uint64_t SIOCSIFSLAVE;
extern const uint64_t SIOCSIFTXQLEN;
extern const uint64_t SIOCSPGRP;
extern const uint64_t SIOCSRARP;
extern const uint64_t SIOGIFINDEX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/termios.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint32_t BRKINT;
extern const uint32_t BS0;
extern const uint32_t BS1;
extern const uint32_t BS2;
extern const uint32_t BSDLY;
extern const long BUSY;
extern const uint32_t CBAUD;
extern const uint32_t CBAUDEX;
extern const uint32_t CIBAUD;
extern const uint32_t CLOCAL;
extern const uint32_t CMSPAR;
extern const uint32_t CR0;
extern const uint32_t CR1;
extern const uint32_t CR2;
extern const uint32_t CR3;
extern const uint32_t CRDLY;
extern const uint32_t CREAD;
extern const uint32_t CS5;
extern const uint32_t CS6;
extern const uint32_t CS7;
extern const uint32_t CS8;
extern const uint32_t CSIZE;
extern const uint32_t CSTOPB;
extern const uint32_t ECHO;
extern const uint32_t ECHOCTL;
extern const uint32_t ECHOE;
extern const uint32_t ECHOK;
extern const uint32_t ECHOKE;
extern const uint32_t ECHONL;
extern const uint32_t ECHOPRT;
extern const long ENDRUNDISC;
extern const long EXTA;
extern const long EXTB;
extern const long EXTPROC;
extern const uint32_t FF0;
extern const uint32_t FF1;
extern const uint32_t FF2;
extern const uint32_t FFDLY;
extern const uint32_t FLUSHO;
extern const long H4DISC;
extern const uint32_t HUPCL;
extern const uint32_t ICANON;
extern const uint32_t ICRNL;
extern const uint32_t IEXTEN;
extern const uint32_t IGNBRK;
extern const uint32_t IGNCR;
extern const uint32_t IGNPAR;
extern const uint32_t IMAXBEL;
extern const uint32_t INLCR;
extern const uint32_t INPCK;
extern const uint32_t ISIG;
extern const uint32_t ISTRIP;
extern const uint32_t IUCLC;
extern const uint32_t IUTF8;
extern const uint32_t IXANY;
extern const uint32_t IXOFF;
extern const uint32_t IXON;
extern const long NETGRAPHDISC;
extern const uint32_t NL0;
extern const uint32_t NL1;
extern const uint32_t NL2;
extern const uint32_t NL3;
extern const uint32_t NLDLY;
extern const long NMEADISC;
extern const uint32_t NOFLSH;
extern const uint32_t OCRNL;
extern const uint32_t OFDEL;
extern const uint32_t OFILL;
extern const uint32_t OLCUC;
extern const uint32_t ONLCR;
extern const uint32_t ONLRET;
extern const uint32_t ONOCR;
extern const uint32_t OPOST;
extern const uint32_t PARENB;
extern const uint32_t PARMRK;
extern const uint32_t PARODD;
extern const uint32_t PENDIN;
extern const long PPPDISC;
extern const long SLIPDISC;
extern const long STRIPDISC;
extern const uint32_t TAB0;
extern const uint32_t TAB1;
extern const uint32_t TAB2;
extern const uint32_t TAB3;
extern const uint32_t TABDLY;
extern const long TABLDISC;
extern const uint64_t TCFLSH;
extern const uint64_t TCGETS;
extern const int TCIFLUSH;
extern const int TCIOFF;
extern const int TCIOFLUSH;
extern const int TCION;
extern const int TCOFLUSH;
extern const int TCOOFF;
extern const int TCOON;
extern const int TCSADRAIN;
extern const int TCSAFLUSH;
extern const int TCSANOW;
extern const uint64_t TCSBRK;
extern const uint64_t TCSETS;
extern const uint64_t TCSETSF;
extern const uint64_t TCSETSW;
extern const uint64_t TCXONC;
extern const uint64_t TIOCCBRK;
extern const uint64_t TIOCCDTR;
extern const uint64_t TIOCCHKVERAUTH;
extern const uint64_t TIOCCONS;
extern const uint64_t TIOCDRAIN;
extern const uint64_t TIOCEXT;
extern const uint64_t TIOCFLAG_CLOCAL;
extern const uint64_t TIOCFLAG_MDMBUF;
extern const uint64_t TIOCFLAG_PPS;
extern const uint64_t TIOCFLAG_SOFTCAR;
extern const uint64_t TIOCFLUSH;
extern const uint64_t TIOCGDRAINWAIT;
extern const uint64_t TIOCGETD;
extern const uint64_t TIOCGFLAGS;
extern const uint64_t TIOCGPGRP;
extern const uint64_t TIOCGPTN;
extern const uint64_t TIOCGSID;
extern const uint64_t TIOCGTSTAMP;
extern const uint64_t TIOCGWINSZ;
extern const uint64_t TIOCNOTTY;
extern const uint64_t TIOCNXCL;
extern const uint64_t TIOCOUTQ;
extern const uint64_t TIOCPTMASTER;
extern const uint64_t TIOCREMOTE;
extern const uint64_t TIOCSBRK;
extern const uint64_t TIOCSCTTY;
extern const uint64_t TIOCSDRAINWAIT;
extern const uint64_t TIOCSDTR;
extern const uint64_t TIOCSERGETLSR;
extern const uint64_t TIOCSERGETMULTI;
extern const uint64_t TIOCSERSETMULTI;
extern const uint64_t TIOCSER_TEMT;
extern const uint64_t TIOCSETD;
extern const uint64_t TIOCSETVERAUTH;
extern const uint64_t TIOCSFLAGS;
extern const uint64_t TIOCSIG;
extern const uint64_t TIOCSPGRP;
extern const uint64_t TIOCSTART;
extern const uint64_t TIOCSTAT;
extern const uint64_t TIOCSTI;
extern const uint64_t TIOCSTOP;
extern const uint64_t TIOCSTSTAMP;
extern const uint64_t TIOCSWINSZ;
extern const uint64_t TIOCTIMESTAMP;
extern const uint64_t TIOCUCNTL_CBRK;
extern const long TOSTOP;
extern const long TTYDISC;
extern const uint8_t VDISCARD;
extern const uint8_t VEOF;
extern const uint8_t VEOL2;
extern const uint8_t VEOL;
extern const uint8_t VERASE;
extern const long VERIFY;
extern const uint8_t VINTR;
extern const uint8_t VKILL;
extern const uint8_t VLNEXT;
extern const uint8_t VMIN;
extern const uint8_t VQUIT;
extern const uint8_t VREPRINT;
extern const uint8_t VSTART;
extern const uint8_t VSTOP;
extern const uint8_t VSUSP;
extern const uint8_t VSWTC;
extern const uint32_t VT0;
extern const uint32_t VT1;
extern const uint32_t VT2;
extern const uint32_t VTDLY;
extern const uint8_t VTIME;
extern const uint8_t VWERASE;
extern const uint32_t XCASE;
extern const uint32_t XTABS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define BRKINT    LITERALLY(0x02)
#define ICRNL     LITERALLY(0x0100)
#define IGNBRK    LITERALLY(0x01)
#define IGNCR     LITERALLY(0x80)
#define IGNPAR    LITERALLY(0x04)
#define IMAXBEL   LITERALLY(0x2000)
#define INLCR     LITERALLY(0x40)
#define INPCK     LITERALLY(0x10)
#define ISTRIP    LITERALLY(0x20)
#define IXANY     LITERALLY(0x0800)
#define OPOST     LITERALLY(0x01)
#define PARMRK    LITERALLY(0x08)
#define TIOCSTART SYMBOLIC(TIOCSTART)
#define TIOCSTOP  SYMBOLIC(TIOCSTOP)

#define NLDLY  SYMBOLIC(NLDLY)
#define NL0    LITERALLY(0)
#define NL1    SYMBOLIC(NL1)
#define NL2    SYMBOLIC(NL2)
#define NL3    SYMBOLIC(NL3)
#define CRDLY  SYMBOLIC(CRDLY)
#define CR0    LITERALLY(0)
#define CR1    SYMBOLIC(CR1)
#define CR2    SYMBOLIC(CR2)
#define CR3    SYMBOLIC(CR3)
#define TABDLY SYMBOLIC(TABDLY)
#define TAB0   LITERALLY(0)
#define TAB1   SYMBOLIC(TAB1)
#define TAB2   SYMBOLIC(TAB2)
#define TAB3   SYMBOLIC(TAB3)
#define XTABS  SYMBOLIC(XTABS)
#define BSDLY  SYMBOLIC(BSDLY)
#define BS0    LITERALLY(0)
#define BS1    SYMBOLIC(BS1)
#define BS2    SYMBOLIC(BS2)
#define VTDLY  SYMBOLIC(VTDLY)
#define VT0    LITERALLY(0)
#define VT1    SYMBOLIC(VT1)
#define VT2    SYMBOLIC(VT2)
#define FFDLY  SYMBOLIC(FFDLY)
#define FF0    LITERALLY(0)
#define FF1    SYMBOLIC(FF1)
#define FF2    SYMBOLIC(FF2)

#define BUSY             SYMBOLIC(BUSY)
#define CBAUD            SYMBOLIC(CBAUD)
#define CBAUDEX          SYMBOLIC(CBAUDEX)
#define CIBAUD           SYMBOLIC(CIBAUD)
#define CLOCAL           SYMBOLIC(CLOCAL)
#define CMSPAR           SYMBOLIC(CMSPAR)
#define CREAD            SYMBOLIC(CREAD)
#define CS5              SYMBOLIC(CS5)
#define CS6              SYMBOLIC(CS6)
#define CS7              SYMBOLIC(CS7)
#define CS8              SYMBOLIC(CS8)
#define CSIZE            SYMBOLIC(CSIZE)
#define CSTOPB           SYMBOLIC(CSTOPB)
#define ECHO             LITERALLY(8)
#define ECHOCTL          SYMBOLIC(ECHOCTL)
#define ECHOE            SYMBOLIC(ECHOE)
#define ECHOK            SYMBOLIC(ECHOK)
#define ECHOKE           SYMBOLIC(ECHOKE)
#define ECHONL           SYMBOLIC(ECHONL)
#define ECHOPRT          SYMBOLIC(ECHOPRT)
#define ENDRUNDISC       SYMBOLIC(ENDRUNDISC)
#define EXTA             SYMBOLIC(EXTA)
#define EXTB             SYMBOLIC(EXTB)
#define EXTPROC          SYMBOLIC(EXTPROC)
#define FLUSHO           SYMBOLIC(FLUSHO)
#define H4DISC           SYMBOLIC(H4DISC)
#define HUPCL            SYMBOLIC(HUPCL)
#define ICANON           SYMBOLIC(ICANON)
#define IEXTEN           SYMBOLIC(IEXTEN)
#define ISIG             SYMBOLIC(ISIG)
#define IUCLC            SYMBOLIC(IUCLC)
#define IUTF8            SYMBOLIC(IUTF8)
#define IXOFF            SYMBOLIC(IXOFF)
#define IXON             SYMBOLIC(IXON)
#define NCCS             LITERALLY(20)
#define NETGRAPHDISC     SYMBOLIC(NETGRAPHDISC)
#define NMEADISC         SYMBOLIC(NMEADISC)
#define NOFLSH           SYMBOLIC(NOFLSH)
#define OCRNL            SYMBOLIC(OCRNL)
#define OFDEL            SYMBOLIC(OFDEL)
#define OFILL            SYMBOLIC(OFILL)
#define OLCUC            SYMBOLIC(OLCUC)
#define ONLCR            SYMBOLIC(ONLCR)
#define ONLRET           SYMBOLIC(ONLRET)
#define ONOCR            SYMBOLIC(ONOCR)
#define PARENB           SYMBOLIC(PARENB)
#define PARODD           SYMBOLIC(PARODD)
#define PENDIN           SYMBOLIC(PENDIN)
#define PPPDISC          SYMBOLIC(PPPDISC)
#define SLIPDISC         SYMBOLIC(SLIPDISC)
#define STRIPDISC        SYMBOLIC(STRIPDISC)
#define TABLDISC         SYMBOLIC(TABLDISC)
#define TCFLSH           SYMBOLIC(TCFLSH)
#define TCFLSH           SYMBOLIC(TCFLSH)
#define TCGETS           SYMBOLIC(TCGETS)
#define TCIFLUSH         SYMBOLIC(TCIFLUSH)
#define TCIOFF           SYMBOLIC(TCIOFF)
#define TCIOFLUSH        SYMBOLIC(TCIOFLUSH)
#define TCION            SYMBOLIC(TCION)
#define TCOFLUSH         SYMBOLIC(TCOFLUSH)
#define TCOOFF           SYMBOLIC(TCOOFF)
#define TCOON            SYMBOLIC(TCOON)
#define TCSADRAIN        LITERALLY(1)
#define TCSAFLUSH        LITERALLY(2)
#define TCSANOW          LITERALLY(0)
#define TCSBRK           SYMBOLIC(TCSBRK)
#define TCSETS           SYMBOLIC(TCSETS)
#define TCSETSF          SYMBOLIC(TCSETSF)
#define TCSETSW          SYMBOLIC(TCSETSW)
#define TCXONC           SYMBOLIC(TCXONC)
#define TIOCCBRK         SYMBOLIC(TIOCCBRK)
#define TIOCCDTR         SYMBOLIC(TIOCCDTR)
#define TIOCCHKVERAUTH   SYMBOLIC(TIOCCHKVERAUTH)
#define TIOCCONS         SYMBOLIC(TIOCCONS)
#define TIOCDRAIN        SYMBOLIC(TIOCDRAIN)
#define TIOCEXT          SYMBOLIC(TIOCEXT)
#define TIOCFLAG_CLOCAL  SYMBOLIC(TIOCFLAG_CLOCAL)
#define TIOCFLAG_MDMBUF  SYMBOLIC(TIOCFLAG_MDMBUF)
#define TIOCFLAG_PPS     SYMBOLIC(TIOCFLAG_PPS)
#define TIOCFLAG_SOFTCAR SYMBOLIC(TIOCFLAG_SOFTCAR)
#define TIOCFLUSH        SYMBOLIC(TIOCFLUSH)
#define TIOCGDRAINWAIT   SYMBOLIC(TIOCGDRAINWAIT)
#define TIOCGETD         SYMBOLIC(TIOCGETD)
#define TIOCGFLAGS       SYMBOLIC(TIOCGFLAGS)
#define TIOCGPGRP        SYMBOLIC(TIOCGPGRP)
#define TIOCGPTN         SYMBOLIC(TIOCGPTN)
#define TIOCGSID         SYMBOLIC(TIOCGSID)
#define TIOCGTSTAMP      SYMBOLIC(TIOCGTSTAMP)
#define TIOCGWINSZ       SYMBOLIC(TIOCGWINSZ)
#define TIOCNOTTY        SYMBOLIC(TIOCNOTTY)
#define TIOCNXCL         SYMBOLIC(TIOCNXCL)
#define TIOCOUTQ         SYMBOLIC(TIOCOUTQ)
#define TIOCPTMASTER     SYMBOLIC(TIOCPTMASTER)
#define TIOCREMOTE       SYMBOLIC(TIOCREMOTE)
#define TIOCSBRK         SYMBOLIC(TIOCSBRK)
#define TIOCSCTTY        SYMBOLIC(TIOCSCTTY)
#define TIOCSDRAINWAIT   SYMBOLIC(TIOCSDRAINWAIT)
#define TIOCSDTR         SYMBOLIC(TIOCSDTR)
#define TIOCSERGETLSR    SYMBOLIC(TIOCSERGETLSR)
#define TIOCSERGETMULTI  SYMBOLIC(TIOCSERGETMULTI)
#define TIOCSERSETMULTI  SYMBOLIC(TIOCSERSETMULTI)
#define TIOCSER_TEMT     SYMBOLIC(TIOCSER_TEMT)
#define TIOCSETD         SYMBOLIC(TIOCSETD)
#define TIOCSETVERAUTH   SYMBOLIC(TIOCSETVERAUTH)
#define TIOCSFLAGS       SYMBOLIC(TIOCSFLAGS)
#define TIOCSIG          SYMBOLIC(TIOCSIG)
#define TIOCSPGRP        SYMBOLIC(TIOCSPGRP)
#define TIOCSTART        SYMBOLIC(TIOCSTART)
#define TIOCSTAT         SYMBOLIC(TIOCSTAT)
#define TIOCSTI          SYMBOLIC(TIOCSTI)
#define TIOCSTSTAMP      SYMBOLIC(TIOCSTSTAMP)
#define TIOCSWINSZ       SYMBOLIC(TIOCSWINSZ)
#define TIOCTIMESTAMP    SYMBOLIC(TIOCTIMESTAMP)
#define TIOCUCNTL_CBRK   SYMBOLIC(TIOCUCNTL_CBRK)
#define TOSTOP           SYMBOLIC(TOSTOP)
#define TTYDISC          SYMBOLIC(TTYDISC)
#define VDISCARD         SYMBOLIC(VDISCARD)
#define VEOF             SYMBOLIC(VEOF)
#define VEOL             SYMBOLIC(VEOL)
#define VEOL2            SYMBOLIC(VEOL2)
#define VERASE           SYMBOLIC(VERASE)
#define VERIFY           SYMBOLIC(VERIFY)
#define VINTR            SYMBOLIC(VINTR)
#define VKILL            SYMBOLIC(VKILL)
#define VLNEXT           SYMBOLIC(VLNEXT)
#define VMIN             SYMBOLIC(VMIN)
#define VQUIT            SYMBOLIC(VQUIT)
#define VREPRINT         SYMBOLIC(VREPRINT)
#define VSTART           SYMBOLIC(VSTART)
#define VSTOP            SYMBOLIC(VSTOP)
#define VSUSP            SYMBOLIC(VSUSP)
#define VSWTC            SYMBOLIC(VSWTC)
#define VTIME            SYMBOLIC(VTIME)
#define VWERASE          SYMBOLIC(VWERASE)
#define XCASE            SYMBOLIC(XCASE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » ioctl                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int ioctl(int, uint64_t, ...);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » ioctl » undiamonding                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define ioctl(FD, REQUEST, ...)                                             \
  __IOCTL_DISPATCH(__EQUIVALENT, ioctl_default(FD, REQUEST, ##__VA_ARGS__), \
                   FD, REQUEST, ##__VA_ARGS__)

#define __EQUIVALENT(X, Y) (__builtin_constant_p((X) == (Y)) && ((X) == (Y)))

#define __IOCTL_DISPATCH(CMP, DEFAULT, FD, REQUEST, ...) \
  ({                                                     \
    int ReZ;                                             \
    if (CMP(REQUEST, TIOCGWINSZ)) {                      \
      ReZ = ioctl_tiocgwinsz(FD, ##__VA_ARGS__);         \
    } else if (CMP(REQUEST, TIOCSWINSZ)) {               \
      ReZ = ioctl_tiocswinsz(FD, ##__VA_ARGS__);         \
    } else if (CMP(REQUEST, TCGETS)) {                   \
      ReZ = ioctl_tcgets(FD, ##__VA_ARGS__);             \
    } else if (CMP(REQUEST, TCSETS)) {                   \
      ReZ = ioctl_tcsets(FD, REQUEST, ##__VA_ARGS__);    \
    } else if (CMP(REQUEST, TCSETSW)) {                  \
      ReZ = ioctl_tcsets(FD, REQUEST, ##__VA_ARGS__);    \
    } else if (CMP(REQUEST, TCSETSF)) {                  \
      ReZ = ioctl_tcsets(FD, REQUEST, ##__VA_ARGS__);    \
    } else if (CMP(REQUEST, SIOCGIFCONF)) {              \
      ReZ = ioctl_siocgifconf(FD, ##__VA_ARGS__);        \
    } else if (CMP(REQUEST, SIOCGIFADDR)) {              \
      ReZ = ioctl_siocgifaddr(FD, ##__VA_ARGS__);        \
    } else if (CMP(REQUEST, SIOCGIFNETMASK)) {           \
      ReZ = ioctl_siocgifnetmask(FD, ##__VA_ARGS__);     \
    } else if (CMP(REQUEST, SIOCGIFBRDADDR)) {           \
      ReZ = ioctl_siocgifbrdaddr(FD, ##__VA_ARGS__);     \
    } else if (CMP(REQUEST, SIOCGIFDSTADDR)) {           \
      ReZ = ioctl_siocgifdstaddr(FD, ##__VA_ARGS__);     \
    } else if (CMP(REQUEST, SIOCGIFFLAGS)) {             \
      ReZ = ioctl_siocgifflags(FD, ##__VA_ARGS__);       \
    } else if (CMP(REQUEST, FIONBIO)) {                  \
      ReZ = ioctl_default(FD, REQUEST, ##__VA_ARGS__);   \
    } else if (CMP(REQUEST, FIOCLEX)) {                  \
      ReZ = ioctl_fioclex(FD, REQUEST);                  \
    } else if (CMP(REQUEST, FIONCLEX)) {                 \
      ReZ = ioctl_fioclex(FD, REQUEST);                  \
    } else {                                             \
      ReZ = DEFAULT;                                     \
    }                                                    \
    ReZ;                                                 \
  })

int ioctl_default(int, uint64_t, ...);
int ioctl_fioclex(int, int);
int ioctl_siocgifaddr(int, ...);
int ioctl_siocgifbrdaddr(int, ...);
int ioctl_siocgifconf(int, ...);
int ioctl_siocgifdstaddr(int, ...);
int ioctl_siocgifflags(int, ...);
int ioctl_siocgifnetmask(int, ...);
int ioctl_tcgets(int, ...);
int ioctl_tcsets(int, uint64_t, ...);
int ioctl_tiocgwinsz(int, ...);
int ioctl_tiocswinsz(int, ...);

#endif /* GNUC && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ipc.h */

#define COSMOPOLITAN_LIBC_CALLS_IPC_H_

#define IPC_PRIVATE 0
#define IPC_RMID    0
#define IPC_SET     1
#define IPC_STAT    2
#define IPC_INFO    3
#define IPC_CREAT   01000
#define IPC_EXCL    02000
#define IPC_NOWAIT  04000

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int ftok(const char *, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/landlock.h */

#define COSMOPOLITAN_LIBC_CALLS_LANDLOCK_H_

#define LANDLOCK_CREATE_RULESET_VERSION 0x0001ul

#define LANDLOCK_ACCESS_FS_EXECUTE     0x0001ul
#define LANDLOCK_ACCESS_FS_WRITE_FILE  0x0002ul
#define LANDLOCK_ACCESS_FS_READ_FILE   0x0004ul
#define LANDLOCK_ACCESS_FS_READ_DIR    0x0008ul
#define LANDLOCK_ACCESS_FS_REMOVE_DIR  0x0010ul
#define LANDLOCK_ACCESS_FS_REMOVE_FILE 0x0020ul
#define LANDLOCK_ACCESS_FS_MAKE_CHAR   0x0040ul
#define LANDLOCK_ACCESS_FS_MAKE_DIR    0x0080ul
#define LANDLOCK_ACCESS_FS_MAKE_REG    0x0100ul
#define LANDLOCK_ACCESS_FS_MAKE_SOCK   0x0200ul
#define LANDLOCK_ACCESS_FS_MAKE_FIFO   0x0400ul
#define LANDLOCK_ACCESS_FS_MAKE_BLOCK  0x0800ul
#define LANDLOCK_ACCESS_FS_MAKE_SYM    0x1000ul

/**
 * Allow renaming or linking file to a different directory.
 *
 * @see https://lore.kernel.org/r/20220329125117.1393824-8-mic@digikod.net
 * @see https://docs.kernel.org/userspace-api/landlock.html
 * @note ABI 2+
 */
#define LANDLOCK_ACCESS_FS_REFER 0x2000ul

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

enum landlock_rule_type {
  LANDLOCK_RULE_PATH_BENEATH = 1,
};

struct landlock_ruleset_attr {
  uint64_t handled_access_fs;
};

struct thatispacked landlock_path_beneath_attr {
  uint64_t allowed_access;
  int32_t parent_fd;
};

int landlock_restrict_self(int, uint32_t);
int landlock_add_rule(int, enum landlock_rule_type, const void *, uint32_t);
int landlock_create_ruleset(const struct landlock_ruleset_attr *, size_t,
                            uint32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/makedev.h */

#define COSMOPOLITAN_LIBC_CALLS_MAKEDEV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

uint64_t makedev(uint32_t, uint32_t);
uint32_t major(uint64_t);
uint32_t minor(uint64_t);

#define major(x)      major(x)
#define minor(x)      minor(x)
#define makedev(x, y) makedev(x, y)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/mount.h */

#define COSMOPOLITAN_LIBC_CALLS_MOUNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int mount(const char *, const char *, const char *, unsigned long,
          const void *);
int unmount(const char *, int);

#ifdef _GNU_SOURCE
int umount(const char *);
int umount2(const char *, int);
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/nanos.h */

#define COSMOPOLITAN_LIBC_CALLS_NANOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int128_t _nanos(int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ntspawn.h */

#define COSMOPOLITAN_LIBC_CALLS_NTSPAWN_H_


/*!BEGIN libc/nt/struct/processinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtProcessInformation {
  int64_t hProcess;
  int64_t hThread;
  uint32_t dwProcessId;
  uint32_t dwThreadId;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/securityattributes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECURITYATTRIBUTES_H_


/*!BEGIN libc/nt/struct/securitydescriptor.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECURITYDESCRIPTOR_H_


/*!BEGIN libc/nt/struct/acl.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_ACL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtAcl {
  uint8_t AclRevision;
  uint8_t Sbz1;
  uint16_t AclSize;
  uint16_t AceCount;
  uint16_t Sbz2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSecurityDescriptor {
  uint8_t Revision;
  uint8_t Sbz1;
  uint16_t Control;
  void *Owner;
  void *Group;
  struct NtAcl *Sacl;
  struct NtAcl *Dacl;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSecurityAttributes {
  uint32_t nLength;
  struct NtSecurityDescriptor *lpSecurityDescriptor;
  bool32 bInheritHandle;
};

const char *DescribeNtSecurityAttributes(struct NtSecurityAttributes *);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/startupinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_STARTUPINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtStartupInfo {
  uint32_t cb /* = sizeof(struct NtStartupInfo) */;
  uint16_t *lpReserved;
  char16_t *lpDesktop;
  char16_t *lpTitle; /* title of *new* console window only */
  uint32_t dwX;      /* position of window on screen */
  uint32_t dwY;
  uint32_t dwXSize;
  uint32_t dwYSize;
  uint32_t dwXCountChars; /* used to dimension the dos terminal */
  uint32_t dwYCountChars;
  uint32_t dwFillAttribute;
  uint32_t dwFlags;
  uint16_t wShowWindow;
  uint16_t cbReserved2;
  uint8_t *lpReserved2;
  union {
    struct {
      int64_t hStdInput;
      int64_t hStdOutput;
      int64_t hStdError;
    };
    int64_t stdiofds[3];
  };
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int mkntcmdline(char16_t[ARG_MAX / 2], const char *, char *const[]) hidden;
int mkntenvblock(char16_t[ARG_MAX / 2], char *const[], const char *,
                 char[ARG_MAX]) hidden;
int ntspawn(const char *, char *const[], char *const[], const char *,
            struct NtSecurityAttributes *, struct NtSecurityAttributes *,
            bool32, uint32_t, const char16_t *, const struct NtStartupInfo *,
            struct NtProcessInformation *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/pledge.h */

#define COSMOPOLITAN_LIBC_CALLS_PLEDGE_H_

#define PLEDGE_PENALTY_KILL_THREAD  0x0000
#define PLEDGE_PENALTY_KILL_PROCESS 0x0001
#define PLEDGE_PENALTY_RETURN_EPERM 0x0002
#define PLEDGE_PENALTY_MASK         0x000f
#define PLEDGE_STDERR_LOGGING       0x0010

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern int __pledge_mode;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/sysparam.h */

#define COSMOPOLITAN_LIBC_CALLS_SYSPARAM_H_

#define MAXSYMLINKS    20
#define MAXHOSTNAMELEN 64
#define MAXNAMLEN      255
#define MAXPATHLEN     4096
#define NBBY           8
#define NGROUPS        32
#define CANBSIZ        255
#define NOFILE         256
#define NCARGS         131072
#define DEV_BSIZE      512
#define NOGROUP        (-1)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define __bitop(x, i, o) ((x)[(i) / 8] o(1 << (i) % 8))
#define setbit(x, i)     __bitop(x, i, |=)
#define clrbit(x, i)     __bitop(x, i, &= ~)
#define isset(x, i)      __bitop(x, i, &)
#define isclr(x, i)      !isset(x, i)

#undef roundup
#define roundup(n, d) (howmany(n, d) * (d))
#define powerof2(n)   !(((n)-1) & (n))
#define howmany(n, d) (((n) + ((d)-1)) / (d))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/termios.h */

#define COSMOPOLITAN_LIBC_CALLS_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § teletypewriter control                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int tcgetattr(int, struct termios *);
int tcsetattr(int, int, const struct termios *);
int tcsetpgrp(int, int32_t);
int32_t tcgetpgrp(int);

int openpty(int *, int *, char *, const struct termios *,
            const struct winsize *) paramsnonnull((1, 2));
int forkpty(int *, char *, const struct termios *, const struct winsize *)
    paramsnonnull((1, 2)) dontdiscard;
char *ptsname(int);
errno_t ptsname_r(int, char *, size_t);

int grantpt(int);
int unlockpt(int);
int posix_openpt(int) dontdiscard;

int tcdrain(int);
int tcgetsid(int);
int tcflow(int, int);
int tcflush(int, int);
int tcsendbreak(int, int);
void cfmakeraw(struct termios *);
int cfsetospeed(struct termios *, int);
int cfsetispeed(struct termios *, int);
uint32_t cfgetospeed(const struct termios *);
uint32_t cfgetispeed(const struct termios *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § teletypewriter » undiamonding                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define tcsetattr(FD, OPT, TIO) tcsetattr_dispatch(FD, OPT, TIO)
forceinline int tcsetattr_dispatch(int fd, int opt, const struct termios *tio) {
  if (__EQUIVALENT(opt, TCSANOW)) return ioctl(fd, TCSETS, (void *)tio);
  if (__EQUIVALENT(opt, TCSADRAIN)) return ioctl(fd, TCSETSW, (void *)tio);
  if (__EQUIVALENT(opt, TCSAFLUSH)) return ioctl(fd, TCSETSF, (void *)tio);
  return (tcsetattr)(fd, opt, tio);
}

#define tcgetattr(FD, TIO) tcgetattr_dispatch(FD, TIO)
forceinline int tcgetattr_dispatch(int fd, const struct termios *tio) {
  return ioctl(fd, TCGETS, (void *)tio);
}

#endif /* GNUC && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ttydefaults.h */

#define COSMOPOLITAN_LIBC_CALLS_TTYDEFAULTS_H_


/*!BEGIN libc/sysv/consts/baud.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_BAUD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint32_t B0;
extern const uint32_t B50;
extern const uint32_t B75;
extern const uint32_t B110;
extern const uint32_t B134;
extern const uint32_t B150;
extern const uint32_t B200;
extern const uint32_t B300;
extern const uint32_t B600;
extern const uint32_t B1200;
extern const uint32_t B1800;
extern const uint32_t B2400;
extern const uint32_t B4800;
extern const uint32_t B9600;
extern const uint32_t B19200;
extern const uint32_t B38400;
extern const uint32_t B57600;
extern const uint32_t B115200;
extern const uint32_t B230400;
extern const uint32_t B500000;
extern const uint32_t B576000;
extern const uint32_t B1000000;
extern const uint32_t B1152000;
extern const uint32_t B1500000;
extern const uint32_t B2000000;
extern const uint32_t B2500000;
extern const uint32_t B3000000;
extern const uint32_t B3500000;
extern const uint32_t B4000000;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define B0       LITERALLY(0)
#define B50      SYMBOLIC(B50)
#define B75      SYMBOLIC(B75)
#define B110     SYMBOLIC(B110)
#define B134     SYMBOLIC(B134)
#define B150     SYMBOLIC(B150)
#define B200     SYMBOLIC(B200)
#define B300     SYMBOLIC(B300)
#define B600     SYMBOLIC(B600)
#define B1200    SYMBOLIC(B1200)
#define B1800    SYMBOLIC(B1800)
#define B2400    SYMBOLIC(B2400)
#define B4800    SYMBOLIC(B4800)
#define B9600    SYMBOLIC(B9600)
#define B19200   SYMBOLIC(B19200)
#define B38400   SYMBOLIC(B38400)
#define B57600   SYMBOLIC(B57600)
#define B115200  SYMBOLIC(B115200)
#define B230400  SYMBOLIC(B230400)
#define B500000  SYMBOLIC(B500000)
#define B576000  SYMBOLIC(B576000)
#define B1000000 SYMBOLIC(B1000000)
#define B1152000 SYMBOLIC(B1152000)
#define B1500000 SYMBOLIC(B1500000)
#define B2000000 SYMBOLIC(B2000000)
#define B2500000 SYMBOLIC(B2500000)
#define B3000000 SYMBOLIC(B3000000)
#define B3500000 SYMBOLIC(B3500000)
#define B4000000 SYMBOLIC(B4000000)


#define TTYDEF_IFLAG (BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)
#define TTYDEF_OFLAG (OPOST | ONLCR | XTABS)
#define TTYDEF_LFLAG (ECHO | ICANON | ISIG | IEXTEN | ECHOE | ECHOKE | ECHOCTL)
#define TTYDEF_CFLAG (CREAD | CS8 | HUPCL)
#define TTYDEF_SPEED (B9600)

#define CTRL(x)  ((x) ^ 0100)
#define CEOF     CTRL('D')
#define CERASE   CTRL('?')
#define CINTR    CTRL('C')
#define CKILL    CTRL('U')
#define CQUIT    CTRL('\\')
#define CSUSP    CTRL('Z')
#define CDSUSP   CTRL('Y')
#define CSTART   CTRL('Q')
#define CSTOP    CTRL('S')
#define CLNEXT   CTRL('V')
#define CDISCARD CTRL('O')
#define CWERASE  CTRL('W')
#define CREPRINT CTRL('R')
#define CEOT     CEOF
#define CBRK     CEOL
#define CRPRNT   CREPRINT
#define CFLUSH   CDISCARD
#define CEOL     255
#define CMIN     1
#define CTIME    0



/*!BEGIN libc/calls/wait4.h */

#define COSMOPOLITAN_LIBC_CALLS_WAIT4_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int sys_wait4_nt(int, int *, int, struct rusage *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/weirdtypes.h */

#define COSMOPOLITAN_LIBC_CALLS_WEIRDTYPES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview Types we'd prefer hadn't been invented.
 */

#define blkcnt_t      int64_t
#define blksize_t     int64_t /* int32_t on xnu */
#define cc_t          uint8_t
#define clock_t       int64_t /* uint64_t on xnu */
#define cpu_set_t     uint64_t
#define dev_t         uint64_t /* int32_t on xnu */
#define fsblkcnt_t    int64_t
#define fsfilcnt_t    int64_t /* uint32_t on xnu */
#define gid_t         uint32_t
#define id_t          uint32_t /* int32_t on linux/freebsd/etc. */
#define in_addr_t     uint32_t
#define in_addr_t     uint32_t
#define in_port_t     uint16_t
#define in_port_t     uint16_t
#define ino_t         uint64_t
#define key_t         int32_t
#define loff_t        int64_t
#define mode_t        uint32_t /* uint16_t on xnu */
#define nfds_t        uint64_t
#define off_t         int64_t
#define pid_t         int32_t
#define register_t    int64_t
#define sa_family_t   uint16_t /* bsd:uint8_t */
#define socklen_t     uint32_t
#define speed_t       uint32_t
#define suseconds_t   int64_t /* int32_t on xnu */
#define syscall_arg_t int64_t /* uint64_t on xnu */
#define tcflag_t      uint32_t
#define time_t        int64_t
#define timer_t       void*
#define uid_t         uint32_t
#define rlim_t        uint64_t /* int64_t on bsd */

typedef __INT_FAST8_TYPE__ int_fast8_t;
typedef __UINT_FAST8_TYPE__ uint_fast8_t;
typedef __INT_FAST16_TYPE__ int_fast16_t;
typedef __UINT_FAST16_TYPE__ uint_fast16_t;
typedef __INT_FAST32_TYPE__ int_fast32_t;
typedef __UINT_FAST32_TYPE__ uint_fast32_t;
typedef __INT_FAST64_TYPE__ int_fast64_t;
typedef __UINT_FAST64_TYPE__ uint_fast64_t;

#define TIME_T_MAX      __INT64_MAX__
#define UINT_FAST64_MAX __UINT_FAST64_MAX__
#define UINT_FAST8_MAX  __UINT_FAST8_MAX__
#define INT_FAST32_MAX  __INT_FAST32_MAX__
#define INT_FAST16_MAX  __INT_FAST16_MAX__
#define UINT_FAST32_MAX __UINT_FAST32_MAX__
#define INT_FAST8_MAX   __INT_FAST8_MAX__
#define INT_FAST64_MAX  __INT_FAST64_MAX__
#define UINT_FAST16_MAX __UINT_FAST16_MAX__

#define TIME_T_MIN      (-TIME_T_MAX - 1)
#define UINT_FAST64_MIN (-UINT_FAST64_MAX - 1)
#define UINT_FAST8_MIN  (-UINT_FAST8_MAX - 1)
#define INT_FAST32_MIN  (-INT_FAST32_MAX - 1)
#define INT_FAST16_MIN  (-INT_FAST16_MAX - 1)
#define UINT_FAST32_MIN (-UINT_FAST32_MAX - 1)
#define INT_FAST8_MIN   (-INT_FAST8_MAX - 1)
#define INT_FAST64_MIN  (-INT_FAST64_MAX - 1)
#define UINT_FAST16_MIN (-UINT_FAST16_MAX - 1)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/xattr.h */

#define COSMOPOLITAN_LIBC_CALLS_XATTR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

ssize_t flistxattr(int, char *, size_t);
ssize_t fgetxattr(int, const char *, void *, size_t);
int fsetxattr(int, const char *, const void *, size_t, int);
int fremovexattr(int, const char *);
ssize_t listxattr(const char *, char *, size_t);
ssize_t getxattr(const char *, const char *, void *, size_t);
int setxattr(const char *, const char *, const void *, size_t, int);
int removexattr(const char *, const char *);
ssize_t llistxattr(const char *, char *, size_t);
ssize_t lgetxattr(const char *, const char *, void *, size_t);
int lsetxattr(const char *, const char *, const void *, size_t, int);
int lremovexattr(const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/consts.h */

#define COSMOPOLITAN_LIBC_DNS_CONSTS_H_


/*!BEGIN libc/sock/sock.h */

#define COSMOPOLITAN_LIBC_SOCK_SOCK_H_


/*!BEGIN libc/intrin/bswap.h */

#define COSMOPOLITAN_LIBC_BITS_BSWAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint16_t bswap_16(uint16_t) pureconst;
uint32_t bswap_32(uint32_t) pureconst;
uint32_t bswap_64(uint32_t) pureconst;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define bswap_16(x) __builtin_bswap16(x)
#define bswap_32(x) __builtin_bswap32(x)
#define bswap_64(x) __builtin_bswap64(x)
#endif /* defined(__GNUC__) && !defined(__STRICT_ANSI__) */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system api » berkeley sockets                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define INET_ADDRSTRLEN 22

#define htons(u16) bswap_16(u16)
#define ntohs(u16) bswap_16(u16)
#define htonl(u32) bswap_32(u32)
#define ntohl(u32) bswap_32(u32)

#define IFHWADDRLEN 6
#define IF_NAMESIZE 16
#define IFNAMSIZ    IF_NAMESIZE

const char *inet_ntop(int, const void *, char *, uint32_t);
int inet_pton(int, const char *, void *);
uint32_t inet_addr(const char *);
int parseport(const char *);
uint32_t *GetHostIps(void);

int nointernet(void);
int socket(int, int, int);
int accept(int, void *, uint32_t *);
int accept4(int, void *, uint32_t *, int);
int bind(int, const void *, uint32_t);
int connect(int, const void *, uint32_t);
int listen(int, int);
int shutdown(int, int);
int getsockname(int, void *, uint32_t *);
int getpeername(int, void *, uint32_t *);
ssize_t send(int, const void *, size_t, int);
ssize_t recv(int, void *, size_t, int);
ssize_t recvfrom(int, void *, size_t, uint32_t, void *, uint32_t *);
ssize_t sendfile(int, int, int64_t *, size_t);
int getsockopt(int, int, int, void *, uint32_t *);
int setsockopt(int, int, int, const void *, uint32_t);
int socketpair(int, int, int, int[2]);
ssize_t sendto(int, const void *, size_t, uint32_t, const void *, uint32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define DNS_TYPE_A     1
#define DNS_TYPE_NS    2
#define DNS_TYPE_CNAME 5
#define DNS_TYPE_SOA   6
#define DNS_TYPE_PTR   12
#define DNS_TYPE_MX    15
#define DNS_TYPE_TXT   16

#define DNS_CLASS_IN 1

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kMinSockaddr4Size \
  (offsetof(struct sockaddr_in, sin_addr) + sizeof(struct in_addr))

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dns.h */

#define COSMOPOLITAN_LIBC_DNS_DNS_H_


/*!BEGIN libc/dns/resolvconf.h */

#define COSMOPOLITAN_LIBC_DNS_RESOLVCONF_H_


/*!BEGIN libc/stdio/stdio.h */

#define COSMOPOLITAN_LIBC_STDIO_STDIO_H_


/*!BEGIN libc/intrin/pthread.h */

#define COSMOPOLITAN_LIBC_RUNTIME_PTHREAD_H_

#define PTHREAD_KEYS_MAX 64

#define PTHREAD_ONCE_INIT 0

#define PTHREAD_MUTEX_DEFAULT    PTHREAD_MUTEX_NORMAL
#define PTHREAD_MUTEX_NORMAL     0
#define PTHREAD_MUTEX_RECURSIVE  1
#define PTHREAD_MUTEX_ERRORCHECK 2
#define PTHREAD_MUTEX_STALLED    0
#define PTHREAD_MUTEX_ROBUST     1

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/* clang-format off */
#define PTHREAD_MUTEX_INITIALIZER {PTHREAD_MUTEX_DEFAULT}
#define PTHREAD_RWLOCK_INITIALIZER {{{0}}}
#define PTHREAD_COND_INITIALIZER {{{0}}}
/* clang-format on */

typedef unsigned long *pthread_t;
typedef int pthread_once_t;
typedef unsigned pthread_key_t;
typedef void (*pthread_key_dtor)(void *);

typedef struct {
  int attr;
  int reent;
  _Atomic(int) lock;
  _Atomic(int) waits;
} pthread_mutex_t;

typedef struct {
  int attr;
} pthread_mutexattr_t;

typedef struct {
  int attr;
} pthread_condattr_t;

typedef struct {
  int attr[2];
} pthread_rwlockattr_t;

typedef struct {
  union {
    int __i[9];
    volatile int __vi[9];
    unsigned __s[9];
  } __u;
} pthread_attr_t;

typedef struct {
  union {
    int __i[12];
    volatile int __vi[12];
    void *__p[12];
  } __u;
} pthread_cond_t;

typedef struct {
  union {
    int __i[8];
    volatile int __vi[8];
    void *__p[8];
  } __u;
} pthread_rwlock_t;

void pthread_exit(void *) wontreturn;
pthread_t pthread_self(void) pureconst;
int pthread_create(pthread_t *, const pthread_attr_t *, void *(*)(void *),
                   void *);
int pthread_yield(void);
int pthread_detach(pthread_t);
int pthread_join(pthread_t, void **);
int pthread_equal(pthread_t, pthread_t);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_consistent(pthread_mutex_t *);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cancel(pthread_t);
int pthread_cond_signal(pthread_cond_t *);
int pthread_rwlock_init(pthread_rwlock_t *, const pthread_rwlockattr_t *);
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_key_create(pthread_key_t *, pthread_key_dtor);
int pthread_key_delete(pthread_key_t);
int pthread_setspecific(pthread_key_t, void *);
void *pthread_getspecific(pthread_key_t);

#define pthread_mutexattr_init(pAttr)           ((pAttr)->attr = PTHREAD_MUTEX_DEFAULT, 0)
#define pthread_mutexattr_destroy(pAttr)        ((pAttr)->attr = 0)
#define pthread_mutexattr_gettype(pAttr, pType) (*(pType) = (pAttr)->attr, 0)
#define pthread_mutexattr_settype(pAttr, type)  ((pAttr)->attr = type, 0)

#ifdef __GNUC__
#define pthread_mutex_init(mutex, pAttr)                   \
  ({                                                       \
    pthread_mutexattr_t *_pAttr = (pAttr);                 \
    *(mutex) = (pthread_mutex_t){                          \
        (_pAttr) ? (_pAttr)->attr : PTHREAD_MUTEX_DEFAULT, \
    };                                                     \
    0;                                                     \
  })
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407
#define pthread_mutex_lock(mutex)                              \
  (((mutex)->attr == PTHREAD_MUTEX_NORMAL &&                   \
    !__atomic_load_n(&(mutex)->lock, __ATOMIC_RELAXED) &&      \
    !__atomic_exchange_n(&(mutex)->lock, 1, __ATOMIC_SEQ_CST)) \
       ? 0                                                     \
       : pthread_mutex_lock(mutex))
#define pthread_mutex_unlock(mutex)                              \
  ((mutex)->attr == PTHREAD_MUTEX_NORMAL                         \
       ? (__atomic_store_n(&(mutex)->lock, 0, __ATOMIC_RELAXED), \
          (__atomic_load_n(&(mutex)->waits, __ATOMIC_RELAXED) && \
           _pthread_mutex_wake(mutex)),                          \
          0)                                                     \
       : pthread_mutex_unlock(mutex))
#endif

int _pthread_mutex_wake(pthread_mutex_t *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define _STDIO_H
#define L_ctermid    20
#define FILENAME_MAX PATH_MAX

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef struct FILE {
  uint8_t bufmode;      /* 0x00 _IOFBF, etc. (ignored if fd=-1) */
  bool noclose;         /* 0x01 for fake dup() todo delete! */
  uint32_t iomode;      /* 0x04 O_RDONLY, etc. (ignored if fd=-1) */
  int32_t state;        /* 0x08 0=OK, -1=EOF, >0=errno */
  int fd;               /* 0x0c ≥0=fd, -1=closed|buffer */
  uint32_t beg;         /* 0x10 */
  uint32_t end;         /* 0x14 */
  char *buf;            /* 0x18 */
  uint32_t size;        /* 0x20 */
  uint32_t nofree;      /* 0x24 */
  int pid;              /* 0x28 */
  char *getln;          /* 0x30 */
  pthread_mutex_t lock; /* 0x38 */
} FILE;

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

errno_t ferror(FILE *) paramsnonnull();
void clearerr(FILE *) paramsnonnull();
int feof(FILE *) paramsnonnull();
int getc(FILE *) paramsnonnull();
int putc(int, FILE *) paramsnonnull();
int fflush(FILE *);
int fpurge(FILE *);
int fgetc(FILE *) paramsnonnull();
char *fgetln(FILE *, size_t *) paramsnonnull((1));
int ungetc(int, FILE *) paramsnonnull();
int fileno(FILE *) paramsnonnull() nosideeffect;
int fputc(int, FILE *) paramsnonnull();
int fputs(const char *, FILE *) paramsnonnull();
int fputws(const wchar_t *, FILE *) paramsnonnull();
char *fgets(char *, int, FILE *) paramsnonnull();
wchar_t *fgetws(wchar_t *, int, FILE *) paramsnonnull();
wint_t putwc(wchar_t, FILE *) paramsnonnull();
wint_t fputwc(wchar_t, FILE *) paramsnonnull();
wint_t putwchar(wchar_t);
wint_t getwchar(void);
wint_t getwc(FILE *) paramsnonnull();
wint_t fgetwc(FILE *) paramsnonnull();
wint_t ungetwc(wint_t, FILE *) paramsnonnull();
int getchar(void);
int putchar(int);
int puts(const char *);
ssize_t getline(char **, size_t *, FILE *) paramsnonnull();
ssize_t getdelim(char **, size_t *, int, FILE *) paramsnonnull();
FILE *fopen(const char *, const char *) paramsnonnull() dontdiscard;
FILE *fdopen(int, const char *) paramsnonnull() dontdiscard;
FILE *fmemopen(void *, size_t, const char *) paramsnonnull((3)) dontdiscard;
FILE *freopen(const char *, const char *, FILE *) paramsnonnull((2, 3));
size_t fread(void *, size_t, size_t, FILE *) paramsnonnull((4));
size_t fwrite(const void *, size_t, size_t, FILE *) paramsnonnull((4));
int fclose(FILE *);
int fclose_s(FILE **) paramsnonnull();
int fseek(FILE *, long, int) paramsnonnull();
long ftell(FILE *) paramsnonnull();
int fseeko(FILE *, int64_t, int) paramsnonnull();
int64_t ftello(FILE *) paramsnonnull();
void rewind(FILE *) paramsnonnull();
int fopenflags(const char *) paramsnonnull();
void setlinebuf(FILE *);
void setbuf(FILE *, char *);
void setbuffer(FILE *, char *, size_t);
int setvbuf(FILE *, char *, int, size_t);
FILE *popen(const char *, const char *);
int pclose(FILE *);
char *ctermid(char *);
void perror(const char *) relegated;

typedef uint64_t fpos_t;
compatfn char *gets(char *) paramsnonnull();
compatfn int fgetpos(FILE *, fpos_t *) paramsnonnull();
compatfn int fsetpos(FILE *, const fpos_t *) paramsnonnull();

int system(const char *);
int systemexec(const char *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o » formatting                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int printf(const char *, ...) printfesque(1)
    paramsnonnull((1)) dontthrow nocallback;
int vprintf(const char *, va_list) paramsnonnull() dontthrow nocallback;
int fprintf(FILE *, const char *, ...) printfesque(2)
    paramsnonnull((1, 2)) dontthrow nocallback;
int vfprintf(FILE *, const char *, va_list)
    paramsnonnull() dontthrow nocallback;
int scanf(const char *, ...) scanfesque(1);
int vscanf(const char *, va_list);
int fscanf(FILE *, const char *, ...) scanfesque(2);
int vfscanf(FILE *, const char *, va_list);

int fwprintf(FILE *, const wchar_t *, ...);
int fwscanf(FILE *, const wchar_t *, ...);
int swprintf(wchar_t *, size_t, const wchar_t *, ...);
int swscanf(const wchar_t *, const wchar_t *, ...);
int vfwprintf(FILE *, const wchar_t *, va_list);
int vfwscanf(FILE *, const wchar_t *, va_list);
int vswprintf(wchar_t *, size_t, const wchar_t *, va_list);
int vswscanf(const wchar_t *, const wchar_t *, va_list);
int vwprintf(const wchar_t *, va_list);
int vwscanf(const wchar_t *, va_list);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);
int fwide(FILE *, int);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o » without mutexes                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int getc_unlocked(FILE *) paramsnonnull();
int getchar_unlocked(void);
int putc_unlocked(int, FILE *) paramsnonnull();
int putchar_unlocked(int);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int fflush_unlocked(FILE *);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);
wint_t getwc_unlocked(FILE *);
wint_t getwchar_unlocked(void);
wint_t fgetwc_unlocked(FILE *);
wint_t fputwc_unlocked(wchar_t, FILE *);
wint_t putwc_unlocked(wchar_t, FILE *);
wint_t putwchar_unlocked(wchar_t);
wchar_t *fgetws_unlocked(wchar_t *, int, FILE *);
int fputws_unlocked(const wchar_t *, FILE *);
wint_t ungetwc_unlocked(wint_t, FILE *) paramsnonnull();
int ungetc_unlocked(int, FILE *) paramsnonnull();
int fseeko_unlocked(FILE *, int64_t, int) paramsnonnull();
ssize_t getdelim_unlocked(char **, size_t *, int, FILE *) paramsnonnull();
int fprintf_unlocked(FILE *, const char *, ...) printfesque(2)
    paramsnonnull((1, 2)) dontthrow nocallback;
int vfprintf_unlocked(FILE *, const char *, va_list)
    paramsnonnull() dontthrow nocallback;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o » optimizations                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define getc(f)     fgetc(f)
#define getwc(f)    fgetwc(f)
#define putc(c, f)  fputc(c, f)
#define putwc(c, f) fputwc(c, f)

#define getc_unlocked(f)     fgetc_unlocked(f)
#define getwc_unlocked(f)    fgetwc_unlocked(f)
#define putc_unlocked(c, f)  fputc_unlocked(c, f)
#define putwc_unlocked(c, f) fputwc_unlocked(c, f)

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
/* clang-format off */
#define printf(FMT, ...)     (printf)(PFLINK(FMT), ##__VA_ARGS__)
#define vprintf(FMT, VA)     (vprintf)(PFLINK(FMT), VA)
#define fprintf(F, FMT, ...) (fprintf)(F, PFLINK(FMT), ##__VA_ARGS__)
#define vfprintf(F, FMT, VA) (vfprintf)(F, PFLINK(FMT),  VA)
#define fprintf_unlocked(F, FMT, ...) (fprintf_unlocked)(F, PFLINK(FMT), ##__VA_ARGS__)
#define vfprintf_unlocked(F, FMT, VA) (vfprintf_unlocked)(F, PFLINK(FMT), VA)
#define vscanf(FMT, VA)      (vscanf)(SFLINK(FMT), VA)
#define scanf(FMT, ...)      (scanf)(SFLINK(FMT), ##__VA_ARGS__)
#define fscanf(F, FMT, ...)  (fscanf)(F, SFLINK(FMT), ##__VA_ARGS__)
#define vfscanf(F, FMT, VA)  (vfscanf)(F, SFLINK(FMT), VA)
/* clang-format on */
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct Nameservers {
  size_t i, n;
  struct sockaddr_in *p;
};

struct ResolvConf {
  struct Nameservers nameservers;
};

const struct ResolvConf *GetResolvConf(void) returnsnonnull;
int ParseResolvConf(struct ResolvConf *, struct FILE *) paramsnonnull();
void FreeResolvConf(struct ResolvConf **) paramsnonnull();
int GetNtNameServers(struct ResolvConf *) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/sockaddr.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_SOCKADDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sockaddr {     /* Linux+NT ABI */
  uint16_t sa_family; /* AF_XXX */
  char sa_data[14];
};

struct in_addr { /* ARPA ABI */
  /* e.g. 127|0<<8|0<<16|1<<24 or inet_pton(AF_INET, "127.0.0.1", &s_addr) */
  uint32_t s_addr;
};

struct sockaddr_in {   /* Linux+NT ABI */
  uint16_t sin_family; /* AF_XXX */
  uint16_t sin_port;   /* htons(XXX) i.e. big endian */
  struct in_addr sin_addr;
  uint8_t sin_zero[8];
};

struct sockaddr_un {
  uint16_t sun_family; /* AF_UNIX */
  char sun_path[108];  /* path */
};

struct sockaddr_storage {
  union {
    uint16_t ss_family;
    intptr_t __ss_align;
    char __ss_storage[128];
  };
};

int inet_aton(const char *, struct in_addr *);
char *inet_ntoa(struct in_addr);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define DNS_PORT      53
#define DNS_NAME_MAX  253
#define DNS_LABEL_MAX 63

#define EAI_SUCCESS     0
#define EAI_BADFLAGS    -1
#define EAI_NONAME      -2
#define EAI_AGAIN       -3
#define EAI_FAIL        -4
#define EAI_NODATA      -5
#define EAI_FAMILY      -6
#define EAI_SOCKTYPE    -7
#define EAI_SERVICE     -8
#define EAI_ADDRFAMILY  -9
#define EAI_MEMORY      -10
#define EAI_OVERFLOW    -12
#define EAI_SYSTEM      -11
#define EAI_ALLDONE     -103
#define EAI_CANCELED    -101
#define EAI_IDN_ENCODE  -105
#define EAI_INPROGRESS  -100
#define EAI_INTR        -104
#define EAI_NOTCANCELED -102

/* AI_* conforms to NT ABI */
#define AI_PASSIVE     1
#define AI_CANONNAME   2
#define AI_NUMERICHOST 4
#define AI_NUMERICSERV 8
#define AI_ALL         0x0100
#define AI_ADDRCONFIG  0x0400
#define AI_V4MAPPED    0x0800

#define NI_NUMERICSCOPE 0
#define NI_NUMERICHOST  1
#define NI_NUMERICSERV  2
#define NI_NOFQDN       4
#define NI_NAMEREQD     8
#define NI_DGRAM        16
#define NI_MAXSERV      32
#define NI_MAXHOST      1025

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct addrinfo {
  int32_t ai_flags;    /* AI_XXX */
  int32_t ai_family;   /* AF_INET */
  int32_t ai_socktype; /* SOCK_XXX */
  int32_t ai_protocol; /* IPPROTO_XXX */
  uint32_t ai_addrlen;
  union {
    struct sockaddr *ai_addr;
    struct sockaddr_in *ai_addr4;
  };
  char *ai_canonname /*[DNS_NAME_MAX + 1]*/;
  struct addrinfo *ai_next;
};

int getaddrinfo(const char *, const char *, const struct addrinfo *,
                struct addrinfo **) paramsnonnull((4));
int freeaddrinfo(struct addrinfo *);
int getnameinfo(const struct sockaddr *, socklen_t, char *, socklen_t, char *,
                socklen_t, int);
const char *gai_strerror(int);
int CompareDnsNames(const char *, const char *) paramsnonnull();
int PascalifyDnsName(uint8_t *, size_t, const char *) paramsnonnull();
int ResolveDns(const struct ResolvConf *, int, const char *, struct sockaddr *,
               uint32_t) paramsnonnull();
int ResolveDnsReverse(const struct ResolvConf *, int, const char *, char *,
                      size_t) paramsnonnull();
struct addrinfo *newaddrinfo(uint16_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dnsheader.h */

#define COSMOPOLITAN_LIBC_DNS_DNSHEADER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DnsHeader {
  uint16_t id;      /* transaction id */
  uint8_t bf1;      /* bit field 1 */
  uint8_t bf2;      /* bit field 2 */
  uint16_t qdcount; /* question count */
  uint16_t ancount; /* answer count */
  uint16_t nscount; /* nameserver count */
  uint16_t arcount; /* additional record count */
};

void SerializeDnsHeader(uint8_t[restrict 12], const struct DnsHeader *);
void DeserializeDnsHeader(struct DnsHeader *, const uint8_t[restrict 12]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dnsquestion.h */

#define COSMOPOLITAN_LIBC_DNS_DNSQUESTION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DnsQuestion {
  const char *qname;
  uint16_t qtype;
  uint16_t qclass;
};

int SerializeDnsQuestion(uint8_t *, size_t, const struct DnsQuestion *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/ent.h */

#define COSMOPOLITAN_LIBC_DNS_ENT_H_

#define HOST_NOT_FOUND 1
#define TRY_AGAIN      2
#define NO_RECOVERY    3
#define NO_DATA        4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct netent {
  char *n_name;     /* official network name */
  char **n_aliases; /* alias list */
  int n_addrtype;   /* net address type */
  uint32_t n_net;   /* network number */
};

struct protoent {
  char *p_name;     /* official protocol name */
  char **p_aliases; /* alias list */
  int p_proto;      /* protocol number */
};

struct hostent {
  char *h_name;       /* official name of host */
  char **h_aliases;   /* alias list */
  int h_addrtype;     /* host address type */
  int h_length;       /* length of address */
  char **h_addr_list; /* list of addresses */
};
#define h_addr h_addr_list[0]

struct servent {
  char *s_name;     /* official service name */
  char **s_aliases; /* alias list */
  int s_port;       /* port number (in network byte order) */
  char *s_proto;    /* protocol to use */
};

extern int h_errno;
void herror(const char *);
const char *hstrerror(int);

struct netent *getnetent(void);
struct netent *getnetbyname(const char *);
struct netent *getnetbyaddr(uint32_t, int);
void setnetent(int);
void endnetent(void);

struct protoent *getprotoent(void);
struct protoent *getprotobyname(const char *);
struct protoent *getprotobynumber(int);
void setprotoent(int);
void endprotoent(void);

struct hostent *gethostent(void);
struct hostent *gethostbyname(const char *);
struct hostent *gethostbyaddr(const void *, socklen_t, int);
void sethostent(int);
void endhostent(void);

struct servent *getservent(void);
struct servent *getservbyname(const char *, const char *);
struct servent *getservbyport(int, const char *);
void setservent(int);
void endservent(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/hoststxt.h */

#define COSMOPOLITAN_LIBC_DNS_HOSTSTXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct HostsTxtEntry {
  uint8_t ip[4];  /* inet_ntop(AF_INET, he->ip, buf, size) */
  uint32_t name;  /* &ht->strings.p[he->name] */
  uint32_t canon; /* &ht->strings.p[he->canon] */
};

struct HostsTxtEntries {
  size_t i, n;
  struct HostsTxtEntry *p;
};

struct HostsTxtStrings {
  size_t i, n;
  char *p;
};

struct HostsTxt {
  struct HostsTxtEntries entries;
  struct HostsTxtStrings strings;
};

const struct HostsTxt *GetHostsTxt(void) returnsnonnull;
void FreeHostsTxt(struct HostsTxt **) paramsnonnull();
int ParseHostsTxt(struct HostsTxt *, FILE *) paramsnonnull();
int ResolveHostsTxt(const struct HostsTxt *, int, const char *,
                    struct sockaddr *, uint32_t, const char **)
    paramsnonnull((1, 3));
int ResolveHostsReverse(const struct HostsTxt *, int, const uint8_t *, char *,
                        size_t) paramsnonnull((1, 3));

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/prototxt.h */

#define COSMOPOLITAN_LIBC_DNS_PROTOTXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int LookupProtoByNumber(const int, char *, size_t, const char *)
    paramsnonnull((2));
int LookupProtoByName(const char *, char *, size_t, const char *)
    paramsnonnull((1, 2));
char *GetNtProtocolsTxtPath(char *, uint32_t);

/* TODO: implement like struct HostsTxt? */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/servicestxt.h */

#define COSMOPOLITAN_LIBC_DNS_SERVICESTXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int LookupServicesByPort(const int, char *, size_t, char *, size_t,
                         const char *) paramsnonnull((2, 4));
int LookupServicesByName(const char *, char *, size_t, char *, size_t,
                         const char *) paramsnonnull((1, 2));
char *GetNtServicesTxtPath(char *, uint32_t);

/* TODO: implement like struct HostsTxt? */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/def.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_DEF_H_

/**
 * @fileoverview Executable and Linkable Format Definitions.
 */

#define EI_NIDENT 16

#define EI_MAG0 0
#define EI_MAG1 1
#define EI_MAG2 2
#define EI_MAG3 3

#define ELFMAG  "\177ELF"
#define ELFMAG0 0x7f
#define ELFMAG1 'E'
#define ELFMAG2 'L'
#define ELFMAG3 'F'
#define SELFMAG 4

#define EI_CLASS     4
#define ELFCLASSNONE 0
#define ELFCLASS32   1
#define ELFCLASS64   2
#define ELFCLASSNUM  3

#define EI_DATA     5
#define ELFDATANONE 0
#define ELFDATA2LSB 1
#define ELFDATA2MSB 2
#define ELFDATANUM  3

#define EI_VERSION 6

#define EI_OSABI            7
#define ELFOSABI_NONE       0
#define ELFOSABI_SYSV       0
#define ELFOSABI_HPUX       1
#define ELFOSABI_NETBSD     2
#define ELFOSABI_LINUX      3
#define ELFOSABI_GNU        3
#define ELFOSABI_SOLARIS    6
#define ELFOSABI_AIX        7
#define ELFOSABI_IRIX       8
#define ELFOSABI_FREEBSD    9
#define ELFOSABI_TRU64      10
#define ELFOSABI_MODESTO    11
#define ELFOSABI_OPENBSD    12
#define ELFOSABI_ARM        97
#define ELFOSABI_STANDALONE 255

#define EI_ABIVERSION 8

#define EI_PAD 9

#define ET_NONE   0
#define ET_REL    1
#define ET_EXEC   2
#define ET_DYN    3
#define ET_CORE   4
#define ET_NUM    5
#define ET_LOOS   0xfe00
#define ET_HIOS   0xfeff
#define ET_LOPROC 0xff00
#define ET_HIPROC 0xffff

#define EM_NONE      0
#define EM_M32       1
#define EM_386       3
#define EM_S390      22
#define EM_ARM       40
#define EM_NEXGEN32E 62
#define EM_X86_64    EM_NEXGEN32E
#define EM_IA32E     EM_NEXGEN32E
#define EM_AMD64     EM_NEXGEN32E
#define EM_PDP11     65
#define EM_CRAYNV2   172
#define EM_L10M      180
#define EM_K10M      181
#define EM_AARCH64   183
#define EM_CUDA      190
#define EM_Z80       220
#define EM_RISCV     243
#define EM_BPF       247

#define GRP_COMDAT 1
#define STN_UNDEF  0

#define EV_NONE    0
#define EV_CURRENT 1
#define EV_NUM     2

#define SYMINFO_NONE          0
#define SYMINFO_CURRENT       1
#define SYMINFO_NUM           2
#define SYMINFO_BT_SELF       0xffff
#define SYMINFO_BT_PARENT     0xfffe
#define SYMINFO_BT_LOWRESERVE 0xff00
#define SYMINFO_FLG_DIRECT    0x0001
#define SYMINFO_FLG_PASSTHRU  0x0002
#define SYMINFO_FLG_COPY      0x0004
#define SYMINFO_FLG_LAZYLOAD  0x0008

#define PT_NULL         0
#define PT_LOAD         1
#define PT_DYNAMIC      2
#define PT_INTERP       3
#define PT_NOTE         4
#define PT_SHLIB        5
#define PT_PHDR         6
#define PT_TLS          7
#define PT_NUM          8
#define PT_LOOS         0x60000000
#define PT_GNU_EH_FRAME 0x6474e550
#define PT_GNU_STACK    0x6474e551
#define PT_GNU_RELRO    0x6474e552
#define PT_LOSUNW       0x6ffffffa
#define PT_SUNWBSS      0x6ffffffa
#define PT_SUNWSTACK    0x6ffffffb
#define PT_HISUNW       0x6fffffff
#define PT_HIOS         0x6fffffff
#define PT_LOPROC       0x70000000
#define PT_HIPROC       0x7fffffff

#define PN_XNUM 0xffff

#define PF_X        1
#define PF_W        2
#define PF_R        4
#define PF_MASKOS   0x0ff00000
#define PF_MASKPROC 0xf0000000

#define R_X86_64_NONE            0
#define R_X86_64_64              1
#define R_X86_64_PC32            2
#define R_X86_64_GOT32           3
#define R_X86_64_PLT32           4
#define R_X86_64_COPY            5
#define R_X86_64_GLOB_DAT        6
#define R_X86_64_JUMP_SLOT       7
#define R_X86_64_RELATIVE        8
#define R_X86_64_GOTPCREL        9
#define R_X86_64_32              10
#define R_X86_64_32S             11
#define R_X86_64_16              12
#define R_X86_64_PC16            13
#define R_X86_64_8               14
#define R_X86_64_PC8             15
#define R_X86_64_DTPMOD64        16
#define R_X86_64_DTPOFF64        17
#define R_X86_64_TPOFF64         18
#define R_X86_64_TLSGD           19
#define R_X86_64_TLSLD           20
#define R_X86_64_DTPOFF32        21
#define R_X86_64_GOTTPOFF        22
#define R_X86_64_TPOFF32         23
#define R_X86_64_PC64            24
#define R_X86_64_GOTOFF64        25
#define R_X86_64_GOTPC32         26
#define R_X86_64_GOT64           27
#define R_X86_64_GOTPCREL64      28
#define R_X86_64_GOTPC64         29
#define R_X86_64_GOTPLT64        30
#define R_X86_64_PLTOFF64        31
#define R_X86_64_SIZE32          32
#define R_X86_64_SIZE64          33
#define R_X86_64_GOTPC32_TLSDESC 34
#define R_X86_64_TLSDESC_CALL    35
#define R_X86_64_TLSDESC         36
#define R_X86_64_IRELATIVE       37
#define R_X86_64_RELATIVE64      38
#define R_X86_64_GOTPCRELX       41 /* 6 bytes */
#define R_X86_64_REX_GOTPCRELX   42 /* 7 bytes */
#define R_X86_64_NUM             43

#define STB_LOCAL      0
#define STB_GLOBAL     1
#define STB_WEAK       2
#define STB_NUM        3
#define STB_LOOS       10
#define STB_GNU_UNIQUE 10
#define STB_HIOS       12
#define STB_LOPROC     13
#define STB_HIPROC     15

#define STT_NOTYPE    0
#define STT_OBJECT    1
#define STT_FUNC      2
#define STT_SECTION   3
#define STT_FILE      4
#define STT_COMMON    5
#define STT_TLS       6
#define STT_NUM       7
#define STT_LOOS      10
#define STT_GNU_IFUNC 10
#define STT_HIOS      12
#define STT_LOPROC    13
#define STT_HIPROC    15

#define STV_DEFAULT   0
#define STV_INTERNAL  1
#define STV_HIDDEN    2
#define STV_PROTECTED 3

#define SHN_UNDEF     0
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC    0xff00
#define SHN_BEFORE    0xff00
#define SHN_AFTER     0xff01
#define SHN_HIPROC    0xff1f
#define SHN_LOOS      0xff20
#define SHN_HIOS      0xff3f
#define SHN_ABS       0xfff1
#define SHN_COMMON    0xfff2
#define SHN_XINDEX    0xffff
#define SHN_HIRESERVE 0xffff

#define SHF_WRITE            (1 << 0)
#define SHF_ALLOC            (1 << 1)
#define SHF_EXECINSTR        (1 << 2)
#define SHF_MERGE            (1 << 4)
#define SHF_STRINGS          (1 << 5)
#define SHF_INFO_LINK        (1 << 6)
#define SHF_LINK_ORDER       (1 << 7)
#define SHF_OS_NONCONFORMING (1 << 8)
#define SHF_GROUP            (1 << 9)
#define SHF_TLS              (1 << 10)
#define SHF_COMPRESSED       (1 << 11)
#define SHF_MASKOS           0x0ff00000
#define SHF_MASKPROC         0xf0000000
#define SHF_ORDERED          (1 << 30)
#define SHF_EXCLUDE          (1U << 31)

#define ELFCOMPRESS_ZLIB   1
#define ELFCOMPRESS_LOOS   0x60000000
#define ELFCOMPRESS_HIOS   0x6fffffff
#define ELFCOMPRESS_LOPROC 0x70000000
#define ELFCOMPRESS_HIPROC 0x7fffffff

#define SHT_NULL           0
#define SHT_PROGBITS       1
#define SHT_SYMTAB         2
#define SHT_STRTAB         3
#define SHT_RELA           4
#define SHT_HASH           5
#define SHT_DYNAMIC        6
#define SHT_NOTE           7
#define SHT_NOBITS         8
#define SHT_REL            9
#define SHT_SHLIB          10
#define SHT_DYNSYM         11
#define SHT_INIT_ARRAY     14
#define SHT_FINI_ARRAY     15
#define SHT_PREINIT_ARRAY  16
#define SHT_GROUP          17
#define SHT_SYMTAB_SHNDX   18
#define SHT_NUM            19
#define SHT_LOOS           0x60000000
#define SHT_GNU_ATTRIBUTES 0x6ffffff5
#define SHT_GNU_HASH       0x6ffffff6
#define SHT_GNU_LIBLIST    0x6ffffff7
#define SHT_CHECKSUM       0x6ffffff8
#define SHT_LOSUNW         0x6ffffffa
#define SHT_SUNW_move      0x6ffffffa
#define SHT_SUNW_COMDAT    0x6ffffffb
#define SHT_SUNW_syminfo   0x6ffffffc
#define SHT_GNU_verdef     0x6ffffffd
#define SHT_GNU_verneed    0x6ffffffe
#define SHT_GNU_versym     0x6fffffff
#define SHT_HISUNW         0x6fffffff
#define SHT_HIOS           0x6fffffff
#define SHT_LOPROC         0x70000000
#define SHT_HIPROC         0x7fffffff
#define SHT_LOUSER         0x80000000
#define SHT_HIUSER         0x8fffffff

#define DT_NULL               0
#define DT_NEEDED             1
#define DT_PLTRELSZ           2
#define DT_PLTGOT             3
#define DT_HASH               4
#define DT_STRTAB             5
#define DT_SYMTAB             6
#define DT_RELA               7
#define DT_RELASZ             8
#define DT_RELAENT            9
#define DT_STRSZ              10
#define DT_SYMENT             11
#define DT_INIT               12
#define DT_FINI               13
#define DT_SONAME             14
#define DT_RPATH              15
#define DT_SYMBOLIC           16
#define DT_REL                17
#define DT_RELSZ              18
#define DT_RELENT             19
#define DT_PLTREL             20
#define DT_DEBUG              21
#define DT_TEXTREL            22
#define DT_JMPREL             23
#define DT_BIND_NOW           24
#define DT_INIT_ARRAY         25
#define DT_FINI_ARRAY         26
#define DT_INIT_ARRAYSZ       27
#define DT_FINI_ARRAYSZ       28
#define DT_RUNPATH            29
#define DT_FLAGS              30
#define DT_ENCODING           32
#define DT_PREINIT_ARRAY      32
#define DT_PREINIT_ARRAYSZ    33
#define DT_SYMTAB_SHNDX       34
#define DT_NUM                35
#define DT_LOOS               0x6000000d
#define DT_HIOS               0x6ffff000
#define DT_LOPROC             0x70000000
#define DT_HIPROC             0x7fffffff
#define DT_VALRNGLO           0x6ffffd00
#define DT_GNU_PRELINKED      0x6ffffdf5
#define DT_GNU_CONFLICTSZ     0x6ffffdf6
#define DT_GNU_LIBLISTSZ      0x6ffffdf7
#define DT_CHECKSUM           0x6ffffdf8
#define DT_PLTPADSZ           0x6ffffdf9
#define DT_MOVEENT            0x6ffffdfa
#define DT_MOVESZ             0x6ffffdfb
#define DT_FEATURE_1          0x6ffffdfc
#define DT_POSFLAG_1          0x6ffffdfd
#define DT_SYMINSZ            0x6ffffdfe
#define DT_SYMINENT           0x6ffffdff
#define DT_VALRNGHI           0x6ffffdff
#define DT_VALTAGIDX(tag)     (DT_VALRNGHI - (tag))
#define DT_VALNUM             12
#define DT_ADDRRNGLO          0x6ffffe00
#define DT_GNU_HASH           0x6ffffef5
#define DT_TLSDESC_PLT        0x6ffffef6
#define DT_TLSDESC_GOT        0x6ffffef7
#define DT_GNU_CONFLICT       0x6ffffef8
#define DT_GNU_LIBLIST        0x6ffffef9
#define DT_CONFIG             0x6ffffefa
#define DT_DEPAUDIT           0x6ffffefb
#define DT_AUDIT              0x6ffffefc
#define DT_PLTPAD             0x6ffffefd
#define DT_MOVETAB            0x6ffffefe
#define DT_SYMINFO            0x6ffffeff
#define DT_ADDRRNGHI          0x6ffffeff
#define DT_ADDRTAGIDX(tag)    (DT_ADDRRNGHI - (tag))
#define DT_ADDRNUM            11
#define DT_VERSYM             0x6ffffff0
#define DT_RELACOUNT          0x6ffffff9
#define DT_RELCOUNT           0x6ffffffa
#define DT_FLAGS_1            0x6ffffffb
#define DT_VERDEF             0x6ffffffc
#define DT_VERDEFNUM          0x6ffffffd
#define DT_VERNEED            0x6ffffffe
#define DT_VERNEEDNUM         0x6fffffff
#define DT_VERSIONTAGIDX(tag) (DT_VERNEEDNUM - (tag))
#define DT_VERSIONTAGNUM      16
#define DT_AUXILIARY          0x7ffffffd
#define DT_FILTER             0x7fffffff
#define DT_EXTRATAGIDX(tag)   ((Elf32_Word) - ((Elf32_Sword)(tag) << 1 >> 1) - 1)
#define DT_EXTRANUM           3

#define VER_NEED_NONE    0
#define VER_NEED_CURRENT 1
#define VER_NEED_NUM     2
#define VER_FLG_WEAK     0x2

#define ELF_NOTE_SOLARIS       "SUNW Solaris"
#define ELF_NOTE_GNU           "GNU"
#define ELF_NOTE_PAGESIZE_HINT 1
#define ELF_NOTE_ABI           NT_GNU_ABI_TAG
#define ELF_NOTE_OS_LINUX      0
#define ELF_NOTE_OS_GNU        1
#define ELF_NOTE_OS_SOLARIS2   2
#define ELF_NOTE_OS_FREEBSD    3

#define NT_GNU_ABI_TAG      1
#define NT_GNU_BUILD_ID     3
#define NT_GNU_GOLD_VERSION 4

#define EF_CPU32 0x00810000

#define DF_ORIGIN       0x00000001
#define DF_SYMBOLIC     0x00000002
#define DF_TEXTREL      0x00000004
#define DF_BIND_NOW     0x00000008
#define DF_STATIC_TLS   0x00000010
#define DF_1_NOW        0x00000001
#define DF_1_GLOBAL     0x00000002
#define DF_1_GROUP      0x00000004
#define DF_1_NODELETE   0x00000008
#define DF_1_LOADFLTR   0x00000010
#define DF_1_INITFIRST  0x00000020
#define DF_1_NOOPEN     0x00000040
#define DF_1_ORIGIN     0x00000080
#define DF_1_DIRECT     0x00000100
#define DF_1_TRANS      0x00000200
#define DF_1_INTERPOSE  0x00000400
#define DF_1_NODEFLIB   0x00000800
#define DF_1_NODUMP     0x00001000
#define DF_1_CONFALT    0x00002000
#define DF_1_ENDFILTEE  0x00004000
#define DF_1_DISPRELDNE 0x00008000
#define DF_1_DISPRELPND 0x00010000
#define DF_1_NODIRECT   0x00020000
#define DF_1_IGNMULDEF  0x00040000
#define DF_1_NOKSYMS    0x00080000
#define DF_1_NOHDR      0x00100000
#define DF_1_EDITED     0x00200000
#define DF_1_NORELOC    0x00400000
#define DF_1_SYMINTPOSE 0x00800000
#define DF_1_GLOBAUDIT  0x01000000
#define DF_1_SINGLETON  0x02000000
#define DF_1_STUB       0x04000000
#define DF_1_PIE        0x08000000
#define DTF_1_PARINIT   0x00000001
#define DTF_1_CONFEXP   0x00000002
#define DF_P1_LAZYLOAD  0x00000001
#define DF_P1_GROUPPERM 0x00000002

#define ELF64_ST_BIND(val)        (((unsigned char)(val)) >> 4)
#define ELF64_ST_TYPE(val)        ((val)&0xf)
#define ELF64_ST_INFO(bind, type) (((bind) << 4) + ((type)&0xf))
#define ELF64_ST_VISIBILITY(o)    ((o)&0x03)

#define ELF64_R_SYM(i)          ((i) >> 32)
#define ELF64_R_TYPE(i)         ((i)&0xffffffff)
#define ELF64_R_INFO(sym, type) ((((Elf64_Xword)(sym)) << 32) + (type))

#define ELF64_M_SYM(info)       ((info) >> 8)
#define ELF64_M_SIZE(info)      ((unsigned char)(info))
#define ELF64_M_INFO(sym, size) (((sym) << 8) + (unsigned char)(size))

#define NT_PRSTATUS         1
#define NT_PRFPREG          2
#define NT_FPREGSET         2
#define NT_PRPSINFO         3
#define NT_PRXREG           4
#define NT_TASKSTRUCT       4
#define NT_PLATFORM         5
#define NT_AUXV             6
#define NT_GWINDOWS         7
#define NT_ASRS             8
#define NT_PSTATUS          10
#define NT_PSINFO           13
#define NT_PRCRED           14
#define NT_UTSNAME          15
#define NT_LWPSTATUS        16
#define NT_LWPSINFO         17
#define NT_PRFPXREG         20
#define NT_SIGINFO          0x53494749
#define NT_FILE             0x46494c45
#define NT_PRXFPREG         0x46e62b7f
#define NT_PPC_VMX          0x100
#define NT_PPC_SPE          0x101
#define NT_PPC_VSX          0x102
#define NT_PPC_TAR          0x103
#define NT_PPC_PPR          0x104
#define NT_PPC_DSCR         0x105
#define NT_PPC_EBB          0x106
#define NT_PPC_PMU          0x107
#define NT_PPC_TM_CGPR      0x108
#define NT_PPC_TM_CFPR      0x109
#define NT_PPC_TM_CVMX      0x10a
#define NT_PPC_TM_CVSX      0x10b
#define NT_PPC_TM_SPR       0x10c
#define NT_PPC_TM_CTAR      0x10d
#define NT_PPC_TM_CPPR      0x10e
#define NT_PPC_TM_CDSCR     0x10f
#define NT_X86_XSTATE       0x202
#define NT_S390_HIGH_GPRS   0x300
#define NT_S390_TIMER       0x301
#define NT_S390_TODCMP      0x302
#define NT_S390_TODPREG     0x303
#define NT_S390_CTRS        0x304
#define NT_S390_PREFIX      0x305
#define NT_S390_LAST_BREAK  0x306
#define NT_S390_SYSTEM_CALL 0x307
#define NT_S390_TDB         0x308
#define NT_S390_VXRS_LOW    0x309
#define NT_S390_VXRS_HIGH   0x30a
#define NT_S390_GS_CB       0x30b
#define NT_S390_GS_BC       0x30c
#define NT_S390_RI_CB       0x30d
#define NT_ARM_VFP          0x400
#define NT_ARM_TLS          0x401
#define NT_ARM_HW_BREAK     0x402
#define NT_ARM_HW_WATCH     0x403
#define NT_ARM_SYSTEM_CALL  0x404
#define NT_ARM_SVE          0x405
#define NT_ARM_PAC_MASK     0x406
#define NT_METAG_CBUF       0x500
#define NT_METAG_RPIPE      0x501
#define NT_METAG_TLS        0x502
#define NT_ARC_V2           0x600
#define NT_VMCOREDD         0x700
#define NT_VERSION          1

#define VER_DEF_NONE      0
#define VER_DEF_CURRENT   1
#define VER_DEF_NUM       2
#define VER_FLG_BASE      0x1
#define VER_FLG_WEAK      0x2
#define VER_NDX_LOCAL     0
#define VER_NDX_GLOBAL    1
#define VER_NDX_LORESERVE 0xff00
#define VER_NDX_ELIMINATE 0xff01

#define LL_NONE           0
#define LL_EXACT_MATCH    (1 << 0)
#define LL_IGNORE_INT_VER (1 << 1)
#define LL_REQUIRE_MINOR  (1 << 2)
#define LL_EXPORTS        (1 << 3)
#define LL_DELAY_LOAD     (1 << 4)
#define LL_DELTA          (1 << 5)

#define R_BPF_NONE   0
#define R_BPF_MAP_FD 1



/*!BEGIN libc/elf/elf.h */

#define COSMOPOLITAN_LIBC_ELF_H_


/*!BEGIN libc/elf/struct/ehdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_EHDR_H_


/*!BEGIN libc/elf/scalar.h */

#define COSMOPOLITAN_LIBC_ELF_SCALAR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define Elf64_Addr    uint64_t
#define Elf64_Half    uint16_t
#define Elf64_Off     uint64_t
#define Elf64_Section uint16_t
#define Elf64_Sword   int32_t
#define Elf64_Sxword  int64_t
#define Elf64_Versym  Elf64_Half
#define Elf64_Word    uint32_t
#define Elf64_Xword   uint64_t
#define Elf_Symndx    uint32_t

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define EI_NIDENT 16

typedef struct Elf64_Ehdr {
  unsigned char e_ident[EI_NIDENT];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
} Elf64_Ehdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/phdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_PHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Phdr {
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
} Elf64_Phdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/shdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Section header.
 * @see https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-94076/index.html
 */
typedef struct Elf64_Shdr {
  Elf64_Word sh_name;
  Elf64_Word sh_type;   /* SHT_{PROGBITS,NOBITS,STRTAB,SYMTAB,RELA,...} */
  Elf64_Xword sh_flags; /* SHF_{WRITE,ALLOC,EXECINSTR,MERGE,STRINGS,...} */
  Elf64_Addr sh_addr;
  Elf64_Off sh_offset;
  Elf64_Xword sh_size;
  /*
   * If SHT_RELA: Index of section of associated symbol table.
   * If SHT_SYMTAB: Index of section of associated string table.
   */
  Elf64_Word sh_link;
  /*
   * If SHT_RELA: Index of section to which relocations apply.
   * If SHT_SYMTAB: One greater than symbol table index of last local symbol.
   */
  Elf64_Word sh_info;
  Elf64_Xword sh_addralign;
  Elf64_Xword sh_entsize;
} Elf64_Shdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/sym.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SYM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Sym {
  Elf64_Word st_name;
  /* ELF64_ST_TYPE(st_info) → STT_{NOTYPE,OBJECT,FUNC,SECTION,FILE,COMMON,...}
   * ELF64_ST_BIND(st_info) → STB_{LOCAL,GLOBAL,WEAK,...} */
  uint8_t st_info;
  /* STV_{DEFAULT,INTERNAL,HIDDEN,PROTECTED} */
  uint8_t st_other;
  /* SHN_UNDEF, <section index>, SHN_ABS, SHN_COMMON, etc. */
  Elf64_Section st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
} Elf64_Sym;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § executable & linkable format                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *GetElfStringTable(const Elf64_Ehdr *, size_t);
char *GetElfStrs(const Elf64_Ehdr *, size_t, size_t *);
Elf64_Sym *GetElfSymbolTable(const Elf64_Ehdr *, size_t, Elf64_Xword *);
bool IsElf64Binary(const Elf64_Ehdr *, size_t);
void CheckElfAddress(const Elf64_Ehdr *, size_t, intptr_t, size_t);
bool IsElfSymbolContent(const Elf64_Sym *);
Elf64_Phdr *GetElfSegmentHeaderAddress(const Elf64_Ehdr *, size_t, unsigned);
Elf64_Shdr *GetElfSectionHeaderAddress(const Elf64_Ehdr *, size_t, Elf64_Half);
void *GetElfSectionAddress(const Elf64_Ehdr *, size_t, const Elf64_Shdr *);
char *GetElfSectionNameStringTable(const Elf64_Ehdr *, size_t);
void GetElfVirtualAddressRange(const Elf64_Ehdr *, size_t, intptr_t *,
                               intptr_t *);
char *GetElfString(const Elf64_Ehdr *, size_t, const char *, Elf64_Word);
const char *GetElfSectionName(const Elf64_Ehdr *, size_t, Elf64_Shdr *);
Elf64_Sym *GetElfDynSymbolTable(const Elf64_Ehdr *, size_t, Elf64_Xword *);
char *GetElfDynStringTable(const Elf64_Ehdr *, size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/auxv.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_AUXV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_auxv_t {
  uint64_t a_type;
  union {
    uint64_t a_val;
  } a_un;
} Elf64_auxv_t;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/chdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_CHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Chdr {
  Elf64_Word ch_type;
  Elf64_Word ch_reserved;
  Elf64_Xword ch_size;
  Elf64_Xword ch_addralign;
} Elf64_Chdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/dyn.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_DYN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Dyn {
  Elf64_Sxword d_tag;
  union {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
} Elf64_Dyn;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/lib.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_LIB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Lib {
  Elf64_Word l_name;
  Elf64_Word l_time_stamp;
  Elf64_Word l_checksum;
  Elf64_Word l_version;
  Elf64_Word l_flags;
} Elf64_Lib;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/move.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_MOVE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Move {
  Elf64_Xword m_value;
  Elf64_Xword m_info;
  Elf64_Xword m_poffset;
  Elf64_Half m_repeat;
  Elf64_Half m_stride;
} Elf64_Move;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/nhdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_NHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Nhdr {
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
} Elf64_Nhdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/rel.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_REL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Rel {
  Elf64_Addr r_offset;
  Elf64_Xword r_info; /** @see ELF64_R_{SYM,SIZE,INFO} */
} Elf64_Rel;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/rela.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_RELA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Rela {
  /*u64*/ Elf64_Addr r_offset;
  /*
   * ELF64_R_SYM(r_info) → sym
   * ELF64_R_TYPE(r_info) → R_X86_64_{64,PC32,GOTPCRELX,...}
   * ELF64_R_INFO(sym, type) → r_info
   */
  /*u64*/ Elf64_Xword r_info; /* ELF64_R_{SYM,SIZE,INFO} */
  /*i64*/ Elf64_Sxword r_addend;
} Elf64_Rela;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/syminfo.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SYMINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Syminfo {
  Elf64_Half si_boundto;
  Elf64_Half si_flags;
} Elf64_Syminfo;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verdaux.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERDAUX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verdaux {
  Elf64_Word vda_name;
  Elf64_Word vda_next;
} Elf64_Verdaux;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verdef.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERDEF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verdef {
  Elf64_Half vd_version;
  Elf64_Half vd_flags;
  Elf64_Half vd_ndx;
  Elf64_Half vd_cnt;
  Elf64_Word vd_hash;
  Elf64_Word vd_aux;
  Elf64_Word vd_next;
} Elf64_Verdef;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/vernaux.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERNAUX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Vernaux {
  Elf64_Word vna_hash;
  Elf64_Half vna_flags;
  Elf64_Half vna_other;
  Elf64_Word vna_name;
  Elf64_Word vna_next;
} Elf64_Vernaux;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verneed.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERNEED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verneed {
  Elf64_Half vn_version;
  Elf64_Half vn_cnt;
  Elf64_Word vn_file;
  Elf64_Word vn_aux;
  Elf64_Word vn_next;
} Elf64_Verneed;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/conv.h */

#define COSMOPOLITAN_LIBC_FMT_CONV_H_


/*!BEGIN libc/nt/struct/filetime.h */

#define COSMOPOLITAN_LIBC_NT_FILETIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileTime {
  uint32_t dwLowDateTime;
  uint32_t dwHighDateTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion                                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define MODERNITYSECONDS 11644473600ull
#define HECTONANOSECONDS 10000000ull

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int abs(int) libcesque pureconst;
long labs(long) libcesque pureconst;
long long llabs(long long) libcesque pureconst;
intmax_t imaxabs(intmax_t) libcesque pureconst;
int atoi(const char *) paramsnonnull() libcesque;
long atol(const char *) paramsnonnull() libcesque;
long long atoll(const char *) paramsnonnull() libcesque;
unsigned long strtoul(const char *, char **, int) paramsnonnull((1));
long long strtoll(const char *, char **, int) paramsnonnull((1));
unsigned long long strtoull(const char *, char **, int) paramsnonnull((1));
long long strtonum(const char *, long long, long long, const char **);
intmax_t strtoimax(const char *, char **, int) paramsnonnull((1));
uintmax_t strtoumax(const char *, char **, int) paramsnonnull((1));
intmax_t wcstoimax(const wchar_t *, wchar_t **, int);
uintmax_t wcstoumax(const wchar_t *, wchar_t **, int);
long wcstol(const wchar_t *, wchar_t **, int);
unsigned long wcstoul(const wchar_t *, wchar_t **, int);
long strtol(const char *, char **, int) paramsnonnull((1)) libcesque;
long sizetol(const char *, long) paramsnonnull() libcesque;
long long wcstoll(const wchar_t *, wchar_t **, int);
unsigned long long wcstoull(const wchar_t *, wchar_t **, int);
int wcscoll(const wchar_t *, const wchar_t *);
size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » time                                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

struct timeval _timespec2timeval(struct timespec);
int64_t DosDateTimeToUnix(unsigned, unsigned) libcesque nosideeffect;
struct timeval WindowsTimeToTimeVal(int64_t) libcesque nosideeffect;
struct timespec WindowsTimeToTimeSpec(int64_t) libcesque nosideeffect;
int64_t TimeSpecToWindowsTime(struct timespec) libcesque nosideeffect;
int64_t TimeValToWindowsTime(struct timeval) libcesque nosideeffect;
struct timeval WindowsDurationToTimeVal(int64_t) libcesque nosideeffect;
struct timespec WindowsDurationToTimeSpec(int64_t) libcesque nosideeffect;

#define MakeFileTime(x)                                        \
  ({                                                           \
    int64_t __x = x;                                           \
    (struct NtFileTime){(uint32_t)__x, (uint32_t)(__x >> 32)}; \
  })

#define ReadFileTime(t)                     \
  ({                                        \
    struct NtFileTime __t = t;              \
    uint64_t x = __t.dwHighDateTime;        \
    (int64_t)(x << 32 | __t.dwLowDateTime); \
  })

#define FileTimeToTimeSpec(x) WindowsTimeToTimeSpec(ReadFileTime(x))
#define FileTimeToTimeVal(x)  WindowsTimeToTimeVal(ReadFileTime(x))
#define TimeSpecToFileTime(x) MakeFileTime(TimeSpecToWindowsTime(x))
#define TimeValToFileTime(x)  MakeFileTime(TimeValToWindowsTime(x))

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » manipulation                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *dirname(char *);
char *basename(char *);
char *stripext(char *);
char *stripexts(char *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » computation                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

typedef struct {
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;

div_t div(int, int) pureconst;
ldiv_t ldiv(long, long) pureconst;
lldiv_t lldiv(long long, long long) pureconst;
imaxdiv_t imaxdiv(intmax_t, intmax_t) pureconst;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » optimizations                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __STDC_VERSION__ + 0 >= 199901L
#define div(num, den)   ((div_t){(num) / (den), (num) % (den)})
#define ldiv(num, den)  ((ldiv_t){(num) / (den), (num) % (den)})
#define lldiv(num, den) ((lldiv_t){(num) / (den), (num) % (den)})
#endif

#if __GNUC__ * 100 + __GNUC_MINOR__ >= 406 || defined(__llvm__)
int128_t i128abs(int128_t) libcesque pureconst;
int128_t strtoi128(const char *, char **, int) paramsnonnull((1));
uint128_t strtou128(const char *, char **, int) paramsnonnull((1));
int128_t wcstoi128(const wchar_t *, wchar_t **, int);
uint128_t wcstou128(const wchar_t *, wchar_t **, int);
#endif /* gcc 4.6+ */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/fmt.h */

#define COSMOPOLITAN_LIBC_FMT_FMT_H_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § string formatting                                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __SIZEOF_POINTER__ == 8
#define POINTER_XDIGITS 12 /* math.log(2**48-1,16) */
#else
#define POINTER_XDIGITS 8
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int snprintf(char *, size_t, const char *, ...) printfesque(3)
    paramsnonnull((3)) dontthrow nocallback;
int vsnprintf(char *, size_t, const char *, va_list)
    paramsnonnull((3)) dontthrow nocallback;
int sprintf(char *, const char *, ...) printfesque(2)
    paramsnonnull((2)) dontthrow nocallback frownedupon(snprintf);
int vsprintf(char *, const char *, va_list)
    paramsnonnull((2)) dontthrow nocallback frownedupon(vsnprintf);
int sscanf(const char *, const char *, ...) scanfesque(2);
int vsscanf(const char *, const char *, va_list);
int vcscanf(int (*)(void *), int (*)(int, void *), void *, const char *,
            va_list);
int __fmt(void *, void *, const char *, va_list) hidden;
char *itoa(int, char *, int) compatfn;
char *fcvt(double, int, int *, int *);
char *ecvt(double, int, int *, int *);
char *gcvt(double, int, char *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § string formatting » optimizations                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(__cplusplus)
#define sprintf(BUF, FMT, ...)        (sprintf)(BUF, PFLINK(FMT), ##__VA_ARGS__)
#define vsprintf(BUF, FMT, VA)        (vsprintf)(BUF, PFLINK(FMT), VA)
#define snprintf(B, Z, F, ...)        (snprintf)(B, Z, PFLINK(F), ##__VA_ARGS__)
#define vsnprintf(BUF, SIZE, FMT, VA) (vsnprintf)(BUF, SIZE, PFLINK(FMT), VA)
#define sscanf(STR, FMT, ...)         (sscanf)(STR, SFLINK(FMT), ##__VA_ARGS__)
#define vsscanf(STR, FMT, VA)         (vsscanf)(STR, SFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/itoa.h */

#define COSMOPOLITAN_LIBC_FMT_ITOA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned LengthInt64(int64_t) pureconst;
unsigned LengthUint64(uint64_t) pureconst;
unsigned LengthInt64Thousands(int64_t) pureconst;
unsigned LengthUint64Thousands(uint64_t) pureconst;
char *FormatInt32(char[hasatleast 12], int32_t);
char *FormatUint32(char[hasatleast 12], uint32_t);
char *FormatInt64(char[hasatleast 21], int64_t);
char *FormatUint64(char[hasatleast 21], uint64_t);
char *FormatInt64Thousands(char[hasatleast 27], int64_t);
char *FormatUint64Thousands(char[hasatleast 27], uint64_t);
char *FormatOctal32(char[hasatleast 13], uint32_t, bool);
char *FormatOctal64(char[hasatleast 24], uint64_t, bool);
char *FormatBinary64(char[hasatleast 67], uint64_t, char);
char *FormatHex64(char[hasatleast 19], uint64_t, char);
char *FormatFlex64(char[hasatleast 24], int64_t, char);
size_t uint64toarray_radix16(uint64_t, char[hasatleast 17]);
size_t uint64toarray_fixed16(uint64_t, char[hasatleast 17], uint8_t);
size_t uint64toarray_radix8(uint64_t, char[hasatleast 24]);
char *FormatMemorySize(char *, uint64_t);

#ifndef __STRICT_ANSI__
size_t int128toarray_radix10(int128_t, char *);
size_t uint128toarray_radix10(uint128_t, char *);
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/leb128.h */

#define COSMOPOLITAN_LIBC_FMT_LEB128_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

char *sleb64(char *, int64_t);
char *zleb64(char[hasatleast 10], int64_t);
char *uleb64(char[hasatleast 10], uint64_t);
int unzleb64(const char *, size_t, int64_t *);
int unuleb64(char *, size_t, uint64_t *);

#ifndef __STRICT_ANSI__
char *sleb128(char *, int128_t);
char *zleb128(char *, int128_t);
char *uleb128(char *, uint128_t);
int unsleb128(const void *, size_t, int128_t *);
#endif /* __STRICT_ANSI__ */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/nf32.h */

#define COSMOPOLITAN_LIBC_FMT_NF32_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const char kNfcimal[256];

uint32_t DecodeNf32(const char *, char **);
char *EncodeNf32(char[hasatleast 12], uint32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/asancodes.h */

#define COSMOPOLITAN_LIBC_INTRIN_ASANCODES_H_

#define kAsanScale          3
#define kAsanMagic          0x7fff8000
#define kAsanNullPage       -1  /* ∅ 0xff */
#define kAsanProtected      -2  /* P 0xfe */
#define kAsanHeapFree       -3  /* F 0xfd */
#define kAsanHeapRelocated  -4  /* R 0xfc */
#define kAsanAllocaOverrun  -5  /* 𝑂 0xfb */
#define kAsanHeapUnderrun   -6  /* U 0xfa */
#define kAsanHeapOverrun    -7  /* O 0xf9 */
#define kAsanStackUnscoped  -8  /* s 0xf8 */
#define kAsanStackOverflow  -9  /* ! 0xf7 */
#define kAsanGlobalOrder    -10 /* I 0xf6 */
#define kAsanStackFree      -11 /* r 0xf5 */
#define kAsanStackPartial   -12 /* p 0xf4 */
#define kAsanStackOverrun   -13 /* o 0xf3 */
#define kAsanStackMiddle    -14 /* m 0xf2 */
#define kAsanStackUnderrun  -15 /* u 0xf1 */
#define kAsanAllocaUnderrun -16 /* 𝑈 0xf0 */
#define kAsanUnmapped       -17 /* M 0xef */
#define kAsanGlobalRedzone  -18 /* G 0xee */
#define kAsanGlobalGone     -19 /* 𝐺 0xed */
#define kAsanGlobalUnderrun -20 /* μ 0xec */
#define kAsanGlobalOverrun  -21 /* Ω 0xeb */



/*!BEGIN libc/intrin/asmflag.h */

#define COSMOPOLITAN_LIBC_BITS_ASMFLAG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/*
 * Constraints for virtual machine flags.
 * @note we beseech clang devs for flag constraints
 */
#ifdef __GCC_ASM_FLAG_OUTPUTS__ /* GCC6+ CLANG10+ */
#define CFLAG_CONSTRAINT  "=@ccc"
#define CFLAG_ASM(OP)     OP
#define ZFLAG_CONSTRAINT  "=@ccz"
#define ZFLAG_ASM(OP)     OP
#define OFLAG_CONSTRAINT  "=@cco"
#define OFLAG_ASM(OP)     OP
#define SFLAG_CONSTRAINT  "=@ccs"
#define SFLAG_ASM(SP)     SP
#define ABOVE_CONSTRAINT  "=@cca" /* i.e. !ZF && !CF */
#define ABOVEFLAG_ASM(OP) OP
#else
#define CFLAG_CONSTRAINT  "=q"
#define CFLAG_ASM(OP)     OP "\n\tsetc\t%b0"
#define ZFLAG_CONSTRAINT  "=q"
#define ZFLAG_ASM(OP)     OP "\n\tsetz\t%b0"
#define OFLAG_CONSTRAINT  "=q"
#define OFLAG_ASM(OP)     OP "\n\tseto\t%b0"
#define SFLAG_CONSTRAINT  "=q"
#define SFLAG_ASM(SP)     OP "\n\tsets\t%b0"
#define ABOVE_CONSTRAINT  "=@cca"
#define ABOVEFLAG_ASM(OP) OP "\n\tseta\t%b0"
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/atomic.h */

#define COSMOPOLITAN_LIBC_BITS_ATOMIC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview Cosmopolitan C11 Atomics Library
 *
 *   - Forty-two different ways to say MOV.
 *   - Fourteen different ways to say XCHG.
 *   - Twenty different ways to say LOCK CMPXCHG.
 *
 * It's a lower level programming language than assembly!
 *
 * @see libc/atomic.h
 */

#define memory_order         int
#define memory_order_relaxed 0
#define memory_order_consume 1
#define memory_order_acquire 2
#define memory_order_release 3
#define memory_order_acq_rel 4
#define memory_order_seq_cst 5

#define ATOMIC_VAR_INIT(value)   (value)
#define atomic_is_lock_free(obj) ((void)(obj), sizeof(obj) <= sizeof(void *))

#define atomic_flag      atomic_bool
#define ATOMIC_FLAG_INIT ATOMIC_VAR_INIT(0)
#define atomic_flag_test_and_set_explicit(x, order) \
  atomic_exchange_explicit(x, 1, order)
#define atomic_flag_clear_explicit(x, order) atomic_store_explicit(x, 0, order)

#define atomic_compare_exchange_strong(pObject, pExpected, desired) \
  atomic_compare_exchange_strong_explicit(                          \
      pObject, pExpected, desired, memory_order_seq_cst, memory_order_seq_cst)
#define atomic_compare_exchange_weak(pObject, pExpected, desired) \
  atomic_compare_exchange_weak_explicit(                          \
      pObject, pExpected, desired, memory_order_seq_cst, memory_order_seq_cst)
#define atomic_exchange(pObject, desired) \
  atomic_exchange_explicit(pObject, desired, memory_order_seq_cst)
#define atomic_fetch_add(pObject, operand) \
  atomic_fetch_add_explicit(pObject, operand, memory_order_seq_cst)
#define atomic_fetch_and(pObject, operand) \
  atomic_fetch_and_explicit(pObject, operand, memory_order_seq_cst)
#define atomic_fetch_or(pObject, operand) \
  atomic_fetch_or_explicit(pObject, operand, memory_order_seq_cst)
#define atomic_fetch_sub(pObject, operand) \
  atomic_fetch_sub_explicit(pObject, operand, memory_order_seq_cst)
#define atomic_fetch_xor(pObject, operand) \
  atomic_fetch_xor_explicit(pObject, operand, memory_order_seq_cst)
#define atomic_load(pObject) atomic_load_explicit(pObject, memory_order_seq_cst)
#define atomic_store(pObject, desired) \
  atomic_store_explicit(pObject, desired, memory_order_seq_cst)
#define atomic_flag_test_and_set(x) \
  atomic_flag_test_and_set_explicit(x, memory_order_seq_cst)
#define atomic_flag_clear(x) atomic_flag_clear_explicit(x, memory_order_seq_cst)

#if defined(__CLANG_ATOMIC_BOOL_LOCK_FREE)

#define atomic_init(obj, value)    __c11_atomic_init(obj, value)
#define atomic_thread_fence(order) __c11_atomic_thread_fence(order)
#define atomic_signal_fence(order) __c11_atomic_signal_fence(order)
#define atomic_compare_exchange_strong_explicit(object, expected, desired, \
                                                success, failure)          \
  __c11_atomic_compare_exchange_strong(object, expected, desired, success, \
                                       failure)
#define atomic_compare_exchange_weak_explicit(object, expected, desired, \
                                              success, failure)          \
  __c11_atomic_compare_exchange_weak(object, expected, desired, success, \
                                     failure)
#define atomic_exchange_explicit(object, desired, order) \
  __c11_atomic_exchange(object, desired, order)
#define atomic_fetch_add_explicit(object, operand, order) \
  __c11_atomic_fetch_add(object, operand, order)
#define atomic_fetch_and_explicit(object, operand, order) \
  __c11_atomic_fetch_and(object, operand, order)
#define atomic_fetch_or_explicit(object, operand, order) \
  __c11_atomic_fetch_or(object, operand, order)
#define atomic_fetch_sub_explicit(object, operand, order) \
  __c11_atomic_fetch_sub(object, operand, order)
#define atomic_fetch_xor_explicit(object, operand, order) \
  __c11_atomic_fetch_xor(object, operand, order)
#define atomic_load_explicit(object, order) __c11_atomic_load(object, order)
#define atomic_store_explicit(object, desired, order) \
  __c11_atomic_store(object, desired, order)

#elif (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407

#define atomic_init(obj, value)    ((void)(*(obj) = (value)))
#define atomic_thread_fence(order) __atomic_thread_fence(order)
#define atomic_signal_fence(order) __atomic_signal_fence(order)
#define atomic_compare_exchange_strong_explicit(pObject, pExpected, desired, \
                                                success, failure)            \
  __atomic_compare_exchange_n(pObject, pExpected, desired, 0, success, failure)
#define atomic_compare_exchange_weak_explicit(pObject, pExpected, desired, \
                                              success, failure)            \
  __atomic_compare_exchange_n(pObject, pExpected, desired, 1, success, failure)
#define atomic_exchange_explicit(pObject, desired, order) \
  __atomic_exchange_n(pObject, desired, order)
#define atomic_fetch_add_explicit(pObject, operand, order) \
  __atomic_fetch_add(pObject, operand, order)
#define atomic_fetch_and_explicit(pObject, operand, order) \
  __atomic_fetch_and(pObject, operand, order)
#define atomic_fetch_or_explicit(pObject, operand, order) \
  __atomic_fetch_or(pObject, operand, order)
#define atomic_fetch_sub_explicit(pObject, operand, order) \
  __atomic_fetch_sub(pObject, operand, order)
#define atomic_fetch_xor_explicit(pObject, operand, order) \
  __atomic_fetch_xor(pObject, operand, order)
#define atomic_load_explicit(pObject, order) __atomic_load_n(pObject, order)
#define atomic_store_explicit(pObject, desired, order) \
  __atomic_store_n(pObject, desired, order)

#else

#define atomic_init(obj, value)    ((void)(*(obj) = (value)))
#define atomic_thread_fence(order) __sync_synchronize()
#define atomic_signal_fence(order) __asm__ volatile("" ::: "memory")
#define __atomic_apply_stride(object, operand) \
  (((__typeof__(__atomic_val(object)))0) + (operand))
#define atomic_compare_exchange_strong_explicit(object, expected, desired, \
                                                success, failure)          \
  __extension__({                                                          \
    __typeof__(expected) __ep = (expected);                                \
    __typeof__(*__ep) __e = *__ep;                                         \
    (void)(success);                                                       \
    (void)(failure);                                                       \
    (_Bool)((*__ep = __sync_val_compare_and_swap(object, __e, desired)) == \
            __e);                                                          \
  })
#define atomic_compare_exchange_weak_explicit(object, expected, desired,      \
                                              success, failure)               \
  atomic_compare_exchange_strong_explicit(object, expected, desired, success, \
                                          failure)
#if __has_builtin(__sync_swap)
#define atomic_exchange_explicit(object, desired, order) \
  ((void)(order), __sync_swap(object, desired))
#else
#define atomic_exchange_explicit(object, desired, order) \
  __extension__({                                        \
    __typeof__(object) __o = (object);                   \
    __typeof__(desired) __d = (desired);                 \
    (void)(order);                                       \
    __sync_synchronize();                                \
    __sync_lock_test_and_set(&__atomic_val(__o), __d);   \
  })
#endif
#define atomic_fetch_add_explicit(object, operand, order) \
  ((void)(order),                                         \
   __sync_fetch_and_add(object, __atomic_apply_stride(object, operand)))
#define atomic_fetch_and_explicit(object, operand, order) \
  ((void)(order), __sync_fetch_and_and(object, operand))
#define atomic_fetch_or_explicit(object, operand, order) \
  ((void)(order), __sync_fetch_and_or(object, operand))
#define atomic_fetch_sub_explicit(object, operand, order) \
  ((void)(order),                                         \
   __sync_fetch_and_sub(object, __atomic_apply_stride(object, operand)))
#define atomic_fetch_xor_explicit(object, operand, order) \
  ((void)(order), __sync_fetch_and_xor(object, operand))
#define atomic_load_explicit(object, order) \
  ((void)(order), __sync_fetch_and_add(object, 0))
#define atomic_store_explicit(object, desired, order) \
  ((void)atomic_exchange_explicit(object, desired, order))

#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/bitop.h */

#define COSMOPOLITAN_LIBC_BITS_BITOP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define bts(MEM, BIT)     __BitOp("bts", BIT, MEM) /** bit test and set */
#define btr(MEM, BIT)     __BitOp("btr", BIT, MEM) /** bit test and reset */
#define btc(MEM, BIT)     __BitOp("btc", BIT, MEM) /** bit test and complement */
#define lockbts(MEM, BIT) __BitOp("lock bts", BIT, MEM)
#define lockbtr(MEM, BIT) __BitOp("lock btr", BIT, MEM)
#define lockbtc(MEM, BIT) __BitOp("lock btc", BIT, MEM)

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define __BitOp(OP, BIT, MEM)                                  \
  ({                                                           \
    bool OldBit;                                               \
    if (__builtin_constant_p(BIT)) {                           \
      asm(CFLAG_ASM(OP "%z1\t%2,%1")                           \
          : CFLAG_CONSTRAINT(OldBit),                          \
            "+m"((MEM)[(BIT) / (sizeof((MEM)[0]) * CHAR_BIT)]) \
          : "J"((BIT) % (sizeof((MEM)[0]) * CHAR_BIT))         \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 2) {                        \
      asm(CFLAG_ASM(OP "\t%w2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 4) {                        \
      asm(CFLAG_ASM(OP "\t%k2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 8) {                        \
      asm(CFLAG_ASM(OP "\t%q2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    }                                                          \
    OldBit;                                                    \
  })
#endif /* __GNUC__ && !__STRICT_ANSI__ */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/cmpxchg.h */

#define COSMOPOLITAN_LIBC_INTRIN_CMPXCHG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool _cmpxchg(void *, intptr_t, intptr_t, size_t);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
#define _cmpxchg(IFTHING, ISEQUALTOME, REPLACEITWITHME)                       \
  ({                                                                          \
    bool DidIt;                                                               \
    autotype(IFTHING) IfThing = (IFTHING);                                    \
    typeof(*IfThing) IsEqualToMe = (ISEQUALTOME);                             \
    typeof(*IfThing) ReplaceItWithMe = (REPLACEITWITHME);                     \
    asm volatile(ZFLAG_ASM("cmpxchg\t%3,%1")                                  \
                 : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(IsEqualToMe) \
                 : "r"(ReplaceItWithMe)                                       \
                 : "cc");                                                     \
    DidIt;                                                                    \
  })
#else
#define _cmpxchg(MEM, CMP, VAL) \
  _cmpxchg(MEM, (intptr_t)(CMP), (intptr_t)(VAL), sizeof(*(MEM)))
#endif /* GNUC && !ANSI && x86 */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/ezlea.h */

#define COSMOPOLITAN_LIBC_BITS_EZLEA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if __pic__ + __pie__ + __code_model_medium__ + __code_model_large__ + 0 > 1
#define ezlea(symbol) "lea\t" symbol "(%%rip),%"
#else
#define ezlea(symbol) "mov\t$" symbol ",%k"
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/hilbert.h */

#define COSMOPOLITAN_LIBC_BITS_HILBERT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

long hilbert(long, long, long) pureconst;
axdx_t unhilbert(long, long) pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/kprintf.h */

#define COSMOPOLITAN_LIBC_INTRIN_KPRINTF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void kprintf(const char *, ...);
size_t ksnprintf(char *, size_t, const char *, ...);
void kvprintf(const char *, va_list);
size_t kvsnprintf(char *, size_t, const char *, va_list);
bool kisdangerous(const void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/likely.h */

#define COSMOPOLITAN_LIBC_BITS_LIKELY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)

#if __GNUC__ + 0 >= 9 && !defined(__chibicc__)
#define VERY_LIKELY(x) __builtin_expect_with_probability(!!(x), 1, 0.999)
#else
#define VERY_LIKELY(x) LIKELY(x)
#endif

#if __GNUC__ + 0 >= 9 && !defined(__chibicc__)
#define VERY_UNLIKELY(x) __builtin_expect_with_probability(!!(x), 0, 0.999)
#else
#define VERY_UNLIKELY(x) UNLIKELY(x)
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/lockcmpxchg.h */

#define COSMOPOLITAN_LIBC_INTRIN_LOCKCMPXCHG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool _lockcmpxchg(void *, intptr_t, intptr_t, size_t);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
#define _lockcmpxchg(IFTHING, ISEQUALTOME, REPLACEITWITHME)                   \
  ({                                                                          \
    bool DidIt;                                                               \
    autotype(IFTHING) IfThing = (IFTHING);                                    \
    typeof(*IfThing) IsEqualToMe = (ISEQUALTOME);                             \
    typeof(*IfThing) ReplaceItWithMe = (REPLACEITWITHME);                     \
    asm volatile(ZFLAG_ASM("lock cmpxchg\t%3,%1")                             \
                 : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(IsEqualToMe) \
                 : "r"(ReplaceItWithMe)                                       \
                 : "cc");                                                     \
    DidIt;                                                                    \
  })
#else
#define _lockcmpxchg(MEM, CMP, VAL) \
  _lockcmpxchg(MEM, (intptr_t)(CMP), (intptr_t)(VAL), sizeof(*(MEM)))
#endif /* GNUC && !ANSI && x86 */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/lockcmpxchg16b.h */

#define COSMOPOLITAN_LIBC_BITS_LOCKCMPXCHG16B_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
/**
 * Compares and exchanges 128-bit value, i.e.
 *
 *     if (*IfThing == *IsEqualToMe) {
 *       *IfThing = ReplaceItWithMe;
 *       return true;
 *     } else {
 *       *IsEqualToMe = *IfThing;
 *       return false;
 *     }
 *
 * @param IfThing should point to aligned memory
 * @param IsEqualToMe should point to in/out local variable
 * @param ReplaceItWithMe might become the new memory value
 * @return true if *IfThing was changed
 * @asyncsignalsafe
 * @threadsafe
 */
static inline bool _lockcmpxchg16b(uint128_t *IfThing, uint128_t *IsEqualToMe,
                                   uint128_t ReplaceItWithMe) {
  bool DidIt;
  uint64_t ax, bx, cx, dx;
  ax = *IsEqualToMe;
  dx = *IsEqualToMe >> 64;
  bx = ReplaceItWithMe;
  cx = ReplaceItWithMe >> 64;
  asm volatile(ZFLAG_ASM("lock cmpxchg16b\t%1")
               : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(ax), "+d"(dx)
               : "b"(bx), "c"(cx));
  if (!DidIt) {
    *IsEqualToMe = ax | (uint128_t)dx << 64;
  }
  return DidIt;
}
#endif /* __GNUC__ && !__STRICT_ANSI__ */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/lockcmpxchgp.h */

#define COSMOPOLITAN_LIBC_INTRIN_LOCKCMPXCHGP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
#define _lockcmpxchgp(IN_OUT_IFTHING, IN_OUT_ISEQUALTOME, IN_REPLACEITWITHME)  \
  ({                                                                           \
    bool DidIt;                                                                \
    autotype(IN_OUT_IFTHING) IfThing = (IN_OUT_IFTHING);                       \
    typeof(IfThing) IsEqualToMe = (IN_OUT_ISEQUALTOME);                        \
    typeof(*IfThing) ReplaceItWithMe = (IN_REPLACEITWITHME);                   \
    asm volatile(ZFLAG_ASM("lock cmpxchg\t%3,%1")                              \
                 : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(*IsEqualToMe) \
                 : "r"(ReplaceItWithMe)                                        \
                 : "cc");                                                      \
    DidIt;                                                                     \
  })
#endif /* GNUC && !ANSI && x86 */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/lockxadd.h */

#define COSMOPOLITAN_LIBC_BITS_LOCKXADD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

intptr_t _lockxadd(void *, intptr_t, size_t);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
#define _lockxadd(PTR, VAL)                                                \
  ({                                                                       \
    typeof(*(PTR)) Res;                                                    \
    typeof(Res) Val = (VAL);                                               \
    asm volatile("lock xadd\t%0,%1" : "=r"(Res), "+m"(*(PTR)) : "0"(Val)); \
    Res; /* contains *PTR before addition cf. InterlockedAdd() */          \
  })
#else
#define _lockxadd(MEM, VAL) _lockxadd(MEM, (intptr_t)(VAL), sizeof(*(MEM)))
#endif /* GNUC && !ANSI && x86 */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/lockxchg.h */

#define COSMOPOLITAN_LIBC_INTRIN_LOCKXCHG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

intptr_t lockxchg(void *, void *, size_t);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
/**
 * Exchanges *MEMORY into *LOCALVAR w/ one operation.
 *
 * @param MEMORY is uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @param LOCALVAR is uint𝑘_t[hasatleast 1]
 * @return LOCALVAR[0]
 * @see xchg()
 */
#define lockxchg(MEMORY, LOCALVAR)                            \
  ({                                                          \
    asm("xchg\t%0,%1" : "+%m"(*(MEMORY)), "+r"(*(LOCALVAR))); \
    *(LOCALVAR);                                              \
  })
#else
#define lockxchg(MEM, VAR) \
  lockxchg(MEM, VAR, sizeof(*(MEM)) / (sizeof(*(MEM)) == sizeof(*(VAR))))
#endif /* __GNUC__ && !__STRICT_ANSI__ */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/macros.h */

#define COSMOPOLITAN_LIBC_INTRIN_MACROS_H_


/*!BEGIN libc/nexgen32e/x86feature.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86FEATURE_H_


/*!BEGIN libc/nexgen32e/kcpuids.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_KCPUIDS_H_

#define KCPUIDS_0H        0
#define KCPUIDS_1H        1
#define KCPUIDS_2H        2
#define KCPUIDS_7H        3
#define KCPUIDS_80000001H 4
#define KCPUIDS_80000007H 5
#define KCPUIDS_16H       6
#define KCPUIDS_LEN       7
#define KCPUIDS_6H        -1 /* TBD: Thermal and Power Management */
#define KCPUIDS_DH        -1 /* TBD: Extended state features */
#define KCPUIDS_80000008H -1 /* TBD: AMD Miscellaneous */
#define KCPUIDS_8000000AH -1 /* TBD: AMD SVM */

#define KCPUIDS_EAX 0
#define KCPUIDS_EBX 1
#define KCPUIDS_ECX 2
#define KCPUIDS_EDX 3

#define KCPUIDS(LEAF, REG) _KCPUIDS(LEAF, REG)
#ifdef __ASSEMBLER__
#define _KCPUIDS(LEAF, REG) KCPUIDS_##LEAF * 16 + KCPUIDS_##REG * 4
#else
#define _KCPUIDS(LEAF, REG) kCpuids[KCPUIDS_##LEAF][KCPUIDS_##REG]
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned kCpuids[KCPUIDS_LEN][4];

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/x86compiler.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86COMPILER_H_

/**
 * @fileoverview x86 cpu feature compile-time requirement detection.
 * @see -march=native, -mavx2, etc.
 */

#ifdef __AES__
#define _X86_CC_AES 1
#else
#define _X86_CC_AES 0
#endif

#ifdef __AVX__
#define _X86_CC_AVX 1
#else
#define _X86_CC_AVX 0
#endif

#ifdef __AVX2__
#define _X86_CC_AVX2 1
#else
#define _X86_CC_AVX2 0
#endif

#ifdef __ABM__
#define _X86_CC_ABM 1
#else
#define _X86_CC_ABM 0
#endif

#ifdef __BMI__
#define _X86_CC_BMI 1
#else
#define _X86_CC_BMI 0
#endif

#ifdef __BMI2__
#define _X86_CC_BMI2 1
#else
#define _X86_CC_BMI2 0
#endif

#ifdef __FMA__
#define _X86_CC_FMA 1
#else
#define _X86_CC_FMA 0
#endif

#ifdef __ADX__
#define _X86_CC_ADX 1
#else
#define _X86_CC_ADX 0
#endif

#ifdef __PCLMUL__
#define _X86_CC_PCLMUL 1
#else
#define _X86_CC_PCLMUL 0
#endif

#ifdef __POPCNT__
#define _X86_CC_POPCNT 1
#else
#define _X86_CC_POPCNT 0
#endif

#ifdef __RDRND__
#define _X86_CC_RDRND 1
#else
#define _X86_CC_RDRND 0
#endif

#ifdef __RDSEED__
#define _X86_CC_RDSEED 1
#else
#define _X86_CC_RDSEED 0
#endif

#ifdef __SHA__
#define _X86_CC_SHA 1
#else
#define _X86_CC_SHA 0
#endif

#ifdef __SSSE3__
#define _X86_CC_SSSE3 1
#else
#define _X86_CC_SSSE3 0
#endif

#ifdef __SSE__
#define _X86_CC_SSE 1
#else
#define _X86_CC_SSE 0
#endif

#ifdef __SSE2__
#define _X86_CC_SSE2 1
#else
#define _X86_CC_SSE2 0
#endif

#ifdef __SSE3__
#define _X86_CC_SSE3 1
#else
#define _X86_CC_SSE3 0
#endif

#ifdef __SSE4_1__
#define _X86_CC_SSE4_1 1
#else
#define _X86_CC_SSE4_1 0
#endif

#ifdef __SSE4_2__
#define _X86_CC_SSE4_2 1
#else
#define _X86_CC_SSE4_2 0
#endif

#ifdef __XSAVE__
#define _X86_CC_XSAVE 1
#else
#define _X86_CC_XSAVE 0
#endif

#ifdef __CLFLUSHOPT__
#define _X86_CC_CLFLUSHOPT 1
#else
#define _X86_CC_CLFLUSHOPT 0
#endif

#ifdef __RDPID__
#define _X86_CC_RDPID 1
#else
#define _X86_CC_RDPID 0
#endif


/**
 * @fileoverview x86 cpu feature detection.
 */

#define X86_HAVE(FEATURE) _X86_HAVE(X86_##FEATURE)

/* clang-format off */
/*      --- FEATURE              LEAF       REG BIT  COMPILE-TIME-DEFINE  HOOK */
#define X86_ACC                  1H,        EDX, 29, 0,                   _
#define X86_ACPI                 1H,        EDX, 22, 0,                   _
#define X86_ADX                  7H,        EBX, 19, _X86_CC_ADX,         _     /* broadwell c. 2014 */
#define X86_AES                  1H,        ECX, 25, _X86_CC_AES,         _     /* westmere c. 2010 */
#define X86_APIC                 1H,        EDX,  9, 0,                   _
#define X86_ARCH_CAPABILITIES    7H,        EDX, 29, 0,                   _
#define X86_AVX                  1H,        ECX, 28, _X86_CC_AVX,         _     /* sandybridge c. 2012 */
#define X86_AVX2                 7H,        EBX,  5, _X86_CC_AVX2,        _     /* haswell c. 2013 */
#define X86_AVX512BW             7H,        EBX, 30, 0,                   _
#define X86_AVX512CD             7H,        EBX, 28, 0,                   _
#define X86_AVX512DQ             7H,        EBX, 17, 0,                   _
#define X86_AVX512ER             7H,        EBX, 27, 0,                   _
#define X86_AVX512F              7H,        EBX, 16, 0,                   _
#define X86_AVX512IFMA           7H,        EBX, 21, 0,                   _
#define X86_AVX512PF             7H,        EBX, 26, 0,                   _
#define X86_AVX512VBMI           7H,        ECX,  1, 0,                   _
#define X86_AVX512VL             7H,        EBX, 31, 0,                   _
#define X86_AVX512_4FMAPS        7H,        EDX,  3, 0,                   _
#define X86_AVX512_4VNNIW        7H,        EDX,  2, 0,                   _
#define X86_AVX512_BF16          7H,        EAX,  5, 0,                   _
#define X86_AVX512_BITALG        7H,        ECX, 12, 0,                   _
#define X86_AVX512_VBMI2         7H,        ECX,  6, 0,                   _
#define X86_AVX512_VNNI          7H,        ECX, 11, 0,                   _
#define X86_AVX512_VP2INTERSECT  7H,        EDX,  8, 0,                   _
#define X86_AVX512_VPOPCNTDQ     7H,        ECX, 14, 0,                   _
#define X86_BMI                  7H,        EBX,  3, _X86_CC_BMI,         _     /* haswell c. 2013 */
#define X86_BMI2                 7H,        EBX,  8, _X86_CC_BMI2,        _     /* haswell c. 2013 */
#define X86_CID                  1H,        ECX, 10, 0,                   _
#define X86_CLDEMOTE             7H,        ECX, 25, 0,                   _
#define X86_CLFLUSH              1H,        EDX, 19, _X86_CC_SSE2,        _
#define X86_CLFLUSHOPT           7H,        EBX, 23, _X86_CC_CLFLUSHOPT,  _     /* skylake/zen  */
#define X86_CLWB                 7H,        EBX, 24, 0,                   _     /* skylake/zen2 */
#define X86_CMOV                 1H,        EDX, 15, 0,                   _
#define X86_CQM                  7H,        EBX, 12, 0,                   _
#define X86_CX16                 1H,        ECX, 13, 0,                   _
#define X86_CX8                  1H,        EDX,  8, 0,                   _
#define X86_DCA                  1H,        ECX, 18, 0,                   _
#define X86_DE                   1H,        EDX,  2, 0,                   _
#define X86_DS                   1H,        EDX, 21, 0,                   _
#define X86_DSCPL                1H,        ECX,  4, 0,                   _
#define X86_DTES64               1H,        ECX,  2, 0,                   _
#define X86_ERMS                 7H,        EBX,  9, 0,                   _     /* broaadwell c. 2014 */
#define X86_EST                  1H,        ECX,  7, 0,                   _
#define X86_F16C                 1H,        ECX, 29, 0,                   _
#define X86_FDP_EXCPTN_ONLY      7H,        EBX,  6, 0,                   _
#define X86_FLUSH_L1D            7H,        EDX, 28, 0,                   _
#define X86_FMA                  1H,        ECX, 12, _X86_CC_FMA,         _     /* haswell c. 2013 */
#define X86_FPU                  1H,        EDX,  0, 0,                   _
#define X86_FSGSBASE             7H,        EBX,  0, 0,                   _
#define X86_FXSR                 1H,        EDX, 24, 0,                   _
#define X86_GBPAGES              80000001H, EDX, 26, 0,                   _
#define X86_GFNI                 7H,        ECX,  8, 0,                   _
#define X86_HLE                  7H,        EBX,  4, 0,                   _
#define X86_HT                   1H,        EDX, 28, 0,                   _
#define X86_HYPERVISOR           1H,        ECX, 31, 0,                   _
#define X86_IA64                 1H,        EDX, 30, 0,                   _
#define X86_INTEL_PT             7H,        EBX, 25, 0,                   _
#define X86_INTEL_STIBP          7H,        EDX, 27, 0,                   _
#define X86_INVPCID              1H,        EBX, 10, 0,                   _
#define X86_INVTSC               80000007H, EDX,  8, _X86_CC_POPCNT,      _     /* i.e. not a K8 */
#define X86_LA57                 7H,        ECX, 16, 0,                   _
#define X86_LAHF_LM              80000001H, ECX,  0, 0,                   _
#define X86_LM                   80000001H, EDX, 29, 0,                   _
#define X86_MCA                  1H,        EDX, 14, 0,                   _
#define X86_MCE                  1H,        EDX,  7, 0,                   _
#define X86_MD_CLEAR             7H,        EDX, 10, 0,                   _
#define X86_MMX                  1H,        EDX, 23, 0,                   _
#define X86_MOVBE                1H,        ECX, 22, 0,                   _
#define X86_MOVDIR64B            7H,        ECX, 28, 0,                   _
#define X86_MOVDIRI              7H,        ECX, 27, 0,                   _
#define X86_MP                   80000001H, EDX, 19, 0,                   _
#define X86_MPX                  7H,        EBX, 14, 0,                   _
#define X86_MSR                  1H,        EDX,  5, 0,                   _
#define X86_MTRR                 1H,        EDX, 12, 0,                   _
#define X86_MWAIT                1H,        ECX,  3, 0,                   _
#define X86_NX                   80000001H, EDX, 20, 0,                   _
#define X86_OSPKE                7H,        ECX,  4, 0,                   _
#define X86_OSXSAVE              1H,        ECX, 27, 0,                   _
#define X86_PAE                  1H,        EDX,  6, 0,                   _
#define X86_PAT                  1H,        EDX, 16, 0,                   _
#define X86_PBE                  1H,        EDX, 31, 0,                   _
#define X86_PCID                 1H,        ECX, 17, 0,                   _
#define X86_PCLMUL               1H,        ECX,  1, _X86_CC_PCLMUL,      _     /* westmere c. 2010 */
#define X86_PCONFIG              7H,        EDX, 18, 0,                   _
#define X86_PDCM                 1H,        ECX, 15, 0,                   _
#define X86_PGE                  1H,        EDX, 13, 0,                   _
#define X86_PKU                  7H,        ECX,  3, 0,                   _
#define X86_PN                   1H,        EDX, 18, 0,                   _
#define X86_POPCNT               1H,        ECX, 23, _X86_CC_POPCNT,      _     /* nehalem c. 2008 */
#define X86_PSE                  1H,        EDX,  3, 0,                   _
#define X86_PSE36                1H,        EDX, 17, 0,                   _
#define X86_RDPID                7H,        ECX, 22, _X86_CC_RDPID,       _     /* cannonlake c. 2018 */
#define X86_RDRND                1H,        ECX, 30, _X86_CC_RDRND,       _     /* ivybridge c. 2012 */
#define X86_RDSEED               7H,        EBX, 18, _X86_CC_RDSEED,      _     /* broadwell c. 2014 */
#define X86_RDTSCP               80000001H, EDX, 27, 0,                   _
#define X86_RDT_A                7H,        EBX, 15, 0,                   _
#define X86_RTM                  7H,        EBX, 11, 0,                   _
#define X86_SDBG                 1H,        ECX, 11, 0,                   _
#define X86_SELFSNOOP            1H,        EDX, 27, 0,                   _
#define X86_SEP                  1H,        EDX, 11, 0,                   _
#define X86_SHA                  7H,        EBX, 29, _X86_CC_SHA,         _     /* goldmont (2016) */
#define X86_SMAP                 7H,        EBX, 20, 0,                   _
#define X86_SMEP                 7H,        EBX,  7, 0,                   _
#define X86_SMX                  1H,        ECX,  6, 0,                   _
#define X86_SPEC_CTRL            7H,        EDX, 26, 0,                   _
#define X86_SPEC_CTRL_SSBD       7H,        EDX, 31, 0,                   _
#define X86_SSE                  1H,        EDX, 25, _X86_CC_SSE,         _     /* pentium c. 1999 */
#define X86_SSE2                 1H,        EDX, 26, _X86_CC_SSE2,        _     /* pentium c. 2001 */
#define X86_SSE3                 1H,        ECX,  0, _X86_CC_SSE3,        _     /* k8 c. 2005 */
#define X86_SSE4_1               1H,        ECX, 19, _X86_CC_SSE4_1,      _     /* core c. 2006 */
#define X86_SSE4_2               1H,        ECX, 20, _X86_CC_SSE4_2,      _     /* nehalem c. 2008 */
#define X86_SSSE3                1H,        ECX,  9, _X86_CC_SSSE3,       _     /* westmere c. 2010 */
#define X86_SYSCALL              80000001H, EDX, 11, 0,                   _
#define X86_TM2                  1H,        ECX,  8, 0,                   _
#define X86_TME                  7H,        ECX, 13, 0,                   _
#define X86_TSC                  1H,        EDX,  4, 0,                   _
#define X86_TSC_ADJUST           7H,        EBX,  1, 0,                   _
#define X86_TSC_DEADLINE_TIMER   1H,        ECX, 24, 0,                   _
#define X86_TSX_FORCE_ABORT      7H,        EDX, 13, 0,                   _
#define X86_UMIP                 7H,        ECX,  2, 0,                   _
#define X86_VAES                 7H,        ECX,  9, 0,                   _
#define X86_VME                  1H,        EDX,  1, 0,                   _
#define X86_VMX                  1H,        ECX,  5, 0,                   _
#define X86_VPCLMULQDQ           7H,        ECX, 10, 0,                   _
#define X86_WAITPKG              7H,        ECX,  5, 0,                   _
#define X86_X2APIC               1H,        ECX, 21, 0,                   _
#define X86_XSAVE                1H,        ECX, 26, _X86_CC_XSAVE,       _     /* sandybridge c. 2012 */
#define X86_XTPR                 1H,        ECX, 14, 0,                   _
#define X86_ZERO_FCS_FDS         7H,        EBX, 13, 0,                   _
/* clang-format on */

/* AMD specific features */
#define X86_ABM            80000001H, ECX, 5, _X86_CC_ABM, _
#define X86_3DNOW          80000001H, EDX, 31, 0, _
#define X86_3DNOWEXT       80000001H, EDX, 30, 0, _
#define X86_3DNOWPREFETCH  80000001H, ECX, 8, 0, _
#define X86_BPEXT          80000001H, ECX, 26, 0, _
#define X86_CMP_LEGACY     80000001H, ECX, 1, 0, _
#define X86_CR8_LEGACY     80000001H, ECX, 4, 0, _
#define X86_EXTAPIC        80000001H, ECX, 3, 0, _
#define X86_FMA4           80000001H, ECX, 16, 0, _
#define X86_FXSR_OPT       80000001H, EDX, 25, 0, _
#define X86_IBS            80000001H, ECX, 10, 0, _
#define X86_LWP            80000001H, ECX, 15, 0, _
#define X86_MISALIGNSSE    80000001H, ECX, 7, 0, _
#define X86_MMXEXT         80000001H, EDX, 22, 0, _
#define X86_MWAITX         80000001H, ECX, 29, 0, _
#define X86_NODEID_MSR     80000001H, ECX, 19, 0, _
#define X86_OSVW           80000001H, ECX, 9, 0, _
#define X86_OVERFLOW_RECOV 80000007H, EBX, 0, 0, _
#define X86_PERFCTR_CORE   80000001H, ECX, 23, 0, _
#define X86_PERFCTR_LLC    80000001H, ECX, 28, 0, _
#define X86_PERFCTR_NB     80000001H, ECX, 24, 0, _
#define X86_PTSC           80000001H, ECX, 27, 0, _
#define X86_SKINIT         80000001H, ECX, 12, 0, _
#define X86_SMCA           80000007H, EBX, 3, 0, _
#define X86_SSE4A          80000001H, ECX, 6, 0, _
#define X86_SUCCOR         80000007H, EBX, 1, 0, _
#define X86_SVM            80000001H, ECX, 2, 0, _
#define X86_TBM            80000001H, ECX, 21, 0, _
#define X86_TCE            80000001H, ECX, 17, 0, _
#define X86_TOPOEXT        80000001H, ECX, 22, 0, _
#define X86_WDT            80000001H, ECX, 13, 0, _
#define X86_XOP            80000001H, ECX, 11, 0, _

/* Defined but not loaded by kCpuids.S */
#define X86_ARAT            6H, EAX, 2, 0, _
#define X86_AVIC            8000000AH, EDX, 13, 0, _
#define X86_CLZERO          80000008H, EBX, 0, 0, _
#define X86_DECODEASSISTS   8000000AH, EDX, 7, 0, _
#define X86_DTHERM          6H, EAX, 0, 0, _
#define X86_FLUSHBYASID     8000000AH, EDX, 6, 0, _
#define X86_HWP             6H, EAX, 7, 0, _
#define X86_HWP_ACT_WINDOW  6H, EAX, 9, 0, _
#define X86_HWP_EPP         6H, EAX, 10, 0, _
#define X86_HWP_NOTIFY      6H, EAX, 8, 0, _
#define X86_HWP_PKG_REQ     6H, EAX, 11, 0, _
#define X86_IBPB            80000008H, EBX, 12, 0, _
#define X86_IBRS            80000008H, EBX, 14, 0, _
#define X86_IDA             6H, EAX, 1, 0, _
#define X86_IRPERF          80000008H, EBX, 1, 0, _
#define X86_LBRV            8000000AH, EDX, 1, 0, _
#define X86_NPT             8000000AH, EDX, 0, 0, _
#define X86_NRIPS           8000000AH, EDX, 3, 0, _
#define X86_PAUSEFILTER     8000000AH, EDX, 10, 0, _
#define X86_PFTHRESHOLD     8000000AH, EDX, 12, 0, _
#define X86_PLN             6H, EAX, 4, 0, _
#define X86_PTS             6H, EAX, 6, 0, _
#define X86_SSBD            80000008H, EBX, 24, 0, _
#define X86_SSB_NO          80000008H, EBX, 26, 0, _
#define X86_STIBP           80000008H, EBX, 15, 0, _
#define X86_STIBP_ALWAYS_ON 80000008H, EBX, 17, 0, _
#define X86_SVML            8000000AH, EDX, 2, 0, _
#define X86_TSCRATEMSR      8000000AH, EDX, 4, 0, _
#define X86_VGIF            8000000AH, EDX, 16, 0, _
#define X86_VIRT_SSBD       80000008H, EBX, 25, 0, _
#define X86_VMCBCLEAN       8000000AH, EDX, 5, 0, _
#define X86_V_VMSAVE_VMLOAD 8000000AH, EDX, 15, 0, _
#define X86_WBNOINVD        80000008H, EBX, 9, 0, _
#define X86_XGETBV1         DH, EAX, 2, 0, _
#define X86_XSAVEC          DH, EAX, 1, 0, _
#define X86_XSAVEERPTR      80000008H, EBX, 2, 0, _
#define X86_XSAVEOPT        DH, EAX, 0, 0, _
#define X86_XSAVES          DH, EAX, 3, 0, _

#define X86_NEED(FEATURE) _X86_NEED(X86_##FEATURE)
#define X86_WORD(FEATURE) _X86_WORD(X86_##FEATURE)
#define X86_LEAF(FEATURE) _X86_LEAF(X86_##FEATURE)
#define X86_REG(FEATURE)  _X86_REG(X86_##FEATURE)
#define X86_BIT(FEATURE)  _X86_BIT(X86_##FEATURE)

#define _X86_HAVE(FEATURE) __X86_HAVE(FEATURE)
#define _X86_NEED(FEATURE) __X86_NEED(FEATURE)
#define _X86_WORD(FEATURE) __X86_WORD(FEATURE)
#define _X86_LEAF(FEATURE) __X86_LEAF(FEATURE)
#define _X86_REG(FEATURE)  __X86_REG(FEATURE)
#define _X86_BIT(FEATURE)  __X86_BIT(FEATURE)

#define __X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  ___X86_HAVE(LEAF, REG, BIT, MANDATORY, _X86_HOOK_##HOOK)
#define __X86_NEED(LEAF, REG, BIT, MANDATORY, HOOK) MANDATORY
#define __X86_WORD(LEAF, REG, BIT, MANDATORY, HOOK) KCPUIDS(LEAF, REG)
#define __X86_LEAF(LEAF, REG, BIT, MANDATORY, HOOK) LEAF
#define __X86_REG(LEAF, REG, BIT, MANDATORY, HOOK)  REG
#define __X86_BIT(LEAF, REG, BIT, MANDATORY, HOOK)  BIT

#ifndef __ASSEMBLER__
#define ___X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  HOOK(!!(MANDATORY || KCPUIDS(LEAF, REG) & (1u << BIT)))
#else
#define ___X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  $1 << (BIT % 8), BIT / 8 + KCPUIDS(LEAF, REG)
#endif

#define _X86_HOOK__(X) X

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define INTRIN_COMMUTATIVE "%"
#define INTRIN_NONCOMMUTATIVE

#if defined(__x86_64__) && !defined(__STRICT_ANSI__)

typedef char __intrin_xmm_t _Vector_size(16) forcealign(16) mayalias;

#define INTRIN_SSEVEX_X_X_X_(PURE, ISA, OP, FLAGS, A, B, C)                    \
  do {                                                                         \
    if (X86_HAVE(ISA)) {                                                       \
      __intrin_xmm_t *Xmm0 = (void *)(A);                                      \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);                \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(C);                \
      if (!X86_NEED(AVX)) {                                                    \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : FLAGS "x"(*Xmm2), "0"(*Xmm1));        \
      } else {                                                                 \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : FLAGS "x"(*Xmm1), "x"(*Xmm2)); \
      }                                                                        \
    } else {                                                                   \
      PURE(A, B, C);                                                           \
    }                                                                          \
  } while (0)

#define INTRIN_SSEVEX_X_X_I_(PURE, ISA, OP, A, B, I)                 \
  do {                                                               \
    if (X86_HAVE(ISA)) {                                             \
      __intrin_xmm_t *Xmm0 = (void *)(A);                            \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);      \
      if (!X86_NEED(AVX)) {                                          \
        asm(OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));     \
      } else {                                                       \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I)); \
      }                                                              \
    } else {                                                         \
      PURE(A, B, I);                                                 \
    }                                                                \
  } while (0)

#define INTRIN_SSEVEX_X_X_(PURE, ISA, OP, A, B)                 \
  do {                                                          \
    if (X86_HAVE(ISA)) {                                        \
      __intrin_xmm_t *Xmm0 = (void *)(A);                       \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B); \
      if (!X86_NEED(AVX)) {                                     \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : "0"(*Xmm1));           \
      } else {                                                  \
        asm("v" OP "\t%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1));       \
      }                                                         \
    } else {                                                    \
      PURE(A, B);                                               \
    }                                                           \
  } while (0)

#define INTRIN_SSEVEX_X_I_(PURE, ISA, OP, A, B, I)                   \
  do {                                                               \
    if (!IsModeDbg() && X86_HAVE(ISA)) {                             \
      __intrin_xmm_t *Xmm0 = (void *)(A);                            \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);      \
      if (!X86_NEED(AVX)) {                                          \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
      } else {                                                       \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I)); \
      }                                                              \
    } else {                                                         \
      PURE(A, B, I);                                                 \
    }                                                                \
  } while (0)

#else
#define INTRIN_SSEVEX_X_X_X_(PURE, ISA, OP, FLAGS, A, B, C) PURE(A, B, C)
#define INTRIN_SSEVEX_X_X_I_(PURE, ISA, OP, A, B, I)        PURE(A, B, I)
#define INTRIN_SSEVEX_X_I_(PURE, ISA, OP, A, B, I)          PURE(A, B, I)
#endif /* X86 && !ANSI */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/midpoint.h */

#define COSMOPOLITAN_LIBC_BITS_MIDPOINT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(__x86__)
/**
 * Computes `(a + b) / 2` assuming unsigned.
 *
 * This implementation is the fastest on AMD Zen architecture.
 */
#define _midpoint(a, b)         \
  ({                            \
    typeof((a) + (b)) a_ = (a); \
    typeof(a_) b_ = (b);        \
    assert(a_ >= 0);            \
    assert(b_ >= 0);            \
    asm("add\t%1,%0\n\t"        \
        "rcr\t%0"               \
        : "+r"(a_)              \
        : "r"(b_));             \
    a_;                         \
  })
#else
/**
 * Computes `(a + b) / 2` assuming unsigned.
 */
#define _midpoint(a, b) (((a) & (b)) + ((a) ^ (b)) / 2)
#endif /* __GNUC__ && !__STRICT_ANSI__ && x86 */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/morton.h */

#define COSMOPOLITAN_LIBC_BITS_MORTON_H_


/*!BEGIN libc/intrin/pdep.h */

#define COSMOPOLITAN_LIBC_INTRIN_PDEP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t pdep(uint64_t, uint64_t) pureconst;

#define PDEP(NUMBER, BITMASK)                                                \
  ({                                                                         \
    typeof(BITMASK) ShuffledBits, Number = (NUMBER);                         \
    asm("pdep\t%2,%1,%0" : "=r"(ShuffledBits) : "r"(Number), "rm"(BITMASK)); \
    ShuffledBits;                                                            \
  })

#define pdep(NUMBER, BITMASK) \
  (!X86_HAVE(BMI2) ? pdep(NUMBER, BITMASK) : PDEP(NUMBER, BITMASK))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pext.h */

#define COSMOPOLITAN_LIBC_INTRIN_PEXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t pext(uint64_t, uint64_t) pureconst;

#define PEXT(NUMBER, BITMASK)                                                \
  ({                                                                         \
    typeof(BITMASK) ShuffledBits, Number = (NUMBER);                         \
    asm("pext\t%2,%1,%0" : "=r"(ShuffledBits) : "r"(Number), "rm"(BITMASK)); \
    ShuffledBits;                                                            \
  })

#define pext(NUMBER, BITMASK) \
  (!X86_HAVE(BMI2) ? pext(NUMBER, BITMASK) : PEXT(NUMBER, BITMASK))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned long morton(unsigned long, unsigned long) libcesque;
axdx_t unmorton(unsigned long) libcesque;

#ifndef __STRICT_ANSI__
#define morton(Y, X)                                                          \
  (X86_NEED(BMI2) ? pdep(X, 0x5555555555555555) | pdep(Y, 0xAAAAAAAAAAAAAAAA) \
                  : morton(Y, X))
#define unmorton(I)                                                         \
  (X86_NEED(BMI2)                                                           \
       ? (axdx_t){pext(I, 0xAAAAAAAAAAAAAAAA), pext(I, 0x5555555555555555)} \
       : unmorton(I))
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/mpsadbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_MPSADBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void mpsadbw(uint16_t[8], const uint8_t[16], const uint8_t[16], uint8_t);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __mpsadbws(__intrin_xmm_t, __intrin_xmm_t);
#define mpsadbw(C, B, A, I)                                                   \
  do {                                                                        \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE4_1),   \
                         1)) {                                                \
      __intrin_xmm_t *Xmm0 = (void *)(C);                                     \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);               \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(A);               \
      if (__builtin_constant_p(I)) {                                          \
        if (!X86_NEED(AVX)) {                                                 \
          asm("mpsadbw\t%2,%1,%0"                                             \
              : "=x"(*Xmm0)                                                   \
              : "x"(*Xmm2), "i"(I), "0"(*Xmm1));                              \
        } else {                                                              \
          asm("vmpsadbw\t%3,%2,%1,%0"                                         \
              : "=x"(*Xmm0)                                                   \
              : "x"(*Xmm1), "x"(*Xmm2), "i"(I));                              \
        }                                                                     \
      } else {                                                                \
        unsigned long Vimm = (I);                                             \
        typeof(__mpsadbws) *Fn;                                               \
        Fn = (typeof(__mpsadbws) *)((uintptr_t)&__mpsadbws + (Vimm & 7) * 8); \
        *Xmm0 = Fn(*Xmm1, *Xmm2);                                             \
      }                                                                       \
    } else {                                                                  \
      mpsadbw(C, B, A, I);                                                    \
    }                                                                         \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/newbie.h */

#define COSMOPOLITAN_LIBC_BITS_NEWBIE_H_

/*
 * Macros for newbies.
 * https://justine.lol/endian.html
 */

#define BYTE_ORDER    __BYTE_ORDER__
#define LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__
#define BIG_ENDIAN    __ORDER_BIG_ENDIAN__
#define PDP_ENDIAN    __ORDER_PDP_ENDIAN__

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define htobe16(x) bswap_16(x)
#define be16toh(x) bswap_16(x)
#define betoh16(x) bswap_16(x)
#define htobe32(x) bswap_32(x)
#define be32toh(x) bswap_32(x)
#define betoh32(x) bswap_32(x)
#define htobe64(x) bswap_64(x)
#define be64toh(x) bswap_64(x)
#define betoh64(x) bswap_64(x)
#define htole16(x) (uint16_t)(x)
#define le16toh(x) (uint16_t)(x)
#define letoh16(x) (uint16_t)(x)
#define htole32(x) (uint32_t)(x)
#define le32toh(x) (uint32_t)(x)
#define letoh32(x) (uint32_t)(x)
#define htole64(x) (uint64_t)(x)
#define le64toh(x) (uint64_t)(x)
#define letoh64(x) (uint64_t)(x)
#else
#define htobe16(x) (uint16_t)(x)
#define be16toh(x) (uint16_t)(x)
#define betoh16(x) (uint16_t)(x)
#define htobe32(x) (uint32_t)(x)
#define be32toh(x) (uint32_t)(x)
#define betoh32(x) (uint32_t)(x)
#define htobe64(x) (uint64_t)(x)
#define be64toh(x) (uint64_t)(x)
#define betoh64(x) (uint64_t)(x)
#define htole16(x) bswap_16(x)
#define le16toh(x) bswap_16(x)
#define letoh16(x) bswap_16(x)
#define htole32(x) bswap_32(x)
#define le32toh(x) bswap_32(x)
#define letoh32(x) bswap_32(x)
#define htole64(x) bswap_64(x)
#define le64toh(x) bswap_64(x)
#define letoh64(x) bswap_64(x)
#endif



/*!BEGIN libc/intrin/nopl.h */

#define COSMOPOLITAN_LIBC_INTRIN_NOPL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0) && defined(__GNUC__) && \
    !defined(__llvm__) && !defined(__chibicc__) && !defined(__STRICT_ANSI__)

/**
 * @fileoverview Turns CALLs into NOPs that are fixupable at runtime.
 *
 * Things like lock/unlock function calls can take on average 100ms.
 * Libc needs to use internal locking pervasively in order to support
 * threads. So there's a lot of cost everywhere, even though most progs
 * don't use threads. In ANSI mode we dispatching (__threaded && lock())
 * to solve this problem, but if we write lock statements that way, it
 * adds a lot of bloat to the functions that call locking routines. So
 * what we do here is replace the CALL instruction with NOP, which keeps
 * the code just as fast as inlining, while making code size 10x tinier.
 */

#define _NOPL_PROLOGUE(SECTION)                    \
  ".section \".sort.rodata." SECTION ".1"          \
  "\",\"aG\",@progbits,\"" SECTION "\",comdat\n\t" \
  ".align\t4\n\t"                                  \
  ".type\t\"" SECTION "_start\",@object\n\t"       \
  ".globl\t\"" SECTION "_start\"\n\t"              \
  ".equ\t\"" SECTION "_start\",.\n\t"              \
  ".previous\n\t"

#define _NOPL_EPILOGUE(SECTION)                    \
  ".section \".sort.rodata." SECTION ".3"          \
  "\",\"aG\",@progbits,\"" SECTION "\",comdat\n\t" \
  ".align\t4\n\t"                                  \
  ".type\"" SECTION "_end\",@object\n\t"           \
  ".globl\t\"" SECTION "_end\"\n\t"                \
  ".equ\t\"" SECTION "_end\",.\n\t"                \
  ".previous\n\t"

#define _NOPL0(SECTION, FUNC)                                                  \
  ({                                                                           \
    asm volatile(_NOPL_PROLOGUE(SECTION) /*                                 */ \
                 _NOPL_EPILOGUE(SECTION) /*                                 */ \
                 ".section \".sort.rodata." SECTION ".2\",\"a\",@progbits\n\t" \
                 ".align\t4\n\t"                                               \
                 ".long\t353f-%a1\n\t"                                         \
                 ".previous\n353:\t"                                           \
                 "nopl\t%a0"                                                   \
                 : /* no inputs */                                             \
                 : "X"(FUNC), "X"(IMAGE_BASE_VIRTUAL)                          \
                 : "rax", "rdi", "rsi", "rdx", "rcx", "r8", "r9", "r10",       \
                   "r11", "memory", "cc");                                     \
    (void)0;                                                                   \
  })

#define _NOPL1(SECTION, FUNC, ARG)                                             \
  ({                                                                           \
    register autotype(ARG) __arg asm("rdi") = ARG;                             \
    asm volatile(_NOPL_PROLOGUE(SECTION) /*                                 */ \
                 _NOPL_EPILOGUE(SECTION) /*                                 */ \
                 ".section \".sort.rodata." SECTION ".2\",\"a\",@progbits\n\t" \
                 ".align\t4\n\t"                                               \
                 ".long\t353f-%a2\n\t"                                         \
                 ".previous\n353:\t"                                           \
                 "nopl\t%a1"                                                   \
                 : "+D"(__arg)                                                 \
                 : "X"(FUNC), "X"(IMAGE_BASE_VIRTUAL)                          \
                 : "rax", "rsi", "rdx", "rcx", "r8", "r9", "r10", "r11",       \
                   "memory", "cc");                                            \
    (void)0;                                                                   \
  })

#endif /* !ASSEMBLER && !LINKER && GNUC && !CHIBICC && !LLVM && !ANSI */


/*!BEGIN libc/intrin/once.h */

#define COSMOPOLITAN_LIBC_INTRIN_ONCE_H_


/*!BEGIN libc/intrin/spinlock.h */

#define COSMOPOLITAN_LIBC_INTRIN_SPINLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § spinlocks                                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  fast tiny inline synchronization routines */

#ifdef TINY
#define _spinlock(lock) _spinlock_tiny(lock)
#else
#define _spinlock(lock) _spinlock_cooperative(lock)
#endif

#define _spunlock(lock) (__atomic_store_n(lock, 0, __ATOMIC_RELAXED), 0)

#define _seizelock(lock, value)                     \
  ({                                                \
    autotype(lock) __lock = (lock);                 \
    typeof(*__lock) __x = (value);                  \
    __atomic_store(__lock, &__x, __ATOMIC_RELEASE); \
  })

#define _spinlock_tiny(lock)  \
  ({                          \
    while (_trylock(lock)) {  \
      __builtin_ia32_pause(); \
    }                         \
    0;                        \
  })

#define _spinlock_cooperative(lock)                  \
  ({                                                 \
    char __x;                                        \
    unsigned __tries = 0;                            \
    char *__lock = (lock);                           \
    for (;;) {                                       \
      __atomic_load(__lock, &__x, __ATOMIC_RELAXED); \
      if (!__x && !_trylock(__lock)) {               \
        break;                                       \
      } else if (++__tries & 7) {                    \
        __builtin_ia32_pause();                      \
      } else {                                       \
        _spinlock_yield();                           \
      }                                              \
    }                                                \
    0;                                               \
  })

#define _spinlock_cooperative_(lock)                 \
  ({                                                 \
    char __x;                                        \
    volatile int __i;                                \
    unsigned __tries = 0;                            \
    char *__lock = (lock);                           \
    for (;;) {                                       \
      __atomic_load(__lock, &__x, __ATOMIC_RELAXED); \
      if (!__x && !_trylock(__lock)) {               \
        break;                                       \
      } else if (__tries < 7) {                      \
        for (__i = 0; __i != 1 << __tries; __i++) {  \
        }                                            \
        __tries++;                                   \
      } else {                                       \
        _spinlock_yield();                           \
      }                                              \
    }                                                \
    0;                                               \
  })

#define _trylock(lock) __atomic_test_and_set(lock, __ATOMIC_SEQ_CST)

int _spinlock_yield(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define _once(x)                       \
  ({                                   \
    typeof(x) oncerc;                  \
    static bool once;                  \
    static typeof(oncerc) onceresult;  \
    _Alignas(64) static char oncelock; \
    _spinlock(&oncelock);              \
    if (once) {                        \
      oncerc = onceresult;             \
    } else {                           \
      oncerc = onceresult = x;         \
    }                                  \
    _spunlock(&oncelock);              \
    oncerc;                            \
  })



/*!BEGIN libc/intrin/pabsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsb(uint8_t[16], const int8_t[16]);

#define pabsb(A, B) INTRIN_SSEVEX_X_X_(pabsb, SSSE3, "pabsb", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pabsd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsd(uint32_t[4], const int32_t[4]);

#define pabsd(A, B) INTRIN_SSEVEX_X_X_(pabsd, SSSE3, "pabsd", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pabsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsw(uint16_t[8], const int16_t[8]);

#define pabsw(A, B) INTRIN_SSEVEX_X_X_(pabsw, SSSE3, "pabsw", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packssdw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKSSDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packssdw(int16_t[8], const int32_t[4], const int32_t[4]);

#define packssdw(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packssdw, SSE2, "packssdw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packsswb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKSSWB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packsswb(int8_t[16], const int16_t[8], const int16_t[8]);

#define packsswb(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packsswb, SSE2, "packsswb", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packusdw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKUSDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packusdw(uint16_t[8], const int32_t[4], const int32_t[4]);

#define packusdw(A, B, C)                                                      \
  INTRIN_SSEVEX_X_X_X_(packusdw, SSE4_1, "packusdw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packuswb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKUSWB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packuswb(uint8_t[16], const int16_t[8], const int16_t[8]);

#define packuswb(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packuswb, SSE2, "packuswb", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddb(int8_t[16], const int8_t[16], const int8_t[16]);

#define paddb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddb, SSE2, "paddb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddd(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define paddd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddd, SSE2, "paddd", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define paddq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddq, SSE2, "paddq", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddsb(int8_t[16], const int8_t[16], const int8_t[16]);

#define paddsb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddsb, SSE2, "paddsb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define paddsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddsw, SSE2, "paddsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddusb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDUSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddusb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define paddusb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddusb, SSE2, "paddusb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddusw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDUSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddusw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define paddusw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddusw, SSE2, "paddusw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddw(int16_t[8], const int16_t[8], const int16_t[8]);

#define paddw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddw, SSE2, "paddw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/palignr.h */

#define COSMOPOLITAN_LIBC_INTRIN_PALIGNR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void palignr(void *, const void *, const void *, unsigned long);

#if !defined(__STRICT_ANSI__) && !defined(__chibicc__)
__intrin_xmm_t __palignrs(__intrin_xmm_t, __intrin_xmm_t);
#define palignr(C, B, A, I)                                                \
  do {                                                                     \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSSE3), \
                         1)) {                                             \
      __intrin_xmm_t *Xmm0 = (void *)(C);                                  \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);            \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(A);            \
      if (__builtin_constant_p(I)) {                                       \
        if (!X86_NEED(AVX)) {                                              \
          asm("palignr\t%2,%1,%0"                                          \
              : "=x"(*Xmm0)                                                \
              : "x"(*Xmm2), "i"(I), "0"(*Xmm1));                           \
        } else {                                                           \
          asm("vpalignr\t%3,%2,%1,%0"                                      \
              : "=x"(*Xmm0)                                                \
              : "x"(*Xmm1), "x"(*Xmm2), "i"(I));                           \
        }                                                                  \
      } else {                                                             \
        unsigned long Vimm = (I);                                          \
        typeof(__palignrs) *Fn;                                            \
        if (__builtin_expect(Vimm < 32, 1)) {                              \
          Fn = (typeof(__palignrs) *)((uintptr_t)&__palignrs + Vimm * 8);  \
          *Xmm0 = Fn(*Xmm1, *Xmm2);                                        \
        } else {                                                           \
          memset(Xmm0, 0, 16);                                             \
        }                                                                  \
      }                                                                    \
    } else {                                                               \
      palignr(C, B, A, I);                                                 \
    }                                                                      \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pand.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAND_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pand(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pand(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pand, SSE2, "pand", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pandn.h */

#define COSMOPOLITAN_LIBC_INTRIN_PANDN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pandn(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pandn(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pandn, SSE2, "pandn", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pavgb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAVGB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pavgb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pavgb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pavgb, SSE2, "pavgb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pavgw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAVGW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pavgw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define pavgw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pavgw, SSE2, "pavgw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pcmpeqb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqb, SSE2, "pcmpeqb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqd(int32_t[4], const int32_t[4], const int32_t[4]);

#define pcmpeqd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqd, SSE2, "pcmpeqd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pcmpeqw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqw, SSE2, "pcmpeqw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtb(int8_t[16], const int8_t[16], const int8_t[16]);

#define pcmpgtb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtb, SSE2, "pcmpgtb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtd(int32_t[4], const int32_t[4], const int32_t[4]);

#define pcmpgtd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtd, SSE2, "pcmpgtd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pcmpgtw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtw, SSE2, "pcmpgtw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddd(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define phaddd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phaddd, SSSE3, "phaddd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phaddsw(A, B, C)                                                       \
  INTRIN_SSEVEX_X_X_X_(phaddsw, SSSE3, "phaddsw", INTRIN_NONCOMMUTATIVE, A, B, \
                       C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phaddw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phaddw, SSSE3, "phaddw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubd(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define phsubd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phsubd, SSSE3, "phsubd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phsubsw(A, B, C)                                                       \
  INTRIN_SSEVEX_X_X_X_(phsubsw, SSSE3, "phsubsw", INTRIN_NONCOMMUTATIVE, A, B, \
                       C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phsubw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phsubw, SSSE3, "phsubw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaddubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMADDUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaddubsw(int16_t[8], const uint8_t[16], const int8_t[16]);

#define pmaddubsw(W, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(pmaddubsw, SSSE3, "pmaddubsw", INTRIN_NONCOMMUTATIVE, \
                       W, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaddwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMADDWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaddwd(int32_t[4], const int16_t[8], const int16_t[8]);

#define pmaddwd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaddwd, SSE2, "pmaddwd", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaxsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMAXSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaxsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmaxsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaxsw, SSE2, "pmaxsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaxub.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMAXUB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaxub(unsigned char[16], const unsigned char[16],
            const unsigned char[16]);

#define pmaxub(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaxub, SSE2, "pmaxub", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pminsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMINSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pminsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pminsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pminsw, SSE2, "pminsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pminub.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMINUB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pminub(unsigned char[16], const unsigned char[16],
            const unsigned char[16]);

#define pminub(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pminub, SSE2, "pminub", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmovmskb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMOVMSKB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint32_t pmovmskb(const uint8_t[16]);

#define pmovmskb(A)                                            \
  ({                                                           \
    uint32_t Mask;                                             \
    if (!IsModeDbg() && X86_HAVE(SSE2)) {                      \
      const __intrin_xmm_t *Xmm = (const __intrin_xmm_t *)(A); \
      if (!X86_NEED(AVX)) {                                    \
        asm("pmovmskb\t%1,%0" : "=r"(Mask) : "x"(*Xmm));       \
      } else {                                                 \
        asm("vpmovmskb\t%1,%0" : "=r"(Mask) : "x"(*Xmm));      \
      }                                                        \
    } else {                                                   \
      Mask = pmovmskb(A);                                      \
    }                                                          \
    Mask;                                                      \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhrsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHRSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhrsw(int16_t a[8], const int16_t b[8], const int16_t c[8]);

#define pmulhrsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhrsw, SSSE3, "pmulhrsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhuw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHUW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhuw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define pmulhuw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhuw, SSE2, "pmulhuw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmulhw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhw, SSE2, "pmulhw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulld(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define pmulld(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulld, SSE4_1, "pmulld", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmullw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmullw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmullw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmullw, SSE2, "pmullw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmuludq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULUDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmuludq(uint64_t[2], const uint32_t[4], const uint32_t[4]);

#define pmuludq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmuludq, SSE2, "pmuludq", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/popcnt.h */

#define COSMOPOLITAN_LIBC_BITS_POPCNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

size_t _countbits(const void *, size_t);
unsigned long popcnt(unsigned long) pureconst;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define popcnt(X)                                                \
  (__builtin_constant_p(X) ? __builtin_popcountll(X) : ({        \
    unsigned long PoP = (X);                                     \
    if (X86_HAVE(POPCNT)) {                                      \
      asm("popcnt\t%0,%0" : "+r"(PoP) : /* no inputs */ : "cc"); \
    } else {                                                     \
      PoP = (popcnt)(PoP);                                       \
    }                                                            \
    PoP;                                                         \
  }))
#endif /* GNUC && !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/por.h */

#define COSMOPOLITAN_LIBC_INTRIN_POR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void por(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define por(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(por, SSE2, "por", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psadbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSADBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psadbw(uint64_t[2], const uint8_t[16], const uint8_t[16]);

#define psadbw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psadbw, SSE2, "psadbw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pshufb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pshufb, SSSE3, "pshufb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufd(int32_t[4], const int32_t[4], uint8_t);

#define pshufd(A, B, I) INTRIN_SSEVEX_X_X_I_(pshufd, SSE2, "pshufd", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufhw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFHW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufhw(int16_t[8], const int16_t[8], uint8_t);

#define pshufhw(A, B, I) INTRIN_SSEVEX_X_X_I_(pshufhw, SSE2, "pshufhw", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshuflw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshuflw(int16_t[8], const int16_t[8], uint8_t);

#define pshuflw(A, B, I) INTRIN_SSEVEX_X_X_I_(pshuflw, SSE2, "pshuflw", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufw(int16_t[4], const int16_t[4], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGNB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignb(int8_t[16], const int8_t[16], const int8_t[16]);

#define psignb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignb, SSSE3, "psignb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGND_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignd(int32_t[4], const int32_t[4], const int32_t[4]);

#define psignd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignd, SSSE3, "psignd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGNW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignw(int16_t[8], const int16_t[8], const int16_t[8]);

#define psignw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignw, SSSE3, "psignw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pslld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pslld(uint32_t[4], const uint32_t[4], unsigned char);
void pslldv(uint32_t[4], const uint32_t[4], const uint64_t[2]);

#define pslld(A, B, I) INTRIN_SSEVEX_X_I_(pslld, SSE2, "pslld", A, B, I)
#define pslldv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pslldv, SSE2, "pslld", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pslldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pslldq(uint8_t[16], const uint8_t[16], unsigned long);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __pslldqs(__intrin_xmm_t);
#define pslldq(B, A, I)                                                   \
  do {                                                                    \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE2), \
                         1)) {                                            \
      __intrin_xmm_t *Xmm0 = (void *)(B);                                 \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(A);           \
      if (__builtin_constant_p(I)) {                                      \
        if (!X86_NEED(AVX)) {                                             \
          asm("pslldq\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
        } else {                                                          \
          asm("vpslldq\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));    \
        }                                                                 \
      } else {                                                            \
        unsigned long Vimm = (I);                                         \
        typeof(__pslldqs) *Fn;                                            \
        if (Vimm > 16) Vimm = 16;                                         \
        Fn = (typeof(__pslldqs) *)((uintptr_t)&__pslldqs + Vimm * 8);     \
        *Xmm0 = Fn(*Xmm1);                                                \
      }                                                                   \
    } else {                                                              \
      pslldq(B, A, I);                                                    \
    }                                                                     \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psllq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psllq(uint64_t[2], const uint64_t[2], unsigned char);
void psllqv(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define psllq(A, B, I) INTRIN_SSEVEX_X_I_(psllq, SSE2, "psllq", A, B, I)
#define psllqv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psllqv, SSE2, "psllq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psllw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psllw(uint16_t[8], const uint16_t[8], unsigned char);
void psllwv(uint16_t[8], const uint16_t[8], const uint64_t[2]);

#define psllw(A, B, I) INTRIN_SSEVEX_X_I_(psllw, SSE2, "psllw", A, B, I)
#define psllwv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psllwv, SSE2, "psllw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrad.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrad(int32_t[4], const int32_t[4], unsigned char);
void psradv(int32_t[4], const int32_t[4], const uint64_t[2]);

#define psrad(A, B, I) INTRIN_SSEVEX_X_I_(psrad, SSE2, "psrad", A, B, I)
#define psradv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psradv, SSE2, "psrad", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psraw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRAW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psraw(int16_t[8], const int16_t[8], unsigned char);
void psrawv(int16_t[8], const int16_t[8], const uint64_t[2]);

#define psraw(A, B, I) INTRIN_SSEVEX_X_I_(psraw, SSE2, "psraw", A, B, I)
#define psrawv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrawv, SSE2, "psraw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrld(uint32_t[4], const uint32_t[4], unsigned char);
void psrldv(uint32_t[4], const uint32_t[4], const uint64_t[2]);

#define psrld(A, B, I) INTRIN_SSEVEX_X_I_(psrld, SSE2, "psrld", A, B, I)
#define psrldv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrldv, SSE2, "psrld", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrldq(uint8_t[16], const uint8_t[16], unsigned long);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __psrldqs(__intrin_xmm_t);
#define psrldq(B, A, I)                                                   \
  do {                                                                    \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE2), \
                         1)) {                                            \
      __intrin_xmm_t *Xmm0 = (void *)(B);                                 \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(A);           \
      if (__builtin_constant_p(I)) {                                      \
        if (!X86_NEED(AVX)) {                                             \
          asm("psrldq\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
        } else {                                                          \
          asm("vpsrldq\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));    \
        }                                                                 \
      } else {                                                            \
        unsigned long Vimm = (I);                                         \
        typeof(__psrldqs) *Fn;                                            \
        if (Vimm > 16) Vimm = 16;                                         \
        Fn = (typeof(__psrldqs) *)((uintptr_t)&__psrldqs + Vimm * 8);     \
        *Xmm0 = Fn(*Xmm1);                                                \
      }                                                                   \
    } else {                                                              \
      psrldq(B, A, I);                                                    \
    }                                                                     \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrlq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrlq(uint64_t[2], const uint64_t[2], unsigned char);
void psrlqv(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define psrlq(A, B, I) INTRIN_SSEVEX_X_I_(psrlq, SSE2, "psrlq", A, B, I)
#define psrlqv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrlqv, SSE2, "psrlq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrlw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrlw(uint16_t[8], const uint16_t[8], unsigned char);
void psrlwv(uint16_t[8], const uint16_t[8], const uint64_t[2]);

#define psrlw(A, B, I) INTRIN_SSEVEX_X_I_(psrlw, SSE2, "psrlw", A, B, I)
#define psrlwv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrlwv, SSE2, "psrlw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define psubb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubb, SSE2, "psubb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubd(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define psubd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubd, SSE2, "psubd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define psubq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubq, SSE2, "psubq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubsb(int8_t[16], const int8_t[16], const int8_t[16]);

#define psubsb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubsb, SSE2, "psubsb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define psubsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubsw, SSE2, "psubsw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubusb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBUSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubusb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define psubusb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubusb, SSE2, "psubusb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubusw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBUSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubusw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define psubusw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubusw, SSE2, "psubusw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void(psubw)(int16_t[8], const int16_t[8], const int16_t[8]);

#define psubw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubw, SSE2, "psubw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhbw(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define punpckhbw(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhbw, SSE2, "punpckhbw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhdq(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define punpckhdq(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhdq, SSE2, "punpckhdq", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhqdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHQDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhqdq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define punpckhqdq(A, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(punpckhqdq, SSE2, "punpckhqdq", INTRIN_NONCOMMUTATIVE, \
                       A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhwd(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define punpckhwd(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhwd, SSE2, "punpckhwd", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklbw(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define punpcklbw(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpcklbw, SSE2, "punpcklbw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckldq(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define punpckldq(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckldq, SSE2, "punpckldq", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklqdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLQDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklqdq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define punpcklqdq(A, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(punpcklqdq, SSE2, "punpcklqdq", INTRIN_NONCOMMUTATIVE, \
                       A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklwd(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define punpcklwd(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpcklwd, SSE2, "punpcklwd", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pushpop.h */

#define COSMOPOLITAN_LIBC_BITS_PUSHPOP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
#define pushpop(x) (x)
#else
/**
 * PushPop
 * An elegant weapon for a more civilized age.
 */
#define pushpop(x)                                          \
  ({                                                        \
    typeof(x) Popped;                                       \
    if (__builtin_constant_p(x) &&                          \
        (TYPE_SIGNED(typeof(x)) ? (intptr_t)(x) + 128 < 256 \
                                : (intptr_t)(x) < 128)) {   \
      if (x) {                                              \
        asm("push\t%1\n\t"                                  \
            "pop\t%q0"                                      \
            : "=r"(Popped)                                  \
            : "ir"(x));                                     \
      } else {                                              \
        asm("xor\t%k0,%k0" : "=r"(Popped));                 \
      }                                                     \
    } else {                                                \
      asm("" : "=r"(Popped) : "0"(x));                      \
    }                                                       \
    Popped;                                                 \
  })
#endif

#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
#define pushmov(d, x) (*(d) = (x))
#else
#define pushmov(d, x)                                       \
  ({                                                        \
    typeof(*(d)) Popped = (x);                              \
    if (__builtin_constant_p(x) &&                          \
        (TYPE_SIGNED(typeof(x)) ? (intptr_t)(x) + 128 < 256 \
                                : (intptr_t)(x) < 128)) {   \
      asm("pushq\t%1\n\t"                                   \
          "popq\t%0"                                        \
          : "=m"(*(d))                                      \
          : "ir"(Popped));                                  \
    } else {                                                \
      *(d) = Popped;                                        \
    }                                                       \
    Popped;                                                 \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pxor.h */

#define COSMOPOLITAN_LIBC_INTRIN_PXOR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pxor(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pxor(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pxor, SSE2, "pxor", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/repmovsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_REPMOVSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

forceinline void repmovsb(void **dest, const void **src, size_t cx) {
  char *di = (char *)*dest;
  const char *si = (const char *)*src;
  while (cx) *di++ = *si++, cx--;
  *dest = di, *src = si;
}

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define repmovsb(DI, SI, CX)                                       \
  ({                                                               \
    void *Di = *(DI);                                              \
    const void *Si = *(SI);                                        \
    size_t Cx = (CX);                                              \
    asm("rep movsb"                                                \
        : "=D"(Di), "=S"(Si), "=c"(Cx), "=m"(*(char(*)[Cx])Di)     \
        : "0"(Di), "1"(Si), "2"(Cx), "m"(*(const char(*)[Cx])Si)); \
    *(DI) = Di, *(SI) = Si;                                        \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/repstosb.h */

#define COSMOPOLITAN_LIBC_INTRIN_REPSTOSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

forceinline void *repstosb(void *dest, unsigned char al, size_t cx) {
  unsigned char *di = (unsigned char *)dest;
  while (cx) *di++ = al, cx--;
  return di;
}

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define repstosb(DI, AL, CX)                         \
  ({                                                 \
    void *Di = (DI);                                 \
    size_t Cx = (CX);                                \
    unsigned char Al = (AL);                         \
    asm("rep stosb %b5,(%0)"                         \
        : "=D"(Di), "=c"(Cx), "=m"(*(char(*)[Cx])Di) \
        : "0"(Di), "1"(Cx), "a"(Al));                \
    Di;                                              \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/segmentation.h */

#define COSMOPOLITAN_LIBC_BITS_SEGMENTATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

/**
 * Reads scalar from memory, offset by segment.
 *
 * @return *(MEM) relative to segment
 * @see arch_prctl()
 * @see pushpop()
 */
#define fs(MEM) __peek("fs", MEM)
#define gs(MEM) __peek("gs", MEM)

#define __peek(SEGMENT, ADDRESS)                                  \
  ({                                                              \
    typeof(*(ADDRESS)) Pk;                                        \
    asm("mov\t%%" SEGMENT ":%1,%0" : "=r"(Pk) : "m"(*(ADDRESS))); \
    Pk;                                                           \
  })

#endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/shufpd.h */

#define COSMOPOLITAN_LIBC_INTRIN_SHUFPD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void shufpd(double[2], const double[2], const double[2], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/shufps.h */

#define COSMOPOLITAN_LIBC_INTRIN_SHUFPS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void shufps(float[4], const float[4], const float[4], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/weaken.h */

#define COSMOPOLITAN_LIBC_BITS_WEAKEN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#ifndef __STRICT_ANSI__

#define weaken(symbol) ((const typeof(&(symbol)))weakaddr(#symbol))

#define strongaddr(symbolstr)                \
  ({                                         \
    intptr_t waddr;                          \
    asm(ezlea(symbolstr) "0" : "=r"(waddr)); \
    waddr;                                   \
  })

#define weakaddr(symbolstr)                                             \
  ({                                                                    \
    intptr_t waddr;                                                     \
    asm(".weak\t" symbolstr "\n\t" ezlea(symbolstr) "0" : "=r"(waddr)); \
    waddr;                                                              \
  })

#else
#define weaken(symbol)      symbol
#define weakaddr(symbolstr) &(symbolstr)
#endif /* __STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/xadd.h */

#define COSMOPOLITAN_LIBC_BITS_XADD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define _xadd(p, v)                                                 \
  ({                                                                \
    typeof(*(p)) Res;                                               \
    autotype(Res) Val = (v);                                        \
    asm volatile("xadd\t%0,%1" : "=r"(Res), "+m"(*(p)) : "0"(Val)); \
    Res + Val;                                                      \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/bsd.h */

#define COSMOPOLITAN_LIBC_LOG_BSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § logging » berkeley logger                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void err(int, const char *, ...) printfesque(2) wontreturn;
void errx(int, const char *, ...) printfesque(2) wontreturn;
void verr(int, const char *, va_list) paramsnonnull((3)) wontreturn;
void verrx(int, const char *, va_list) paramsnonnull((3)) wontreturn;
void vwarn(const char *, va_list) paramsnonnull((2));
void vwarnx(const char *, va_list) paramsnonnull((2));
void warn(const char *, ...) printfesque(1);
void warnx(const char *, ...) printfesque(1);

#define err(EVAL, FMT, ...)  (err)(EVAL, PFLINK(FMT), ##__VA_ARGS__)
#define errx(EVAL, FMT, ...) (errx)(EVAL, PFLINK(FMT), ##__VA_ARGS__)
#define verr(EVAL, FMT, VA)  (verr)(EVAL, PFLINK(FMT), VA)
#define verrx(EVAL, FMT, VA) (verrx)(EVAL, PFLINK(FMT), VA)
#define vwarn(FMT, VA)       (vwarn)(PFLINK(FMT), VA)
#define vwarnx(FMT, VA)      (vwarnx)(PFLINK(FMT), VA)
#define warn(FMT, ...)       (warn)(PFLINK(FMT), ##__VA_ARGS__)
#define warnx(FMT, ...)      (warn)(PFLINK(FMT), ##__VA_ARGS__)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/check.h */

#define COSMOPOLITAN_LIBC_LOG_CHECK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define CHECK(X, ...)         __CHK(ne, !=, false, "false", !!(X), #X, "" __VA_ARGS__)
#define CHECK_EQ(Y, X, ...)   __CHK(eq, ==, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_NE(Y, X, ...)   __CHK(ne, !=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_LE(Y, X, ...)   __CHK(le, <=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_LT(Y, X, ...)   __CHK(lt, <, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_GE(Y, X, ...)   __CHK(ge, >=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_GT(Y, X, ...)   __CHK(gt, >, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_NOTNULL(X, ...) __CHK(ne, !=, NULL, "NULL", X, #X, "" __VA_ARGS__)

#define DCHECK(X, ...)       __DCHK(ne, !=, false, "false", !!(X), #X, "" __VA_ARGS__)
#define DCHECK_EQ(Y, X, ...) __DCHK(eq, ==, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_NE(Y, X, ...) __DCHK(ne, !=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_LE(Y, X, ...) __DCHK(le, <=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_LT(Y, X, ...) __DCHK(lt, <, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_GE(Y, X, ...) __DCHK(ge, >=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_GT(Y, X, ...) __DCHK(gt, >, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_NOTNULL(X, ...) \
  __DCHK(ne, !=, NULL, "NULL", X, #X, "" __VA_ARGS__)

#define CHECK_ALIGNED(BYTES, VAR, ...)                                \
  do {                                                                \
    if (((uintptr_t)VAR & ((BYTES)-1u))) {                            \
      __check_fail_aligned(BYTES, (uintptr_t)VAR, __FILE__, __LINE__, \
                           "" __VA_ARGS__);                           \
      unreachable;                                                    \
    }                                                                 \
    VAR = (typeof(VAR))__builtin_assume_aligned(VAR, BYTES);          \
  } while (0)

#define DCHECK_ALIGNED(BYTES, VAR, ...)                      \
  do {                                                       \
    if (((uintptr_t)VAR & ((BYTES)-1u))) {                   \
      __DCHK_ALIGNED(BYTES, (uintptr_t)VAR, "" __VA_ARGS__); \
      unreachable;                                           \
    }                                                        \
    VAR = (typeof(VAR))__builtin_assume_aligned(VAR, BYTES); \
  } while (0)

#define __CHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, ...)                   \
  do {                                                                       \
    autotype(GOT) Got = (GOT);                                               \
    autotype(WANT) Want = (WANT);                                            \
    if (!(Want OP Got)) {                                                    \
      if (!NoDebug()) {                                                      \
        __check_fail(#SUFFIX, #OP, (uint64_t)Want, (WANTSTR), (uint64_t)Got, \
                     (GOTSTR), __FILE__, __LINE__, __VA_ARGS__);             \
      } else {                                                               \
        __check_fail_##SUFFIX((uint64_t)Want, (uint64_t)Got, __FILE__,       \
                              __LINE__, 0, __VA_ARGS__);                     \
      }                                                                      \
      unreachable;                                                           \
    }                                                                        \
  } while (0)

#ifdef NDEBUG
#define __DCHK(SUFFIX, OP, WANT, WANTSTR, GOT, ...) \
  do {                                              \
    autotype(GOT) Got = (GOT);                      \
    autotype(WANT) Want = (WANT);                   \
    if (!(Want OP Got)) {                           \
      unreachable;                                  \
    }                                               \
  } while (0)
#else
#define __DCHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, ...) \
  __CHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, __VA_ARGS__)
#endif /* NDEBUG */

#ifdef NDEBUG
#define __DCHK_ALIGNED(BYTES, VAR, ...)
#else
#define __DCHK_ALIGNED(BYTES, VAR, ...) \
  __check_fail_aligned(BYTES, VAR, __FILE__, __LINE__, __VA_ARGS__)
#endif

void __check_fail(const char *, const char *, uint64_t, const char *, uint64_t,
                  const char *, const char *, int, const char *,
                  ...) relegated wontreturn;

void __check_fail_eq(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_ne(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_le(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_lt(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_ge(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_gt(uint64_t, uint64_t, const char *, int, const char *,
                     const char *, ...) relegated wontreturn;
void __check_fail_aligned(unsigned, uint64_t, const char *, int, const char *,
                          ...) relegated wontreturn;

#ifdef __VSCODE_INTELLISENSE__
#undef __CHK
#define __CHK(...)
#undef __DCHK
#define __DCHK(...)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/countbranch.h */

#define COSMOPOLITAN_LIBC_LOG_COUNTBRANCH_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define COUNTBRANCH(x) COUNTBRANCH_(x, #x, STRINGIFY(__FILE__), __LINE__)
#define COUNTBRANCH_(x, xs, file, line) \
  COUNTBRANCH__(x, STRINGIFY(xs), STRINGIFY(xs), file, line)
#define COUNTBRANCH__(x, xs, xss, file, line)                   \
  ({                                                            \
    bool Cond;                                                  \
    struct countbranch *Info;                                   \
    asm(".section .rodata.str1.1,\"aMS\",@progbits,1\n\t"       \
        ".align\t1\n"                                           \
        "31338:\t"                                              \
        ".asciz\t" xs "\n"                                      \
        "31339:\t"                                              \
        ".asciz\t" xss "\n"                                     \
        "31340:\t"                                              \
        ".asciz\t" file "\n\t"                                  \
        ".previous\n\t"                                         \
        ".section .yoink\n\t"                                   \
        "nopl\tcountbranch_data(%%rip)\n\t"                     \
        ".previous\n\t"                                         \
        ".section .sort.data.countbranch.2,\"a\",@progbits\n\t" \
        ".align\t8\n31337:\t"                                   \
        ".quad\t0\n\t"                                          \
        ".quad\t0\n\t"                                          \
        ".quad\t31338b\n\t"                                     \
        ".quad\t31339b\n\t"                                     \
        ".quad\t31340b\n\t"                                     \
        ".quad\t" #line "\n\t"                                  \
        ".previous\n\t"                                         \
        "lea\t31337b(%%rip),%0"                                 \
        : "=r"(Info));                                          \
    Cond = (x);                                                 \
    ++Info->total;                                              \
    if (Cond) ++Info->taken;                                    \
    Cond;                                                       \
  })

struct countbranch {
  long total;
  long taken;
  const char *code;
  const char *xcode;
  const char *file;
  long line;
};

extern struct countbranch countbranch_data[];

void countbranch_report(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/countexpr.h */

#define COSMOPOLITAN_LIBC_LOG_COUNTEXPR_H_


/*!BEGIN libc/nexgen32e/bench.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BENCH_H_


/*!BEGIN libc/nexgen32e/rdtsc.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_RDTSC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Reads CPU timestamp counter.
 *
 * This macro inhibits compiler magic.
 * This macro does not inhibit CPU magic.
 *
 * @see X86_HAVE(INVTSC)
 */
#define rdtsc() __RDTSC("rdtsc")

/**
 * Reads CPU timestamp counter w/ full serialization.
 *
 * This macro inhibits CPU magic.
 * This macro inhibits compiler magic.
 *
 * The clock isn't read until:
 *
 *   1. previous instructions finish executing; and
 *   2. previous loads are globally visible; and
 *   3. previous stores are globally visible.
 *
 * Later instructions won't dispatch until RDTSC completes.
 *
 * @see X86_HAVE(INVTSC)
 */
#define mfence_lfence_rdtsc_lfence() \
  __RDTSC("mfence\n\tlfence\n\trdtsc\n\tlfence")

#define __RDTSC(ASM)                                                       \
  ({                                                                       \
    uint64_t Rax, Rdx;                                                     \
    asm volatile(ASM : "=a"(Rax), "=d"(Rdx) : /* no inputs */ : "memory"); \
    Rdx << 32 | Rax;                                                       \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview NexGen32e Microbenchmarking.
 *
 * @see X86_HAVE(INVTSC)
 * @see libc/testlib/bench.h
 */

#define __startbench()                            \
  ({                                              \
    uint64_t Ticks;                               \
    asm volatile("lfence\n\t"                     \
                 "push\t%%rbx\n\t"                \
                 "cpuid\n\t"                      \
                 "pop\t%%rbx\n\t"                 \
                 "rdtsc\n\t"                      \
                 "shl\t%2,%%rdx\n\t"              \
                 "or\t%%rdx,%0"                   \
                 : "=a"(Ticks)                    \
                 : "0"(0), "J"(32)                \
                 : "rcx", "rdx", "memory", "cc"); \
    Ticks;                                        \
  })

#define __endbench()                                     \
  ({                                                     \
    uint64_t Ticks;                                      \
    asm volatile("rdtscp\n\t"                            \
                 "shl\t%1,%%rdx\n\t"                     \
                 "or\t%%rdx,%%rax\n\t"                   \
                 "mov\t%%rax,%0\n\t"                     \
                 "xor\t%%eax,%%eax\n\t"                  \
                 "push\t%%rbx\n\t"                       \
                 "cpuid\n\t"                             \
                 "pop\t%%rbx"                            \
                 : "=r"(Ticks)                           \
                 : "J"(32)                               \
                 : "rax", "rcx", "rdx", "memory", "cc"); \
    Ticks;                                               \
  })

#define __startbench_m() mfence_lfence_rdtsc_lfence()
#define __endbench_m()   __startbench_m()
#define __marker()       asm("nop")
#define __ordered()      asm volatile("" ::: "memory")
#define __fakeread(X)    asm volatile("" : /* no outputs */ : "g"(X))
#define __fakereadwrite(X)                 \
  ({                                       \
    autotype(X) Res = (X);                 \
    asm volatile("" : "=g"(Res) : "0"(X)); \
    Res;                                   \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/bsr.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BSR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int bsr(int) pureconst;
int bsrl(long) pureconst;
int bsrll(long long) pureconst;
int bsr128(uint128_t) pureconst;

#if defined(__GNUC__) && defined(__x86_64__) && !defined(__STRICT_ANSI__)
#define bsr(u)                                                  \
  ({                                                            \
    unsigned BiTs;                                              \
    asm("bsr\t%0,%0" : "=r"(BiTs) : "0"((unsigned)(u)) : "cc"); \
    BiTs;                                                       \
  })
#define bsrl(u)                                                      \
  ({                                                                 \
    unsigned long BiTs;                                              \
    asm("bsr\t%0,%0" : "=r"(BiTs) : "0"((unsigned long)(u)) : "cc"); \
    (unsigned)BiTs;                                                  \
  })
#define bsrll(u) bsrl(u)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Shows nanosecond timings histogram for expr at exit().
 */
#define COUNTEXPR(expr)                                                \
  COUNTEXPR_(expr, #expr, STRINGIFY(__FILE__), __LINE__, rdtsc, rdtsc, \
             "COUNTEXPR")

/**
 * Like COUNTEXPR() but can be used on function calls that return void.
 */
#define COUNTSTMT(stmt)                                                    \
  (void)COUNTEXPR_((stmt, 0), #stmt, STRINGIFY(__FILE__), __LINE__, rdtsc, \
                   rdtsc, "COUNTSTMT")

/**
 * Same as COUNTEXPR() but uses Intel's expensive measurement technique.
 */
#define BENCHEXPR(expr)                                                \
  COUNTEXPR_(expr, #expr, STRINGIFY(__FILE__), __LINE__, __startbench, \
             __endbench, "BENCHEXPR")

#define COUNTEXPR_(expr, code, file, line, start, stop, macro) \
  COUNTEXPR__(expr, STRINGIFY(code), file, line, start, stop, STRINGIFY(macro))

#define COUNTEXPR__(expr, code, file, line, start, stop, macro) \
  ({                                                            \
    struct countexpr *InfO;                                     \
    uint64_t t1_, t2_, TiCkS, NaNoS;                            \
    t1_ = start();                                              \
    asm volatile("" ::: "memory");                              \
    autotype(expr) ReS = (expr);                                \
    asm volatile("" ::: "memory");                              \
    t2_ = stop();                                               \
    TiCkS = t2_ >= t1_ ? t2_ - t1_ : ~t1_ + t2_ + 1;            \
    asm(".section .rodata.str1.1,\"aMS\",@progbits,1\n\t"       \
        ".align\t1\n"                                           \
        "31340:\t.asciz\t" file "\n\t"                          \
        "31338:\t.asciz\t" code "\n"                            \
        "31332:\t.asciz\t" macro "\n"                           \
        ".previous\n\t"                                         \
        ".section .yoink\n\t"                                   \
        "nopl\tcountexpr_data(%%rip)\n\t"                       \
        ".previous\n\t"                                         \
        ".section .sort.data.countexpr.2,\"a\",@progbits\n\t"   \
        ".align\t8\n31337:\t"                                   \
        ".quad\t" #line "\n\t"                                  \
        ".quad\t31340b\n\t"                                     \
        ".quad\t31338b\n\t"                                     \
        ".quad\t31332b\n\t"                                     \
        ".rept\t65\n\t"                                         \
        ".quad\t0\n\t"                                          \
        ".endr\n\t"                                             \
        ".previous\n\t"                                         \
        "lea\t31337b(%%rip),%0"                                 \
        : "=r"(InfO));                                          \
    /* approximation of round(x*.323018) which is usually */    \
    /* the ratio, between x86 rdtsc ticks and nanoseconds */    \
    NaNoS = (TiCkS * 338709) >> 20;                             \
    ++InfO->logos[NaNoS ? bsrl(NaNoS) + 1 : 0];                 \
    ReS;                                                        \
  })

struct countexpr {
  long line; /* zero for last entry */
  const char *file;
  const char *code;
  const char *macro;
  long logos[65];
};

extern struct countexpr countexpr_data[];

void countexpr_report(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/gdb.h */

#define COSMOPOLITAN_LIBC_LOG_GDB_H_


/*!BEGIN libc/sysv/consts/nr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_NR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long __NR_exit;
extern const long __NR_exit_group;
extern const long __NR_read;
extern const long __NR_write;
extern const long __NR_open;
extern const long __NR_close;
extern const long __NR_stat;
extern const long __NR_fstat;
extern const long __NR_lstat;
extern const long __NR_poll;
extern const long __NR_ppoll;
extern const long __NR_lseek;
extern const long __NR_mmap;
extern const long __NR_msync;
extern const long __NR_mprotect;
extern const long __NR_munmap;
extern const long __NR_sigaction;
extern const long __NR_sigprocmask;
extern const long __NR_ioctl;
extern const long __NR_pread;
extern const long __NR_pwrite;
extern const long __NR_readv;
extern const long __NR_writev;
extern const long __NR_access;
extern const long __NR_pipe;
extern const long __NR_select;
extern const long __NR_pselect;
extern const long __NR_pselect6;
extern const long __NR_sched_yield;
extern const long __NR_mremap;
extern const long __NR_mincore;
extern const long __NR_madvise;
extern const long __NR_shmget;
extern const long __NR_shmat;
extern const long __NR_shmctl;
extern const long __NR_dup;
extern const long __NR_dup2;
extern const long __NR_pause;
extern const long __NR_nanosleep;
extern const long __NR_getitimer;
extern const long __NR_setitimer;
extern const long __NR_alarm;
extern const long __NR_getpid;
extern const long __NR_sendfile;
extern const long __NR_socket;
extern const long __NR_connect;
extern const long __NR_accept;
extern const long __NR_sendto;
extern const long __NR_recvfrom;
extern const long __NR_sendmsg;
extern const long __NR_recvmsg;
extern const long __NR_shutdown;
extern const long __NR_bind;
extern const long __NR_listen;
extern const long __NR_getsockname;
extern const long __NR_getpeername;
extern const long __NR_socketpair;
extern const long __NR_setsockopt;
extern const long __NR_getsockopt;
extern const long __NR_fork;
extern const long __NR_vfork;
extern const long __NR_posix_spawn;
extern const long __NR_execve;
extern const long __NR_wait4;
extern const long __NR_kill;
extern const long __NR_killpg;
extern const long __NR_clone;
extern const long __NR_tkill;
extern const long __NR_futex;
extern const long __NR_set_robust_list;
extern const long __NR_get_robust_list;
extern const long __NR_uname;
extern const long __NR_semget;
extern const long __NR_semop;
extern const long __NR_semctl;
extern const long __NR_shmdt;
extern const long __NR_msgget;
extern const long __NR_msgsnd;
extern const long __NR_msgrcv;
extern const long __NR_msgctl;
extern const long __NR_fcntl;
extern const long __NR_flock;
extern const long __NR_fsync;
extern const long __NR_fdatasync;
extern const long __NR_truncate;
extern const long __NR_ftruncate;
extern const long __NR_getcwd;
extern const long __NR_chdir;
extern const long __NR_fchdir;
extern const long __NR_rename;
extern const long __NR_mkdir;
extern const long __NR_rmdir;
extern const long __NR_creat;
extern const long __NR_link;
extern const long __NR_unlink;
extern const long __NR_symlink;
extern const long __NR_readlink;
extern const long __NR_chmod;
extern const long __NR_fchmod;
extern const long __NR_chown;
extern const long __NR_fchown;
extern const long __NR_lchown;
extern const long __NR_umask;
extern const long __NR_gettimeofday;
extern const long __NR_getrlimit;
extern const long __NR_getrusage;
extern const long __NR_sysinfo;
extern const long __NR_times;
extern const long __NR_ptrace;
extern const long __NR_syslog;
extern const long __NR_getuid;
extern const long __NR_getgid;
extern const long __NR_getppid;
extern const long __NR_getpgrp;
extern const long __NR_setsid;
extern const long __NR_getsid;
extern const long __NR_getpgid;
extern const long __NR_setpgid;
extern const long __NR_geteuid;
extern const long __NR_getegid;
extern const long __NR_getgroups;
extern const long __NR_setgroups;
extern const long __NR_setreuid;
extern const long __NR_setregid;
extern const long __NR_setuid;
extern const long __NR_setgid;
extern const long __NR_setresuid;
extern const long __NR_setresgid;
extern const long __NR_getresuid;
extern const long __NR_getresgid;
extern const long __NR_sigpending;
extern const long __NR_sigsuspend;
extern const long __NR_sigaltstack;
extern const long __NR_mknod;
extern const long __NR_mknodat;
extern const long __NR_mkfifo;
extern const long __NR_mkfifoat;
extern const long __NR_statfs;
extern const long __NR_fstatfs;
extern const long __NR_getpriority;
extern const long __NR_setpriority;
extern const long __NR_mlock;
extern const long __NR_munlock;
extern const long __NR_mlockall;
extern const long __NR_munlockall;
extern const long __NR_setrlimit;
extern const long __NR_chroot;
extern const long __NR_sync;
extern const long __NR_acct;
extern const long __NR_settimeofday;
extern const long __NR_mount;
extern const long __NR_reboot;
extern const long __NR_quotactl;
extern const long __NR_setfsuid;
extern const long __NR_setfsgid;
extern const long __NR_capget;
extern const long __NR_capset;
extern const long __NR_sigtimedwait;
extern const long __NR_rt_sigqueueinfo;
extern const long __NR_personality;
extern const long __NR_ustat;
extern const long __NR_sysfs;
extern const long __NR_sched_setparam;
extern const long __NR_sched_getparam;
extern const long __NR_sched_setscheduler;
extern const long __NR_sched_getscheduler;
extern const long __NR_sched_get_priority_max;
extern const long __NR_sched_get_priority_min;
extern const long __NR_sched_rr_get_interval;
extern const long __NR_vhangup;
extern const long __NR_modify_ldt;
extern const long __NR_pivot_root;
extern const long __NR__sysctl;
extern const long __NR_prctl;
extern const long __NR_arch_prctl;
extern const long __NR_adjtimex;
extern const long __NR_umount2;
extern const long __NR_swapon;
extern const long __NR_swapoff;
extern const long __NR_sethostname;
extern const long __NR_setdomainname;
extern const long __NR_iopl;
extern const long __NR_ioperm;
extern const long __NR_init_module;
extern const long __NR_delete_module;
extern const long __NR_gettid;
extern const long __NR_readahead;
extern const long __NR_setxattr;
extern const long __NR_fsetxattr;
extern const long __NR_getxattr;
extern const long __NR_fgetxattr;
extern const long __NR_listxattr;
extern const long __NR_flistxattr;
extern const long __NR_removexattr;
extern const long __NR_fremovexattr;
extern const long __NR_lsetxattr;
extern const long __NR_lgetxattr;
extern const long __NR_llistxattr;
extern const long __NR_lremovexattr;
extern const long __NR_sched_setaffinity;
extern const long __NR_sched_getaffinity;
extern const long __NR_cpuset_getaffinity;
extern const long __NR_cpuset_setaffinity;
extern const long __NR_io_setup;
extern const long __NR_io_destroy;
extern const long __NR_io_getevents;
extern const long __NR_io_submit;
extern const long __NR_io_cancel;
extern const long __NR_lookup_dcookie;
extern const long __NR_epoll_create;
extern const long __NR_epoll_wait;
extern const long __NR_epoll_ctl;
extern const long __NR_getdents;
extern const long __NR_set_tid_address;
extern const long __NR_restart_syscall;
extern const long __NR_semtimedop;
extern const long __NR_fadvise;
extern const long __NR_timer_create;
extern const long __NR_timer_settime;
extern const long __NR_timer_gettime;
extern const long __NR_timer_getoverrun;
extern const long __NR_timer_delete;
extern const long __NR_clock_settime;
extern const long __NR_clock_gettime;
extern const long __NR_clock_getres;
extern const long __NR_clock_nanosleep;
extern const long __NR_tgkill;
extern const long __NR_mbind;
extern const long __NR_set_mempolicy;
extern const long __NR_get_mempolicy;
extern const long __NR_mq_open;
extern const long __NR_mq_unlink;
extern const long __NR_mq_timedsend;
extern const long __NR_mq_timedreceive;
extern const long __NR_mq_notify;
extern const long __NR_mq_getsetattr;
extern const long __NR_kexec_load;
extern const long __NR_waitid;
extern const long __NR_add_key;
extern const long __NR_request_key;
extern const long __NR_keyctl;
extern const long __NR_ioprio_set;
extern const long __NR_ioprio_get;
extern const long __NR_inotify_init;
extern const long __NR_inotify_add_watch;
extern const long __NR_inotify_rm_watch;
extern const long __NR_openat;
extern const long __NR_mkdirat;
extern const long __NR_fchownat;
extern const long __NR_utime;
extern const long __NR_utimes;
extern const long __NR_futimesat;
extern const long __NR_futimes;
extern const long __NR_futimens;
extern const long __NR_fstatat;
extern const long __NR_unlinkat;
extern const long __NR_renameat;
extern const long __NR_linkat;
extern const long __NR_symlinkat;
extern const long __NR_readlinkat;
extern const long __NR_fchmodat;
extern const long __NR_faccessat;
extern const long __NR_unshare;
extern const long __NR_splice;
extern const long __NR_tee;
extern const long __NR_sync_file_range;
extern const long __NR_vmsplice;
extern const long __NR_migrate_pages;
extern const long __NR_move_pages;
extern const long __NR_preadv;
extern const long __NR_pwritev;
extern const long __NR_utimensat;
extern const long __NR_fallocate;
extern const long __NR_posix_fallocate;
extern const long __NR_accept4;
extern const long __NR_dup3;
extern const long __NR_pipe2;
extern const long __NR_epoll_pwait;
extern const long __NR_epoll_create1;
extern const long __NR_perf_event_open;
extern const long __NR_inotify_init1;
extern const long __NR_rt_tgsigqueueinfo;
extern const long __NR_signalfd;
extern const long __NR_signalfd4;
extern const long __NR_eventfd;
extern const long __NR_eventfd2;
extern const long __NR_timerfd_create;
extern const long __NR_timerfd_settime;
extern const long __NR_timerfd_gettime;
extern const long __NR_recvmmsg;
extern const long __NR_fanotify_init;
extern const long __NR_fanotify_mark;
extern const long __NR_prlimit;
extern const long __NR_name_to_handle_at;
extern const long __NR_open_by_handle_at;
extern const long __NR_clock_adjtime;
extern const long __NR_syncfs;
extern const long __NR_sendmmsg;
extern const long __NR_setns;
extern const long __NR_getcpu;
extern const long __NR_process_vm_readv;
extern const long __NR_process_vm_writev;
extern const long __NR_kcmp;
extern const long __NR_finit_module;
extern const long __NR_sched_setattr;
extern const long __NR_sched_getattr;
extern const long __NR_renameat2;
extern const long __NR_seccomp;
extern const long __NR_getrandom;
extern const long __NR_memfd_create;
extern const long __NR_kexec_file_load;
extern const long __NR_bpf;
extern const long __NR_execveat;
extern const long __NR_userfaultfd;
extern const long __NR_membarrier;
extern const long __NR_mlock2;
extern const long __NR_copy_file_range;
extern const long __NR_preadv2;
extern const long __NR_pwritev2;
extern const long __NR_pkey_mprotect;
extern const long __NR_pkey_alloc;
extern const long __NR_pkey_free;
extern const long __NR_statx;
extern const long __NR_io_pgetevents;
extern const long __NR_rseq;
extern const long __NR_pidfd_send_signal;
extern const long __NR_io_uring_setup;
extern const long __NR_io_uring_enter;
extern const long __NR_io_uring_register;
extern const long __NR_pledge;
extern const long __NR_msyscall;
extern const long __NR_ktrace;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define __NR_exit                   SYMBOLIC(__NR_exit)
#define __NR_exit_group             SYMBOLIC(__NR_exit_group)
#define __NR_read                   SYMBOLIC(__NR_read)
#define __NR_write                  SYMBOLIC(__NR_write)
#define __NR_open                   SYMBOLIC(__NR_open)
#define __NR_close                  SYMBOLIC(__NR_close)
#define __NR_stat                   SYMBOLIC(__NR_stat)
#define __NR_fstat                  SYMBOLIC(__NR_fstat)
#define __NR_lstat                  SYMBOLIC(__NR_lstat)
#define __NR_poll                   SYMBOLIC(__NR_poll)
#define __NR_ppoll                  SYMBOLIC(__NR_ppoll)
#define __NR_lseek                  SYMBOLIC(__NR_lseek)
#define __NR_mmap                   SYMBOLIC(__NR_mmap)
#define __NR_msync                  SYMBOLIC(__NR_msync)
#define __NR_mprotect               SYMBOLIC(__NR_mprotect)
#define __NR_munmap                 SYMBOLIC(__NR_munmap)
#define __NR_sigaction              SYMBOLIC(__NR_sigaction)
#define __NR_sigprocmask            SYMBOLIC(__NR_sigprocmask)
#define __NR_ioctl                  SYMBOLIC(__NR_ioctl)
#define __NR_pread                  SYMBOLIC(__NR_pread)
#define __NR_pwrite                 SYMBOLIC(__NR_pwrite)
#define __NR_readv                  SYMBOLIC(__NR_readv)
#define __NR_writev                 SYMBOLIC(__NR_writev)
#define __NR_access                 SYMBOLIC(__NR_access)
#define __NR_pipe                   SYMBOLIC(__NR_pipe)
#define __NR_select                 SYMBOLIC(__NR_select)
#define __NR_pselect                SYMBOLIC(__NR_pselect)
#define __NR_pselect6               SYMBOLIC(__NR_pselect6)
#define __NR_sched_yield            SYMBOLIC(__NR_sched_yield)
#define __NR_mremap                 SYMBOLIC(__NR_mremap)
#define __NR_mincore                SYMBOLIC(__NR_mincore)
#define __NR_madvise                SYMBOLIC(__NR_madvise)
#define __NR_shmget                 SYMBOLIC(__NR_shmget)
#define __NR_shmat                  SYMBOLIC(__NR_shmat)
#define __NR_shmctl                 SYMBOLIC(__NR_shmctl)
#define __NR_dup                    SYMBOLIC(__NR_dup)
#define __NR_dup2                   SYMBOLIC(__NR_dup2)
#define __NR_pause                  SYMBOLIC(__NR_pause)
#define __NR_nanosleep              SYMBOLIC(__NR_nanosleep)
#define __NR_getitimer              SYMBOLIC(__NR_getitimer)
#define __NR_setitimer              SYMBOLIC(__NR_setitimer)
#define __NR_alarm                  SYMBOLIC(__NR_alarm)
#define __NR_getpid                 SYMBOLIC(__NR_getpid)
#define __NR_sendfile               SYMBOLIC(__NR_sendfile)
#define __NR_socket                 SYMBOLIC(__NR_socket)
#define __NR_connect                SYMBOLIC(__NR_connect)
#define __NR_accept                 SYMBOLIC(__NR_accept)
#define __NR_sendto                 SYMBOLIC(__NR_sendto)
#define __NR_recvfrom               SYMBOLIC(__NR_recvfrom)
#define __NR_sendmsg                SYMBOLIC(__NR_sendmsg)
#define __NR_recvmsg                SYMBOLIC(__NR_recvmsg)
#define __NR_shutdown               SYMBOLIC(__NR_shutdown)
#define __NR_bind                   SYMBOLIC(__NR_bind)
#define __NR_listen                 SYMBOLIC(__NR_listen)
#define __NR_getsockname            SYMBOLIC(__NR_getsockname)
#define __NR_getpeername            SYMBOLIC(__NR_getpeername)
#define __NR_socketpair             SYMBOLIC(__NR_socketpair)
#define __NR_setsockopt             SYMBOLIC(__NR_setsockopt)
#define __NR_getsockopt             SYMBOLIC(__NR_getsockopt)
#define __NR_fork                   SYMBOLIC(__NR_fork)
#define __NR_vfork                  SYMBOLIC(__NR_vfork)
#define __NR_posix_spawn            SYMBOLIC(__NR_posix_spawn)
#define __NR_execve                 LITERALLY(0x003b)
#define __NR_wait4                  SYMBOLIC(__NR_wait4)
#define __NR_kill                   SYMBOLIC(__NR_kill)
#define __NR_killpg                 SYMBOLIC(__NR_killpg)
#define __NR_clone                  SYMBOLIC(__NR_clone)
#define __NR_tkill                  SYMBOLIC(__NR_tkill)
#define __NR_futex                  SYMBOLIC(__NR_futex)
#define __NR_set_robust_list        SYMBOLIC(__NR_set_robust_list)
#define __NR_get_robust_list        SYMBOLIC(__NR_get_robust_list)
#define __NR_uname                  SYMBOLIC(__NR_uname)
#define __NR_semget                 SYMBOLIC(__NR_semget)
#define __NR_semop                  SYMBOLIC(__NR_semop)
#define __NR_semctl                 SYMBOLIC(__NR_semctl)
#define __NR_shmdt                  SYMBOLIC(__NR_shmdt)
#define __NR_msgget                 SYMBOLIC(__NR_msgget)
#define __NR_msgsnd                 SYMBOLIC(__NR_msgsnd)
#define __NR_msgrcv                 SYMBOLIC(__NR_msgrcv)
#define __NR_msgctl                 SYMBOLIC(__NR_msgctl)
#define __NR_fcntl                  SYMBOLIC(__NR_fcntl)
#define __NR_flock                  SYMBOLIC(__NR_flock)
#define __NR_fsync                  SYMBOLIC(__NR_fsync)
#define __NR_fdatasync              SYMBOLIC(__NR_fdatasync)
#define __NR_truncate               SYMBOLIC(__NR_truncate)
#define __NR_ftruncate              SYMBOLIC(__NR_ftruncate)
#define __NR_getcwd                 SYMBOLIC(__NR_getcwd)
#define __NR_chdir                  SYMBOLIC(__NR_chdir)
#define __NR_fchdir                 SYMBOLIC(__NR_fchdir)
#define __NR_rename                 SYMBOLIC(__NR_rename)
#define __NR_mkdir                  SYMBOLIC(__NR_mkdir)
#define __NR_rmdir                  SYMBOLIC(__NR_rmdir)
#define __NR_creat                  SYMBOLIC(__NR_creat)
#define __NR_link                   SYMBOLIC(__NR_link)
#define __NR_unlink                 SYMBOLIC(__NR_unlink)
#define __NR_symlink                SYMBOLIC(__NR_symlink)
#define __NR_readlink               SYMBOLIC(__NR_readlink)
#define __NR_chmod                  SYMBOLIC(__NR_chmod)
#define __NR_fchmod                 SYMBOLIC(__NR_fchmod)
#define __NR_chown                  SYMBOLIC(__NR_chown)
#define __NR_fchown                 SYMBOLIC(__NR_fchown)
#define __NR_lchown                 SYMBOLIC(__NR_lchown)
#define __NR_umask                  SYMBOLIC(__NR_umask)
#define __NR_gettimeofday           SYMBOLIC(__NR_gettimeofday)
#define __NR_getrlimit              SYMBOLIC(__NR_getrlimit)
#define __NR_getrusage              SYMBOLIC(__NR_getrusage)
#define __NR_sysinfo                SYMBOLIC(__NR_sysinfo)
#define __NR_times                  SYMBOLIC(__NR_times)
#define __NR_ptrace                 SYMBOLIC(__NR_ptrace)
#define __NR_syslog                 SYMBOLIC(__NR_syslog)
#define __NR_getuid                 SYMBOLIC(__NR_getuid)
#define __NR_getgid                 SYMBOLIC(__NR_getgid)
#define __NR_getppid                SYMBOLIC(__NR_getppid)
#define __NR_getpgrp                SYMBOLIC(__NR_getpgrp)
#define __NR_setsid                 SYMBOLIC(__NR_setsid)
#define __NR_getsid                 SYMBOLIC(__NR_getsid)
#define __NR_getpgid                SYMBOLIC(__NR_getpgid)
#define __NR_setpgid                SYMBOLIC(__NR_setpgid)
#define __NR_geteuid                SYMBOLIC(__NR_geteuid)
#define __NR_getegid                SYMBOLIC(__NR_getegid)
#define __NR_getgroups              SYMBOLIC(__NR_getgroups)
#define __NR_setgroups              SYMBOLIC(__NR_setgroups)
#define __NR_setreuid               SYMBOLIC(__NR_setreuid)
#define __NR_setregid               SYMBOLIC(__NR_setregid)
#define __NR_setuid                 SYMBOLIC(__NR_setuid)
#define __NR_setgid                 SYMBOLIC(__NR_setgid)
#define __NR_setresuid              SYMBOLIC(__NR_setresuid)
#define __NR_setresgid              SYMBOLIC(__NR_setresgid)
#define __NR_getresuid              SYMBOLIC(__NR_getresuid)
#define __NR_getresgid              SYMBOLIC(__NR_getresgid)
#define __NR_sigpending             SYMBOLIC(__NR_sigpending)
#define __NR_sigsuspend             SYMBOLIC(__NR_sigsuspend)
#define __NR_sigaltstack            SYMBOLIC(__NR_sigaltstack)
#define __NR_mknod                  SYMBOLIC(__NR_mknod)
#define __NR_mknodat                SYMBOLIC(__NR_mknodat)
#define __NR_mkfifo                 SYMBOLIC(__NR_mkfifo)
#define __NR_mkfifoat               SYMBOLIC(__NR_mkfifoat)
#define __NR_statfs                 SYMBOLIC(__NR_statfs)
#define __NR_fstatfs                SYMBOLIC(__NR_fstatfs)
#define __NR_getpriority            SYMBOLIC(__NR_getpriority)
#define __NR_setpriority            SYMBOLIC(__NR_setpriority)
#define __NR_mlock                  SYMBOLIC(__NR_mlock)
#define __NR_munlock                SYMBOLIC(__NR_munlock)
#define __NR_mlockall               SYMBOLIC(__NR_mlockall)
#define __NR_munlockall             SYMBOLIC(__NR_munlockall)
#define __NR_setrlimit              SYMBOLIC(__NR_setrlimit)
#define __NR_chroot                 SYMBOLIC(__NR_chroot)
#define __NR_sync                   SYMBOLIC(__NR_sync)
#define __NR_acct                   SYMBOLIC(__NR_acct)
#define __NR_settimeofday           SYMBOLIC(__NR_settimeofday)
#define __NR_mount                  SYMBOLIC(__NR_mount)
#define __NR_reboot                 SYMBOLIC(__NR_reboot)
#define __NR_quotactl               SYMBOLIC(__NR_quotactl)
#define __NR_setfsuid               SYMBOLIC(__NR_setfsuid)
#define __NR_setfsgid               SYMBOLIC(__NR_setfsgid)
#define __NR_capget                 SYMBOLIC(__NR_capget)
#define __NR_capset                 SYMBOLIC(__NR_capset)
#define __NR_sigtimedwait           SYMBOLIC(__NR_sigtimedwait)
#define __NR_rt_sigqueueinfo        SYMBOLIC(__NR_rt_sigqueueinfo)
#define __NR_personality            SYMBOLIC(__NR_personality)
#define __NR_ustat                  SYMBOLIC(__NR_ustat)
#define __NR_sysfs                  SYMBOLIC(__NR_sysfs)
#define __NR_sched_setparam         SYMBOLIC(__NR_sched_setparam)
#define __NR_sched_getparam         SYMBOLIC(__NR_sched_getparam)
#define __NR_sched_setscheduler     SYMBOLIC(__NR_sched_setscheduler)
#define __NR_sched_getscheduler     SYMBOLIC(__NR_sched_getscheduler)
#define __NR_sched_get_priority_max SYMBOLIC(__NR_sched_get_priority_max)
#define __NR_sched_get_priority_min SYMBOLIC(__NR_sched_get_priority_min)
#define __NR_sched_rr_get_interval  SYMBOLIC(__NR_sched_rr_get_interval)
#define __NR_vhangup                SYMBOLIC(__NR_vhangup)
#define __NR_modify_ldt             SYMBOLIC(__NR_modify_ldt)
#define __NR_pivot_root             SYMBOLIC(__NR_pivot_root)
#define __NR__sysctl                SYMBOLIC(__NR__sysctl)
#define __NR_prctl                  SYMBOLIC(__NR_prctl)
#define __NR_arch_prctl             SYMBOLIC(__NR_arch_prctl)
#define __NR_adjtimex               SYMBOLIC(__NR_adjtimex)
#define __NR_umount2                SYMBOLIC(__NR_umount2)
#define __NR_swapon                 SYMBOLIC(__NR_swapon)
#define __NR_swapoff                SYMBOLIC(__NR_swapoff)
#define __NR_sethostname            SYMBOLIC(__NR_sethostname)
#define __NR_setdomainname          SYMBOLIC(__NR_setdomainname)
#define __NR_iopl                   SYMBOLIC(__NR_iopl)
#define __NR_ioperm                 SYMBOLIC(__NR_ioperm)
#define __NR_init_module            SYMBOLIC(__NR_init_module)
#define __NR_delete_module          SYMBOLIC(__NR_delete_module)
#define __NR_gettid                 SYMBOLIC(__NR_gettid)
#define __NR_readahead              SYMBOLIC(__NR_readahead)
#define __NR_setxattr               SYMBOLIC(__NR_setxattr)
#define __NR_fsetxattr              SYMBOLIC(__NR_fsetxattr)
#define __NR_getxattr               SYMBOLIC(__NR_getxattr)
#define __NR_fgetxattr              SYMBOLIC(__NR_fgetxattr)
#define __NR_listxattr              SYMBOLIC(__NR_listxattr)
#define __NR_flistxattr             SYMBOLIC(__NR_flistxattr)
#define __NR_removexattr            SYMBOLIC(__NR_removexattr)
#define __NR_fremovexattr           SYMBOLIC(__NR_fremovexattr)
#define __NR_lsetxattr              SYMBOLIC(__NR_lsetxattr)
#define __NR_lgetxattr              SYMBOLIC(__NR_lgetxattr)
#define __NR_llistxattr             SYMBOLIC(__NR_llistxattr)
#define __NR_lremovexattr           SYMBOLIC(__NR_lremovexattr)
#define __NR_sched_setaffinity      SYMBOLIC(__NR_sched_setaffinity)
#define __NR_sched_getaffinity      SYMBOLIC(__NR_sched_getaffinity)
#define __NR_cpuset_getaffinity     SYMBOLIC(__NR_cpuset_getaffinity)
#define __NR_cpuset_setaffinity     SYMBOLIC(__NR_cpuset_setaffinity)
#define __NR_io_setup               SYMBOLIC(__NR_io_setup)
#define __NR_io_destroy             SYMBOLIC(__NR_io_destroy)
#define __NR_io_getevents           SYMBOLIC(__NR_io_getevents)
#define __NR_io_submit              SYMBOLIC(__NR_io_submit)
#define __NR_io_cancel              SYMBOLIC(__NR_io_cancel)
#define __NR_lookup_dcookie         SYMBOLIC(__NR_lookup_dcookie)
#define __NR_epoll_create           SYMBOLIC(__NR_epoll_create)
#define __NR_epoll_wait             SYMBOLIC(__NR_epoll_wait)
#define __NR_epoll_ctl              SYMBOLIC(__NR_epoll_ctl)
#define __NR_getdents               SYMBOLIC(__NR_getdents)
#define __NR_set_tid_address        SYMBOLIC(__NR_set_tid_address)
#define __NR_restart_syscall        SYMBOLIC(__NR_restart_syscall)
#define __NR_semtimedop             SYMBOLIC(__NR_semtimedop)
#define __NR_fadvise                SYMBOLIC(__NR_fadvise)
#define __NR_timer_create           SYMBOLIC(__NR_timer_create)
#define __NR_timer_settime          SYMBOLIC(__NR_timer_settime)
#define __NR_timer_gettime          SYMBOLIC(__NR_timer_gettime)
#define __NR_timer_getoverrun       SYMBOLIC(__NR_timer_getoverrun)
#define __NR_timer_delete           SYMBOLIC(__NR_timer_delete)
#define __NR_clock_settime          SYMBOLIC(__NR_clock_settime)
#define __NR_clock_gettime          SYMBOLIC(__NR_clock_gettime)
#define __NR_clock_getres           SYMBOLIC(__NR_clock_getres)
#define __NR_clock_nanosleep        SYMBOLIC(__NR_clock_nanosleep)
#define __NR_tgkill                 SYMBOLIC(__NR_tgkill)
#define __NR_mbind                  SYMBOLIC(__NR_mbind)
#define __NR_set_mempolicy          SYMBOLIC(__NR_set_mempolicy)
#define __NR_get_mempolicy          SYMBOLIC(__NR_get_mempolicy)
#define __NR_mq_open                SYMBOLIC(__NR_mq_open)
#define __NR_mq_unlink              SYMBOLIC(__NR_mq_unlink)
#define __NR_mq_timedsend           SYMBOLIC(__NR_mq_timedsend)
#define __NR_mq_timedreceive        SYMBOLIC(__NR_mq_timedreceive)
#define __NR_mq_notify              SYMBOLIC(__NR_mq_notify)
#define __NR_mq_getsetattr          SYMBOLIC(__NR_mq_getsetattr)
#define __NR_kexec_load             SYMBOLIC(__NR_kexec_load)
#define __NR_waitid                 SYMBOLIC(__NR_waitid)
#define __NR_add_key                SYMBOLIC(__NR_add_key)
#define __NR_request_key            SYMBOLIC(__NR_request_key)
#define __NR_keyctl                 SYMBOLIC(__NR_keyctl)
#define __NR_ioprio_set             SYMBOLIC(__NR_ioprio_set)
#define __NR_ioprio_get             SYMBOLIC(__NR_ioprio_get)
#define __NR_inotify_init           SYMBOLIC(__NR_inotify_init)
#define __NR_inotify_add_watch      SYMBOLIC(__NR_inotify_add_watch)
#define __NR_inotify_rm_watch       SYMBOLIC(__NR_inotify_rm_watch)
#define __NR_openat                 SYMBOLIC(__NR_openat)
#define __NR_mkdirat                SYMBOLIC(__NR_mkdirat)
#define __NR_fchownat               SYMBOLIC(__NR_fchownat)
#define __NR_utime                  SYMBOLIC(__NR_utime)
#define __NR_utimes                 SYMBOLIC(__NR_utimes)
#define __NR_futimesat              SYMBOLIC(__NR_futimesat)
#define __NR_futimes                SYMBOLIC(__NR_futimes)
#define __NR_futimens               SYMBOLIC(__NR_futimens)
#define __NR_fstatat                SYMBOLIC(__NR_fstatat)
#define __NR_unlinkat               SYMBOLIC(__NR_unlinkat)
#define __NR_renameat               SYMBOLIC(__NR_renameat)
#define __NR_linkat                 SYMBOLIC(__NR_linkat)
#define __NR_symlinkat              SYMBOLIC(__NR_symlinkat)
#define __NR_readlinkat             SYMBOLIC(__NR_readlinkat)
#define __NR_fchmodat               SYMBOLIC(__NR_fchmodat)
#define __NR_faccessat              SYMBOLIC(__NR_faccessat)
#define __NR_unshare                SYMBOLIC(__NR_unshare)
#define __NR_splice                 SYMBOLIC(__NR_splice)
#define __NR_tee                    SYMBOLIC(__NR_tee)
#define __NR_sync_file_range        SYMBOLIC(__NR_sync_file_range)
#define __NR_vmsplice               SYMBOLIC(__NR_vmsplice)
#define __NR_migrate_pages          SYMBOLIC(__NR_migrate_pages)
#define __NR_move_pages             SYMBOLIC(__NR_move_pages)
#define __NR_preadv                 SYMBOLIC(__NR_preadv)
#define __NR_pwritev                SYMBOLIC(__NR_pwritev)
#define __NR_utimensat              SYMBOLIC(__NR_utimensat)
#define __NR_fallocate              SYMBOLIC(__NR_fallocate)
#define __NR_posix_fallocate        SYMBOLIC(__NR_posix_fallocate)
#define __NR_accept4                SYMBOLIC(__NR_accept4)
#define __NR_dup3                   SYMBOLIC(__NR_dup3)
#define __NR_pipe2                  SYMBOLIC(__NR_pipe2)
#define __NR_epoll_pwait            SYMBOLIC(__NR_epoll_pwait)
#define __NR_epoll_create1          SYMBOLIC(__NR_epoll_create1)
#define __NR_perf_event_open        SYMBOLIC(__NR_perf_event_open)
#define __NR_inotify_init1          SYMBOLIC(__NR_inotify_init1)
#define __NR_rt_tgsigqueueinfo      SYMBOLIC(__NR_rt_tgsigqueueinfo)
#define __NR_signalfd               SYMBOLIC(__NR_signalfd)
#define __NR_signalfd4              SYMBOLIC(__NR_signalfd4)
#define __NR_eventfd                SYMBOLIC(__NR_eventfd)
#define __NR_eventfd2               SYMBOLIC(__NR_eventfd2)
#define __NR_timerfd_create         SYMBOLIC(__NR_timerfd_create)
#define __NR_timerfd_settime        SYMBOLIC(__NR_timerfd_settime)
#define __NR_timerfd_gettime        SYMBOLIC(__NR_timerfd_gettime)
#define __NR_recvmmsg               SYMBOLIC(__NR_recvmmsg)
#define __NR_fanotify_init          SYMBOLIC(__NR_fanotify_init)
#define __NR_fanotify_mark          SYMBOLIC(__NR_fanotify_mark)
#define __NR_prlimit                SYMBOLIC(__NR_prlimit)
#define __NR_name_to_handle_at      SYMBOLIC(__NR_name_to_handle_at)
#define __NR_open_by_handle_at      SYMBOLIC(__NR_open_by_handle_at)
#define __NR_clock_adjtime          SYMBOLIC(__NR_clock_adjtime)
#define __NR_syncfs                 SYMBOLIC(__NR_syncfs)
#define __NR_sendmmsg               SYMBOLIC(__NR_sendmmsg)
#define __NR_setns                  SYMBOLIC(__NR_setns)
#define __NR_getcpu                 SYMBOLIC(__NR_getcpu)
#define __NR_process_vm_readv       SYMBOLIC(__NR_process_vm_readv)
#define __NR_process_vm_writev      SYMBOLIC(__NR_process_vm_writev)
#define __NR_kcmp                   SYMBOLIC(__NR_kcmp)
#define __NR_finit_module           SYMBOLIC(__NR_finit_module)
#define __NR_sched_setattr          SYMBOLIC(__NR_sched_setattr)
#define __NR_sched_getattr          SYMBOLIC(__NR_sched_getattr)
#define __NR_renameat2              SYMBOLIC(__NR_renameat2)
#define __NR_seccomp                SYMBOLIC(__NR_seccomp)
#define __NR_getrandom              SYMBOLIC(__NR_getrandom)
#define __NR_memfd_create           SYMBOLIC(__NR_memfd_create)
#define __NR_kexec_file_load        SYMBOLIC(__NR_kexec_file_load)
#define __NR_bpf                    SYMBOLIC(__NR_bpf)
#define __NR_execveat               SYMBOLIC(__NR_execveat)
#define __NR_userfaultfd            SYMBOLIC(__NR_userfaultfd)
#define __NR_membarrier             SYMBOLIC(__NR_membarrier)
#define __NR_mlock2                 SYMBOLIC(__NR_mlock2)
#define __NR_copy_file_range        SYMBOLIC(__NR_copy_file_range)
#define __NR_preadv2                SYMBOLIC(__NR_preadv2)
#define __NR_pwritev2               SYMBOLIC(__NR_pwritev2)
#define __NR_pkey_mprotect          SYMBOLIC(__NR_pkey_mprotect)
#define __NR_pkey_alloc             SYMBOLIC(__NR_pkey_alloc)
#define __NR_pkey_free              SYMBOLIC(__NR_pkey_free)
#define __NR_statx                  SYMBOLIC(__NR_statx)
#define __NR_io_pgetevents          SYMBOLIC(__NR_io_pgetevents)
#define __NR_rseq                   SYMBOLIC(__NR_rseq)
#define __NR_pidfd_send_signal      SYMBOLIC(__NR_pidfd_send_signal)
#define __NR_io_uring_setup         SYMBOLIC(__NR_io_uring_setup)
#define __NR_io_uring_enter         SYMBOLIC(__NR_io_uring_enter)
#define __NR_pledge                 SYMBOLIC(__NR_pledge)
#define __NR_msyscall               SYMBOLIC(__NR_msyscall)
#define __NR_ktrace                 SYMBOLIC(__NR_ktrace)



/*!BEGIN libc/sysv/consts/w.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_W_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int WNOHANG;
extern const int WUNTRACED;
extern const int WCONTINUED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define WNOHANG    LITERALLY(1)
#define WUNTRACED  SYMBOLIC(WUNTRACED)
#define WCONTINUED SYMBOLIC(WCONTINUED)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview GDB Attach Support Code.
 *
 * The goal of these macros is to make the backtrace into the failing
 * code as short as possible. It also helps avoid GDB getting confused
 * about how we don't use its readability destroying unwind directives.
 */

extern volatile int g_gdbsync;

int gdbexec(const char *);
int AttachDebugger(intptr_t);

#define AttachDebugger(CONTINUE_TO_ADDR) /* shorten backtraces */ \
  SYNCHRONIZE_DEBUGGER((AttachDebugger)(CONTINUE_TO_ADDR))

#define SYNCHRONIZE_DEBUGGER(PID)                                    \
  ({                                                                 \
    int Rc, Pid = (PID);                                             \
    if (Pid != -1) {                                                 \
      while ((Rc = __inline_wait4(Pid, NULL, WNOHANG, NULL)) == 0) { \
        if (g_gdbsync) {                                             \
          g_gdbsync = 0;                                             \
          if (Rc > 0) Pid = 0;                                       \
          break;                                                     \
        } else {                                                     \
          sched_yield();                                             \
        }                                                            \
      }                                                              \
    }                                                                \
    Pid;                                                             \
  })

#define __inline_wait4(PID, OPT_OUT_WSTATUS, OPTIONS, OPT_OUT_RUSAGE)     \
  ({                                                                      \
    int64_t WaAx;                                                         \
    if (!IsWindows()) {                                                   \
      asm volatile("mov\t%5,%%r10\n\t"                                    \
                   "syscall"                                              \
                   : "=a"(WaAx)                                           \
                   : "0"(__NR_wait4), "D"(PID), "S"(OPT_OUT_WSTATUS),     \
                     "d"(OPTIONS), "g"(OPT_OUT_RUSAGE)                    \
                   : "rcx", "r8", "r9", "r10", "r11", "memory", "cc");    \
    } else {                                                              \
      WaAx = sys_wait4_nt(PID, OPT_OUT_WSTATUS, OPTIONS, OPT_OUT_RUSAGE); \
    }                                                                     \
    WaAx;                                                                 \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/log.h */

#define COSMOPOLITAN_LIBC_LOG_LOG_H_


/*!BEGIN libc/nexgen32e/stackframe.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_STACKFRAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct StackFrame {
  struct StackFrame *next;
  intptr_t addr;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/runtime.h */

#define COSMOPOLITAN_LIBC_RUNTIME_RUNTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § runtime                                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef long jmp_buf[8];

extern char **environ;                              /* CRT */
extern int __argc;                                  /* CRT */
extern char **__argv;                               /* CRT */
extern char **__envp;                               /* CRT */
extern unsigned long *__auxv;                       /* CRT */
extern intptr_t __oldstack;                         /* CRT */
extern uint64_t __nosync;                           /* SYS */
extern _Atomic(int) __ftrace;                       /* SYS */
extern _Atomic(int) __strace;                       /* SYS */
extern char *program_invocation_name;               /* RII */
extern char *program_invocation_short_name;         /* RII */
extern uint64_t __syscount;                         /* RII */
extern uint64_t kStartTsc;                          /* RII */
extern char kTmpPath[];                             /* RII */
extern const char kNtSystemDirectory[];             /* RII */
extern const char kNtWindowsDirectory[];            /* RII */
extern unsigned char _base[] forcealign(PAGESIZE);  /* αpε */
extern unsigned char _ehead[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _etext[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _edata[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _ezip[];                       /* αpε */
extern unsigned char _end[] forcealign(FRAMESIZE);  /* αpε */
extern unsigned char _ereal[];                      /* αpε */
extern unsigned char __privileged_start[];          /* αpε */
extern unsigned char __privileged_addr[];           /* αpε */
extern unsigned char __privileged_size[];           /* αpε */
extern unsigned char __privileged_end[];            /* αpε */
extern unsigned char __test_start[];                /* αpε */
extern unsigned char __ro[];                        /* αpε */
extern unsigned char *__relo_start[];               /* αpε */
extern unsigned char *__relo_end[];                 /* αpε */
extern uint8_t __zip_start[];                       /* αpε */
extern uint8_t __zip_end[];                         /* αpε */
extern uint8_t __data_start[];                      /* αpε */
extern uint8_t __data_end[];                        /* αpε */
extern uint8_t __bss_start[];                       /* αpε */
extern uint8_t __bss_end[];                         /* αpε */
extern size_t __virtualmax;
extern bool __isworker;

void mcount(void);
int _freestack(void *);
unsigned long getauxval(unsigned long);
void *_mapanon(size_t) attributeallocsize((1)) mallocesque;
void *_mapshared(size_t) attributeallocsize((1)) mallocesque;
void *_mapstack(void) returnsaligned((FRAMESIZE)) mallocesque;
int setjmp(jmp_buf) libcesque returnstwice paramsnonnull();
void longjmp(jmp_buf, int) libcesque wontreturn paramsnonnull();
axdx_t setlongerjmp(jmp_buf) libcesque returnstwice paramsnonnull();
void longerjmp(jmp_buf, intptr_t) libcesque wontreturn paramsnonnull();
int _setjmp(jmp_buf) libcesque returnstwice paramsnonnull();
void _longjmp(jmp_buf, int) libcesque wontreturn paramsnonnull();
void exit(int) wontreturn;
void _exit(int) libcesque wontreturn;
void _Exit(int) libcesque wontreturn;
void _Exit1(int) libcesque wontreturn;
void quick_exit(int) wontreturn;
void abort(void) wontreturn noinstrument;
int __cxa_atexit(void *, void *, void *) libcesque;
int atfork(void *, void *) libcesque;
int atexit(void (*)(void)) libcesque;
char *getenv(const char *) nosideeffect libcesque;
int putenv(char *) paramsnonnull();
int setenv(const char *, const char *, int) paramsnonnull();
int unsetenv(const char *);
int clearenv(void);
void fpreset(void);
void *mmap(void *, uint64_t, int32_t, int32_t, int32_t, int64_t);
void *mremap(void *, size_t, size_t, int, ...);
int munmap(void *, uint64_t);
int mprotect(void *, uint64_t, int) privileged;
int msync(void *, size_t, int);
void *sbrk(intptr_t);
int brk(void *);
long fpathconf(int, int);
long pathconf(const char *, int);
int getgroups(int, uint32_t[]);
long gethostid(void);
int sethostid(long);
char *getlogin(void);
int getlogin_r(char *, size_t);
int lchown(const char *, uint32_t, uint32_t);
int getpagesize(void);
int syncfs(int);
int vhangup(void);
int getdtablesize(void);
int sethostname(const char *, size_t);
int acct(const char *);
void longsort(long *, size_t);

bool _isheap(void *);
int NtGetVersion(void) pureconst;
long missingno();
void __oom_hook(size_t);
void _loadxmm(void *);
void _peekall(void);
void _savexmm(void *);
void _weakfree(void *);
void free_s(void *) paramsnonnull() libcesque;
int close_s(int *) paramsnonnull() libcesque;
int OpenExecutable(void);
int ftrace_install(void);
long GetResourceLimit(int);
long GetMaxFd(void);
char *GetProgramExecutableName(void);
char *GetInterpreterExecutableName(char *, size_t);
void __printargs(const char *);
void __paginate(int, const char *);
int __arg_max(void);
void __morph_begin(void);
void __morph_end(void);
unsigned char *GetFirstInstruction(void);
unsigned char *GetInstructionLengths(void);
void __print_maps(void);
void __warn_if_powersave(void);
const char *__describe_os(void);
bool IsDynamicExecutable(const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kLogFatal   0
#define kLogError   1
#define kLogWarn    2
#define kLogInfo    3
#define kLogVerbose 4
#define kLogDebug   5
#define kLogNoise   6

/**
 * Log level for compile-time DCE.
 */
#ifndef LOGGABLELEVEL
#ifndef TINY
#define LOGGABLELEVEL kLogNoise
/* #elif IsTiny() */
/* #define LOGGABLELEVEL kLogInfo */
#else
#define LOGGABLELEVEL kLogVerbose
#endif
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern FILE *__log_file;

void __die(void) relegated wontreturn; /* print backtrace and abort() */
void meminfo(int);                     /* shows malloc statistics &c. */
void memsummary(int);                  /* light version of same thing */
uint16_t getttycols(uint16_t);
int getttysize(int, struct winsize *) paramsnonnull();
bool IsTerminalInarticulate(void) nosideeffect;
const char *commandvenv(const char *, const char *);
const char *GetAddr2linePath(void);
const char *GetGdbPath(void);
const char *GetCallerName(const struct StackFrame *);

void ShowCrashReports(void);
void callexitontermination(struct sigset *);
bool32 IsDebuggerPresent(bool);
bool IsRunningUnderMake(void);
const char *GetSiCodeName(int, int);
void AppendResourceReport(char **, struct rusage *, const char *);
char *__get_symbol_by_addr(int64_t);
void PrintGarbage(void);
void PrintGarbageNumeric(FILE *);
void CheckForMemoryLeaks(void);

#define showcrashreports() ShowCrashReports()

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » logging                                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#ifndef __STRICT_ANSI__

extern unsigned __log_level; /* log level for runtime check */

#define LOGGABLE(LEVEL)                                          \
  ((!__builtin_constant_p(LEVEL) || (LEVEL) <= LOGGABLELEVEL) && \
   (LEVEL) <= __log_level)

// log a message with the specified log level (not checking if LOGGABLE)
#define LOGF(LEVEL, FMT, ...)                                   \
  do {                                                          \
    if (!IsTiny()) --__ftrace;                                  \
    flogf(LEVEL, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    if (!IsTiny()) ++__ftrace;                                  \
  } while (0)

// report an error without backtrace and debugger invocation
#define FATALF(FMT, ...)                                            \
  do {                                                              \
    if (!IsTiny()) --__ftrace;                                      \
    flogf(kLogError, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    __restorewintty();                                              \
    _Exit(1);                                                       \
    unreachable;                                                    \
  } while (0)

#define DIEF(FMT, ...)                                                \
  do {                                                                \
    if (!IsTiny()) --__ftrace;                                        \
    ffatalf(kLogFatal, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    unreachable;                                                      \
  } while (0)

#define ERRORF(FMT, ...)                   \
  do {                                     \
    if (LOGGABLE(kLogError)) {             \
      LOGF(kLogError, FMT, ##__VA_ARGS__); \
    }                                      \
  } while (0)

#define WARNF(FMT, ...)                   \
  do {                                    \
    if (LOGGABLE(kLogWarn)) {             \
      LOGF(kLogWarn, FMT, ##__VA_ARGS__); \
    }                                     \
  } while (0)

#define INFOF(FMT, ...)                   \
  do {                                    \
    if (LOGGABLE(kLogInfo)) {             \
      LOGF(kLogInfo, FMT, ##__VA_ARGS__); \
    }                                     \
  } while (0)

#define VERBOSEF(FMT, ...)                                                  \
  do {                                                                      \
    if (LOGGABLE(kLogVerbose)) {                                            \
      if (!IsTiny()) --__ftrace;                                            \
      fverbosef(kLogVerbose, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                            \
    }                                                                       \
  } while (0)

#define DEBUGF(FMT, ...)                                                \
  do {                                                                  \
    if (UNLIKELY(LOGGABLE(kLogDebug))) {                                \
      if (!IsTiny()) --__ftrace;                                        \
      fdebugf(kLogDebug, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                        \
    }                                                                   \
  } while (0)

#define NOISEF(FMT, ...)                                                \
  do {                                                                  \
    if (UNLIKELY(LOGGABLE(kLogNoise))) {                                \
      if (!IsTiny()) --__ftrace;                                        \
      fnoisef(kLogNoise, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                        \
    }                                                                   \
  } while (0)

#define FLOGF(F, FMT, ...)                                        \
  do {                                                            \
    if (LOGGABLE(kLogInfo)) {                                     \
      if (!IsTiny()) --__ftrace;                                  \
      flogf(kLogInfo, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                  \
    }                                                             \
  } while (0)

#define FWARNF(F, FMT, ...)                                       \
  do {                                                            \
    if (LOGGABLE(kLogWarn)) {                                     \
      if (!IsTiny()) --__ftrace;                                  \
      flogf(kLogWarn, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                  \
    }                                                             \
  } while (0)

#define FFATALF(F, FMT, ...)                                     \
  do {                                                           \
    if (!IsTiny()) --__ftrace;                                   \
    flogf(kLogError, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
    __restorewintty();                                           \
    _Exit(1);                                                    \
    unreachable;                                                 \
  } while (0)

#define FDEBUGF(F, FMT, ...)                                         \
  do {                                                               \
    if (UNLIKELY(LOGGABLE(kLogDebug))) {                             \
      if (!IsTiny()) --__ftrace;                                     \
      fdebugf(kLogDebug, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                     \
    }                                                                \
  } while (0)

#define FNOISEF(F, FMT, ...)                                         \
  do {                                                               \
    if (UNLIKELY(LOGGABLE(kLogNoise))) {                             \
      if (!IsTiny()) --__ftrace;                                     \
      fnoisef(kLogNoise, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
      if (!IsTiny()) ++__ftrace;                                     \
    }                                                                \
  } while (0)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » on error resume next                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LOGIFNEG1(FORM)                                           \
  ({                                                              \
    int e = errno;                                                \
    autotype(FORM) Ax = (FORM);                                   \
    if (UNLIKELY(Ax == (typeof(Ax))(-1)) && LOGGABLE(kLogWarn)) { \
      if (!IsTiny()) --__ftrace;                                  \
      __logerrno(__FILE__, __LINE__, #FORM);                      \
      if (!IsTiny()) ++__ftrace;                                  \
      errno = e;                                                  \
    }                                                             \
    Ax;                                                           \
  })

#define LOGIFNULL(FORM)                      \
  ({                                         \
    int e = errno;                           \
    autotype(FORM) Ax = (FORM);              \
    if (Ax == NULL && LOGGABLE(kLogWarn)) {  \
      if (!IsTiny()) --__ftrace;             \
      __logerrno(__FILE__, __LINE__, #FORM); \
      if (!IsTiny()) ++__ftrace;             \
      errno = e;                             \
    }                                        \
    Ax;                                      \
  })

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » implementation details                           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void __logerrno(const char *, int, const char *) relegated;

#define ARGS  unsigned, const char *, int, FILE *, const char *
#define ATTR  paramsnonnull((5)) printfesque(5)
#define ATTRV paramsnonnull((5, 6))
void flogf(ARGS, ...) ATTR libcesque;
void vflogf(ARGS, va_list) ATTRV libcesque;
void fverbosef(ARGS, ...) asm("flogf") ATTR relegated libcesque;
void vfverbosef(ARGS, va_list) asm("vflogf") ATTRV relegated libcesque;
void fdebugf(ARGS, ...) asm("flogf") ATTR relegated libcesque;
void vfdebugf(ARGS, va_list) asm("vflogf") ATTRV relegated libcesque;
void fnoisef(ARGS, ...) asm("flogf") ATTR relegated libcesque;
void vfnoisef(ARGS, va_list) asm("vflogf") ATTRV relegated libcesque;
void ffatalf(ARGS, ...) asm("flogf") ATTR relegated wontreturn libcesque;
void vffatalf(ARGS, va_list) asm("vflogf") ATTRV relegated wontreturn libcesque;
#undef ARGS
#undef ATTR
#undef ATTRV

#endif /* __STRICT_ANSI__ */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/rop.h */

#define COSMOPOLITAN_LIBC_LOG_ROP_H_

#define RETURN_ON_ERROR(expr)     \
  do {                            \
    if (UNLIKELY((expr) == -1)) { \
      goto OnError;               \
    }                             \
  } while (0)



/*!BEGIN libc/log/traceme.h */

#define COSMOPOLITAN_LIBC_LOG_TRACEME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern int traceme;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/alg.h */

#define COSMOPOLITAN_LIBC_ALG_ALG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § algorithms                                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void *bsearch(const void *, const void *, size_t, size_t,
              int cmp(const void *, const void *))
    paramsnonnull() dontthrow nosideeffect;
void *bsearch_r(const void *, const void *, size_t, size_t,
                int cmp(const void *, const void *, void *), void *)
    paramsnonnull((1, 2, 5)) dontthrow nosideeffect;
void djbsort(int32_t *, size_t);
void qsort(void *, size_t, size_t, int (*)(const void *, const void *))
    paramsnonnull();
void qsort_r(void *, size_t, size_t,
             int cmp(const void *, const void *, void *), void *arg)
    paramsnonnull((1, 4));
int tarjan(int, const int (*)[2], int, int[], int[], int *)
    paramsnonnull((2, 4)) nocallback dontthrow;

#define __algalloc returnspointerwithnoaliases dontthrow nocallback dontdiscard

char *replacestr(const char *, const char *, const char *)
    paramsnonnull() __algalloc;
char16_t *replacestr16(const char16_t *, const char16_t *, const char16_t *)
    paramsnonnull() __algalloc;
wchar_t *replacewcs(const wchar_t *, const wchar_t *, const wchar_t *)
    paramsnonnull() __algalloc;

char *concatstr(const char *, ...) nullterminated() paramsnonnull() __algalloc;
char16_t *concatstr16(const char16_t *, ...) nullterminated()
    paramsnonnull() __algalloc;
wchar_t *concatwcs(const wchar_t *, ...) nullterminated()
    paramsnonnull() __algalloc;

int cmpsb(const void *, const void *);
int cmpub(const void *, const void *);
int cmpsw(const void *, const void *);
int cmpuw(const void *, const void *);
int cmpsl(const void *, const void *);
int cmpul(const void *, const void *);
int cmpsq(const void *, const void *);
int cmpuq(const void *, const void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/alloca.h */

#define COSMOPOLITAN_LIBC_MEM_ALLOCA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define alloca(size) __builtin_alloca(size)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/arena.h */

#define COSMOPOLITAN_LIBC_MEM_ARENA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void __arena_push(void);
void __arena_pop(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/critbit0.h */

#define COSMOPOLITAN_LIBC_ALG_CRITBIT0_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § data structures » critical bit tree (for c strings)       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

struct critbit0 {
  void *root;
  size_t count;
};

bool critbit0_contains(struct critbit0 *, const char *) dontthrow nosideeffect
    paramsnonnull();
int critbit0_insert(struct critbit0 *, const char *) paramsnonnull();
bool critbit0_delete(struct critbit0 *, const char *) dontthrow paramsnonnull();
void critbit0_clear(struct critbit0 *) dontthrow paramsnonnull();
char *critbit0_get(struct critbit0 *, const char *);
intptr_t critbit0_allprefixed(struct critbit0 *, const char *,
                              intptr_t (*)(const char *, void *), void *)
    paramsnonnull((1, 2, 3)) dontthrow;
int critbit0_emplace(struct critbit0 *, char *, size_t) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/fmt.h */

#define COSMOPOLITAN_LIBC_MEM_FMT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int asprintf(char **, const char *, ...) printfesque(2)
    paramsnonnull((1, 2)) libcesque;
int vasprintf(char **, const char *, va_list) paramsnonnull() libcesque;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define asprintf(SP, FMT, ...) (asprintf)(SP, PFLINK(FMT), ##__VA_ARGS__)
#define vasprintf(SP, FMT, VA) (vasprintf)(SP, PFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/io.h */

#define COSMOPOLITAN_LIBC_MEM_IO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

ssize_t _copyfd(int, int, size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/mem.h */

#define COSMOPOLITAN_LIBC_MEM_MEM_H_

#define M_TRIM_THRESHOLD (-1)
#define M_GRANULARITY    (-2)
#define M_MMAP_THRESHOLD (-3)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dynamic memory                                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void free(void *) libcesque;
void *malloc(size_t) attributeallocsize((1)) mallocesque;
void *calloc(size_t, size_t) attributeallocsize((1, 2)) mallocesque;
void *memalign(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) returnspointerwithnoaliases libcesque dontdiscard;
void *realloc(void *, size_t) reallocesque;
void *realloc_in_place(void *, size_t) reallocesque;
void *reallocarray(void *, size_t, size_t) dontdiscard;
void *valloc(size_t) attributeallocsize((1)) vallocesque;
void *pvalloc(size_t) vallocesque;
char *strdup(const char *) paramsnonnull() mallocesque;
char *strndup(const char *, size_t) paramsnonnull() mallocesque;
void *aligned_alloc(size_t, size_t) attributeallocsize((1))
    attributeallocsize((2)) returnspointerwithnoaliases libcesque dontdiscard;
int posix_memalign(void **, size_t, size_t);
bool __grow(void *, size_t *, size_t, size_t) paramsnonnull((1, 2)) libcesque;

int malloc_trim(size_t);
size_t bulk_free(void **, size_t);
size_t malloc_usable_size(void *);
void **independent_calloc(size_t, size_t, void **);
void **independent_comalloc(size_t, size_t *, void **);

wchar_t *wcsdup(const wchar_t *) strlenesque dontdiscard;

struct mallinfo {
  size_t arena;    /* non-mmapped space allocated from system */
  size_t ordblks;  /* number of free chunks */
  size_t smblks;   /* always 0 */
  size_t hblks;    /* always 0 */
  size_t hblkhd;   /* space in mmapped regions */
  size_t usmblks;  /* maximum total allocated space */
  size_t fsmblks;  /* always 0 */
  size_t uordblks; /* total allocated space */
  size_t fordblks; /* total free space */
  size_t keepcost; /* releasable (via malloc_trim) space */
};

struct mallinfo mallinfo(void);

void malloc_stats(void);
bool32 mallopt(int, int);
size_t malloc_footprint(void);
size_t malloc_max_footprint(void);
size_t malloc_footprint_limit(void);
size_t malloc_set_footprint_limit(size_t);
void malloc_inspect_all(void (*handler)(void *, void *, size_t, void *),
                        void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/bsf.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BSF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int bsf(int) pureconst;
int bsfl(long) pureconst;
int bsfll(long long) pureconst;
int bsf128(uintmax_t) pureconst;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define bsf(u)                                                  \
  ({                                                            \
    unsigned BiTs;                                              \
    asm("bsf\t%0,%0" : "=r"(BiTs) : "0"((unsigned)(u)) : "cc"); \
    BiTs;                                                       \
  })
#define bsfl(u)                                                      \
  ({                                                                 \
    unsigned long BiTs;                                              \
    asm("bsf\t%0,%0" : "=r"(BiTs) : "0"((unsigned long)(u)) : "cc"); \
    (unsigned)BiTs;                                                  \
  })
#define bsfll(u) bsfl(u)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/cachesize.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_CACHESIZE_H_

#define kCpuCacheTypeData        1
#define kCpuCacheTypeInstruction 2
#define kCpuCacheTypeUnified     3

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned getcachesize(int, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/crc32.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_CRC32_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint32_t kCrc32cTab[256];

void crc32init(uint32_t[hasatleast 256], uint32_t);
uint32_t crc32a(uint32_t, const void *, size_t);
uint32_t crc32c(uint32_t, const void *, size_t);
uint32_t crc32_z(uint32_t, const void *, size_t);
uint32_t crc32c_pure(uint32_t, const void *, size_t) strlenesque hidden;
uint32_t crc32c_sse42(uint32_t, const void *, size_t) strlenesque hidden;
uint32_t crc32_pclmul(uint32_t, const void *, size_t) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/ffs.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_FFS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
 * BIT SCANNING 101
 *                          ctz(𝑥)         31^clz(𝑥)   clz(𝑥)
 *      uint32 𝑥   bsf(𝑥) tzcnt(𝑥)   ffs(𝑥)   bsr(𝑥) lzcnt(𝑥)
 *    0x00000000      wut       32        0      wut       32
 *    0x00000001        0        0        1        0       31
 *    0x80000001        0        0        1       31        0
 *    0x80000000       31       31       32       31        0
 *    0x00000010        4        4        5        4       27
 *    0x08000010        4        4        5       27        4
 *    0x08000000       27       27       28       27        4
 *    0xffffffff        0        0        1       31        0
 */

int ffs(int) pureconst;
int ffsl(long) pureconst;
int ffsll(long long) pureconst;

#ifdef __GNUC__
#define ffs(u)   __builtin_ffs(u)
#define ffsl(u)  __builtin_ffsl(u)
#define ffsll(u) __builtin_ffsll(u)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/gettls.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_GETTLS_H_


/*!BEGIN libc/nexgen32e/threaded.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_THREADED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern int __threaded;
extern bool __tls_enabled;
extern unsigned __tls_index;

void *__initialize_tls(char[64]);
void __install_tls(char[64]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if defined(__GNUC__) && defined(__x86_64__) && !defined(__STRICT_ANSI__)
/**
 * Returns location of thread information block.
 *
 * This can't be used in privileged functions.
 */
static noasan inline char *__get_tls(void) {
  char *tib;
  asm("mov\t%%fs:0,%0" : "=r"(tib) : /* no inputs */ : "memory");
  return tib;
}
#endif /* GNU x86-64 */

#if defined(__GNUC__) && defined(__x86_64__) && !defined(__STRICT_ANSI__)
/**
 * Returns location of thread information block.
 *
 * This should be favored over __get_tls() for .privileged code that
 * can't be self-modified by __enable_tls().
 */
static noasan inline char *__get_tls_privileged(void) {
  char *tib, *lin = (char *)0x30;
  if (IsLinux() || IsFreebsd() || IsNetbsd() || IsOpenbsd()) {
    asm("mov\t%%fs:(%1),%0" : "=a"(tib) : "r"(lin) : "memory");
  } else {
    asm("mov\t%%gs:(%1),%0" : "=a"(tib) : "r"(lin) : "memory");
    if (IsWindows()) {
      tib = *(char **)(tib + 0x1480 + __tls_index * 8);
    }
  }
  return tib;
}
#endif /* GNU x86-64 */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/kompressor.h */

#define COSMOPOLITAN_LIBC_KOMPRESSOR_KOMPRESSOR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
#if 0
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard library » compression                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#endif

struct RlDecode {
  uint8_t repititions;
  uint8_t byte;
};

void rldecode(void *dest, const struct RlDecode *) hidden;
void rldecode2(void *dest, const struct RlDecode *) hidden;
const uint8_t *lz4check(const void *data) hidden;
void *lz4cpy(void *dest, const void *blockdata, size_t blocksize) hidden;
void *lz4decode(void *dest, const void *src) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/lz4.h */

#define COSMOPOLITAN_LIBC_LZ4_H_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4                                                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  LZ4 is a framing format for REP MOVSB designed by Yann Collet.

  @see https://github.com/lz4/lz4/blob/master/doc/lz4_Frame_format.md
  @see https://github.com/lz4/lz4/blob/master/doc/lz4_Block_format.md
  @see http://ticki.github.io/blog/how-lz4-works/ */

#define LZ4_EOF                0
#define LZ4_VERSION            1
#define LZ4_MAGICNUMBER        0x184D2204
#define LZ4_SKIPPABLE0         0x184D2A50
#define LZ4_SKIPPABLEMASK      0xFFFFFFF0
#define LZ4_MAXHEADERSIZE      (MAGICNUMBER_SIZE + 2 + 8 + 4 + 1)
#define LZ4_BLOCKMAXSIZE_64KB  4
#define LZ4_BLOCKMAXSIZE_256KB 5
#define LZ4_BLOCKMAXSIZE_1MB   6
#define LZ4_BLOCKMAXSIZE_4MB   7

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4 » frames                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LZ4_MAGIC(FRAME)                      READ32LE(FRAME)
#define LZ4_FRAME_VERSION(FRAME)              ((_LZ4_FRAME_FLG(FRAME) >> 6) & 3)
#define LZ4_FRAME_BLOCKINDEPENDENCE(FRAME)    ((_LZ4_FRAME_FLG(FRAME) >> 5) & 1)
#define LZ4_FRAME_BLOCKCHECKSUMFLAG(FRAME)    ((_LZ4_FRAME_FLG(FRAME) >> 4) & 1)
#define LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) ((_LZ4_FRAME_FLG(FRAME) >> 3) & 1)
#define LZ4_FRAME_BLOCKCONTENTCHECKSUMFLAG(FRAME) \
  ((_LZ4_FRAME_FLG(FRAME) >> 2) & 1)
#define LZ4_FRAME_DICTIONARYIDFLAG(FRAME) ((_LZ4_FRAME_FLG(FRAME) >> 0) & 1)
#define LZ4_FRAME_BLOCKMAXSIZE(FRAME)     ((_LZ4_FRAME_BD(FRAME) >> 4) & 7)
#define LZ4_FRAME_RESERVED1(FRAME)        ((_LZ4_FRAME_FLG(FRAME) >> 1) & 1)
#define LZ4_FRAME_RESERVED2(FRAME)        ((_LZ4_FRAME_BD(FRAME) >> 7) & 1)
#define LZ4_FRAME_RESERVED3(FRAME)        ((_LZ4_FRAME_BD(FRAME) >> 0) & 15)
#define LZ4_FRAME_BLOCKCONTENTSIZE(FRAME) \
  (LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) ? READ64LE((FRAME) + 4 + 1 + 1) : 0)
#define LZ4_FRAME_DICTIONARYID(FRAME)                          \
  (LZ4_FRAME_DICTIONARYIDFLAG(FRAME)                           \
       ? READ32LE(((FRAME) + 4 + 1 + 1 +                       \
                   8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME))) \
       : 0)
#define LZ4_FRAME_HEADERCHECKSUM(FRAME)                                \
  (*((FRAME) + 4 + 1 + 1 + 8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) + \
     4 * LZ4_FRAME_DICTIONARYIDFLAG(FRAME)))
#define LZ4_FRAME_HEADERSIZE(FRAME)                        \
  (4 + 1 + 1 + 8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) + \
   4 * LZ4_FRAME_DICTIONARYIDFLAG(FRAME) + 1)
#define _LZ4_FRAME_FLG(FRAME) (*((FRAME) + 4))
#define _LZ4_FRAME_BD(FRAME)  (*((FRAME) + 5))

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4 » blocks                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LZ4_BLOCK_DATA(block)         (block + sizeof(uint32_t))
#define LZ4_BLOCK_DATASIZE(block)     (READ32LE(block) & 0x7fffffff)
#define LZ4_BLOCK_ISEOF(block)        (READ32LE(block) == LZ4_EOF)
#define LZ4_BLOCK_ISCOMPRESSED(block) ((READ32LE(block) & 0x80000000) == 0)
#define LZ4_BLOCK_SIZE(frame, block)              \
  (sizeof(uint32_t) + LZ4_BLOCK_DATASIZE(block) + \
   (LZ4_FRAME_BLOCKCHECKSUMFLAG(frame) ? sizeof(uint8_t) : 0))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/macros.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_MACROS_H_
#ifdef __ASSEMBLER__
#else

/* let's give auto-import tooling a helping hand */
#define pbroadcastb pbroadcastb

#endif /* __ASSEMBLER__ */


/*!BEGIN libc/nexgen32e/msr.h */

#define COSMOPOLITAN_LIBC_MSR_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § model specific registers                                      │
╚─────────────────────────────────────────────────────────────────────────────*/

#define MSR_P5_TSC 0x10       /* time stamp register */
#define MSR_P5_CESR 0x11      /* control and event select register */
#define MSR_P5_CTR0 0x12      /* counter #0 */
#define MSR_P5_CTR1 0x13      /* counter #1 */
#define MSR_P5_CESR_PC 0x0200 /* pin control */
#define MSR_P5_CESR_CC 0x01C0 /* counter control mask */
#define MSR_P5_CESR_ES 0x003F /* event control mask */
#define MSR_P5_CESR_SHIFT 16  /* shift to get counter 1 */
#define MSR_P5_CESR_MASK      /* mask Counter */ \
  (MSR_P5_CESR_PC | MSR_P5_CESR_CC | MSR_P5_CESR_ES)

#define MSR_CORE_THREAD_COUNT 0x35
#define MSR_FLEX_RATIO 0x194
#define MSR_IA32_APERF 0xE8
#define MSR_IA32_APIC_BASE 0x1b
#define MSR_IA32_APIC_BASE_BASE (0xfffff << 12)
#define MSR_IA32_APIC_BASE_BSP (1 << 8)
#define MSR_IA32_APIC_BASE_ENABLE (1 << 11)
#define MSR_IA32_APIC_BASE_EXTENDED (1 << 10)
#define MSR_IA32_BBL_CR_CTL 0x119
#define MSR_IA32_BIOS_SIGN_ID 0x8b
#define MSR_IA32_CLOCK_MODULATION 0x19a
#define MSR_IA32_CORE_C3_RESIDENCY 0x3FC
#define MSR_IA32_CORE_C6_RESIDENCY 0x3FD
#define MSR_IA32_CORE_C7_RESIDENCY 0x3FE
#define MSR_IA32_CR_PAT 0x277
#define MSR_IA32_CSTAR 0xC0000083
#define MSR_IA32_DDR_ENERGY_STATUS 0x619
#define MSR_IA32_DEBUGCTLMSR 0x1d9
#define MSR_IA32_DS_AREA 0x600
#define MSR_IA32_EBL_CR_POWERON 0x2a
#define MSR_IA32_EFER 0xC0000080
#define MSR_IA32_EFER_LMA 0x00000400
#define MSR_IA32_EFER_LME 0x00000100
#define MSR_IA32_EFER_NXE 0x00000800
#define MSR_IA32_EFER_SCE 0x00000001
#define MSR_IA32_EVNTSEL0 0x186
#define MSR_IA32_EVNTSEL1 0x187
#define MSR_IA32_EVNTSEL2 0x188
#define MSR_IA32_EVNTSEL3 0x189
#define MSR_IA32_FEATCTL_CSTATE_SMI (1 << 16)
#define MSR_IA32_FEATCTL_LOCK (1 << 0)
#define MSR_IA32_FEATCTL_VMXON (1 << 2)
#define MSR_IA32_FEATCTL_VMXON_SMX (1 << 1)
#define MSR_IA32_FEATURE_CONTROL 0x3a
#define MSR_IA32_FMASK 0xC0000084
#define MSR_IA32_FS_BASE 0xC0000100
#define MSR_IA32_GS_BASE 0xC0000101
#define MSR_IA32_GS_BASE_KERNEL 0xC0000102
#define MSR_IA32_GT_PERF_LIMIT_REASONS 0x6B0
#define MSR_IA32_IA_PERF_LIMIT_REASONS 0x690
#define MSR_IA32_IA_PERF_LIMIT_REASONS_SKL 0x64F
#define MSR_IA32_LASTBRANCHFROMIP 0x1db
#define MSR_IA32_LASTBRANCHTOIP 0x1dc
#define MSR_IA32_LASTINTFROMIP 0x1dd
#define MSR_IA32_LASTINTTOIP 0x1de
#define MSR_IA32_LLC_FLUSHED_RESIDENCY_TIMER 0x61D
#define MSR_IA32_LSTAR 0xC0000082
#define MSR_IA32_MC0_ADDR 0x402
#define MSR_IA32_MC0_CTL 0x400
#define MSR_IA32_MC0_MISC 0x403
#define MSR_IA32_MC0_STATUS 0x401
#define MSR_IA32_MCG_CAP 0x179
#define MSR_IA32_MCG_CTL 0x17b
#define MSR_IA32_MCG_STATUS 0x17a
#define MSR_IA32_MISC_ENABLE 0x1a0
#define MSR_IA32_MPERF 0xE7
#define MSR_IA32_MTRRCAP 0xfe
#define MSR_IA32_MTRR_DEF_TYPE 0x2ff
#define MSR_IA32_MTRR_FIX16K_80000 0x258
#define MSR_IA32_MTRR_FIX16K_A0000 0x259
#define MSR_IA32_MTRR_FIX4K_C0000 0x268
#define MSR_IA32_MTRR_FIX4K_C8000 0x269
#define MSR_IA32_MTRR_FIX4K_D0000 0x26a
#define MSR_IA32_MTRR_FIX4K_D8000 0x26b
#define MSR_IA32_MTRR_FIX4K_E0000 0x26c
#define MSR_IA32_MTRR_FIX4K_E8000 0x26d
#define MSR_IA32_MTRR_FIX4K_F0000 0x26e
#define MSR_IA32_MTRR_FIX4K_F8000 0x26f
#define MSR_IA32_MTRR_FIX64K_00000 0x250
#define MSR_IA32_MTRR_PHYSBASE(n) (0x200 + 2 * (n))
#define MSR_IA32_MTRR_PHYSMASK(n) (0x200 + 2 * (n) + 1)
#define MSR_IA32_P5_MC_ADDR 0
#define MSR_IA32_P5_MC_TYPE 1
#define MSR_IA32_PACKAGE_THERM_INTERRUPT 0x1b2
#define MSR_IA32_PACKAGE_THERM_STATUS 0x1b1
#define MSR_IA32_PERFCTR0 0xc1
#define MSR_IA32_PERFCTR1 0xc2
#define MSR_IA32_PERFCTR3 0xc3
#define MSR_IA32_PERFCTR4 0xc4
#define MSR_IA32_PERF_CTL 0x199
#define MSR_IA32_PERF_FIXED_CTR0 0x309
#define MSR_IA32_PERF_FIXED_CTR_CTRL 0x38D
#define MSR_IA32_PERF_GLOBAL_CTRL 0x38F
#define MSR_IA32_PERF_GLOBAL_OVF_CTRL 0x390
#define MSR_IA32_PERF_GLOBAL_STATUS 0x38E
#define MSR_IA32_PERF_STS 0x198
#define MSR_IA32_PKG_C10_RESIDENCY 0x632
#define MSR_IA32_PKG_C2_RESIDENCY 0x60D
#define MSR_IA32_PKG_C3_RESIDENCY 0x3F8
#define MSR_IA32_PKG_C6_RESIDENCY 0x3F9
#define MSR_IA32_PKG_C7_RESIDENCY 0x3FA
#define MSR_IA32_PKG_C8_RESIDENCY 0x630
#define MSR_IA32_PKG_C9_RESIDENCY 0x631
#define MSR_IA32_PKG_ENERGY_STATUS 0x611
#define MSR_IA32_PKG_POWER_SKU_UNIT 0x606
#define MSR_IA32_PLATFORM_ID 0x17
#define MSR_IA32_PP0_ENERGY_STATUS 0x639
#define MSR_IA32_PP1_ENERGY_STATUS 0x641
#define MSR_IA32_RING_PERF_STATUS 0x621
#define MSR_IA32_STAR 0xC0000081
#define MSR_IA32_SYSENTER_CS 0x174
#define MSR_IA32_SYSENTER_EIP 0x176
#define MSR_IA32_SYSENTER_ESP 0x175
#define MSR_IA32_TSC_AUX 0xC0000103
#define MSR_IA32_TSC_DEADLINE 0x6e0
#define MSR_IA32_UCODE_REV MSR_IA32_BIOS_SIGN_ID
#define MSR_IA32_UCODE_WRITE MSR_IA32_UPDT_TRIG
#define MSR_IA32_UPDT_TRIG 0x79
#define MSR_IA32_VMX_BASE 0x480
#define MSR_IA32_VMX_BASIC MSR_IA32_VMX_BASE
#define MSR_IA32_VMX_CR0_FIXED0 MSR_IA32_VMX_BASE + 6
#define MSR_IA32_VMX_CR0_FIXED1 MSR_IA32_VMX_BASE + 7
#define MSR_IA32_VMX_CR4_FIXED0 MSR_IA32_VMX_BASE + 8
#define MSR_IA32_VMX_CR4_FIXED1 MSR_IA32_VMX_BASE + 9
#define MSR_IA32_VMX_ENTRY_CTLS MSR_IA32_VMX_BASE + 4
#define MSR_IA32_VMX_EPT_VPID_CAP MSR_IA32_VMX_BASE + 12
#define MSR_IA32_VMX_EPT_VPID_CAP_AD_SHIFT 21
#define MSR_IA32_VMX_EXIT_CTLS MSR_IA32_VMX_BASE + 3
#define MSR_IA32_VMX_MISC MSR_IA32_VMX_BASE + 5
#define MSR_IA32_VMX_PINBASED_CTLS MSR_IA32_VMX_BASE + 1
#define MSR_IA32_VMX_PROCBASED_CTLS MSR_IA32_VMX_BASE + 2
#define MSR_IA32_VMX_PROCBASED_CTLS2 MSR_IA32_VMX_BASE + 11
#define MSR_IA32_VMX_TRUE_PINBASED_CTLS MSR_IA32_VMX_BASE + 13
#define MSR_IA32_VMX_TRUE_PROCBASED_CTLS MSR_IA32_VMX_BASE + 14
#define MSR_IA32_VMX_TRUE_VMENTRY_CTLS MSR_IA32_VMX_BASE + 16
#define MSR_IA32_VMX_TRUE_VMEXIT_CTLS MSR_IA32_VMX_BASE + 15
#define MSR_IA32_VMX_VMCS_ENUM MSR_IA32_VMX_BASE + 10
#define MSR_IA32_VMX_VMFUNC MSR_IA32_VMX_BASE + 17
#define MSR_P5_CESR_CC_CLOCK 0x0100   /* Clock Counting (otherwise Event) */
#define MSR_P5_CESR_CC_CPL 0x00C0     /* Count regardless of the CPL */
#define MSR_P5_CESR_CC_CPL012 0x0040  /* Count if the CPL == 0, 1, 2 */
#define MSR_P5_CESR_CC_CPL3 0x0080    /* Count if the CPL == 3 */
#define MSR_P5_CESR_CC_DISABLE 0x0000 /* Disable counter */
#define MSR_P5_CESR_ES_AGI 0x011111   /* Stall because of AGI */
#define MSR_P5_CESR_ES_BANK_CONFLICTS 0x001010  /* Bank conflicts */
#define MSR_P5_CESR_ES_BRANCHE 0x010010         /* Branches */
#define MSR_P5_CESR_ES_BRANCHE_BTB 0x010100     /* Taken branch or BTB Hit */
#define MSR_P5_CESR_ES_BREAK_DR0 0x100011       /* Breakpoint matches on DR0 */
#define MSR_P5_CESR_ES_BREAK_DR1 0x100100       /* Breakpoint matches on DR1 */
#define MSR_P5_CESR_ES_BREAK_DR2 0x100101       /* Breakpoint matches on DR2 */
#define MSR_P5_CESR_ES_BREAK_DR3 0x100110       /* Breakpoint matches on DR3 */
#define MSR_P5_CESR_ES_BTB_HIT 0x010011         /* BTB Hits */
#define MSR_P5_CESR_ES_BUS_CYCLE 0x011000       /* Clocks while bus cycle */
#define MSR_P5_CESR_ES_CACHE_SNOOP_HIT 0x001000 /* Data cache snoop hits */
#define MSR_P5_CESR_ES_CODE_CACHE_MISS 0x001110 /* Code Cache miss */
#define MSR_P5_CESR_ES_CODE_READ 0x001100       /* Code Read */
#define MSR_P5_CESR_ES_CODE_TLB_MISS 0x001101   /* Code TLB miss */
#define MSR_P5_CESR_ES_DATA_CACHE_WB 0x000110   /* Cache lines written back */
#define MSR_P5_CESR_ES_DATA_MEM_READ 0x011010   /* Pipeline waiting for read */
#define MSR_P5_CESR_ES_DATA_READ 0x000000       /* Data Read */
#define MSR_P5_CESR_ES_DATA_READ_MISS 0x000011  /* Data Read Miss */
#define MSR_P5_CESR_ES_DATA_RW 0x101000         /* Data Read or Write */
#define MSR_P5_CESR_ES_DATA_RW_MISS 0x101001    /* Data Read or Write Miss */
#define MSR_P5_CESR_ES_DATA_TLB_MISS 0x000010   /* Data TLB Miss */
#define MSR_P5_CESR_ES_DATA_WRITE 0x000001      /* Data Write */
#define MSR_P5_CESR_ES_DATA_WRITE_MISS 0x000100 /* Data Write Miss */
#define MSR_P5_CESR_ES_EXTERNAL_SNOOP 0x000111  /* External Snoop */
#define MSR_P5_CESR_ES_FLOP 0x100010            /* Floating Point operations */
#define MSR_P5_CESR_ES_FULL_WRITE_BUF 0x011001  /* Clocks while full wrt buf */
#define MSR_P5_CESR_ES_HARDWARE_IT 0x100111     /* Hardware interrupts */
#define MSR_P5_CESR_ES_HIT_EM 0x000101          /* Write (hit) to M|E state */
#define MSR_P5_CESR_ES_INSTRUCTION 0x010110     /* Instruction executed */
#define MSR_P5_CESR_ES_INSTRUCTION_V 0x010111   /* Inst. executed (v-pipe) */
#define MSR_P5_CESR_ES_IO_CYCLE 0x011101        /* I/O Read or Write cycles */
#define MSR_P5_CESR_ES_LOCKED_CYCLE 0x011100    /* Locked bus cycles */
#define MSR_P5_CESR_ES_MEM_ACCESS_PIPE 0x001001 /* mem access both pipes */
#define MSR_P5_CESR_ES_MISALIGNED 0x001011      /* Misaligned Memory or I/O */
#define MSR_P5_CESR_ES_NON_CACHEABLE 0x011110   /* Non-cacheable Mem. read */
#define MSR_P5_CESR_ES_PIPELINE_FLUSH 0x010101  /* Pipeline Flushes */
#define MSR_P5_CESR_ES_SEGMENT_LOADED 0x001111  /* Any segment reg. loaded */
#define MSR_P5_CESR_ES_WRITE_EM 0x011011        /* Stall on write E|M state */
#define MSR_PLATFORM_INFO 0xce



/*!BEGIN libc/nexgen32e/nexgen32e.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_NEXGEN32E_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern long kHalfCache3;
extern const uint64_t kTens[20];
extern const uint32_t kSha256[64];
extern const uint64_t kSha512[80];
extern const unsigned char kTensIndex[64];

void imapxlatab(void *);
void insertionsort(int32_t *, size_t);
void CheckStackIsAligned(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/nt2sysv.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_NT2SYSV_H_


/*!BEGIN libc/nexgen32e/trampoline.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_TRAMPOLINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define TRAMPOLINE(FUNCTION, THUNK)   \
  ({                                  \
    typeof(FUNCTION) *Tramp;          \
    asm(".section .text.trampoline\n" \
        "183:\n\t"                    \
        "mov\t%1,%%eax\n\t"           \
        "jmp\t" #THUNK "\n\t"         \
        ".previous\n\t"               \
        "mov\t$183b,%k0"              \
        : "=r"(Tramp)                 \
        : "i"(FUNCTION));             \
    Tramp;                            \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Creates function to thunk FUNCTION from MSX64 to System V ABI.
 *
 * This macro should be used when specifying callbacks in the WIN32 API.
 */
#define NT2SYSV(FUNCTION) TRAMPOLINE(FUNCTION, __nt2sysv)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/rdtscp.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_RDTSCP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define TSC_AUX_CORE(MSR) ((MSR)&0xfff)
#define TSC_AUX_NODE(MSR) (((MSR) >> 12) & 0xfff)

/**
 * Reads CPU timestamp counter and IA32_TSC_AUX.
 *
 * This macro inhibits compiler magic.
 * This macro does not inhibit CPU magic.
 *
 * @see X86_HAVE(RDTSCP)
 */
#define rdtscp(OPT_OUT_IA32_TSC_AUX)               \
  ({                                               \
    uint32_t Ecx, *EcxOut;                         \
    uint64_t Rax, Rcx, Rdx;                        \
    asm volatile("rdtscp"                          \
                 : "=a"(Rax), "=c"(Ecx), "=d"(Rdx) \
                 : /* no inputs */                 \
                 : "memory");                      \
    EcxOut = (OPT_OUT_IA32_TSC_AUX);               \
    if (EcxOut) *EcxOut = Ecx;                     \
    Rdx << 32 | Rax;                               \
  })

/**
 * Reads timestamp counter auxiliary model specific register value.
 */
#define rdpid()                                                           \
  ({                                                                      \
    bool Ok;                                                              \
    long Msr;                                                             \
    Ok = false;                                                           \
    if (X86_HAVE(RDPID)) {                                                \
      asm volatile("rdpid\t%0" : "=r"(Msr) : /* no inputs */ : "memory"); \
      Ok = true;                                                          \
    } else if (IsLinux()) {                                               \
      asm volatile(ZFLAG_ASM("lsl\t%2,%1")                                \
                   : ZFLAG_CONSTRAINT(Ok), "=r"(Msr)                      \
                   : "r"(0x7b)                                            \
                   : "memory");                                           \
    }                                                                     \
    if (!Ok && X86_HAVE(RDTSCP)) {                                        \
      asm volatile("rdtscp"                                               \
                   : "=c"(Msr)                                            \
                   : /* no inputs */                                      \
                   : "eax", "edx", "memory");                             \
      Ok = true;                                                          \
    }                                                                     \
    if (!Ok) {                                                            \
      Msr = -1;                                                           \
    }                                                                     \
    Msr;                                                                  \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/sha.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_SHA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void sha1_transform_avx2(uint32_t[hasatleast 5], const void *, unsigned);
void sha1_transform_ni(uint32_t[hasatleast 5], const void *, unsigned);
void sha256_transform_rorx(uint32_t[hasatleast 8], const void *, unsigned);
void sha256_transform_ni(uint32_t[hasatleast 8], const void *, unsigned);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/x86info.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86INFO_H_

#define kX86CpuStepping    ((KCPUIDS(1H, EAX) >> 0) & 15)
#define kX86CpuModelid     ((KCPUIDS(1H, EAX) >> 4) & 15)
#define kX86CpuFamilyid    ((KCPUIDS(1H, EAX) >> 8) & 15)
#define kX86CpuType        ((KCPUIDS(1H, EAX) >> 12) & 3)
#define kX86CpuExtmodelid  ((KCPUIDS(1H, EAX) >> 16) & 15)
#define kX86CpuExtfamilyid ((KCPUIDS(1H, EAX) >> 20) & 255)

#define kX86CpuFamily \
  (kX86CpuFamilyid + (kX86CpuFamilyid == 15 ? kX86CpuExtfamilyid : 0))

#define kX86CpuModel                                                       \
  (kX86CpuModelid |                                                        \
   (kX86CpuFamilyid == 6 || kX86CpuFamilyid == 15 ? kX86CpuExtmodelid : 0) \
       << 4)

#define kX86ProcessorModelKey                                                 \
  (kX86CpuExtfamilyid << 12 | kX86CpuFamilyid << 8 | kX86CpuExtmodelid << 4 | \
   kX86CpuModelid)

#define X86_MARCH_UNKNOWN        0
#define X86_MARCH_CORE2          1
#define X86_MARCH_NEHALEM        2
#define X86_MARCH_WESTMERE       3
#define X86_MARCH_SANDYBRIDGE    4
#define X86_MARCH_IVYBRIDGE      5
#define X86_MARCH_HASWELL        6
#define X86_MARCH_BROADWELL      7
#define X86_MARCH_SKYLAKE        8
#define X86_MARCH_KABYLAKE       9
#define X86_MARCH_CANNONLAKE     10
#define X86_MARCH_ICELAKE        11
#define X86_MARCH_TIGERLAKE      12
#define X86_MARCH_BONNELL        13
#define X86_MARCH_SALTWELL       14
#define X86_MARCH_SILVERMONT     15
#define X86_MARCH_AIRMONT        16
#define X86_MARCH_GOLDMONT       17
#define X86_MARCH_GOLDMONTPLUS   18
#define X86_MARCH_TREMONT        19
#define X86_MARCH_KNIGHTSLANDING 20
#define X86_MARCH_KNIGHTSMILL    21

#define X86_GRADE_UNKNOWN   0
#define X86_GRADE_APPLIANCE 1
#define X86_GRADE_MOBILE    2
#define X86_GRADE_TABLET    3
#define X86_GRADE_DESKTOP   4
#define X86_GRADE_CLIENT    5
#define X86_GRADE_DENSITY   6
#define X86_GRADE_SERVER    7
#define X86_GRADE_SCIENCE   8

struct X86ProcessorModel {
  short key;
  unsigned char march;
  unsigned char grade;
};

extern const size_t kX86ProcessorModelCount;
extern const struct X86ProcessorModel kX86ProcessorModels[];

const struct X86ProcessorModel *getx86processormodel(short) nosideeffect;



/*!BEGIN libc/nt/enum/accessmask.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_ACCESSMASK_H_

/**
 * Can also be described as follows:
 *
 *   struct NtAccessMask {
 *     union {
 *       uint32_t value;
 *       struct {
 *         uint16_t SpecificRights;
 *         unsigned char StandardRights;
 *         unsigned AccessSystemAcl : 1;
 *         unsigned Reserved : 3;
 *         unsigned GenericAll : 1;
 *         unsigned GenericExecute : 1;
 *         unsigned GenericWrite : 1;
 *         unsigned GenericRead : 1;
 *       };
 *     };
 *   };
 */
#define kNtGenericRead            0x80000000u
#define kNtGenericWrite           0x40000000u
#define kNtGenericExecute         0x20000000u
#define kNtGenericAll             0x10000000u
#define kNtDelete                 0x00010000u
#define kNtReadControl            0x00020000u
#define kNtWriteDac               0x00040000u
#define kNtWriteOwner             0x00080000u
#define kNtSynchronize            0x00100000u
#define kNtStandardRightsRequired 0x000F0000u
#define kNtStandardRightsRead     kNtReadControl
#define kNtStandardRightsWrite    kNtReadControl
#define kNtStandardRightsExecute  kNtReadControl
#define kNtStandardRightsAll      0x001F0000u
#define kNtSpecificRightsAll      0x0000FFFFu
#define kNtAccessSystemSecurity   0x01000000u
#define kNtMaximumAllowed         0x02000000u
#define kNtFileReadData           0x0001u
#define kNtFileListDirectory      0x0001u
#define kNtFileWriteData          0x0002u
#define kNtFileAddFile            0x0002u
#define kNtFileAppendData         0x0004u
#define kNtFileAddSubdirectory    0x0004u
#define kNtFileCreatePipeInstance 0x0004u
#define kNtFileReadEa             0x0008u
#define kNtFileWriteEa            0x0010u
#define kNtFileExecute            0x0020u
#define kNtFileTraverse           0x0020u
#define kNtFileDeleteChild        0x0040u
#define kNtFileReadAttributes     0x0080u
#define kNtFileWriteAttributes    0x0100u
#define kNtFileAllAccess          (kNtStandardRightsRequired | kNtSynchronize | 0x1FFu)
#define kNtFileGenericRead                                           \
  (kNtStandardRightsRead | kNtFileReadData | kNtFileReadAttributes | \
   kNtFileReadEa | kNtSynchronize)
#define kNtFileGenericWrite                                             \
  (kNtStandardRightsWrite | kNtFileWriteData | kNtFileWriteAttributes | \
   kNtFileWriteEa | kNtFileAppendData | kNtSynchronize)
#define kNtFileGenericExecute                                          \
  (kNtStandardRightsExecute | kNtFileReadAttributes | kNtFileExecute | \
   kNtSynchronize)
#define kNtTokenAssignPrimary    0x0001u
#define kNtTokenDuplicate        0x0002u
#define kNtTokenImpersonate      0x0004u
#define kNtTokenQuery            0x0008u
#define kNtTokenQuerySource      0x0010u
#define kNtTokenAdjustPrivileges 0x0020u
#define kNtTokenAdjustGroups     0x0040u
#define kNtTokenAdjustDefault    0x0080u
#define kNtTokenAdjustSessionid  0x0100u
#define kNtTokenAllAccessP                                                 \
  (kNtStandardRightsRequired | kNtTokenAssignPrimary | kNtTokenDuplicate | \
   kNtTokenImpersonate | kNtTokenQuery | kNtTokenQuerySource |             \
   kNtTokenAdjustPrivileges | kNtTokenAdjustGroups | kNtTokenAdjustDefault)
#define kNtTokenAllAccess kNtTokenAllAccessP | kNtTokenAdjustSessionid
#define kNtTokenRead      kNtStandardRightsRead | kNtTokenQuery
#define kNtTokenWrite                                                         \
  (kNtStandardRightsWrite | kNtTokenAdjustPrivileges | kNtTokenAdjustGroups | \
   kNtTokenAdjustDefault)
#define kNtTokenExecute kNtStandardRightsExecute
#define kNtTokenTrustConstraintMask \
  (kNtStandardRightsRead | kNtTokenQuery | kNtTokenQuerySource)
#define kNtTokenAccessPseudoHandleWin8 kNtTokenQuery | kNtTokenQuerySource
#define kNtTokenAccessPseudoHandle     kNtTokenAccessPseudoHandleWin8



/*!BEGIN libc/nt/enum/afd.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_AFD_H_

#define kNtAfdPollReceive          0x0001
#define kNtAfdPollReceiveExpedited 0x0002
#define kNtAfdPollSend             0x0004
#define kNtAfdPollDisconnect       0x0008
#define kNtAfdPollAbort            0x0010
#define kNtAfdPollLocalClose       0x0020
#define kNtAfdPollAccept           0x0080
#define kNtAfdPollConnectFail      0x0100



/*!BEGIN libc/nt/enum/bitblt.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_BITBLT_H_

#define kNtSrccopy     0x00CC0020u /* src */
#define kNtSrcpaint    0x00EE0086u /* src | dst */
#define kNtSrcand      0x008800C6u /* src & dst */
#define kNtSrcinvert   0x00660046u /* src ^ dst */
#define kNtSrcerase    0x00440328u /* src & ~dst */
#define kNtNotsrccopy  0x00330008u /* ~src */
#define kNtNotsrcerase 0x001100A6u /* ~src & ~dst */
#define kNtMergecopy   0x00C000CAu /* (src & pattern) */
#define kNtMergepaint  0x00BB0226u /* ~src | dst */
#define kNtPatcopy     0x00F00021u /* pat */
#define kNtPatpaint    0x00FB0A09u /* wut */
#define kNtPatinvert   0x005A0049u /* pat ^ dst */
#define kNtDstinvert   0x00550009u /* ~dst */
#define kNtBlackness   0x00000042u /* black */
#define kNtWhiteness   0x00FF0062u /* white */



/*!BEGIN libc/nt/enum/callback.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CALLBACK_H_

#define kNtCallbackChunkFinished 0
#define kNtCallbackStreamSwitch  1



/*!BEGIN libc/nt/enum/color.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COLOR_H_

#define kNtColorScrollbar               0
#define kNtColorBackground              1
#define kNtColorActivecaption           2
#define kNtColorInactivecaption         3
#define kNtColorMenu                    4
#define kNtColorWindow                  5
#define kNtColorWindowframe             6
#define kNtColorMenutext                7
#define kNtColorWindowtext              8
#define kNtColorCaptiontext             9
#define kNtColorActiveborder            10
#define kNtColorInactiveborder          11
#define kNtColorAppworkspace            12
#define kNtColorHighlight               13
#define kNtColorHighlighttext           14
#define kNtColorBtnface                 15
#define kNtColorBtnshadow               16
#define kNtColorGraytext                17
#define kNtColorBtntext                 18
#define kNtColorInactivecaptiontext     19
#define kNtColorBtnhighlight            20
#define kNtColor3ddkshadow              21
#define kNtColor3dlight                 22
#define kNtColorInfotext                23
#define kNtColorInfobk                  24
#define kNtColorHotlight                26
#define kNtColorGradientactivecaption   27
#define kNtColorGradientinactivecaption 28
#define kNtColorMenuhilight             29
#define kNtColorMenubar                 30



/*!BEGIN libc/nt/enum/computernameformat.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COMPUTERNAMEFORMAT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtComputerNameNetBios                   0
#define kNtComputerNameDnsHostname               1
#define kNtComputerNameDnsDomain                 2
#define kNtComputerNameDnsFullyQualified         3
#define kNtComputerNamePhysicalNetBios           4
#define kNtComputerNamePhysicalDnsHostname       5
#define kNtComputerNamePhysicalDnsDomain         6
#define kNtComputerNamePhysicalDnsFullyQualified 7
#define kNtComputerName_MAX                      8

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/consolemodeflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CONSOLEMODEFLAGS_H_

/* input mode */
#define kNtEnableProcessedInput 0x0001u
#define kNtEnableLineInput 0x0002u
#define kNtEnableEchoInput 0x0004u
#define kNtEnableWindowInput 0x0008u
#define kNtEnableMouseInput 0x0010u
#define kNtEnableInsertMode 0x0020u
#define kNtEnableQuickEditMode 0x0040u
#define kNtEnableExtendedFlags 0x0080u
#define kNtEnableAutoPosition 0x0100u
#define kNtEnableVirtualTerminalInput 0x0200u

/* output mode */
#define kNtEnableProcessedOutput 0x0001u
#define kNtEnableWrapAtEolOutput 0x0002u
#define kNtEnableVirtualTerminalProcessing 0x0004u
#define kNtDisableNewlineAutoReturn 0x0008u
#define kNtEnableLvbGridWorldwide 0x0010u



/*!BEGIN libc/nt/enum/consoleselectionflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CONSOLESELECTIONFLAGS_H_

#define kNtConsoleNoSelection 0x0000u
#define kNtConsoleSelectionInProgress 0x0001u
#define kNtConsoleSelectionNotEmpty 0x0002u
#define kNtConsoleMouseSelection 0x0004u
#define kNtConsoleMouseDown 0x0008u



/*!BEGIN libc/nt/enum/copyfile.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COPYFILE_H_

#define kNtCopyFileFailIfExists              0x00000001
#define kNtCopyFileRestartable               0x00000002
#define kNtCopyFileOpenSourceForWrite        0x00000004
#define kNtCopyFileAllowDecryptedDestination 0x00000008
#define kNtCopyFileCopySymlink               0x00000800
#define kNtCopyFileNoBuffering               0x00001000
#define kNtCopyFileRequestSecurityPrivileges 0x00002000 /* Win8+ */
#define kNtCopyFileResumeFromPause           0x00004000 /* Win8+ */
#define kNtCopyFileRequestSecurityPrivileges 0x00002000 /* Win8+ */
#define kNtCopyFileNoOffload                 0x00040000 /* Win8+ */
#define kNtCopyFileIgnoreEdpBlock            0x00400000 /* Win10+ */
#define kNtCopyFileIgnoreSourceEncryption    0x00800000 /* Win10+ */



/*!BEGIN libc/nt/enum/creationdisposition.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CREATIONDISPOSITION_H_

#define kNtCreateNew 1
#define kNtCreateAlways 2
#define kNtOpenExisting 3
#define kNtOpenAlways 4
#define kNtTruncateExisting 5



/*!BEGIN libc/nt/enum/cs.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CS_H_

#define kNtCsVredraw         0x00000001
#define kNtCsHredraw         0x00000002
#define kNtCsDblclks         0x00000008
#define kNtCsOwndc           0x00000020
#define kNtCsClassdc         0x00000040
#define kNtCsParentdc        0x00000080
#define kNtCsNoclose         0x00000200
#define kNtCsSavebits        0x00000800
#define kNtCsBytealignclient 0x00001000
#define kNtCsBytealignwindow 0x00002000
#define kNtCsGlobalclass     0x00004000
#define kNtCsIme             0x00010000
#define kNtCsDropshadow      0x00020000



/*!BEGIN libc/nt/enum/ctrlevent.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CTRLEVENT_H_

#define kNtCtrlCEvent 0      /* SIGINT */
#define kNtCtrlBreakEvent 1  /* SIGQUIT */
#define kNtCtrlCloseEvent 2  /* SIGHUP */
#define kNtCtrlLogoffEvent 5 /* SIGTERM */
#define kNtCtrlShutdownEvent 6



/*!BEGIN libc/nt/enum/cw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtCwUsedefault ((int)0x80000000)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/dialogresult.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_DIALOGRESULT_H_

#define kNtIdok       1
#define kNtIdcancel   2
#define kNtIdabort    3
#define kNtIdretry    4
#define kNtIdignore   5
#define kNtIdyes      6
#define kNtIdno       7
#define kNtIdclose    8
#define kNtIdhelp     9
#define kNtIdtryagain 10
#define kNtIdcontinue 11



/*!BEGIN libc/nt/enum/errormodeflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_ERRORMODEFLAGS_H_

#define kNtErrorModeDefault      0x0
#define kNtSemFailcriticalerrors 0x1
#define kNtSemNogpfaulterrorbox  0x2
#define kNtSemNoopenfileerrorbox 0x8000



/*!BEGIN libc/nt/enum/event.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EVENT_H_

#define kNtEventSystemSound            0x0001
#define kNtEventSystemAlert            0x0002
#define kNtEventSystemForeground       0x0003
#define kNtEventSystemMenustart        0x0004
#define kNtEventSystemMenuend          0x0005
#define kNtEventSystemMenupopupstart   0x0006
#define kNtEventSystemMenupopupend     0x0007
#define kNtEventSystemCapturestart     0x0008
#define kNtEventSystemCaptureend       0x0009
#define kNtEventSystemMovesizestart    0x000A
#define kNtEventSystemMovesizeend      0x000B
#define kNtEventSystemContexthelpstart 0x000C
#define kNtEventSystemContexthelpend   0x000D
#define kNtEventSystemDragdropstart    0x000E
#define kNtEventSystemDragdropend      0x000F
#define kNtEventSystemDialogstart      0x0010
#define kNtEventSystemDialogend        0x0011
#define kNtEventSystemScrollingstart   0x0012
#define kNtEventSystemScrollingend     0x0013
#define kNtEventSystemSwitchstart      0x0014
#define kNtEventSystemSwitchend        0x0015
#define kNtEventSystemMinimizestart    0x0016
#define kNtEventSystemMinimizeend      0x0017

#define kNtEventConsoleCaret            0x4001
#define kNtEventConsoleUpdateRegion     0x4002
#define kNtEventConsoleUpdateSimple     0x4003
#define kNtEventConsoleUpdateScroll     0x4004
#define kNtEventConsoleLayout           0x4005
#define kNtEventConsoleStartApplication 0x4006
#define kNtEventConsoleEndApplication   0x4007

#define kNtEventObjectCreate            0x8000
#define kNtEventObjectDestroy           0x8001
#define kNtEventObjectShow              0x8002
#define kNtEventObjectHide              0x8003
#define kNtEventObjectReorder           0x8004
#define kNtEventObjectFocus             0x8005
#define kNtEventObjectSelection         0x8006
#define kNtEventObjectSelectionadd      0x8007
#define kNtEventObjectSelectionremove   0x8008
#define kNtEventObjectSelectionwithin   0x8009
#define kNtEventObjectStatechange       0x800A
#define kNtEventObjectLocationchange    0x800B
#define kNtEventObjectNamechange        0x800C
#define kNtEventObjectDescriptionchange 0x800D
#define kNtEventObjectValuechange       0x800E
#define kNtEventObjectParentchange      0x800F
#define kNtEventObjectHelpchange        0x8010
#define kNtEventObjectDefactionchange   0x8011
#define kNtEventObjectAcceleratorchange 0x8012



/*!BEGIN libc/nt/enum/eventtype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EVENTTYPE_H_

#define kNtNotificationEvent    0
#define kNtSynchronizationEvent 1



/*!BEGIN libc/nt/enum/exceptionhandleractions.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EXCEPTIONHANDLERACTIONS_H_

#define kNtExceptionExecuteHandler 0x1u
#define kNtExceptionContinueExecution 0xffffffffu
#define kNtExceptionContinueSearch 0x0u



/*!BEGIN libc/nt/enum/fileflagandattributes.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEFLAGANDATTRIBUTES_H_

/**
 * MS-DOS File Attributes.
 *
 * @see GetFileInformationByHandle()
 * @see libc/sysv/consts.sh
 */
#define kNtFileAttributeReadonly    0x00000001u
#define kNtFileAttributeHidden      0x00000002u
#define kNtFileAttributeSystem      0x00000004u
#define kNtFileAttributeVolumelabel 0x00000008u
#define kNtFileAttributeDirectory   0x00000010u
#define kNtFileAttributeArchive     0x00000020u

/**
 * NT File Attributes.
 */
#define kNtFileAttributeDevice            0x00000040u
#define kNtFileAttributeNormal            0x00000080u
#define kNtFileAttributeTemporary         0x00000100u
#define kNtFileAttributeSparseFile        0x00000200u
#define kNtFileAttributeReparsePoint      0x00000400u
#define kNtFileAttributeCompressed        0x00000800u
#define kNtFileAttributeOffline           0x00001000u
#define kNtFileAttributeNotContentIndexed 0x00002000u
#define kNtFileAttributeEncrypted         0x00004000u

/**
 * NT File Flags.
 */
#define kNtFileFlagWriteThrough      0x80000000u
#define kNtFileFlagOverlapped        0x40000000u
#define kNtFileFlagNoBuffering       0x20000000u
#define kNtFileFlagRandomAccess      0x10000000u
#define kNtFileFlagSequentialScan    0x08000000u
#define kNtFileFlagDeleteOnClose     0x04000000u
#define kNtFileFlagBackupSemantics   0x02000000u
#define kNtFileFlagPosixSemantics    0x01000000u
#define kNtFileFlagOpenReparsePoint  0x00200000u
#define kNtFileFlagOpenNoRecall      0x00100000u
#define kNtFileFlagFirstPipeInstance 0x00080000u



/*!BEGIN libc/nt/enum/fileinfobyhandleclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEINFOBYHANDLECLASS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtFileBasicInfo 0        /* struct NtFileBasicInformation */
#define kNtFileStandardInfo 1     /* struct NtFileStandardInformation */
#define kNtFileNameInfo 2         /* struct NtFileNameInformation */
#define kNtFileStreamInfo 7       /* struct NtFileStreamInformation */
#define kNtFileCompressionInfo 8  /* struct NtFileCompressionInfo */
#define kNtFileAttributeTagInfo 9 /* struct NtFileAttributeTagInformation */
#define kNtFileIdBothDirectoryInfo 10
#define kNtFileIdBothDirectoryRestartInfo 11
#define kNtFileRemoteProtocolInfo 13
#define kNtFileFullDirectoryInfo 14 /* NtFileFullDirectoryInformation */
#define kNtFileFullDirectoryRestartInfo 15
#define kNtFileStorageInfo 16                /* win8+ */
#define kNtFileAlignmentInfo 17              /* win8+ */
#define kNtFileIdInfo 18                     /* win8+ */
#define kNtFileIdExtdDirectoryInfo 19        /* win8+ */
#define kNtFileIdExtdDirectoryRestartInfo 20 /* win8+ */

/* #define kNtFileRenameInfo 4 */
/* #define kNtFileDispositionInfo 5 */
/* #define kNtFileAllocationInfo 6 */
/* #define kNtFileEndOfFileInfo 7 */
/* #define kNtFileIoPriorityHintInfo 13 */
/* #define kNtFileDispositionInfoEx 22          /\* win10+ *\/ */
/* #define kNtFileRenameInfoEx 23               /\* win10+ *\/ */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/fileinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEINFORMATIONCLASS_H_

#define kNtFileDirectoryInformation 1 /*→ struct NtFileDirectoryInformation */
#define kNtFileFullDirectoryInformation 2 /*→ etc. */
#define kNtFileBothDirectoryInformation 3
#define kNtFileBasicInformation 4
#define kNtFileStandardInformation 5
#define kNtFileInternalInformation 6
#define kNtFileEaInformation 7
#define kNtFileAccessInformation 8
#define kNtFileNameInformation 9
#define kNtFileRenameInformation 10
#define kNtFileLinkInformation 11
#define kNtFileNamesInformation 12
#define kNtFileDispositionInformation 13
#define kNtFilePositionInformation 14
#define kNtFileFullEaInformation 15
#define kNtFileModeInformation 16
#define kNtFileAlignmentInformation 17
#define kNtFileAllInformation 18
#define kNtFileAllocationInformation 19
#define kNtFileEndOfFileInformation 20
#define kNtFileAlternateNameInformation 21
#define kNtFileStreamInformation 22
#define kNtFilePipeInformation 23
#define kNtFilePipeLocalInformation 24
#define kNtFilePipeRemoteInformation 25
#define kNtFileMailslotQueryInformation 26
#define kNtFileMailslotSetInformation 27
#define kNtFileCompressionInformation 28
#define kNtFileObjectIdInformation 29
#define kNtFileCompletionInformation 30
#define kNtFileMoveClusterInformation 31
#define kNtFileQuotaInformation 32
#define kNtFileReparsePointInformation 33
#define kNtFileNetworkOpenInformation 34
#define kNtFileAttributeTagInformation 35
#define kNtFileTrackingInformation 36
#define kNtFileIdBothDirectoryInformation 37
#define kNtFileIdFullDirectoryInformation 38
#define kNtFileValidDataLengthInformation 39
#define kNtFileShortNameInformation 40
#define kNtFileInformation_MAX 40



/*!BEGIN libc/nt/enum/filelockflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILELOCKFLAGS_H_

#define kNtLockfileFailImmediately 1
#define kNtLockfileExclusiveLock   2



/*!BEGIN libc/nt/enum/filemapflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEMAPFLAGS_H_

#define kNtFileMapCopy           0x00000001u
#define kNtFileMapWrite          0x00000002u
#define kNtFileMapRead           0x00000004u
#define kNtFileMapExecute        0x00000020u
#define kNtFileMapReserve        0x80000000u
#define kNtFileMapTargetsInvalid 0x40000000u
#define kNtFileMapLargePages     0x20000000u



/*!BEGIN libc/nt/enum/filemovemethod.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEMOVEMETHOD_H_

#define kNtFileBegin   0
#define kNtFileCurrent 1
#define kNtFileEnd     2



/*!BEGIN libc/nt/enum/filesharemode.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILESHAREFLAGS_H_

#define kNtFileShareExclusive 0x00000000u
#define kNtFileShareRead 0x00000001u
#define kNtFileShareWrite 0x00000002u
#define kNtFileShareDelete 0x00000004u



/*!BEGIN libc/nt/enum/filetype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILETYPE_H_

#define kNtFileTypeUnknown 0x0000
#define kNtFileTypeDisk    0x0001 /* @see S_ISBLK() */
#define kNtFileTypeChar    0x0002 /* @see S_ISCHR() */
#define kNtFileTypePipe    0x0003 /* @see S_ISFIFO() */
#define kNtFileTypeRemote  0x8000 /* unused -MSDN */



/*!BEGIN libc/nt/enum/fillattribute.h */

#define COSMOPOLITAN_LIBC_NT_NTFILLATTRIBUTE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtForegroundBlue 0x0001
#define kNtForegroundGreen 0x0002
#define kNtForegroundRed 0x0004
#define kNtForegroundIntensity 0x0008
#define kNtBackgroundBlue 0x0010
#define kNtBackgroundGreen 0x0020
#define kNtBackgroundRed 0x0040
#define kNtBackgroundIntensity 0x0080

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/findexinfolevels.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FINDEXINFOLEVELS_H_

#define kNtFindExInfoStandard     0
#define kNtFindExInfoBasic        1
#define kNtFindExInfoMaxInfoLevel 2



/*!BEGIN libc/nt/enum/findexsearchops.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FINDEXSEARCHOPS_H_

#define kNtFindExSearchNameMatch          0
#define kNtFindExSearchLimitToDirectories 1
#define kNtFindExSearchLimitToDevices     2
#define kNtFindExSearchMaxSearchOp        3



/*!BEGIN libc/nt/enum/formatmessageflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FORMATMESSAGEFLAGS_H_

#define kNtFormatMessageAllocateBuffer 0x100
#define kNtFormatMessageIgnoreInserts  0x200
#define kNtFormatMessageFromString     0x400
#define kNtFormatMessageFromHmodule    0x800
#define kNtFormatMessageFromSystem     0x1000
#define kNtFormatMessageArgumentArray  0x2000
#define kNtFormatMessageMaxWidthMask   0xff



/*!BEGIN libc/nt/enum/fsctl.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FSCTL_H_

#define kNtFsctlDisableLocalBuffering   0x000902B8u
#define kNtFsctlFilePrefetch            0x00090120u
#define kNtFsctlFilesystemGetStatistics 0x00090060u
#define kNtFsctlGetCompression          0x0009003Cu
#define kNtFsctlGetNtfsFileRecord       0x00090068u
#define kNtFsctlGetNtfsVolumeData       0x00090064u
#define kNtFsctlQueryAllocatedRanges    0x000940CFu
#define kNtFsctlScrubData               0x000902B0u
#define kNtFsctlSetCompression          0x0009C040u
#define kNtFsctlSetSparse               0x000900C4u
#define kNtFsctlSetZeroData             0x000980C8u
#define kNtFsctlGetReparsePoint         0x000900a8u
#define kNtFsctlSetReparsePoint         0x000900a4u



/*!BEGIN libc/nt/enum/fsinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FSINFORMATIONCLASS_H_

#define kNtFileFsVolumeInformation 1
#define kNtFileFsLabelInformation 2
#define kNtFileFsSizeInformation 3
#define kNtFileFsDeviceInformation 4
#define kNtFileFsAttributeInformation 5
#define kNtFileFsControlInformation 6
#define kNtFileFsFullSizeInformation 7
#define kNtFileFsObjectIdInformation 8
#define kNtFileFsDriverPathInformation 9
#define kNtFileFsInformation_MAX 10



/*!BEGIN libc/nt/enum/getfileexinfolevels.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_GETFILEEXINFOLEVELS_H_

#define kNtGetFileExInfoStandard 0



/*!BEGIN libc/nt/enum/heap.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_HEAP_H_

#define kNtHeapNoSerialize        1
#define kNtHeapGenerateExceptions 4
#define kNtHeapZeroMemory         8
#define kNtHeapReallocInPlaceOnly 16



/*!BEGIN libc/nt/enum/ht.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_HT_H_

#define kNtHterror       -2
#define kNtHttransparent -1
#define kNtHtnowhere     0
#define kNtHtclient      1
#define kNtHtcaption     2
#define kNtHtsysmenu     3
#define kNtHtgrowbox     4
#define kNtHtsize        kNtHtgrowbox
#define kNtHtmenu        5
#define kNtHthscroll     6
#define kNtHtvscroll     7
#define kNtHtminbutton   8
#define kNtHtmaxbutton   9
#define kNtHtleft        10
#define kNtHtright       11
#define kNtHttop         12
#define kNtHttopleft     13
#define kNtHttopright    14
#define kNtHtbottom      15
#define kNtHtbottomleft  16
#define kNtHtbottomright 17
#define kNtHtborder      18
#define kNtHtreduce      kNtHtminbutton
#define kNtHtzoom        kNtHtmaxbutton
#define kNtHtsizefirst   kNtHtleft
#define kNtHtsizelast    kNtHtbottomright
#define kNtHtobject      19
#define kNtHtclose       20
#define kNtHthelp        21



/*!BEGIN libc/nt/enum/idc.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IDC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define kNtIdcArrow    ((const char16_t *)32512)
#define kNtIdcIbeam    ((const char16_t *)32513)
#define kNtIdcWait     ((const char16_t *)32514)
#define kNtIdcCross    ((const char16_t *)32515)
#define kNtIdcUparrow  ((const char16_t *)32516)
#define kNtIdcSizenwse ((const char16_t *)32642)
#define kNtIdcSizenesw ((const char16_t *)32643)
#define kNtIdcSizewe   ((const char16_t *)32644)
#define kNtIdcSizens   ((const char16_t *)32645)
#define kNtIdcSizeall  ((const char16_t *)32646)
#define kNtIdcNo       ((const char16_t *)32648)
#define kNtIdcHand     ((const char16_t *)32649)
#define kNtIdcHelp     ((const char16_t *)32651)
#define kNtIdcPin      ((const char16_t *)32671)
#define kNtIdcPerson   ((const char16_t *)32672)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/imageauxsymboltype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMAGEAUXSYMBOLTYPE_H_

#define kNtImageAuxSymbolTypeTokenDef 1



/*!BEGIN libc/nt/enum/importobjectnametype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMPORTOBJECTNAMETYPE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtImportObjectNameType {
  IMPORT_OBJECT_ORDINAL,
  IMPORT_OBJECT_NAME,
  IMPORT_OBJECT_NAME_NO_PREFIX,
  IMPORT_OBJECT_NAME_UNDECORATE,
  IMPORT_OBJECT_NAME_EXPORTAS
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/importobjecttype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMPORTOBJECTTYPE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtImportObjectType {
  IMPORT_OBJECT_CODE,
  IMPORT_OBJECT_DATA,
  IMPORT_OBJECT_CONST
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/io.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IO_H_

#define kNtIoReparseTagSymlink    0xa000000c
#define kNtIoReparseTagMountPoint 0xa0000003



/*!BEGIN libc/nt/enum/ioctl.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IOCTL_H_

#define kNtIoctlDiskGetDriveGeometry 0x00070000u
#define kNtIoctlAfdPoll              0x00012024u



/*!BEGIN libc/nt/enum/jobobjectinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_JOBOBJECTINFOCLASS_H_

#define kNtJobObjectBasicAccountingInformation         1
#define kNtJobObjectBasicLimitInformation              2
#define kNtJobObjectBasicProcessIdList                 3
#define kNtJobObjectBasicUIRestrictions                4
#define kNtJobObjectSecurityLimitInformation           5
#define kNtJobObjectEndOfJobTimeInformation            6
#define kNtJobObjectAssociateCompletionPortInformation 7
#define kNtJobObjectBasicAndIoAccountingInformation    8
#define kNtJobObjectExtendedLimitInformation           9
#define kNtJobObjectJobSetInformation                  10



/*!BEGIN libc/nt/enum/keyaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYACCESS_H_

#define kNtKeyRead      0x00020019
#define kNtKeyWrite     0x00020006
#define kNtKeyExecute   0x00020019
#define kNtKeyAllAccess 0x000f003f



/*!BEGIN libc/nt/enum/keyedevent.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYEDEVENT_H_

#define kNtKeyedeventWait 0x00000001u
#define kNtKeyedeventWake 0x00000002u
#define kNtKeyedeventAllAccess \
  (kNtStandardRightsRequired | kNtKeyedeventWait | kNtKeyedeventWake)



/*!BEGIN libc/nt/enum/keyinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYINFORMATIONCLASS_H_

#define kNtKeyBasicInformation 0
#define kNtKeyNodeInformation  1
#define kNtKeyFullInformation  2
#define kNtKeyNameInformation  3



/*!BEGIN libc/nt/enum/kwaitreason.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KWAITREASON_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtExecutive 0
#define kNtFreePage 1
#define kNtPageIn 2
#define kNtPoolAllocation 3
#define kNtDelayExecution 4
#define kNtSuspended 5
#define kNtUserRequest 6
#define kNtWrExecutive 7
#define kNtWrFreePage 8
#define kNtWrPageIn 9
#define kNtWrPoolAllocation 10
#define kNtWrDelayExecution 11
#define kNtWrSuspended 12
#define kNtWrUserRequest 13
#define kNtWrEventPair 14
#define kNtWrQueue 15
#define kNtWrLpcReceive 16
#define kNtWrLpcReply 17
#define kNtWrVirtualMemory 18
#define kNtWrPageOut 19
#define kNtWrRendezvous 20
#define kNtSpare2 21
#define kNtSpare3 22
#define kNtSpare4 23
#define kNtSpare5 24
#define kNtSpare6 25
#define kNtWrKernel 26
#define kNtMaximumWaitReason 27

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/lang.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_LANG_H_

#define MAKELANGID(p, s) ((((uint16_t)(s)) << 10) | (uint16_t)(p))

#define kNtLangNeutral            0x00
#define kNtLangInvariant          0x7f
#define kNtLangAfrikaans          0x36
#define kNtLangAlbanian           0x1c
#define kNtLangAlsatian           0x84
#define kNtLangAmharic            0x5e
#define kNtLangArabic             0x01
#define kNtLangArmenian           0x2b
#define kNtLangAssamese           0x4d
#define kNtLangAzeri              0x2c
#define kNtLangAzerbaijani        0x2c
#define kNtLangBangla             0x45
#define kNtLangBashkir            0x6d
#define kNtLangBasque             0x2d
#define kNtLangBelarusian         0x23
#define kNtLangBengali            0x45
#define kNtLangBreton             0x7e
#define kNtLangBosnian            0x1a
#define kNtLangBosnianNeutral     0x781a
#define kNtLangBulgarian          0x02
#define kNtLangCatalan            0x03
#define kNtLangCentralKurdish     0x92
#define kNtLangCherokee           0x5c
#define kNtLangChinese            0x04
#define kNtLangChineseSimplified  0x04
#define kNtLangChineseTraditional 0x7c04
#define kNtLangCorsican           0x83
#define kNtLangCroatian           0x1a
#define kNtLangCzech              0x05
#define kNtLangDanish             0x06
#define kNtLangDari               0x8c
#define kNtLangDivehi             0x65
#define kNtLangDutch              0x13
#define kNtLangEnglish            0x09
#define kNtLangEstonian           0x25
#define kNtLangFaeroese           0x38
#define kNtLangFarsi              0x29
#define kNtLangFilipino           0x64
#define kNtLangFinnish            0x0b
#define kNtLangFrench             0x0c
#define kNtLangFrisian            0x62
#define kNtLangFulah              0x67
#define kNtLangGalician           0x56
#define kNtLangGeorgian           0x37
#define kNtLangGerman             0x07
#define kNtLangGreek              0x08
#define kNtLangGreenlandic        0x6f
#define kNtLangGujarati           0x47
#define kNtLangHausa              0x68
#define kNtLangHawaiian           0x75
#define kNtLangHebrew             0x0d
#define kNtLangHindi              0x39
#define kNtLangHungarian          0x0e
#define kNtLangIcelandic          0x0f
#define kNtLangIgbo               0x70
#define kNtLangIndonesian         0x21
#define kNtLangInuktitut          0x5d
#define kNtLangIrish              0x3c
#define kNtLangItalian            0x10
#define kNtLangJapanese           0x11
#define kNtLangKannada            0x4b
#define kNtLangKashmiri           0x60
#define kNtLangKazak              0x3f
#define kNtLangKhmer              0x53
#define kNtLangKiche              0x86
#define kNtLangKinyarwanda        0x87
#define kNtLangKonkani            0x57
#define kNtLangKorean             0x12
#define kNtLangKyrgyz             0x40
#define kNtLangLao                0x54
#define kNtLangLatvian            0x26
#define kNtLangLithuanian         0x27
#define kNtLangLowerSorbian       0x2e
#define kNtLangLuxembourgish      0x6e
#define kNtLangMacedonian         0x2f
#define kNtLangMalay              0x3e
#define kNtLangMalayalam          0x4c
#define kNtLangMaltese            0x3a
#define kNtLangManipuri           0x58
#define kNtLangMaori              0x81
#define kNtLangMapudungun         0x7a
#define kNtLangMarathi            0x4e
#define kNtLangMohawk             0x7c
#define kNtLangMongolian          0x50
#define kNtLangNepali             0x61
#define kNtLangNorwegian          0x14
#define kNtLangOccitan            0x82
#define kNtLangOdia               0x48
#define kNtLangOriya              0x48
#define kNtLangPashto             0x63
#define kNtLangPersian            0x29
#define kNtLangPolish             0x15
#define kNtLangPortuguese         0x16
#define kNtLangPular              0x67
#define kNtLangPunjabi            0x46
#define kNtLangQuechua            0x6b
#define kNtLangRomanian           0x18
#define kNtLangRomansh            0x17
#define kNtLangRussian            0x19
#define kNtLangSakha              0x85
#define kNtLangSami               0x3b
#define kNtLangSanskrit           0x4f
#define kNtLangScottishGaelic     0x91
#define kNtLangSerbian            0x1a
#define kNtLangSerbianNeutral     0x7c1a
#define kNtLangSindhi             0x59
#define kNtLangSinhalese          0x5b
#define kNtLangSlovak             0x1b
#define kNtLangSlovenian          0x24
#define kNtLangSotho              0x6c
#define kNtLangSpanish            0x0a
#define kNtLangSwahili            0x41
#define kNtLangSwedish            0x1d
#define kNtLangSyriac             0x5a
#define kNtLangTajik              0x28
#define kNtLangTamazight          0x5f
#define kNtLangTamil              0x49
#define kNtLangTatar              0x44
#define kNtLangTelugu             0x4a
#define kNtLangThai               0x1e
#define kNtLangTibetan            0x51
#define kNtLangTigrigna           0x73
#define kNtLangTigrinya           0x73
#define kNtLangTswana             0x32
#define kNtLangTurkish            0x1f
#define kNtLangTurkmen            0x42
#define kNtLangUighur             0x80
#define kNtLangUkrainian          0x22
#define kNtLangUpperSorbian       0x2e
#define kNtLangUrdu               0x20
#define kNtLangUzbek              0x43
#define kNtLangValencian          0x03
#define kNtLangVietnamese         0x2a
#define kNtLangWelsh              0x52
#define kNtLangWolof              0x88
#define kNtLangXhosa              0x34
#define kNtLangYakut              0x85
#define kNtLangYi                 0x78
#define kNtLangYoruba             0x6a
#define kNtLangZulu               0x35

#define kNtSublangNeutral                          0x00
#define kNtSublangDefault                          0x01
#define kNtSublangSysDefault                       0x02
#define kNtSublangCustomDefault                    0x03
#define kNtSublangCustomUnspecified                0x04
#define kNtSublangUiCustomDefault                  0x05
#define kNtSublangAfrikaansSouthAfrica             0x01
#define kNtSublangAlbanianAlbania                  0x01
#define kNtSublangAlsatianFrance                   0x01
#define kNtSublangAmharicEthiopia                  0x01
#define kNtSublangArabicSaudiArabia                0x01
#define kNtSublangArabicIraq                       0x02
#define kNtSublangArabicEgypt                      0x03
#define kNtSublangArabicLibya                      0x04
#define kNtSublangArabicAlgeria                    0x05
#define kNtSublangArabicMorocco                    0x06
#define kNtSublangArabicTunisia                    0x07
#define kNtSublangArabicOman                       0x08
#define kNtSublangArabicYemen                      0x09
#define kNtSublangArabicSyria                      0x0a
#define kNtSublangArabicJordan                     0x0b
#define kNtSublangArabicLebanon                    0x0c
#define kNtSublangArabicKuwait                     0x0d
#define kNtSublangArabicUae                        0x0e
#define kNtSublangArabicBahrain                    0x0f
#define kNtSublangArabicQatar                      0x10
#define kNtSublangArmenianArmenia                  0x01
#define kNtSublangAssameseIndia                    0x01
#define kNtSublangAzeriLatin                       0x01
#define kNtSublangAzeriCyrillic                    0x02
#define kNtSublangAzerbaijaniAzerbaijanLatin       0x01
#define kNtSublangAzerbaijaniAzerbaijanCyrillic    0x02
#define kNtSublangBanglaIndia                      0x01
#define kNtSublangBanglaBangladesh                 0x02
#define kNtSublangBashkirRussia                    0x01
#define kNtSublangBasqueBasque                     0x01
#define kNtSublangBelarusianBelarus                0x01
#define kNtSublangBengaliIndia                     0x01
#define kNtSublangBengaliBangladesh                0x02
#define kNtSublangBosnianBosniaHerzegovinaLatin    0x05
#define kNtSublangBosnianBosniaHerzegovinaCyrillic 0x08
#define kNtSublangBretonFrance                     0x01
#define kNtSublangBulgarianBulgaria                0x01
#define kNtSublangCatalanCatalan                   0x01
#define kNtSublangCentralKurdishIraq               0x01
#define kNtSublangCherokeeCherokee                 0x01
#define kNtSublangChineseTraditional               0x01
#define kNtSublangChineseSimplified                0x02
#define kNtSublangChineseHongkong                  0x03
#define kNtSublangChineseSingapore                 0x04
#define kNtSublangChineseMacau                     0x05
#define kNtSublangCorsicanFrance                   0x01
#define kNtSublangCzechCzechRepublic               0x01
#define kNtSublangCroatianCroatia                  0x01
#define kNtSublangCroatianBosniaHerzegovinaLatin   0x04
#define kNtSublangDanishDenmark                    0x01
#define kNtSublangDariAfghanistan                  0x01
#define kNtSublangDivehiMaldives                   0x01
#define kNtSublangDutch                            0x01
#define kNtSublangDutchBelgian                     0x02
#define kNtSublangEnglishUs                        0x01
#define kNtSublangEnglishUk                        0x02
#define kNtSublangEnglishAus                       0x03
#define kNtSublangEnglishCan                       0x04
#define kNtSublangEnglishNz                        0x05
#define kNtSublangEnglishEire                      0x06
#define kNtSublangEnglishSouthAfrica               0x07
#define kNtSublangEnglishJamaica                   0x08
#define kNtSublangEnglishCaribbean                 0x09
#define kNtSublangEnglishBelize                    0x0a
#define kNtSublangEnglishTrinidad                  0x0b
#define kNtSublangEnglishZimbabwe                  0x0c
#define kNtSublangEnglishPhilippines               0x0d
#define kNtSublangEnglishIndia                     0x10
#define kNtSublangEnglishMalaysia                  0x11
#define kNtSublangEnglishSingapore                 0x12
#define kNtSublangEstonianEstonia                  0x01
#define kNtSublangFaeroeseFaroeIslands             0x01
#define kNtSublangFilipinoPhilippines              0x01
#define kNtSublangFinnishFinland                   0x01
#define kNtSublangFrench                           0x01
#define kNtSublangFrenchBelgian                    0x02
#define kNtSublangFrenchCanadian                   0x03
#define kNtSublangFrenchSwiss                      0x04
#define kNtSublangFrenchLuxembourg                 0x05
#define kNtSublangFrenchMonaco                     0x06
#define kNtSublangFrisianNetherlands               0x01
#define kNtSublangFulahSenegal                     0x02
#define kNtSublangGalicianGalician                 0x01
#define kNtSublangGeorgianGeorgia                  0x01
#define kNtSublangGerman                           0x01
#define kNtSublangGermanSwiss                      0x02
#define kNtSublangGermanAustrian                   0x03
#define kNtSublangGermanLuxembourg                 0x04
#define kNtSublangGermanLiechtenstein              0x05
#define kNtSublangGreekGreece                      0x01
#define kNtSublangGreenlandicGreenland             0x01
#define kNtSublangGujaratiIndia                    0x01
#define kNtSublangHausaNigeriaLatin                0x01
#define kNtSublangHawaiianUs                       0x01
#define kNtSublangHebrewIsrael                     0x01
#define kNtSublangHindiIndia                       0x01
#define kNtSublangHungarianHungary                 0x01
#define kNtSublangIcelandicIceland                 0x01
#define kNtSublangIgboNigeria                      0x01
#define kNtSublangIndonesianIndonesia              0x01
#define kNtSublangInuktitutCanada                  0x01
#define kNtSublangInuktitutCanadaLatin             0x02
#define kNtSublangIrishIreland                     0x02
#define kNtSublangItalian                          0x01
#define kNtSublangItalianSwiss                     0x02
#define kNtSublangJapaneseJapan                    0x01
#define kNtSublangKannadaIndia                     0x01
#define kNtSublangKashmiriSasia                    0x02
#define kNtSublangKashmiriIndia                    0x02
#define kNtSublangKazakKazakhstan                  0x01
#define kNtSublangKhmerCambodia                    0x01
#define kNtSublangKicheGuatemala                   0x01
#define kNtSublangKinyarwandaRwanda                0x01
#define kNtSublangKonkaniIndia                     0x01
#define kNtSublangKorean                           0x01
#define kNtSublangKyrgyzKyrgyzstan                 0x01
#define kNtSublangLaoLao                           0x01
#define kNtSublangLatvianLatvia                    0x01
#define kNtSublangLithuanian                       0x01
#define kNtSublangLowerSorbianGermany              0x02
#define kNtSublangLuxembourgishLuxembourg          0x01
#define kNtSublangMacedonianMacedonia              0x01
#define kNtSublangMalayMalaysia                    0x01
#define kNtSublangMalayBruneiDarussalam            0x02
#define kNtSublangMalayalamIndia                   0x01
#define kNtSublangMalteseMalta                     0x01
#define kNtSublangMaoriNewZealand                  0x01
#define kNtSublangMapudungunChile                  0x01
#define kNtSublangMarathiIndia                     0x01
#define kNtSublangMohawkMohawk                     0x01
#define kNtSublangMongolianCyrillicMongolia        0x01
#define kNtSublangMongolianPrc                     0x02
#define kNtSublangNepaliIndia                      0x02
#define kNtSublangNepaliNepal                      0x01
#define kNtSublangNorwegianBokmal                  0x01
#define kNtSublangNorwegianNynorsk                 0x02
#define kNtSublangOccitanFrance                    0x01
#define kNtSublangOdiaIndia                        0x01
#define kNtSublangOriyaIndia                       0x01
#define kNtSublangPashtoAfghanistan                0x01
#define kNtSublangPersianIran                      0x01
#define kNtSublangPolishPoland                     0x01
#define kNtSublangPortuguese                       0x02
#define kNtSublangPortugueseBrazilian              0x01
#define kNtSublangPularSenegal                     0x02
#define kNtSublangPunjabiIndia                     0x01
#define kNtSublangPunjabiPakistan                  0x02
#define kNtSublangQuechuaBolivia                   0x01
#define kNtSublangQuechuaEcuador                   0x02
#define kNtSublangQuechuaPeru                      0x03
#define kNtSublangRomanianRomania                  0x01
#define kNtSublangRomanshSwitzerland               0x01
#define kNtSublangRussianRussia                    0x01
#define kNtSublangSakhaRussia                      0x01
#define kNtSublangSamiNorthernNorway               0x01
#define kNtSublangSamiNorthernSweden               0x02
#define kNtSublangSamiNorthernFinland              0x03
#define kNtSublangSamiLuleNorway                   0x04
#define kNtSublangSamiLuleSweden                   0x05
#define kNtSublangSamiSouthernNorway               0x06
#define kNtSublangSamiSouthernSweden               0x07
#define kNtSublangSamiSkoltFinland                 0x08
#define kNtSublangSamiInariFinland                 0x09
#define kNtSublangSanskritIndia                    0x01
#define kNtSublangScottishGaelic                   0x01
#define kNtSublangSerbianBosniaHerzegovinaLatin    0x06
#define kNtSublangSerbianBosniaHerzegovinaCyrillic 0x07
#define kNtSublangSerbianMontenegroLatin           0x0b
#define kNtSublangSerbianMontenegroCyrillic        0x0c
#define kNtSublangSerbianSerbiaLatin               0x09
#define kNtSublangSerbianSerbiaCyrillic            0x0a
#define kNtSublangSerbianCroatia                   0x01
#define kNtSublangSerbianLatin                     0x02
#define kNtSublangSerbianCyrillic                  0x03
#define kNtSublangSindhiIndia                      0x01
#define kNtSublangSindhiPakistan                   0x02
#define kNtSublangSindhiAfghanistan                0x02
#define kNtSublangSinhaleseSriLanka                0x01
#define kNtSublangSothoNorthernSouthAfrica         0x01
#define kNtSublangSlovakSlovakia                   0x01
#define kNtSublangSlovenianSlovenia                0x01
#define kNtSublangSpanish                          0x01
#define kNtSublangSpanishMexican                   0x02
#define kNtSublangSpanishModern                    0x03
#define kNtSublangSpanishGuatemala                 0x04
#define kNtSublangSpanishCostaRica                 0x05
#define kNtSublangSpanishPanama                    0x06
#define kNtSublangSpanishDominicanRepublic         0x07
#define kNtSublangSpanishVenezuela                 0x08
#define kNtSublangSpanishColombia                  0x09
#define kNtSublangSpanishPeru                      0x0a
#define kNtSublangSpanishArgentina                 0x0b
#define kNtSublangSpanishEcuador                   0x0c
#define kNtSublangSpanishChile                     0x0d
#define kNtSublangSpanishUruguay                   0x0e
#define kNtSublangSpanishParaguay                  0x0f
#define kNtSublangSpanishBolivia                   0x10
#define kNtSublangSpanishElSalvador                0x11
#define kNtSublangSpanishHonduras                  0x12
#define kNtSublangSpanishNicaragua                 0x13
#define kNtSublangSpanishPuertoRico                0x14
#define kNtSublangSpanishUs                        0x15
#define kNtSublangSwahiliKenya                     0x01
#define kNtSublangSwedish                          0x01
#define kNtSublangSwedishFinland                   0x02
#define kNtSublangSyriacSyria                      0x01
#define kNtSublangTajikTajikistan                  0x01
#define kNtSublangTamazightAlgeriaLatin            0x02
#define kNtSublangTamazightMoroccoTifinagh         0x04
#define kNtSublangTamilIndia                       0x01
#define kNtSublangTamilSriLanka                    0x02
#define kNtSublangTatarRussia                      0x01
#define kNtSublangTeluguIndia                      0x01
#define kNtSublangThaiThailand                     0x01
#define kNtSublangTibetanPrc                       0x01
#define kNtSublangTigrignaEritrea                  0x02
#define kNtSublangTigrinyaEritrea                  0x02
#define kNtSublangTigrinyaEthiopia                 0x01
#define kNtSublangTswanaBotswana                   0x02
#define kNtSublangTswanaSouthAfrica                0x01
#define kNtSublangTurkishTurkey                    0x01
#define kNtSublangTurkmenTurkmenistan              0x01
#define kNtSublangUighurPrc                        0x01
#define kNtSublangUkrainianUkraine                 0x01
#define kNtSublangUpperSorbianGermany              0x01
#define kNtSublangUrduPakistan                     0x01
#define kNtSublangUrduIndia                        0x02
#define kNtSublangUzbekLatin                       0x01
#define kNtSublangUzbekCyrillic                    0x02
#define kNtSublangValencianValencia                0x02
#define kNtSublangVietnameseVietnam                0x01
#define kNtSublangWelshUnitedKingdom               0x01
#define kNtSublangWolofSenegal                     0x01
#define kNtSublangXhosaSouthAfrica                 0x01
#define kNtSublangYakutRussia                      0x01
#define kNtSublangYiPrc                            0x01
#define kNtSublangYorubaNigeria                    0x01
#define kNtSublangZuluSouthAfrica                  0x01



/*!BEGIN libc/nt/enum/loadlibrarysearch.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_LOADLIBRARYSEARCH_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtLoadLibrarySearchApplicationDir 0x00000200u
#define kNtLoadLibrarySearchSearchSystem32 0x00000800u
#define kNtLoadLibrarySearchUserDirs       0x00000400u
#define kNtLoadLibrarySearchDefaultDirs    0x00001000u

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/lockfile.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_LOCKFILE_H_

#define kNtLockfileFailImmediately 1
#define kNtLockfileExclusiveLock   2



/*!BEGIN libc/nt/enum/mb.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtMbOk                      0x00000000
#define kNtMbOkcancel                0x00000001
#define kNtMbAbortretryignore        0x00000002
#define kNtMbYesnocancel             0x00000003
#define kNtMbYesno                   0x00000004
#define kNtMbRetrycancel             0x00000005
#define kNtMbCanceltrycontinue       0x00000006
#define kNtMbIconhand                0x00000010
#define kNtMbIconquestion            0x00000020
#define kNtMbIconexclamation         0x00000030
#define kNtMbIconasterisk            0x00000040
#define kNtMbUsericon                0x00000080
#define kNtMbIconwarning             kNtMbIconexclamation
#define kNtMbIconerror               kNtMbIconhand
#define kNtMbIconinformation         kNtMbIconasterisk
#define kNtMbIconstop                kNtMbIconhand
#define kNtMbDefbutton1              0x00000000
#define kNtMbDefbutton2              0x00000100
#define kNtMbDefbutton3              0x00000200
#define kNtMbDefbutton4              0x00000300
#define kNtMbApplmodal               0x00000000
#define kNtMbSystemmodal             0x00001000
#define kNtMbTaskmodal               0x00002000
#define kNtMbHelp                    0x00004000
#define kNtMbNofocus                 0x00008000
#define kNtMbSetforeground           0x00010000
#define kNtMbDefaultDesktopOnly      0x00020000
#define kNtMbTopmost                 0x00040000
#define kNtMbRight                   0x00080000
#define kNtMbRtlreading              0x00100000
#define kNtMbServiceNotification     0x00200000
#define kNtMbServiceNotificationNt3x 0x00040000
#define kNtMbTypemask                0x0000000F
#define kNtMbIconmask                0x000000F0
#define kNtMbDefmask                 0x00000F00
#define kNtMbModemask                0x00003000
#define kNtMbMiscmask                0x0000C000

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/memflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MEMFLAGS_H_

#define kNtMemCommit 0x1000  /* perform physical memory reservation step */
#define kNtMemReserve 0x2000 /* perform virtual memory reservation step */
#define kNtMemDecommit 0x4000
#define kNtMemRelease 0x8000
#define kNtMemFree 0x10000
#define kNtMemPrivate 0x20000
#define kNtMemMapped 0x40000
#define kNtMemReset 0x80000
#define kNtMemTopDown 0x100000
#define kNtMemWriteWatch 0x200000
#define kNtMemPhysical 0x400000
#define kNtMemLargePages 0x20000000
#define kNtMem4mbPages 0x80000000



/*!BEGIN libc/nt/enum/memoryinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MEMORYINFORMATIONCLASS_H_

#define kNtMemoryBasicInformation    0
#define kNtMemoryWorkingSetList      1
#define kNtMemorySectionName         2
#define kNtMemoryBasicVlmInformation 3



/*!BEGIN libc/nt/enum/mf.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MF_H_

#define kNtMfInsert          0x00000000
#define kNtMfChange          0x00000080
#define kNtMfAppend          0x00000100
#define kNtMfDelete          0x00000200
#define kNtMfRemove          0x00001000
#define kNtMfBycommand       0x00000000
#define kNtMfByposition      0x00000400
#define kNtMfSeparator       0x00000800
#define kNtMfEnabled         0x00000000
#define kNtMfGrayed          0x00000001
#define kNtMfDisabled        0x00000002
#define kNtMfUnchecked       0x00000000
#define kNtMfChecked         0x00000008
#define kNtMfUsecheckbitmaps 0x00000200
#define kNtMfString          0x00000000
#define kNtMfBitmap          0x00000004
#define kNtMfOwnerdraw       0x00000100
#define kNtMfPopup           0x00000010
#define kNtMfMenubarbreak    0x00000020
#define kNtMfMenubreak       0x00000040
#define kNtMfUnhilite        0x00000000
#define kNtMfHilite          0x00000080
#define kNtMfDefault         0x00001000
#define kNtMfSysmenu         0x00002000
#define kNtMfHelp            0x00004000
#define kNtMfRightjustify    0x00004000
#define kNtMfMouseselect     0x00008000



/*!BEGIN libc/nt/enum/mk.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MK_H_

#define kNtMkLbutton  0x0001
#define kNtMkRbutton  0x0002
#define kNtMkShift    0x0004
#define kNtMkControl  0x0008
#define kNtMkMbutton  0x0010
#define kNtMkXbutton1 0x0020
#define kNtMkXbutton2 0x0040



/*!BEGIN libc/nt/enum/movefileexflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MOVEFILEEXFLAGS_H_

#define kNtMovefileReplaceExisting    1
#define kNtMovefileCopyAllowed        2
#define kNtMovefileDelayUntilReboot   4
#define kNtMovefileWriteThrough       8
#define kNtMovefileCreateHardlink     16
#define kNtMovefileFailIfNotTrackable 32



/*!BEGIN libc/nt/enum/objectinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OBJECTINFORMATIONCLASS_H_

#define kNtObjectBasicInformation 0 /*→ struct NtObjectBasicInformation */
#define kNtObjectNameInformation  1 /*→ etc. */
#define kNtObjectTypeInformation  2
#define kNtObjectAllInformation   3
#define kNtObjectDataInformation  4



/*!BEGIN libc/nt/enum/offerpriority.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OFFERPRIORITY_H_

/* TODO(jart): Are these values correct? */
#define kNtVmOfferPriorityVeryLow     1 /* 0x00001000? */
#define kNtVmOfferPriorityLow         2 /* 0x00002000? */
#define kNtVmOfferPriorityBelowNormal 3 /* 0x00002000? */
#define kNtVmOfferPriorityNormal      4 /* 0x00002000? */



/*!BEGIN libc/nt/enum/ofn.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OFN_H_

#define kNtOfnReadonly             0x00000001
#define kNtOfnOverwriteprompt      0x00000002
#define kNtOfnHidereadonly         0x00000004
#define kNtOfnNochangedir          0x00000008
#define kNtOfnShowhelp             0x00000010
#define kNtOfnEnablehook           0x00000020
#define kNtOfnEnabletemplate       0x00000040
#define kNtOfnEnabletemplatehandle 0x00000080
#define kNtOfnNovalidate           0x00000100
#define kNtOfnAllowmultiselect     0x00000200
#define kNtOfnExtensiondifferent   0x00000400
#define kNtOfnPathmustexist        0x00000800
#define kNtOfnFilemustexist        0x00001000
#define kNtOfnCreateprompt         0x00002000
#define kNtOfnShareaware           0x00004000
#define kNtOfnNoreadonlyreturn     0x00008000
#define kNtOfnNotestfilecreate     0x00010000
#define kNtOfnNonetworkbutton      0x00020000
#define kNtOfnNolongnames          0x00040000
#define kNtOfnExplorer             0x00080000
#define kNtOfnNodereferencelinks   0x00100000
#define kNtOfnLongnames            0x00200000
#define kNtOfnEnableincludenotify  0x00400000
#define kNtOfnEnablesizing         0x00800000
#define kNtOfnDontaddtorecent      0x02000000
#define kNtOfnForceshowhidden      0x10000000



/*!BEGIN libc/nt/enum/pageflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PAGEFLAGS_H_

/* Pick One */
#define kNtPageNoaccess         0x001
#define kNtPageReadonly         0x002
#define kNtPageReadwrite        0x004
#define kNtPageWritecopy        0x008
#define kNtPageExecute          0x010
#define kNtPageExecuteRead      0x020
#define kNtPageExecuteReadwrite 0x040
#define kNtPageExecuteWritecopy 0x080
#define kNtPageGuard            0x100
#define kNtPageNocache          0x200
#define kNtPageWritecombine     0x400

/* These may be OR'd */
#define kNtSecReserve        0x04000000
#define kNtSecCommit         0x08000000 /* default */
#define kNtSecImageNoExecute 0x11000000
#define kNtSecImage          0x01000000
#define kNtSecNocache        0x10000000
#define kNtSecLargePages     0x80000000
#define kNtSecWritecombine   0x40000000



/*!BEGIN libc/nt/enum/pdh.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PDH_H_

#define kNtPdhFmtRaw          0x00000010u
#define kNtPdhFmtAnsi         0x00000020u
#define kNtPdhFmtUnicode      0x00000040u
#define kNtPdhFmtLong         0x00000100u
#define kNtPdhFmtDouble       0x00000200u
#define kNtPdhFmtLarge        0x00000400u
#define kNtPdhFmtNoscale      0x00001000u
#define kNtPdhFmt1000         0x00002000u
#define kNtPdhFmtNodata       0x00004000u
#define kNtPdhFmtNocap100     0x00008000u
#define kNtPerfDetailCostly   0x00010000u
#define kNtPerfDetailStandard 0x0000FFFFu



/*!BEGIN libc/nt/enum/processaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSACCESS_H_

#define kNtProcessCreateProcess 0x0080u
#define kNtProcessCreateThread 0x0002u
#define kNtProcessDupHandle 0x0040u
#define kNtProcessQueryInformation 0x0400u
#define kNtProcessQueryLimitedInformation 0x1000u
#define kNtProcessSetInformation 0x0200u
#define kNtProcessSetQuota 0x0100u
#define kNtProcessSuspendResume 0x0800u
#define kNtProcessTerminate 0x0001u
#define kNtProcessVmOperation 0x0008u
#define kNtProcessVmRead 0x0010u
#define kNtProcessVmWrite 0x0020u
#define kNtProcessSynchronize kNtSynchronize
#define kNtProcessAllAccess \
  (kNtStandardRightsRequired | kNtSynchronize | 0xffffu)



/*!BEGIN libc/nt/enum/processcreationflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSCREATIONFLAGS_H_

#define kNtIdlePriorityClass        0x00000040u
#define kNtBelowNormalPriorityClass 0x00004000u
#define kNtNormalPriorityClass      0x00000020u
#define kNtAboveNormalPriorityClass 0x00008000u
#define kNtHighPriorityClass        0x00000080u
#define kNtRealtimePriorityClass    0x00000100u

#define kNtDebugProcess                 0x00000001u
#define kNtDebugOnlyThisProcess         0x00000002u
#define kNtCreateSuspended              0x00000004u
#define kNtDetachedProcess              0x00000008u
#define kNtCreateNewConsole             0x00000010u
#define kNtCreateNewProcessGroup        0x00000200u
#define kNtCreateUnicodeEnvironment     0x00000400u
#define kNtCreateSeparateWowVdm         0x00000800u
#define kNtCreateSharedWowVdm           0x00001000u
#define kNtCreateForcedos               0x00002000u
#define kNtInheritParentAffinity        0x00010000u
#define kNtCreateProtectedProcess       0x00040000u
#define kNtExtendedStartupinfoPresent   0x00080000u
#define kNtProcessModeBackgroundBegin   0x00100000u
#define kNtProcessModeBackgroundEnd     0x00200000u
#define kNtCreateSecureProcess          0x00400000u
#define kNtCreateBreakawayFromJob       0x01000000u
#define kNtCreatePreserveCodeAuthzLevel 0x02000000u
#define kNtCreateDefaultErrorMode       0x04000000u
#define kNtCreateNoWindow               0x08000000u
#define kNtProfileUser                  0x10000000u
#define kNtProfileKernel                0x20000000u
#define kNtProfileServer                0x40000000u
#define kNtCreateIgnoreSystemDefault    0x80000000u



/*!BEGIN libc/nt/enum/processinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSINFOCLASS_H_

#define kNtProcessBasicInformation 0
#define kNtProcessQuotaLimits      1
#define kNtProcessIoCounters       2
#define kNtProcessVmCounters       3
#define kNtProcessTimes            4
#define kNtProcessBasePriority     5
#define kNtProcessRaisePriority    6
#define kNtProcessDebugPort        7
#define kNtProcessExceptionPort    8
#define kNtProcessAccessToken      9
#define kNtProcessWow64Information 26
#define kNtProcessImageFileName    27



/*!BEGIN libc/nt/enum/procthreadattributes.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCTHREADATTRIBUTES_H_

#define kNtProcThreadAttributeReplaceValue 1
#define kNtProcThreadAttributeHandleList 0x00020002



/*!BEGIN libc/nt/enum/progress.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROGRESS_H_

#define kNtProgressContinue 0
#define kNtProgressCancel   1
#define kNtProgressStop     2
#define kNtProgressQuiet    3



/*!BEGIN libc/nt/enum/pwr.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PWR_H_

#define kNtPwrOk             1
#define kNtPwrFail           (-1)
#define kNtPwrSuspendrequest 1
#define kNtPwrSuspendresume  2
#define kNtPwrCriticalresume 3



/*!BEGIN libc/nt/enum/rdw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_RDW_H_

#define kNtRdwInvalidate      0x0001
#define kNtRdwInternalpaint   0x0002
#define kNtRdwErase           0x0004
#define kNtRdwValidate        0x0008
#define kNtRdwNointernalpaint 0x0010
#define kNtRdwNoerase         0x0020
#define kNtRdwNochildren      0x0040
#define kNtRdwAllchildren     0x0080
#define kNtRdwUpdatenow       0x0100
#define kNtRdwErasenow        0x0200
#define kNtRdwFrame           0x0400
#define kNtRdwNoframe         0x0800



/*!BEGIN libc/nt/enum/reggetvalueflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REGGETVALUEFLAGS_H_

#define kNtRrfRtRegNone        0x00000001
#define kNtRrfRtRegSz          0x00000002
#define kNtRrfRtRegExpandSz    0x00000004
#define kNtRrfRtRegBinary      0x00000008
#define kNtRrfRtRegDword       0x00000010
#define kNtRrfRtRegMultiSz     0x00000020
#define kNtRrfRtRegQword       0x00000040
#define kNtRrfRtDword          (kNtRrfRtRegBinary | kNtRrfRtRegDword)
#define kNtRrfRtQword          (kNtRrfRtRegBinary | kNtRrfRtRegQword)
#define kNtRrfRtAny            0x0000ffff
#define kNtRrfSubkeyWow6464key 0x00010000
#define kNtRrfSubkeyWow6432key 0x00020000
#define kNtRrfWow64Mask        0x00030000
#define kNtRrfNoexpand         0x10000000
#define kNtRrfZeroonfailure    0x20000000



/*!BEGIN libc/nt/enum/regtype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REGTYPE_H_

#define kNtRegNone                     0
#define kNtRegSz                       1 /* UTF-16 string */
#define kNtRegExpandSz                 2 /* UTF-16 string w/ env vars refs */
#define kNtRegBinary                   3
#define kNtRegDword                    4
#define kNtRegDwordBigEndian           5
#define kNtRegLink                     6
#define kNtRegMultiSz                  7 /* UTF-16 double-nul-terminated */
#define kNtRegResourceList             8
#define kNtRegFullResourceDescriptor   9
#define kNtRegResourceRequirementsList 10
#define kNtRegQword                    11



/*!BEGIN libc/nt/enum/replacefile.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REPLACEFILE_H_

#define kNtReplacefileWriteThrough      1
#define kNtReplacefileIgnoreMergeErrors 2
#define kNtReplacefileIgnoreAclErrors   4



/*!BEGIN libc/nt/enum/sc.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SC_H_

#define kNtScSize         0xF000
#define kNtScMove         0xF010
#define kNtScMinimize     0xF020
#define kNtScMaximize     0xF030
#define kNtScNextwindow   0xF040
#define kNtScPrevwindow   0xF050
#define kNtScClose        0xF060
#define kNtScVscroll      0xF070
#define kNtScHscroll      0xF080
#define kNtScMousemenu    0xF090
#define kNtScKeymenu      0xF100
#define kNtScArrange      0xF110
#define kNtScRestore      0xF120
#define kNtScTasklist     0xF130
#define kNtScScreensave   0xF140
#define kNtScHotkey       0xF150
#define kNtScDefault      0xF160
#define kNtScMonitorpower 0xF170
#define kNtScContexthelp  0xF180
#define kNtScSeparator    0xF00F



/*!BEGIN libc/nt/enum/sectioninformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONINFORMATIONCLASS_H_

#define kNtSectionBasicInformation 0
#define kNtSectionImageInformation 1



/*!BEGIN libc/nt/enum/sectioninherit.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONINHERIT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtSectionInherit { kNtViewShare = 1, kNtViewUnmap = 2 };

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/sectionmapflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONMAPFLAGS_H_

#define kNtSectionQuery              0x0001
#define kNtSectionMapWrite           0x0002
#define kNtSectionMapRead            0x0004
#define kNtSectionMapExecute         0x0008
#define kNtSectionExtendSize         0x0010
#define kNtSectionMapExecuteExplicit 0x0020



/*!BEGIN libc/nt/enum/securityimpersonationlevel.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECURITYIMPERSONATIONLEVEL_H_

#define kNtSecurityAnonymous      0
#define kNtSecurityIdentification 1
#define kNtSecurityImpersonation  2
#define kNtSecurityDelegation     3



/*!BEGIN libc/nt/enum/securityinformation.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECURITYINFORMATION_H_

#define kNtOwnerSecurityInformation 0x00000001
#define kNtGroupSecurityInformation 0x00000002
#define kNtDaclSecurityInformation 0x00000004
#define kNtSaclSecurityInformation 0x00000008
#define kNtLabelSecurityInformation 0x00000010
#define kNtAttributeSecurityInformation 0x00000020
#define kNtScopeSecurityInformation 0x00000040
#define kNtProcessTrustLabelSecurityInformation 0x00000080
#define kNtAccessFilterSecurityInformation 0x00000100
#define kNtBackupSecurityInformation 0x00010000
#define kNtProtectedDaclSecurityInformation 0x80000000
#define kNtProtectedSaclSecurityInformation 0x40000000
#define kNtUnprotectedDaclSecurityInformation 0x20000000
#define kNtUnprotectedSaclSecurityInformation 0x10000000



/*!BEGIN libc/nt/enum/signal.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIGNAL_H_

#define kNtSignalBreakpoint          0x80000003u
#define kNtSignalIllegalInstruction  0xC000001Du
#define kNtSignalPrivInstruction     0xC0000096u
#define kNtSignalGuardPage           0x80000001u
#define kNtSignalAccessViolation     0xC0000005u
#define kNtSignalInPageError         0xC0000006u
#define kNtSignalInvalidHandle       0xC0000008u
#define kNtSignalInvalidParameter    0xC000000du
#define kNtSignalFltDenormalOperand  0xC000008Du
#define kNtSignalFltDivideByZero     0xC000008Eu
#define kNtSignalFltInexactResult    0xC000008Fu
#define kNtSignalFltInvalidOperation 0xC0000090u
#define kNtSignalFltOverflow         0xC0000091u
#define kNtSignalFltStackCheck       0xC0000092u
#define kNtSignalFltUnderflow        0xC0000093u
#define kNtSignalIntegerDivideByZero 0xC0000094u
#define kNtSignalDllNotFound         0xC0000135u
#define kNtSignalOrdinalNotFound     0xC0000138u
#define kNtSignalEntrypointNotFound  0xC0000139u
#define kNtSignalControlCExit        0xC000013Au
#define kNtSignalDllInitFailed       0xC0000142u
#define kNtSignalFloatMultipleFaults 0xC00002B4u
#define kNtSignalFloatMultipleTraps  0xC00002B5u
#define kNtSignalAssertionFailure    0xC0000420u



/*!BEGIN libc/nt/enum/sio.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIO_H_

#define kNtSioAbsorbRtralert                      0x98000005u
#define kNtSioAcquirePortReservation              0x98000064u
#define kNtSioAddressListChange                   0x28000017u
#define kNtSioAddressListQuery                    0x48000016u
#define kNtSioAddressListSort                     0xc8000019u
#define kNtSioApplyTransportSetting               0x98000013u
#define kNtSioAssociateHandle                     0x88000001u
#define kNtSioAssociatePortReservation            0x98000066u
#define kNtSioBaseHandle                          0x48000022u
#define kNtSioBspHandlePoll                       0x4800001Du
#define kNtSioDeletePeerTargetName                0x980000cbu
#define kNtSioEnableCircularQueueing              0x28000002u
#define kNtSioFindRoute                           0x48000003u
#define kNtSioFlush                               0x28000004u
#define kNtSioGetBroadcastAddress                 0x48000005u
#define kNtSioGetExtensionFunctionPointer         0xc8000006u
#define kNtSioGetGroupQos                         0xc8000008u
#define kNtSioGetInterfaceList                    0x4008747fu
#define kNtSioGetMultipleExtensionFunctionPointer 0xc8000024u
#define kNtSioGetQos                              0xc8000007u
#define kNtSioIndexAddMcast                       0x9800000au
#define kNtSioIndexBind                           0x98000008u
#define kNtSioIndexDelMcast                       0x9800000bu
#define kNtSioIndexMcastif                        0x98000009u
#define kNtSioKeepaliveVals                       0x98000004u
#define kNtSioLimitBroadcasts                     0x98000007u
#define kNtSioLoopbackFastPath                    0x98000010u
#define kNtSioMulticastScope                      0x8800000au
#define kNtSioMultipointLoopback                  0x88000009u
#define kNtSioQueryRssProcessorInfo               0x48000025u
#define kNtSioQueryRssScalabilityInfo             0x580000d2u
#define kNtSioQuerySecurity                       0xd80000c9u
#define kNtSioQueryTargetPnpHandle                0x48000018u
#define kNtSioQueryTransportSetting               0x98000014u
#define kNtSioQueryWfpAleEndpointHandle           0x580000cdu
#define kNtSioQueryWfpConnectionRedirectContext   0x980000ddu
#define kNtSioQueryWfpConnectionRedirectRecords   0x980000dcu
#define kNtSioRcvall                              0x98000001u
#define kNtSioRcvallIf                            0x9800000eu
#define kNtSioRcvallIgmpmcast                     0x98000003u
#define kNtSioRcvallMcast                         0x98000002u
#define kNtSioRcvallMcastIf                       0x9800000du
#define kNtSioReleasePortReservation              0x98000065u
#define kNtSioReserved1                           0x8800001au
#define kNtSioReserved2                           0x88000021u
#define kNtSioRoutingInterfaceChange              0x88000015u
#define kNtSioRoutingInterfaceQuery               0xc8000014u
#define kNtSioSetGroupQos                         0x8800000cu
#define kNtSioSetPeerTargetName                   0x980000cau
#define kNtSioSetPriorityHint                     0x98000018u
#define kNtSioSetQos                              0x8800000bu
#define kNtSioSetSecurity                         0x980000c8u
#define kNtSioSetWfpConnectionRedirectRecords     0x980000deu
#define kNtSioSocketCloseNotify                   0x9800000du
#define kNtSioSocketUsageNotification             0x980000ccu
#define kNtSioTcpInfo                             0xd8000027u
#define kNtSioTcpInitialRto                       0x98000011u
#define kNtSioTcpSetAckFrequency                  0x98000017u
#define kNtSioTcpSetIcw                           0x98000016u
#define kNtSioTranslateHandle                     0xc800000du
#define kNtSioUcastIf                             0x98000006u
#define kNtSioUdpConnreset                        0x9800000cu
#define kNtSioUdpNetreset                         0x9800000fu



/*!BEGIN libc/nt/enum/size.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIZE_H_

#define kNtSizeRestored  0
#define kNtSizeMinimized 1
#define kNtSizeMaximized 2
#define kNtSizeMaxshow   3
#define kNtSizeMaxhide   4



/*!BEGIN libc/nt/enum/startf.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_STARTF_H_

#define kNtStartfUseshowwindow 0x00000001 /* otherwise wShowWindow ignored */
#define kNtStartfUsesize 0x00000002       /* otherwise dwX / dwY ignored */
#define kNtStartfUseposition 0x00000004   /* otherwise dwX/YSize ignored */
#define kNtStartfUsecountchars 0x00000008 /* otherwise dwX/YCountChars ign. */
#define kNtStartfUsefillattribute 0x00000010 /* etc. */
#define kNtStartfRunfullscreen 0x00000020
#define kNtStartfForceonfeedback 0x00000040
#define kNtStartfForceofffeedback 0x00000080
#define kNtStartfUsestdhandles 0x00000100 /* otherwise hStd... ignored */
#define kNtStartfUsehotkey 0x00000200
#define kNtStartfTitleislinkname 0x00000800
#define kNtStartfTitleisappid 0x00001000
#define kNtStartfPreventpinning 0x00002000
#define kNtStartfUntrustedsource 0x00008000



/*!BEGIN libc/nt/enum/status.h */

#define COSMOPOLITAN_LIBC_NT_STATUS_H_

/* high two bits = {success,informational,warning,error} */
#define kNtStatusSuccess                  0x00000000 /* success statuses */
#define kNtStatusWait0                    0x00000000
#define kNtStatusAbandonedWait0           0x00000080
#define kNtStatusUserApc                  0x000000C0
#define kNtStatusTimeout                  0x00000102
#define kNtStatusPending                  0x00000103
#define kNtStatusGuardPageViolation       0x80000001 /* warning statuses */
#define kNtStatusDatatypeMisalignment     0x80000002
#define kNtStatusBreakpoint               0x80000003
#define kNtStatusSingleStep               0x80000004
#define kNtStatusLongjump                 0x80000026
#define kNtStatusUnwindConsolidate        0x80000029
#define kNtStatusAccessViolation          0xC0000005 /* error statuses */
#define kNtStatusInPageError              0xC0000006
#define kNtStatusInvalidHandle            0xC0000008
#define kNtStatusInvalidParameter         0xC000000D
#define kNtStatusNoMemory                 0xC0000017
#define kNtStatusIllegalInstruction       0xC000001D
#define kNtStatusNoncontinuableException  0xC0000025
#define kNtStatusInvalidDisposition       0xC0000026
#define kNtStatusArrayBoundsExceeded      0xC000008C
#define kNtStatusFloatDenormalOperand     0xC000008D
#define kNtStatusFloatDivideByZero        0xC000008E
#define kNtStatusFloatInexactResult       0xC000008F
#define kNtStatusFloatInvalidOperation    0xC0000090
#define kNtStatusFloatOverflow            0xC0000091
#define kNtStatusFloatStackCheck          0xC0000092
#define kNtStatusFloatUnderflow           0xC0000093
#define kNtStatusIntegerDivideBYZero      0xC0000094
#define kNtStatusIntegerOverflow          0xC0000095
#define kNtStatusPrivilegedInstruction    0xC0000096
#define kNtStatusStackOverflow            0xC00000FD
#define kNtStatusDllNotFound              0xC0000135
#define kNtStatusOrdinalNotFound          0xC0000138
#define kNtStatusEntrypointNotFound       0xC0000139
#define kNtStatusControlCExit             0xC000013A
#define kNtStatusDllInitFailed            0xC0000142
#define kNtStatusFloatMultipleFaults      0xC00002B4
#define kNtStatusFloatMultipleTraps       0xC00002B5
#define kNtStatusRegNatConsumption        0xC00002C9
#define kNtStatusHeapCorruption           0xC0000374
#define kNtStatusStackBufferOverrun       0xC0000409
#define kNtStatusInvalidCruntimeParameter 0xC0000417
#define kNtStatusAssertionFailure         0xC0000420
#define kNtStatusEnclaveViolation         0xC00004A2
#define kNtStatusSegmentNotification      0x40000005
#define kNtStatusFatalAppExit             0x40000015
#define kNtStatusNotFound                 0xC0000225
#define kNtStatusCancelled                0xC0000120

#define kNtDbgExceptionHandled    0x00010001
#define kNtDbgContinue            0x00010002
#define kNtDbgReplyLater          0x40010001
#define kNtDbgTerminateThread     0x40010003
#define kNtDbgTerminateProcess    0x40010004
#define kNtDbgControlC            0x40010005
#define kNtDbgPrintexceptionC     0x40010006
#define kNtDbgRipexception        0x40010007
#define kNtDbgControlBreak        0x40010008
#define kNtDbgCommandException    0x40010009
#define kNtDbgPrintexceptionWideC 0x4001000A
#define kNtDbgExceptionNotHandled 0x80010001
#define kNtStillActive            kNtStatusPending

#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef uint32_t NtStatus;

#define NtSuccess(s)      ((NtStatus)(s) >= 0)
#define NtInformation(s)  (NtSeverity(s) == 1)
#define NtWarning(s)      (NtSeverity(s) == 2)
#define NtError(s)        (NtSeverity(s) == 3)
#define NtCode(s)         ((NtStatus)(s)&0xffff)
#define NtSeverity(s)     ((NtStatus)(s) >> 30)
#define NtFacility(s)     (((NtStatus)(s) >> 16) & 0xfff)
#define NtFacilityCode(s) ((NtStatus)(s)&0x0FFFFFFF)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/sw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SW_H_

#define kNtSwHide            0
#define kNtSwShownormal      1
#define kNtSwNormal          1
#define kNtSwShowminimized   2
#define kNtSwShowmaximized   3
#define kNtSwMaximize        3
#define kNtSwShownoactivate  4
#define kNtSwShow            5
#define kNtSwMinimize        6
#define kNtSwShowminnoactive 7
#define kNtSwShowna          8
#define kNtSwRestore         9
#define kNtSwShowdefault     10
#define kNtSwForceminimize   11



/*!BEGIN libc/nt/enum/symboliclink.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SYMBOLICLINK_H_

#define kNtSymbolicLinkFlagDirectory               1
#define kNtSymbolicLinkFlagAllowUnprivilegedCreate 2



/*!BEGIN libc/nt/enum/systeminformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SYSTEMINFORMATIONCLASS_H_

#define kNtSystemBasicInformation 0
#define kNtSystemProcessorInformation 1
#define kNtSystemPerformanceInformation 2
#define kNtSystemTimeOfDayInformation 3
#define kNtSystemProcessInformation 5
#define kNtSystemProcessorTimes 8
#define kNtSystemGlobalFlag 9
#define kNtSystemModuleInformation 11
#define kNtSystemLockInformation 12
#define kNtSystemHandleInformation 16
#define kNtSystemObjectInformation 17
#define kNtSystemInterruptInformation 23
#define kNtSystemExceptionInformation 33
#define kNtSystemRegistryQuotaInformation 37
#define kNtSystemLookasideInformation 45



/*!BEGIN libc/nt/enum/th32cs.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TH32CS_H_

#define kNtTh32csInherit      0x80000000
#define kNtTh32csSnapheaplist 0x00000001
#define kNtTh32csSnapmodule   0x00000008
#define kNtTh32csSnapmodule32 0x00000010
#define kNtTh32csSnapprocess  0x00000002
#define kNtTh32csSnapthread   0x00000004



/*!BEGIN libc/nt/enum/threadaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADACCESS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtThreadTerminate 0x0001
#define kNtThreadSuspendResume 0x0002
#define kNtThreadGetContext 0x0008
#define kNtThreadSetContext 0x0010
#define kNtThreadQueryInformation 0x0040
#define kNtThreadSetInformation 0x0020
#define kNtThreadSetThreadToken 0x0080
#define kNtThreadImpersonate 0x0100
#define kNtThreadDirectImpersonation 0x0200
#define kNtThreadSetLimitedInformation 0x0400
#define kNtThreadQueryLimitedInformation 0x0800
#define kNtThreadResume 0x1000
#define kNtThreadAllAccess (kNtStandardRightsRequired | kNtSynchronize | 0xFFFF)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/threadinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADINFOCLASS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtThreadInfoClass {
  kNtThreadBasicInformation,
  kNtThreadTimes,
  kNtThreadPriority,
  kNtThreadBasePriority,
  kNtThreadAffinityMask,
  kNtThreadImpersonationToken,
  kNtThreadDescriptorTableEntry,
  kNtThreadEnableAlignmentFaultFixup,
  kNtThreadEventPair_Reusable,
  kNtThreadQuerySetWin32StartAddress,
  kNtThreadZeroTlsCell,
  kNtThreadPerformanceCount,
  kNtThreadAmILastThread,
  kNtThreadIdealProcessor,
  kNtThreadPriorityBoost,
  kNtThreadSetTlsArrayAddress,
  kNtThreadIsIoPending,
  kNtThreadHideFromDebugger,
  kNtThreadInfoClass_MAX
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/threadpriority.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADPRIORITY_H_

#define kNtThreadBasePriorityIdle  (-15)
#define kNtThreadBasePriorityMin   (-2)
#define kNtThreadBasePriorityMax   2
#define kNtThreadBasePriorityLowrt 15

#define kNtThreadPriorityIdle         kNtThreadBasePriorityIdle
#define kNtThreadPriorityLowest       kNtThreadBasePriorityMin
#define kNtThreadPriorityBelowNormal  (kNtThreadPriorityLowest + 1)
#define kNtThreadPriorityNormal       0
#define kNtThreadPriorityAboveNormal  (kNtThreadPriorityHighest - 1)
#define kNtThreadPriorityHighest      kNtThreadBasePriorityMax
#define kNtThreadPriorityTimeCritical kNtThreadBasePriorityLowrt



/*!BEGIN libc/nt/enum/threadstate.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADSTATE_H_

#define kNtStateInitialized 0
#define kNtStateReady       1
#define kNtStateRunning     2
#define kNtStateStandby     3
#define kNtStateTerminated  4
#define kNtStateWait        5
#define kNtStateTransition  6
#define kNtStateUnknown     7



/*!BEGIN libc/nt/enum/tokeninformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TOKENINFORMATIONCLASS_H_

#define kNtTokenUser 1
#define kNtTokenGroups 2
#define kNtTokenPrivileges 3
#define kNtTokenOwner 4
#define kNtTokenPrimaryGroup 5
#define kNtTokenDefaultDacl 6
#define kNtTokenSource 7
#define kNtTokenType 8
#define kNtTokenImpersonationLevel 9
#define kNtTokenStatistics 10
#define kNtTokenRestrictedSids 11
#define kNtTokenSessionId 12
#define kNtTokenGroupsAndPrivileges 13
#define kNtTokenSessionReference 14
#define kNtTokenSandBoxInert 15
#define kNtTokenAuditPolicy 16
#define kNtTokenOrigin 17
#define kNtTokenInfoClass_MAX 18



/*!BEGIN libc/nt/enum/tokentype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TOKENTYPE_H_

#define kNtTokenPrimary       1
#define kNtTokenImpersonation 2



/*!BEGIN libc/nt/enum/tpm.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TPM_H_

#define kNtTpmLeftbutton      0x00000
#define kNtTpmRightbutton     0x00002
#define kNtTpmLeftalign       0x00000
#define kNtTpmCenteralign     0x00004
#define kNtTpmRightalign      0x00008
#define kNtTpmTopalign        0x00000
#define kNtTpmVcenteralign    0x00010
#define kNtTpmBottomalign     0x00020
#define kNtTpmHorizontal      0x00000
#define kNtTpmVertical        0x00040
#define kNtTpmNonotify        0x00080
#define kNtTpmReturncmd       0x00100
#define kNtTpmRecurse         0x00001
#define kNtTpmHorposanimation 0x00400
#define kNtTpmHorneganimation 0x00800
#define kNtTpmVerposanimation 0x01000
#define kNtTpmVerneganimation 0x02000
#define kNtTpmNoanimation     0x04000
#define kNtTpmLayoutrtl       0x08000
#define kNtTpmWorkarea        0x10000



/*!BEGIN libc/nt/enum/valueinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VALUEINFORMATIONCLASS_H_

#define kNtKeyValueBasicInformation          0
#define kNtKeyValueFullInformation           1
#define kNtKeyValuePartialInformation        2
#define kNtKeyValueFullInformationAlign64    3
#define kNtKeyValuePartialInformationAlign64 4



/*!BEGIN libc/nt/enum/version.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VERSION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Known versions of the New Technology executive.
 * @see IsAtLeastWindows10()
 * @see NtGetVersion()
 */
#define kNtVersionWindows10    0x0a00
#define kNtVersionWindows81    0x0603
#define kNtVersionWindows8     0x0602
#define kNtVersionWindows7     0x0601
#define kNtVersionWindowsVista 0x0600 /* intended baseline */
#define kNtVersionWindowsXp64  0x0502 /* end of the road */
#define kNtVersionWindowsXp    0x0501 /* snowball's chance */
#define kNtVersionWindows2000  0x0500 /* the golden age */
#define kNtVersionFuture       0x0b00

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/vk.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VK_H_

#define kNtVkLbutton                      0x01
#define kNtVkRbutton                      0x02
#define kNtVkCancel                       0x03
#define kNtVkMbutton                      0x04
#define kNtVkXbutton1                     0x05
#define kNtVkXbutton2                     0x06
#define kNtVkBack                         0x08
#define kNtVkTab                          0x09
#define kNtVkClear                        0x0C
#define kNtVkReturn                       0x0D
#define kNtVkShift                        0x10
#define kNtVkControl                      0x11
#define kNtVkMenu                         0x12 /* alt? */
#define kNtVkPause                        0x13
#define kNtVkCapital                      0x14
#define kNtVkKana                         0x15
#define kNtVkHangul                       0x15
#define kNtVkJunja                        0x17
#define kNtVkFinal                        0x18
#define kNtVkHanja                        0x19
#define kNtVkKanji                        0x19
#define kNtVkEscape                       0x1B
#define kNtVkConvert                      0x1C
#define kNtVkNonconvert                   0x1D
#define kNtVkAccept                       0x1E
#define kNtVkModechange                   0x1F
#define kNtVkSpace                        0x20
#define kNtVkPrior                        0x21
#define kNtVkNext                         0x22
#define kNtVkEnd                          0x23
#define kNtVkHome                         0x24
#define kNtVkLeft                         0x25
#define kNtVkUp                           0x26
#define kNtVkRight                        0x27
#define kNtVkDown                         0x28
#define kNtVkSelect                       0x29
#define kNtVkPrint                        0x2A
#define kNtVkExecute                      0x2B
#define kNtVkSnapshot                     0x2C
#define kNtVkInsert                       0x2D
#define kNtVkDelete                       0x2E
#define kNtVkHelp                         0x2F
#define kNtVkLwin                         0x5B
#define kNtVkRwin                         0x5C
#define kNtVkApps                         0x5D
#define kNtVkSleep                        0x5F
#define kNtVkNumpad0                      0x60
#define kNtVkNumpad1                      0x61
#define kNtVkNumpad2                      0x62
#define kNtVkNumpad3                      0x63
#define kNtVkNumpad4                      0x64
#define kNtVkNumpad5                      0x65
#define kNtVkNumpad6                      0x66
#define kNtVkNumpad7                      0x67
#define kNtVkNumpad8                      0x68
#define kNtVkNumpad9                      0x69
#define kNtVkMultiply                     0x6A
#define kNtVkAdd                          0x6B
#define kNtVkSeparator                    0x6C
#define kNtVkSubtract                     0x6D
#define kNtVkDecimal                      0x6E
#define kNtVkDivide                       0x6F
#define kNtVkF1                           0x70
#define kNtVkF2                           0x71
#define kNtVkF3                           0x72
#define kNtVkF4                           0x73
#define kNtVkF5                           0x74
#define kNtVkF6                           0x75
#define kNtVkF7                           0x76
#define kNtVkF8                           0x77
#define kNtVkF9                           0x78
#define kNtVkF10                          0x79
#define kNtVkF11                          0x7A
#define kNtVkF12                          0x7B
#define kNtVkF13                          0x7C
#define kNtVkF14                          0x7D
#define kNtVkF15                          0x7E
#define kNtVkF16                          0x7F
#define kNtVkF17                          0x80
#define kNtVkF18                          0x81
#define kNtVkF19                          0x82
#define kNtVkF20                          0x83
#define kNtVkF21                          0x84
#define kNtVkF22                          0x85
#define kNtVkF23                          0x86
#define kNtVkF24                          0x87
#define kNtVkNumlock                      0x90
#define kNtVkScroll                       0x91
#define kNtVkLshift                       0xA0
#define kNtVkRshift                       0xA1
#define kNtVkLcontrol                     0xA2
#define kNtVkRcontrol                     0xA3
#define kNtVkLmenu                        0xA4
#define kNtVkRmenu                        0xA5
#define kNtVkBrowserBack                  0xA6
#define kNtVkBrowserForward               0xA7
#define kNtVkBrowserRefresh               0xA8
#define kNtVkBrowserStop                  0xA9
#define kNtVkBrowserSearch                0xAA
#define kNtVkBrowserFavorites             0xAB
#define kNtVkBrowserHome                  0xAC
#define kNtVkVolumeMute                   0xAD
#define kNtVkVolumeDown                   0xAE
#define kNtVkVolumeUp                     0xAF
#define kNtVkMediaNextTrack               0xB0
#define kNtVkMediaPrevTrack               0xB1
#define kNtVkMediaStop                    0xB2
#define kNtVkMediaPlayPause               0xB3
#define kNtVkLaunchMail                   0xB4
#define kNtVkLaunchMediaSelect            0xB5
#define kNtVkLaunchApp1                   0xB6
#define kNtVkLaunchApp2                   0xB7
#define kNtVkOem_1                        0xBA
#define kNtVkOemPlus                      0xBB
#define kNtVkOemComma                     0xBC
#define kNtVkOemMinus                     0xBD
#define kNtVkOemPeriod                    0xBE
#define kNtVkOem_2                        0xBF
#define kNtVkOem_3                        0xC0
#define kNtVkGamepadA                     0xC3
#define kNtVkGamepadB                     0xC4
#define kNtVkGamepadX                     0xC5
#define kNtVkGamepadY                     0xC6
#define kNtVkGamepadRightShoulder         0xC7
#define kNtVkGamepadLeftShoulder          0xC8
#define kNtVkGamepadLeftTrigger           0xC9
#define kNtVkGamepadRightTrigger          0xCA
#define kNtVkGamepadDpadUp                0xCB
#define kNtVkGamepadDpadDown              0xCC
#define kNtVkGamepadDpadLeft              0xCD
#define kNtVkGamepadDpadRight             0xCE
#define kNtVkGamepadMenu                  0xCF
#define kNtVkGamepadView                  0xD0
#define kNtVkGamepadLeftThumbstickButton  0xD1
#define kNtVkGamepadRightThumbstickButton 0xD2
#define kNtVkGamepadLeftThumbstickUp      0xD3
#define kNtVkGamepadLeftThumbstickDown    0xD4
#define kNtVkGamepadLeftThumbstickRight   0xD5
#define kNtVkGamepadLeftThumbstickLeft    0xD6
#define kNtVkGamepadRightThumbstickUp     0xD7
#define kNtVkGamepadRightThumbstickDown   0xD8
#define kNtVkGamepadRightThumbstickRight  0xD9
#define kNtVkGamepadRightThumbstickLeft   0xDA
#define kNtVkOem_4                        0xDB
#define kNtVkOem_5                        0xDC
#define kNtVkOem_6                        0xDD
#define kNtVkOem_7                        0xDE
#define kNtVkOem_8                        0xDF
#define kNtVkOemAx                        0xE1
#define kNtVkOem_102                      0xE2
#define kNtVkIcoHelp                      0xE3
#define kNtVkIco_00                       0xE4
#define kNtVkProcesskey                   0xE5
#define kNtVkIcoClear                     0xE6
#define kNtVkPacket                       0xE7
#define kNtVkOemReset                     0xE9
#define kNtVkOemJump                      0xEA
#define kNtVkOemPa1                       0xEB
#define kNtVkOemPa2                       0xEC
#define kNtVkOemPa3                       0xED
#define kNtVkOemWsctrl                    0xEE
#define kNtVkOemCusel                     0xEF
#define kNtVkOemAttn                      0xF0
#define kNtVkOemFinish                    0xF1
#define kNtVkOemCopy                      0xF2
#define kNtVkOemAuto                      0xF3
#define kNtVkOemEnlw                      0xF4
#define kNtVkOemBacktab                   0xF5
#define kNtVkAttn                         0xF6
#define kNtVkCrsel                        0xF7
#define kNtVkExsel                        0xF8
#define kNtVkEreof                        0xF9
#define kNtVkPlay                         0xFA
#define kNtVkZoom                         0xFB
#define kNtVkNoname                       0xFC
#define kNtVkPa1                          0xFD
#define kNtVkOemClear                     0xFE



/*!BEGIN libc/nt/enum/wa.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WA_H_

#define kNtWaInactive    0
#define kNtWaActive      1
#define kNtWaClickactive 2



/*!BEGIN libc/nt/enum/wait.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WAIT_H_

#define kNtWaitFailed  0xffffffffu
#define kNtWaitTimeout 0x00000102u



/*!BEGIN libc/nt/enum/wm.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WM_H_

#define kNtWmNull                   0x0000
#define kNtWmCreate                 0x0001
#define kNtWmDestroy                0x0002
#define kNtWmMove                   0x0003
#define kNtWmSize                   0x0005
#define kNtWmActivate               0x0006
#define kNtWmSetfocus               0x0007
#define kNtWmKillfocus              0x0008
#define kNtWmEnable                 0x000A
#define kNtWmSetredraw              0x000B
#define kNtWmSettext                0x000C
#define kNtWmGettext                0x000D
#define kNtWmGettextlength          0x000E
#define kNtWmPaint                  0x000F
#define kNtWmClose                  0x0010
#define kNtWmQueryendsession        0x0011
#define kNtWmQueryopen              0x0013
#define kNtWmEndsession             0x0016
#define kNtWmQuit                   0x0012
#define kNtWmErasebkgnd             0x0014
#define kNtWmSyscolorchange         0x0015
#define kNtWmShowwindow             0x0018
#define kNtWmWininichange           0x001A
#define kNtWmSettingchange          kNtWmWininichange
#define kNtWmDevmodechange          0x001B
#define kNtWmActivateapp            0x001C
#define kNtWmFontchange             0x001D
#define kNtWmTimechange             0x001E
#define kNtWmCancelmode             0x001F
#define kNtWmSetcursor              0x0020
#define kNtWmMouseactivate          0x0021
#define kNtWmChildactivate          0x0022
#define kNtWmQueuesync              0x0023
#define kNtWmGetminmaxinfo          0x0024
#define kNtWmPainticon              0x0026
#define kNtWmIconerasebkgnd         0x0027
#define kNtWmNextdlgctl             0x0028
#define kNtWmSpoolerstatus          0x002A
#define kNtWmDrawitem               0x002B
#define kNtWmMeasureitem            0x002C
#define kNtWmDeleteitem             0x002D
#define kNtWmVkeytoitem             0x002E
#define kNtWmChartoitem             0x002F
#define kNtWmSetfont                0x0030
#define kNtWmGetfont                0x0031
#define kNtWmSethotkey              0x0032
#define kNtWmGethotkey              0x0033
#define kNtWmQuerydragicon          0x0037
#define kNtWmCompareitem            0x0039
#define kNtWmGetobject              0x003D
#define kNtWmCompacting             0x0041
#define kNtWmWindowposchanging      0x0046
#define kNtWmWindowposchanged       0x0047
#define kNtWmPower                  0x0048
#define kNtWmCopydata               0x004A
#define kNtWmCanceljournal          0x004B
#define kNtWmNotify                 0x004E
#define kNtWmInputlangchangerequest 0x0050
#define kNtWmInputlangchange        0x0051
#define kNtWmTcard                  0x0052
#define kNtWmHelp                   0x0053
#define kNtWmUserchanged            0x0054
#define kNtWmNotifyformat           0x0055
#define kNtWmContextmenu            0x007B
#define kNtWmStylechanging          0x007C
#define kNtWmStylechanged           0x007D
#define kNtWmDisplaychange          0x007E
#define kNtWmGeticon                0x007F
#define kNtWmSeticon                0x0080
#define kNtWmNccreate               0x0081
#define kNtWmNcdestroy              0x0082
#define kNtWmNccalcsize             0x0083
#define kNtWmNchittest              0x0084
#define kNtWmNcpaint                0x0085
#define kNtWmNcactivate             0x0086
#define kNtWmGetdlgcode             0x0087
#define kNtWmNcmousemove            0x00A0
#define kNtWmNclbuttondown          0x00A1
#define kNtWmNclbuttonup            0x00A2
#define kNtWmNclbuttondblclk        0x00A3
#define kNtWmNcrbuttondown          0x00A4
#define kNtWmNcrbuttonup            0x00A5
#define kNtWmNcrbuttondblclk        0x00A6
#define kNtWmNcmbuttondown          0x00A7
#define kNtWmNcmbuttonup            0x00A8
#define kNtWmNcmbuttondblclk        0x00A9
#define kNtWmNcxbuttondown          0x00AB
#define kNtWmNcxbuttonup            0x00AC
#define kNtWmNcxbuttondblclk        0x00AD
#define kNtWmKeyfirst               0x0100
#define kNtWmKeydown                0x0100
#define kNtWmKeyup                  0x0101
#define kNtWmChar                   0x0102
#define kNtWmDeadchar               0x0103
#define kNtWmSyskeydown             0x0104
#define kNtWmSyskeyup               0x0105
#define kNtWmSyschar                0x0106
#define kNtWmSysdeadchar            0x0107
#define kNtWmUnichar                0x0109
#define kNtWmKeylast                0x0109
#define kNtWmInitdialog             0x0110
#define kNtWmCommand                0x0111
#define kNtWmSyscommand             0x0112
#define kNtWmTimer                  0x0113
#define kNtWmHscroll                0x0114
#define kNtWmVscroll                0x0115
#define kNtWmInitmenu               0x0116
#define kNtWmInitmenupopup          0x0117
#define kNtWmGesture                0x0119
#define kNtWmGesturenotify          0x011A
#define kNtWmMenuselect             0x011F
#define kNtWmMenuchar               0x0120
#define kNtWmEnteridle              0x0121
#define kNtWmMenurbuttonup          0x0122
#define kNtWmMenudrag               0x0123
#define kNtWmMenugetobject          0x0124
#define kNtWmUninitmenupopup        0x0125
#define kNtWmMenucommand            0x0126
#define kNtWmChangeuistate          0x0127
#define kNtWmUpdateuistate          0x0128
#define kNtWmQueryuistate           0x0129
#define kNtWmMousefirst             0x0200
#define kNtWmMousemove              0x0200
#define kNtWmLbuttondown            0x0201
#define kNtWmLbuttonup              0x0202
#define kNtWmLbuttondblclk          0x0203
#define kNtWmRbuttondown            0x0204
#define kNtWmRbuttonup              0x0205
#define kNtWmRbuttondblclk          0x0206
#define kNtWmMbuttondown            0x0207
#define kNtWmMbuttonup              0x0208
#define kNtWmMbuttondblclk          0x0209
#define kNtWmMousewheel             0x020A
#define kNtWmXbuttondown            0x020B
#define kNtWmXbuttonup              0x020C
#define kNtWmXbuttondblclk          0x020D
#define kNtWmMousehwheel            0x020E
#define kNtWmMouselast              0x020E
#define kNtWmParentnotify           0x0210
#define kNtWmEntermenuloop          0x0211
#define kNtWmExitmenuloop           0x0212
#define kNtWmNextmenu               0x0213
#define kNtWmSizing                 0x0214
#define kNtWmCapturechanged         0x0215
#define kNtWmMoving                 0x0216
#define kNtWmPowerbroadcast         0x0218
#define kNtWmMdicreate              0x0220
#define kNtWmMdidestroy             0x0221
#define kNtWmMdiactivate            0x0222
#define kNtWmMdirestore             0x0223
#define kNtWmMdinext                0x0224
#define kNtWmMdimaximize            0x0225
#define kNtWmMditile                0x0226
#define kNtWmMdicascade             0x0227
#define kNtWmMdiiconarrange         0x0228
#define kNtWmMdigetactive           0x0229
#define kNtWmMdisetmenu             0x0230
#define kNtWmEntersizemove          0x0231
#define kNtWmExitsizemove           0x0232
#define kNtWmDropfiles              0x0233
#define kNtWmMdirefreshmenu         0x0234
#define kNtWmCut                    0x0300
#define kNtWmCopy                   0x0301
#define kNtWmPaste                  0x0302
#define kNtWmClear                  0x0303
#define kNtWmUndo                   0x0304
#define kNtWmRenderformat           0x0305
#define kNtWmRenderallformats       0x0306
#define kNtWmDestroyclipboard       0x0307
#define kNtWmDrawclipboard          0x0308
#define kNtWmPaintclipboard         0x0309
#define kNtWmVscrollclipboard       0x030A
#define kNtWmSizeclipboard          0x030B
#define kNtWmAskcbformatname        0x030C
#define kNtWmChangecbchain          0x030D
#define kNtWmHscrollclipboard       0x030E
#define kNtWmQuerynewpalette        0x030F
#define kNtWmPaletteischanging      0x0310
#define kNtWmPalettechanged         0x0311
#define kNtWmHotkey                 0x0312



/*!BEGIN libc/nt/enum/ws.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WS_H_

#define kNtWsOverlapped   0x00000000
#define kNtWsPopup        0x80000000
#define kNtWsChild        0x40000000
#define kNtWsMinimize     0x20000000
#define kNtWsVisible      0x10000000
#define kNtWsDisabled     0x08000000
#define kNtWsClipsiblings 0x04000000
#define kNtWsClipchildren 0x02000000
#define kNtWsMaximize     0x01000000
#define kNtWsCaption      0x00C00000
#define kNtWsBorder       0x00800000
#define kNtWsDlgframe     0x00400000
#define kNtWsVscroll      0x00200000
#define kNtWsHscroll      0x00100000
#define kNtWsSysmenu      0x00080000
#define kNtWsThickframe   0x00040000
#define kNtWsGroup        0x00020000
#define kNtWsTabstop      0x00010000
#define kNtWsMinimizebox  0x00020000
#define kNtWsMaximizebox  0x00010000
#define kNtWsTiled        kNtWsOverlapped
#define kNtWsIconic       kNtWsMinimize
#define kNtWsSizebox      kNtWsThickframe
#define kNtWsTiledwindow  kNtWsOverlappedwindow
#define kNtWsOverlappedwindow                                        \
  (kNtWsOverlapped | kNtWsCaption | kNtWsSysmenu | kNtWsThickframe | \
   kNtWsMinimizebox | kNtWsMaximizebox)
#define kNtWsPopupwindow (kNtWsPopup | kNtWsBorder | kNtWsSysmenu)

#define kNtWsExDlgmodalframe       0x00000001
#define kNtWsExNoparentnotify      0x00000004
#define kNtWsExTopmost             0x00000008
#define kNtWsExAcceptfiles         0x00000010
#define kNtWsExTransparent         0x00000020
#define kNtWsExMdichild            0x00000040
#define kNtWsExToolwindow          0x00000080
#define kNtWsExWindowedge          0x00000100
#define kNtWsExClientedge          0x00000200
#define kNtWsExContexthelp         0x00000400
#define kNtWsExRight               0x00001000
#define kNtWsExLeft                0x00000000
#define kNtWsExRtlreading          0x00002000
#define kNtWsExLtrreading          0x00000000
#define kNtWsExLeftscrollbar       0x00004000
#define kNtWsExRightscrollbar      0x00000000
#define kNtWsExControlparent       0x00010000
#define kNtWsExStaticedge          0x00020000
#define kNtWsExAppwindow           0x00040000
#define kNtWsExNoinheritlayout     0x00100000
#define kNtWsExNoredirectionbitmap 0x00200000
#define kNtWsExLayoutrtl           0x00400000
#define kNtWsExComposited          0x02000000
#define kNtWsExNoactivate          0x08000000

#define kNtWsExOverlappedwindow (kNtWsExWindowedge | kNtWsExClientedge)
#define kNtWsExPalettewindow \
  (kNtWsExWindowedge | kNtWsExToolwindow | kNtWsExTopmost)



/*!BEGIN libc/nt/enum/wsa.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WSA_H_


/*!BEGIN libc/nt/errors.h */

#define COSMOPOLITAN_NT_ERRORS_H_

#define kNtNoError 0

#define kNtErrorInsufficientBuffer 122

#define kNtErrorSuccess 0
#define kNtErrorInvalidFunction 1  /* ENOSYS */
#define kNtErrorFileNotFound 2     /* ENOENT */
#define kNtErrorPathNotFound 3     /* ENOTDIR */
#define kNtErrorTooManyOpenFiles 4 /* EMFILE */
#define kNtErrorAccessDenied 5     /* EACCES */
#define kNtErrorInvalidHandle 6    /* EBADF */
#define kNtErrorArenaTrashed 7
#define kNtErrorNotEnoughMemory 8
#define kNtErrorInvalidBlock 9
#define kNtErrorBadEnvironment 10
#define kNtErrorBadFormat 11
#define kNtErrorInvalidAccess 12 /* EPERM */
#define kNtErrorInvalidData 13
#define kNtErrorOutofmemory 14 /* ENOMEM */
#define kNtErrorInvalidDrive 15
#define kNtErrorCurrentDirectory 16
#define kNtErrorNotSameDevice 17
#define kNtErrorNoMoreFiles 18
#define kNtErrorWriteProtect 19
#define kNtErrorBadUnit 20
#define kNtErrorNotReady 21
#define kNtErrorBadCommand 22
#define kNtErrorCrc 23
#define kNtErrorBadLength 24
#define kNtErrorSeek 25       /* ESPIPE */
#define kNtErrorNotDosDisk 26 /* ENOTBLK */
#define kNtErrorSectorNotFound 27
#define kNtErrorOutOfPaper 28
#define kNtErrorWriteFault 29
#define kNtErrorReadFault 30
#define kNtErrorGenFailure 31
#define kNtErrorSharingViolation 32
#define kNtErrorLockViolation 33
#define kNtErrorWrongDisk 34
#define kNtErrorSharingBufferExceeded 36
#define kNtErrorHandleEof 38 /* w/ GetOverlappedResult() */
#define kNtErrorHandleDiskFull 39
#define kNtErrorNotSupported 50
#define kNtErrorRemNotList 51
#define kNtErrorDupName 52
#define kNtErrorBadNetpath 53
#define kNtErrorNetworkBusy 54
#define kNtErrorDevNotExist 55
#define kNtErrorTooManyCmds 56
#define kNtErrorAdapHdwErr 57
#define kNtErrorBadNetResp 58
#define kNtErrorUnexpNetErr 59
#define kNtErrorBadRemAdap 60
#define kNtErrorPrintqFull 61
#define kNtErrorNoSpoolSpace 62
#define kNtErrorPrintCancelled 63
#define kNtErrorNetnameDeleted 64
#define kNtErrorNetworkAccessDenied 65
#define kNtErrorBadDevType 66
#define kNtErrorBadNetName 67
#define kNtErrorTooManyNames 68
#define kNtErrorTooManySess 69
#define kNtErrorSharingPaused 70
#define kNtErrorReqNotAccep 71
#define kNtErrorRedirPaused 72
#define kNtErrorFileExists 80 /* EEXIST */
#define kNtErrorCannotMake 82
#define kNtErrorFailI24 83
#define kNtErrorOutOfStructures 84
#define kNtErrorAlreadyAssigned 85
#define kNtErrorInvalidPassword 86
#define kNtErrorInvalidParameter 87 /* EINVAL */
#define kNtErrorNetWriteFault 88
#define kNtErrorNoProcSlots 89
#define kNtErrorTooManySemaphores 100
#define kNtErrorExclSemAlreadyOwned 101
#define kNtErrorSemIsSet 102
#define kNtErrorTooManySemRequests 103
#define kNtErrorInvalidAtInterruptTime 104
#define kNtErrorSemOwnerDied 105
#define kNtErrorSemUserLimit 106
#define kNtErrorDiskChange 107
#define kNtErrorDriveLocked 108
#define kNtErrorBrokenPipe 109 /* EPIPE; happens on ReadFile() too */
#define kNtErrorOpenFailed 110
#define kNtErrorBufferOverflow 111
#define kNtErrorDiskFull 112 /* ENOSPC */
#define kNtErrorNoMoreSearchHandles 113
#define kNtErrorInvalidTargetHandle 114
#define kNtErrorInvalidCategory 117
#define kNtErrorInvalidVerifySwitch 118
#define kNtErrorBadDriverLevel 119
#define kNtErrorCallNotImplemented 120
#define kNtErrorSemTimeout 121
#define kNtErrorInsufficientBuffer 122
#define kNtErrorInvalidName 123
#define kNtErrorInvalidLevel 124
#define kNtErrorNoVolumeLabel 125
#define kNtErrorModNotFound 126
#define kNtErrorProcNotFound 127
#define kNtErrorWaitNoChildren 128 /* ECHILD */
#define kNtErrorChildNotComplete 129
#define kNtErrorDirectAccessHandle 130
#define kNtErrorNegativeSeek 131
#define kNtErrorSeekOnDevice 132
#define kNtErrorIsJoinTarget 133
#define kNtErrorIsJoined 134
#define kNtErrorIsSubsted 135
#define kNtErrorNotJoined 136
#define kNtErrorNotSubsted 137
#define kNtErrorJoinToJoin 138
#define kNtErrorSubstToSubst 139
#define kNtErrorJoinToSubst 140
#define kNtErrorSubstToJoin 141
#define kNtErrorBusyDrive 142
#define kNtErrorSameDrive 143
#define kNtErrorDirNotRoot 144
#define kNtErrorDirNotEmpty 145
#define kNtErrorIsSubstPath 146
#define kNtErrorIsJoinPath 147
#define kNtErrorPathBusy 148 /* ETXTBSY */
#define kNtErrorIsSubstTarget 149
#define kNtErrorSystemTrace 150
#define kNtErrorInvalidEventCount 151
#define kNtErrorTooManyMuxwaiters 152
#define kNtErrorInvalidListFormat 153
#define kNtErrorLabelTooLong 154
#define kNtErrorTooManyTcbs 155
#define kNtErrorSignalRefused 156
#define kNtErrorDiscarded 157
#define kNtErrorNotLocked 158
#define kNtErrorBadThreadidAddr 159
#define kNtErrorBadArguments 160
#define kNtErrorBadPathname 161
#define kNtErrorSignalPending 162
#define kNtErrorMaxThrdsReached 164
#define kNtErrorLockFailed 167
#define kNtErrorBusy 170 /* EBUSY */
#define kNtErrorDeviceSupportInProgress 171
#define kNtErrorCancelViolation 173
#define kNtErrorAtomicLocksNotSupported 174
#define kNtErrorInvalidSegmentNumber 180
#define kNtErrorInvalidOrdinal 182
#define kNtErrorAlreadyExists 183 /* EEXIST */
#define kNtErrorInvalidFlagNumber 186
#define kNtErrorSemNotFound 187
#define kNtErrorInvalidStartingCodeseg 188
#define kNtErrorInvalidStackseg 189
#define kNtErrorInvalidModuletype 190
#define kNtErrorInvalidExeSignature 191
#define kNtErrorExeMarkedInvalid 192
#define kNtErrorBadExeFormat 193 /* ENOEXEC */
#define kNtErrorIteratedDataExceeds_64k 194
#define kNtErrorInvalidMinallocsize 195
#define kNtErrorDynlinkFromInvalidRing 196
#define kNtErrorIoplNotEnabled 197
#define kNtErrorInvalidSegdpl 198
#define kNtErrorAutodatasegExceeds_64k 199
#define kNtErrorRing2segMustBeMovable 200
#define kNtErrorRelocChainXeedsSeglim 201
#define kNtErrorInfloopInRelocChain 202
#define kNtErrorEnvvarNotFound 203
#define kNtErrorNoSignalSent 205
#define kNtErrorFilenameExcedRange 206 /* ENAMETOOLONG */
#define kNtErrorRing2StackInUse 207
#define kNtErrorMetaExpansionTooLong 208
#define kNtErrorInvalidSignalNumber 209
#define kNtErrorThread_1Inactive 210
#define kNtErrorLocked 212
#define kNtErrorTooManyModules 214
#define kNtErrorNestingNotAllowed 215
#define kNtErrorExeMachineTypeMismatch 216
#define kNtErrorExeCannotModifySignedBinary 217
#define kNtErrorExeCannotModifyStrongSignedBinary 218
#define kNtErrorFileCheckedOut 220
#define kNtErrorCheckoutRequired 221
#define kNtErrorBadFileType 222
#define kNtErrorFileTooLarge 223 /* EFBIG */
#define kNtErrorFormsAuthRequired 224
#define kNtErrorVirusInfected 225
#define kNtErrorVirusDeleted 226
#define kNtErrorPipeLocal 229
#define kNtErrorBadPipe 230
#define kNtErrorPipeBusy 231
#define kNtErrorNoData 232
#define kNtErrorPipeNotConnected 233
#define kNtErrorMoreData 234
#define kNtErrorNoWorkDone 235
#define kNtErrorVcDisconnected 240
#define kNtErrorInvalidEaName 254
#define kNtErrorEaListInconsistent 255
#define kNtErrorNoMoreItems 259
#define kNtErrorCannotCopy 266
#define kNtErrorDirectory 267 /* EISDIR */
#define kNtErrorEasDidntFit 275
#define kNtErrorEaFileCorrupt 276
#define kNtErrorEaTableFull 277
#define kNtErrorInvalidEaHandle 278
#define kNtErrorEasNotSupported 282
#define kNtErrorNotOwner 288
#define kNtErrorTooManyPosts 298
#define kNtErrorPartialCopy 299
#define kNtErrorOplockNotGranted 300
#define kNtErrorInvalidOplockProtocol 301
#define kNtErrorDiskTooFragmented 302
#define kNtErrorDeletePending 303
#define kNtErrorIncompatibleWithGlobalShortNameRegistrySetting 304
#define kNtErrorShortNamesNotEnabledOnVolume 305
#define kNtErrorSecurityStreamIsInconsistent 306
#define kNtErrorInvalidLockRange 307
#define kNtErrorImageSubsystemNotPresent 308
#define kNtErrorNotificationGuidAlreadyDefined 309
#define kNtErrorInvalidExceptionHandler 310
#define kNtErrorDuplicatePrivileges 311
#define kNtErrorNoRangesProcessed 312
#define kNtErrorNotAllowedOnSystemFile 313
#define kNtErrorDiskResourcesExhausted 314
#define kNtErrorInvalidToken 315
#define kNtErrorDeviceFeatureNotSupported 316
#define kNtErrorMrMidNotFound 317
#define kNtErrorScopeNotFound 318
#define kNtErrorUndefinedScope 319
#define kNtErrorInvalidCap 320
#define kNtErrorDeviceUnreachable 321
#define kNtErrorDeviceNoResources 322
#define kNtErrorDataChecksumError 323
#define kNtErrorIntermixedKernelEaOperation 324
#define kNtErrorFileLevelTrimNotSupported 326
#define kNtErrorOffsetAlignmentViolation 327
#define kNtErrorInvalidFieldInParameterList 328
#define kNtErrorOperationInProgress 329
#define kNtErrorBadDevicePath 330
#define kNtErrorTooManyDescriptors 331 /* ENFILE */
#define kNtErrorScrubDataDisabled 332
#define kNtErrorNotRedundantStorage 333
#define kNtErrorResidentFileNotSupported 334
#define kNtErrorCompressedFileNotSupported 335
#define kNtErrorDirectoryNotSupported 336
#define kNtErrorNotReadFromCopy 337
#define kNtErrorFtWriteFailure 338
#define kNtErrorFtDiScanRequired 339
#define kNtErrorInvalidKernelInfoVersion 340
#define kNtErrorInvalidPepInfoVersion 341
#define kNtErrorObjectNotExternallyBacked 342
#define kNtErrorExternalBackingProviderUnknown 343
#define kNtErrorCompressionNotBeneficial 344
#define kNtErrorStorageTopologyIdMismatch 345
#define kNtErrorBlockedByParentalControls 346
#define kNtErrorBlockTooManyReferences 347
#define kNtErrorMarkedToDisallowWrites 348
#define kNtErrorEnclaveFailure 349
#define kNtErrorFailNoactionReboot 350
#define kNtErrorFailShutdown 351
#define kNtErrorFailRestart 352
#define kNtErrorMaxSessionsReached 353
#define kNtErrorNetworkAccessDeniedEdp 354
#define kNtErrorDeviceHintNameBufferTooSmall 355
#define kNtErrorEdpPolicyDeniesOperation 356
#define kNtErrorEdpDplPolicyCantBeSatisfied 357
#define kNtErrorCloudFileSyncRootMetadataCorrupt 358
#define kNtErrorDeviceInMaintenance 359
#define kNtErrorNotSupportedOnDax 360
#define kNtErrorDaxMappingExists 361
#define kNtErrorCloudFileProviderNotRunning 362
#define kNtErrorCloudFileMetadataCorrupt 363
#define kNtErrorCloudFileMetadataTooLarge 364
#define kNtErrorCloudFilePropertyBlobTooLarge 365
#define kNtErrorCloudFilePropertyBlobChecksumMismatch 366
#define kNtErrorChildProcessBlocked 367
#define kNtErrorStorageLostDataPersistence 368
#define kNtErrorFileSystemVirtualizationUnavailable 369
#define kNtErrorFileSystemVirtualizationMetadataCorrupt 370
#define kNtErrorFileSystemVirtualizationBusy 371
#define kNtErrorFileSystemVirtualizationProviderUnknown 372
#define kNtErrorGdiHandleLeak 373
#define kNtErrorCloudFileTooManyPropertyBlobs 374
#define kNtErrorCloudFilePropertyVersionNotSupported 375
#define kNtErrorNotACloudFile 376
#define kNtErrorCloudFileNotInSync 377
#define kNtErrorCloudFileAlreadyConnected 378
#define kNtErrorCloudFileNotSupported 379
#define kNtErrorCloudFileInvalidRequest 380
#define kNtErrorCloudFileReadOnlyVolume 381
#define kNtErrorCloudFileConnectedProviderOnly 382
#define kNtErrorCloudFileValidationFailed 383
#define kNtErrorSmb1NotAvailable 384
#define kNtErrorFileSystemVirtualizationInvalidOperation 385
#define kNtErrorCloudFileAuthenticationFailed 386
#define kNtErrorCloudFileInsufficientResources 387
#define kNtErrorCloudFileNetworkUnavailable 388
#define kNtErrorCloudFileUnsuccessful 389
#define kNtErrorCloudFileNotUnderSyncRoot 390
#define kNtErrorCloudFileInUse 391
#define kNtErrorCloudFilePinned 392
#define kNtErrorCloudFileRequestAborted 393
#define kNtErrorCloudFilePropertyCorrupt 394
#define kNtErrorCloudFileAccessDenied 395
#define kNtErrorCloudFileIncompatibleHardlinks 396
#define kNtErrorCloudFilePropertyLockConflict 397
#define kNtErrorCloudFileRequestCanceled 398
#define kNtErrorExternalSyskeyNotSupported 399
#define kNtErrorThreadModeAlreadyBackground 400
#define kNtErrorThreadModeNotBackground 401
#define kNtErrorProcessModeAlreadyBackground 402
#define kNtErrorProcessModeNotBackground 403
#define kNtErrorCloudFileProviderTerminated 404
#define kNtErrorNotACloudSyncRoot 405
#define kNtErrorFileProtectedUnderDpl 406
#define kNtErrorVolumeNotClusterAligned 407
#define kNtErrorNoPhysicallyAlignedFreeSpaceFound 408
#define kNtErrorAppxFileNotEncrypted 409
#define kNtErrorRwrawEncryptedFileNotEncrypted 410
#define kNtErrorRwrawEncryptedInvalidEdatainfoFileoffset 411
#define kNtErrorRwrawEncryptedInvalidEdatainfoFilerange 412
#define kNtErrorRwrawEncryptedInvalidEdatainfoParameter 413
#define kNtErrorLinuxSubsystemNotPresent 414
#define kNtErrorCapauthzNotDevunlocked 450
#define kNtErrorCapauthzChangeType 451
#define kNtErrorCapauthzNotProvisioned 452
#define kNtErrorCapauthzNotAuthorized 453
#define kNtErrorCapauthzNoPolicy 454
#define kNtErrorCapauthzDbCorrupted 455
#define kNtErrorCapauthzSccdInvalidCatalog 456
#define kNtErrorCapauthzSccdNoAuthEntity 457
#define kNtErrorCapauthzSccdParseError 458
#define kNtErrorCapauthzSccdDevModeRequired 459
#define kNtErrorCapauthzSccdNoCapabilityMatch 460
#define kNtErrorPnpQueryRemoveDeviceTimeout 480
#define kNtErrorPnpQueryRemoveRelatedDeviceTimeout 481
#define kNtErrorPnpQueryRemoveUnrelatedDeviceTimeout 482
#define kNtErrorDeviceHardwareError 483
#define kNtErrorInvalidAddress 487 /* EFAULT */
#define kNtErrorVrfCfgEnabled 1183
#define kNtErrorPartitionTerminating 1184
#define kNtErrorUserProfileLoad 500
#define kNtErrorArithmeticOverflow 534
#define kNtErrorPipeConnected 535
#define kNtErrorPipeListening 536
#define kNtErrorVerifierStop 537
#define kNtErrorAbiosError 538
#define kNtErrorWx86Warning 539
#define kNtErrorWx86Error 540
#define kNtErrorTimerNotCanceled 541
#define kNtErrorUnwind 542
#define kNtErrorBadStack 543
#define kNtErrorInvalidUnwindTarget 544
#define kNtErrorInvalidPortAttributes 545
#define kNtErrorPortMessageTooLong 546
#define kNtErrorInvalidQuotaLower 547
#define kNtErrorDeviceAlreadyAttached 548
#define kNtErrorInstructionMisalignment 549
#define kNtErrorProfilingNotStarted 550
#define kNtErrorProfilingNotStopped 551
#define kNtErrorCouldNotInterpret 552
#define kNtErrorProfilingAtLimit 553
#define kNtErrorCantWait 554
#define kNtErrorCantTerminateSelf 555
#define kNtErrorUnexpectedMmCreateErr 556
#define kNtErrorUnexpectedMmMapError 557
#define kNtErrorUnexpectedMmExtendErr 558
#define kNtErrorBadFunctionTable 559
#define kNtErrorNoGuidTranslation 560
#define kNtErrorInvalidLdtSize 561
#define kNtErrorInvalidLdtOffset 563
#define kNtErrorInvalidLdtDescriptor 564
#define kNtErrorTooManyThreads 565
#define kNtErrorThreadNotInProcess 566 /* ESRCH */
#define kNtErrorPagefileQuotaExceeded 567
#define kNtErrorLogonServerConflict 568
#define kNtErrorSynchronizationRequired 569
#define kNtErrorNetOpenFailed 570
#define kNtErrorIoPrivilegeFailed 571
#define kNtErrorControlCExit 572
#define kNtErrorMissingSystemfile 573
#define kNtErrorUnhandledException 574
#define kNtErrorAppInitFailure 575
#define kNtErrorPagefileCreateFailed 576
#define kNtErrorInvalidImageHash 577
#define kNtErrorNoPagefile 578
#define kNtErrorIllegalFloatContext 579
#define kNtErrorNoEventPair 580
#define kNtErrorDomainCtrlrConfigError 581
#define kNtErrorIllegalCharacter 582
#define kNtErrorUndefinedCharacter 583
#define kNtErrorFloppyVolume 584
#define kNtErrorBiosFailedToConnectInterrupt 585
#define kNtErrorBackupController 586
#define kNtErrorMutantLimitExceeded 587
#define kNtErrorFsDriverRequired 588
#define kNtErrorCannotLoadRegistryFile 589
#define kNtErrorDebugAttachFailed 590
#define kNtErrorSystemProcessTerminated 591
#define kNtErrorDataNotAccepted 592
#define kNtErrorVdmHardError 593
#define kNtErrorDriverCancelTimeout 594
#define kNtErrorReplyMessageMismatch 595
#define kNtErrorLostWritebehindData 596
#define kNtErrorClientServerParametersInvalid 597
#define kNtErrorNotTinyStream 598
#define kNtErrorStackOverflowRead 599
#define kNtErrorConvertToLarge 600
#define kNtErrorFoundOutOfScope 601
#define kNtErrorAllocateBucket 602
#define kNtErrorMarshallOverflow 603
#define kNtErrorInvalidVariant 604
#define kNtErrorBadCompressionBuffer 605
#define kNtErrorAuditFailed 606
#define kNtErrorTimerResolutionNotSet 607
#define kNtErrorInsufficientLogonInfo 608
#define kNtErrorBadDllEntrypoint 609
#define kNtErrorBadServiceEntrypoint 610
#define kNtErrorIpAddressConflict1 611
#define kNtErrorIpAddressConflict2 612
#define kNtErrorRegistryQuotaLimit 613
#define kNtErrorNoCallbackActive 614
#define kNtErrorPwdTooShort 615
#define kNtErrorPwdTooRecent 616
#define kNtErrorPwdHistoryConflict 617
#define kNtErrorUnsupportedCompression 618
#define kNtErrorInvalidHwProfile 619
#define kNtErrorInvalidPlugplayDevicePath 620
#define kNtErrorQuotaListInconsistent 621
#define kNtErrorEvaluationExpiration 622
#define kNtErrorIllegalDllRelocation 623
#define kNtErrorDllInitFailedLogoff 624
#define kNtErrorValidateContinue 625
#define kNtErrorNoMoreMatches 626
#define kNtErrorRangeListConflict 627
#define kNtErrorServerSidMismatch 628
#define kNtErrorCantEnableDenyOnly 629
#define kNtErrorFloatMultipleFaults 630
#define kNtErrorFloatMultipleTraps 631
#define kNtErrorNointerface 632
#define kNtErrorDriverFailedSleep 633
#define kNtErrorCorruptSystemFile 634
#define kNtErrorCommitmentMinimum 635
#define kNtErrorPnpRestartEnumeration 636
#define kNtErrorSystemImageBadSignature 637
#define kNtErrorPnpRebootRequired 638
#define kNtErrorInsufficientPower 639
#define kNtErrorMultipleFaultViolation 640
#define kNtErrorSystemShutdown 641
#define kNtErrorPortNotSet 642
#define kNtErrorDsVersionCheckFailure 643
#define kNtErrorRangeNotFound 644
#define kNtErrorNotSafeModeDriver 646
#define kNtErrorFailedDriverEntry 647
#define kNtErrorDeviceEnumerationError 648
#define kNtErrorMountPointNotResolved 649
#define kNtErrorInvalidDeviceObjectParameter 650
#define kNtErrorMcaOccured 651
#define kNtErrorDriverDatabaseError 652
#define kNtErrorSystemHiveTooLarge 653
#define kNtErrorDriverFailedPriorUnload 654
#define kNtErrorVolsnapPrepareHibernate 655
#define kNtErrorHibernationFailure 656
#define kNtErrorPwdTooLong 657
#define kNtErrorFileSystemLimitation 665
#define kNtErrorAssertionFailure 668
#define kNtErrorAcpiError 669
#define kNtErrorWowAssertion 670
#define kNtErrorPnpBadMpsTable 671
#define kNtErrorPnpTranslationFailed 672
#define kNtErrorPnpIrqTranslationFailed 673
#define kNtErrorPnpInvalidId 674
#define kNtErrorWakeSystemDebugger 675
#define kNtErrorHandlesClosed 676
#define kNtErrorExtraneousInformation 677
#define kNtErrorRxactCommitNecessary 678
#define kNtErrorMediaCheck 679
#define kNtErrorGuidSubstitutionMade 680
#define kNtErrorStoppedOnSymlink 681
#define kNtErrorLongjump 682
#define kNtErrorPlugplayQueryVetoed 683
#define kNtErrorUnwindConsolidate 684
#define kNtErrorRegistryHiveRecovered 685
#define kNtErrorDllMightBeInsecure 686
#define kNtErrorDllMightBeIncompatible 687
#define kNtErrorDbgExceptionNotHandled 688
#define kNtErrorDbgReplyLater 689
#define kNtErrorDbgUnableToProvideHandle 690
#define kNtErrorDbgTerminateThread 691
#define kNtErrorDbgTerminateProcess 692
#define kNtErrorDbgControlC 693
#define kNtErrorDbgPrintexceptionC 694
#define kNtErrorDbgRipexception 695
#define kNtErrorDbgControlBreak 696
#define kNtErrorDbgCommandException 697
#define kNtErrorObjectNameExists 698
#define kNtErrorThreadWasSuspended 699
#define kNtErrorImageNotAtBase 700
#define kNtErrorRxactStateCreated 701
#define kNtErrorSegmentNotification 702
#define kNtErrorBadCurrentDirectory 703
#define kNtErrorFtReadRecoveryFromBackup 704
#define kNtErrorFtWriteRecovery 705
#define kNtErrorImageMachineTypeMismatch 706
#define kNtErrorReceivePartial 707
#define kNtErrorReceiveExpedited 708
#define kNtErrorReceivePartialExpedited 709
#define kNtErrorEventDone 710
#define kNtErrorEventPending 711
#define kNtErrorCheckingFileSystem 712
#define kNtErrorFatalAppExit 713
#define kNtErrorPredefinedHandle 714
#define kNtErrorWasUnlocked 715
#define kNtErrorServiceNotification 716
#define kNtErrorWasLocked 717
#define kNtErrorLogHardError 718
#define kNtErrorAlreadyWin32 719
#define kNtErrorImageMachineTypeMismatchExe 720
#define kNtErrorNoYieldPerformed 721
#define kNtErrorTimerResumeIgnored 722
#define kNtErrorArbitrationUnhandled 723
#define kNtErrorCardbusNotSupported 724
#define kNtErrorMpProcessorMismatch 725
#define kNtErrorHibernated 726
#define kNtErrorResumeHibernation 727
#define kNtErrorFirmwareUpdated 728
#define kNtErrorDriversLeakingLockedPages 729
#define kNtErrorWakeSystem 730
#define kNtErrorWait_1 731
#define kNtErrorWait_2 732
#define kNtErrorWait_3 733
#define kNtErrorWait_63 734
#define kNtErrorAbandonedWait_0 735
#define kNtErrorAbandonedWait_63 736
#define kNtErrorUserApc 737
#define kNtErrorKernelApc 738
#define kNtErrorAlerted 739
#define kNtErrorElevationRequired 740
#define kNtErrorReparse 741
#define kNtErrorOplockBreakInProgress 742
#define kNtErrorVolumeMounted 743
#define kNtErrorRxactCommitted 744
#define kNtErrorNotifyCleanup 745
#define kNtErrorPrimaryTransportConnectFailed 746
#define kNtErrorPageFaultTransition 747
#define kNtErrorPageFaultDemandZero 748
#define kNtErrorPageFaultCopyOnWrite 749
#define kNtErrorPageFaultGuardPage 750
#define kNtErrorPageFaultPagingFile 751
#define kNtErrorCachePageLocked 752
#define kNtErrorCrashDump 753
#define kNtErrorBufferAllZeros 754
#define kNtErrorReparseObject 755
#define kNtErrorResourceRequirementsChanged 756
#define kNtErrorTranslationComplete 757
#define kNtErrorNothingToTerminate 758
#define kNtErrorProcessNotInJob 759
#define kNtErrorProcessInJob 760
#define kNtErrorVolsnapHibernateReady 761
#define kNtErrorFsfilterOpCompletedSuccessfully 762
#define kNtErrorInterruptVectorAlreadyConnected 763
#define kNtErrorInterruptStillConnected 764
#define kNtErrorWaitForOplock 765
#define kNtErrorDbgExceptionHandled 766
#define kNtErrorDbgContinue 767
#define kNtErrorCallbackPopStack 768
#define kNtErrorCompressionDisabled 769
#define kNtErrorCantfetchbackwards 770
#define kNtErrorCantscrollbackwards 771
#define kNtErrorRowsnotreleased 772
#define kNtErrorBadAccessorFlags 773
#define kNtErrorErrorsEncountered 774
#define kNtErrorNotCapable 775
#define kNtErrorRequestOutOfSequence 776
#define kNtErrorVersionParseError 777
#define kNtErrorBadstartposition 778
#define kNtErrorMemoryHardware 779
#define kNtErrorDiskRepairDisabled 780
#define kNtErrorInsufficientResourceForSpecifiedSharedSectionSize 781
#define kNtErrorSystemPowerstateTransition 782
#define kNtErrorSystemPowerstateComplexTransition 783
#define kNtErrorMcaException 784
#define kNtErrorAccessAuditByPolicy 785
#define kNtErrorAccessDisabledNoSaferUiByPolicy 786
#define kNtErrorAbandonHiberfile 787
#define kNtErrorLostWritebehindDataNetworkDisconnected 788
#define kNtErrorLostWritebehindDataNetworkServerError 789
#define kNtErrorLostWritebehindDataLocalDiskError 790
#define kNtErrorBadMcfgTable 791
#define kNtErrorDiskRepairRedirected 792
#define kNtErrorDiskRepairUnsuccessful 793
#define kNtErrorCorruptLogOverfull 794
#define kNtErrorCorruptLogCorrupted 795
#define kNtErrorCorruptLogUnavailable 796
#define kNtErrorCorruptLogDeletedFull 797
#define kNtErrorCorruptLogCleared 798
#define kNtErrorOrphanNameExhausted 799
#define kNtErrorOplockSwitchedToNewHandle 800
#define kNtErrorCannotGrantRequestedOplock 801
#define kNtErrorCannotBreakOplock 802
#define kNtErrorOplockHandleClosed 803
#define kNtErrorNoAceCondition 804
#define kNtErrorInvalidAceCondition 805
#define kNtErrorFileHandleRevoked 806
#define kNtErrorImageAtDifferentBase 807
#define kNtErrorEncryptedIoNotPossible 808
#define kNtErrorFileMetadataOptimizationInProgress 809
#define kNtErrorQuotaActivity 810
#define kNtErrorHandleRevoked 811
#define kNtErrorCallbackInvokeInline 812
#define kNtErrorCpuSetInvalid 813
#define kNtErrorEnclaveNotTerminated 814
#define kNtErrorEnclaveViolation 815
#define kNtErrorEaAccessDenied 994
#define kNtErrorOperationAborted 995
#define kNtErrorIoIncomplete 996
#define kNtErrorIoPending 997
#define kNtErrorNoaccess 998
#define kNtErrorSwaperror 999
#define kNtErrorStackOverflow 1001
#define kNtErrorInvalidMessage 1002
#define kNtErrorCanNotComplete 1003
#define kNtErrorInvalidFlags 1004
#define kNtErrorUnrecognizedVolume 1005
#define kNtErrorFileInvalid 1006
#define kNtErrorFullscreenMode 1007
#define kNtErrorNoToken 1008
#define kNtErrorBaddb 1009
#define kNtErrorBadkey 1010
#define kNtErrorCantopen 1011
#define kNtErrorCantread 1012
#define kNtErrorCantwrite 1013
#define kNtErrorRegistryRecovered 1014
#define kNtErrorRegistryCorrupt 1015
#define kNtErrorRegistryIoFailed 1016
#define kNtErrorNotRegistryFile 1017
#define kNtErrorKeyDeleted 1018
#define kNtErrorNoLogSpace 1019
#define kNtErrorKeyHasChildren 1020
#define kNtErrorChildMustBeVolatile 1021
#define kNtErrorNotifyEnumDir 1022
#define kNtErrorDependentServicesRunning 1051
#define kNtErrorInvalidServiceControl 1052
#define kNtErrorServiceRequestTimeout 1053
#define kNtErrorServiceNoThread 1054
#define kNtErrorServiceDatabaseLocked 1055
#define kNtErrorServiceAlreadyRunning 1056
#define kNtErrorInvalidServiceAccount 1057
#define kNtErrorServiceDisabled 1058
#define kNtErrorCircularDependency 1059
#define kNtErrorServiceDoesNotExist 1060
#define kNtErrorServiceCannotAcceptCtrl 1061
#define kNtErrorServiceNotActive 1062
#define kNtErrorFailedServiceControllerConnect 1063
#define kNtErrorExceptionInService 1064
#define kNtErrorDatabaseDoesNotExist 1065
#define kNtErrorServiceSpecificError 1066
#define kNtErrorProcessAborted 1067
#define kNtErrorServiceDependencyFail 1068
#define kNtErrorServiceLogonFailed 1069
#define kNtErrorServiceStartHang 1070
#define kNtErrorInvalidServiceLock 1071
#define kNtErrorServiceMarkedForDelete 1072
#define kNtErrorServiceExists 1073
#define kNtErrorAlreadyRunningLkg 1074
#define kNtErrorServiceDependencyDeleted 1075
#define kNtErrorBootAlreadyAccepted 1076
#define kNtErrorServiceNeverStarted 1077
#define kNtErrorDuplicateServiceName 1078
#define kNtErrorDifferentServiceAccount 1079
#define kNtErrorCannotDetectDriverFailure 1080
#define kNtErrorCannotDetectProcessAbort 1081
#define kNtErrorNoRecoveryProgram 1082
#define kNtErrorServiceNotInExe 1083
#define kNtErrorNotSafebootService 1084
#define kNtErrorEndOfMedia 1100
#define kNtErrorFilemarkDetected 1101
#define kNtErrorBeginningOfMedia 1102
#define kNtErrorSetmarkDetected 1103
#define kNtErrorNoDataDetected 1104
#define kNtErrorPartitionFailure 1105
#define kNtErrorInvalidBlockLength 1106
#define kNtErrorDeviceNotPartitioned 1107
#define kNtErrorUnableToLockMedia 1108
#define kNtErrorUnableToUnloadMedia 1109
#define kNtErrorMediaChanged 1110
#define kNtErrorBusReset 1111
#define kNtErrorNoMediaInDrive 1112 /* ENXIO */
#define kNtErrorNoUnicodeTranslation 1113
#define kNtErrorDllInitFailed 1114
#define kNtErrorShutdownInProgress 1115
#define kNtErrorNoShutdownInProgress 1116
#define kNtErrorIoDevice 1117       /* EIO */
#define kNtErrorSerialNoDevice 1118 /* ENOTTY */
#define kNtErrorIrqBusy 1119
#define kNtErrorMoreWrites 1120
#define kNtErrorCounterTimeout 1121
#define kNtErrorFloppyIdMarkNotFound 1122
#define kNtErrorFloppyWrongCylinder 1123
#define kNtErrorFloppyUnknownError 1124
#define kNtErrorFloppyBadRegisters 1125
#define kNtErrorDiskRecalibrateFailed 1126
#define kNtErrorDiskOperationFailed 1127
#define kNtErrorDiskResetFailed 1128
#define kNtErrorEomOverflow 1129
#define kNtErrorNotEnoughServerMemory 1130
#define kNtErrorPossibleDeadlock 1131 /* EDEADLK */
#define kNtErrorMappedAlignment 1132
#define kNtErrorSetPowerStateVetoed 1140
#define kNtErrorSetPowerStateFailed 1141
#define kNtErrorTooManyLinks 1142
#define kNtErrorOldWinVersion 1150
#define kNtErrorAppWrongOs 1151
#define kNtErrorSingleInstanceApp 1152
#define kNtErrorRmodeApp 1153
#define kNtErrorInvalidDll 1154
#define kNtErrorNoAssociation 1155
#define kNtErrorDdeFail 1156
#define kNtErrorDllNotFound 1157
#define kNtErrorNoMoreUserHandles 1158
#define kNtErrorMessageSyncOnly 1159
#define kNtErrorSourceElementEmpty 1160
#define kNtErrorDestinationElementFull 1161
#define kNtErrorIllegalElementAddress 1162
#define kNtErrorMagazineNotPresent 1163
#define kNtErrorDeviceReinitializationNeeded 1164
#define kNtErrorDeviceRequiresCleaning 1165
#define kNtErrorDeviceDoorOpen 1166
#define kNtErrorDeviceNotConnected 1167
#define kNtErrorNotFound 1168
#define kNtErrorNoMatch 1169
#define kNtErrorSetNotFound 1170
#define kNtErrorPointNotFound 1171
#define kNtErrorNoTrackingService 1172
#define kNtErrorNoVolumeId 1173
#define kNtErrorUnableToRemoveReplaced 1175
#define kNtErrorUnableToMoveReplacement 1176
#define kNtErrorUnableToMoveReplacement_2 1177
#define kNtErrorJournalDeleteInProgress 1178
#define kNtErrorJournalNotActive 1179
#define kNtErrorPotentialFileFound 1180
#define kNtErrorJournalEntryDeleted 1181
#define kNtErrorShutdownIsScheduled 1190
#define kNtErrorShutdownUsersLoggedOn 1191
#define kNtErrorBadDevice 1200 /* ENODEV */
#define kNtErrorConnectionUnavail 1201
#define kNtErrorDeviceAlreadyRemembered 1202
#define kNtErrorNoNetOrBadPath 1203
#define kNtErrorBadProvider 1204
#define kNtErrorCannotOpenProfile 1205
#define kNtErrorBadProfile 1206
#define kNtErrorNotContainer 1207
#define kNtErrorExtendedError 1208
#define kNtErrorInvalidGroupname 1209
#define kNtErrorInvalidComputername 1210
#define kNtErrorInvalidEventname 1211
#define kNtErrorInvalidDomainname 1212
#define kNtErrorInvalidServicename 1213
#define kNtErrorInvalidNetname 1214
#define kNtErrorInvalidSharename 1215
#define kNtErrorInvalidPasswordname 1216
#define kNtErrorInvalidMessagename 1217
#define kNtErrorInvalidMessagedest 1218
#define kNtErrorSessionCredentialConflict 1219
#define kNtErrorRemoteSessionLimitExceeded 1220
#define kNtErrorDupDomainname 1221
#define kNtErrorNoNetwork 1222
#define kNtErrorCancelled 1223
#define kNtErrorUserMappedFile 1224
#define kNtErrorConnectionRefused 1225
#define kNtErrorGracefulDisconnect 1226
#define kNtErrorAddressAlreadyAssociated 1227
#define kNtErrorAddressNotAssociated 1228
#define kNtErrorConnectionInvalid 1229
#define kNtErrorConnectionActive 1230
#define kNtErrorNetworkUnreachable 1231
#define kNtErrorHostUnreachable 1232
#define kNtErrorProtocolUnreachable 1233
#define kNtErrorPortUnreachable 1234
#define kNtErrorRequestAborted 1235
#define kNtErrorConnectionAborted 1236
#define kNtErrorRetry 1237
#define kNtErrorConnectionCountLimit 1238
#define kNtErrorLoginTimeRestriction 1239
#define kNtErrorLoginWkstaRestriction 1240
#define kNtErrorIncorrectAddress 1241
#define kNtErrorAlreadyRegistered 1242
#define kNtErrorServiceNotFound 1243
#define kNtErrorNotAuthenticated 1244
#define kNtErrorNotLoggedOn 1245
#define kNtErrorContinue 1246
#define kNtErrorAlreadyInitialized 1247
#define kNtErrorNoMoreDevices 1248
#define kNtErrorNoSuchSite 1249
#define kNtErrorDomainControllerExists 1250
#define kNtErrorOnlyIfConnected 1251
#define kNtErrorOverrideNochanges 1252
#define kNtErrorBadUserProfile 1253
#define kNtErrorNotSupportedOnSbs 1254
#define kNtErrorServerShutdownInProgress 1255
#define kNtErrorHostDown 1256
#define kNtErrorNonAccountSid 1257
#define kNtErrorNonDomainSid 1258
#define kNtErrorApphelpBlock 1259
#define kNtErrorAccessDisabledByPolicy 1260
#define kNtErrorRegNatConsumption 1261
#define kNtErrorCscshareOffline 1262
#define kNtErrorPkinitFailure 1263
#define kNtErrorSmartcardSubsystemFailure 1264
#define kNtErrorDowngradeDetected 1265
#define kNtErrorMachineLocked 1271
#define kNtErrorSmbGuestLogonBlocked 1272
#define kNtErrorCallbackSuppliedInvalidData 1273
#define kNtErrorSyncForegroundRefreshRequired 1274
#define kNtErrorDriverBlocked 1275
#define kNtErrorInvalidImportOfNonDll 1276
#define kNtErrorAccessDisabledWebblade 1277
#define kNtErrorAccessDisabledWebbladeTamper 1278
#define kNtErrorRecoveryFailure 1279
#define kNtErrorAlreadyFiber 1280
#define kNtErrorAlreadyThread 1281
#define kNtErrorStackBufferOverrun 1282
#define kNtErrorParameterQuotaExceeded 1283
#define kNtErrorDebuggerInactive 1284
#define kNtErrorDelayLoadFailed 1285
#define kNtErrorVdmDisallowed 1286
#define kNtErrorUnidentifiedError 1287
#define kNtErrorInvalidCruntimeParameter 1288
#define kNtErrorBeyondVdl 1289
#define kNtErrorIncompatibleServiceSidType 1290
#define kNtErrorDriverProcessTerminated 1291
#define kNtErrorImplementationLimit 1292
#define kNtErrorProcessIsProtected 1293
#define kNtErrorServiceNotifyClientLagging 1294
#define kNtErrorDiskQuotaExceeded 1295
#define kNtErrorContentBlocked 1296
#define kNtErrorIncompatibleServicePrivilege 1297
#define kNtErrorAppHang 1298
#define kNtErrorInvalidLabel 1299
#define kNtErrorNotAllAssigned 1300
#define kNtErrorSomeNotMapped 1301
#define kNtErrorNoQuotasForAccount 1302
#define kNtErrorLocalUserSessionKey 1303
#define kNtErrorNullLmPassword 1304
#define kNtErrorUnknownRevision 1305
#define kNtErrorRevisionMismatch 1306
#define kNtErrorInvalidOwner 1307
#define kNtErrorInvalidPrimaryGroup 1308
#define kNtErrorNoImpersonationToken 1309
#define kNtErrorCantDisableMandatory 1310
#define kNtErrorNoLogonServers 1311
#define kNtErrorNoSuchLogonSession 1312
#define kNtErrorNoSuchPrivilege 1313
#define kNtErrorPrivilegeNotHeld 1314
#define kNtErrorInvalidAccountName 1315
#define kNtErrorUserExists 1316
#define kNtErrorNoSuchUser 1317
#define kNtErrorGroupExists 1318
#define kNtErrorNoSuchGroup 1319
#define kNtErrorMemberInGroup 1320
#define kNtErrorMemberNotInGroup 1321
#define kNtErrorLastAdmin 1322
#define kNtErrorWrongPassword 1323
#define kNtErrorIllFormedPassword 1324
#define kNtErrorPasswordRestriction 1325
#define kNtErrorLogonFailure 1326
#define kNtErrorAccountRestriction 1327
#define kNtErrorInvalidLogonHours 1328
#define kNtErrorInvalidWorkstation 1329
#define kNtErrorPasswordExpired 1330
#define kNtErrorAccountDisabled 1331
#define kNtErrorNoneMapped 1332
#define kNtErrorTooManyLuidsRequested 1333
#define kNtErrorLuidsExhausted 1334
#define kNtErrorInvalidSubAuthority 1335
#define kNtErrorInvalidAcl 1336
#define kNtErrorInvalidSid 1337
#define kNtErrorInvalidSecurityDescr 1338
#define kNtErrorBadInheritanceAcl 1340
#define kNtErrorServerDisabled 1341
#define kNtErrorServerNotDisabled 1342
#define kNtErrorInvalidIdAuthority 1343
#define kNtErrorAllottedSpaceExceeded 1344
#define kNtErrorInvalidGroupAttributes 1345
#define kNtErrorBadImpersonationLevel 1346
#define kNtErrorCantOpenAnonymous 1347
#define kNtErrorBadValidationClass 1348
#define kNtErrorBadTokenType 1349
#define kNtErrorNoSecurityOnObject 1350
#define kNtErrorCantAccessDomainInfo 1351
#define kNtErrorInvalidServerState 1352
#define kNtErrorInvalidDomainState 1353
#define kNtErrorInvalidDomainRole 1354
#define kNtErrorNoSuchDomain 1355
#define kNtErrorDomainExists 1356
#define kNtErrorDomainLimitExceeded 1357
#define kNtErrorInternalDbCorruption 1358
#define kNtErrorInternalError 1359
#define kNtErrorGenericNotMapped 1360
#define kNtErrorBadDescriptorFormat 1361
#define kNtErrorNotLogonProcess 1362
#define kNtErrorLogonSessionExists 1363
#define kNtErrorNoSuchPackage 1364
#define kNtErrorBadLogonSessionState 1365
#define kNtErrorLogonSessionCollision 1366
#define kNtErrorInvalidLogonType 1367
#define kNtErrorCannotImpersonate 1368
#define kNtErrorRxactInvalidState 1369
#define kNtErrorRxactCommitFailure 1370
#define kNtErrorSpecialAccount 1371
#define kNtErrorSpecialGroup 1372
#define kNtErrorSpecialUser 1373
#define kNtErrorMembersPrimaryGroup 1374
#define kNtErrorTokenAlreadyInUse 1375
#define kNtErrorNoSuchAlias 1376
#define kNtErrorMemberNotInAlias 1377
#define kNtErrorMemberInAlias 1378
#define kNtErrorAliasExists 1379
#define kNtErrorLogonNotGranted 1380
#define kNtErrorTooManySecrets 1381
#define kNtErrorSecretTooLong 1382
#define kNtErrorInternalDbError 1383
#define kNtErrorTooManyContextIds 1384
#define kNtErrorLogonTypeNotGranted 1385
#define kNtErrorNtCrossEncryptionRequired 1386
#define kNtErrorNoSuchMember 1387
#define kNtErrorInvalidMember 1388
#define kNtErrorTooManySids 1389
#define kNtErrorLmCrossEncryptionRequired 1390
#define kNtErrorNoInheritance 1391
#define kNtErrorFileCorrupt 1392
#define kNtErrorDiskCorrupt 1393
#define kNtErrorNoUserSessionKey 1394
#define kNtErrorLicenseQuotaExceeded 1395
#define kNtErrorWrongTargetName 1396
#define kNtErrorMutualAuthFailed 1397
#define kNtErrorTimeSkew 1398
#define kNtErrorCurrentDomainNotAllowed 1399
#define kNtErrorInvalidWindowHandle 1400
#define kNtErrorInvalidMenuHandle 1401
#define kNtErrorInvalidCursorHandle 1402
#define kNtErrorInvalidAccelHandle 1403
#define kNtErrorInvalidHookHandle 1404
#define kNtErrorInvalidDwpHandle 1405
#define kNtErrorTlwWithWschild 1406
#define kNtErrorCannotFindWndClass 1407
#define kNtErrorWindowOfOtherThread 1408
#define kNtErrorHotkeyAlreadyRegistered 1409
#define kNtErrorClassAlreadyExists 1410
#define kNtErrorClassDoesNotExist 1411
#define kNtErrorClassHasWindows 1412
#define kNtErrorInvalidIndex 1413
#define kNtErrorInvalidIconHandle 1414
#define kNtErrorPrivateDialogIndex 1415
#define kNtErrorListboxIdNotFound 1416
#define kNtErrorNoWildcardCharacters 1417
#define kNtErrorClipboardNotOpen 1418
#define kNtErrorHotkeyNotRegistered 1419
#define kNtErrorWindowNotDialog 1420
#define kNtErrorControlIdNotFound 1421
#define kNtErrorInvalidComboboxMessage 1422
#define kNtErrorWindowNotCombobox 1423
#define kNtErrorInvalidEditHeight 1424
#define kNtErrorDcNotFound 1425
#define kNtErrorInvalidHookFilter 1426
#define kNtErrorInvalidFilterProc 1427
#define kNtErrorHookNeedsHmod 1428
#define kNtErrorGlobalOnlyHook 1429
#define kNtErrorJournalHookSet 1430
#define kNtErrorHookNotInstalled 1431
#define kNtErrorInvalidLbMessage 1432
#define kNtErrorSetcountOnBadLb 1433
#define kNtErrorLbWithoutTabstops 1434
#define kNtErrorDestroyObjectOfOtherThread 1435
#define kNtErrorChildWindowMenu 1436
#define kNtErrorNoSystemMenu 1437
#define kNtErrorInvalidMsgboxStyle 1438
#define kNtErrorInvalidSpiValue 1439
#define kNtErrorScreenAlreadyLocked 1440
#define kNtErrorHwndsHaveDiffParent 1441
#define kNtErrorNotChildWindow 1442
#define kNtErrorInvalidGwCommand 1443
#define kNtErrorInvalidThreadId 1444
#define kNtErrorNonMdichildWindow 1445
#define kNtErrorPopupAlreadyActive 1446
#define kNtErrorNoScrollbars 1447
#define kNtErrorInvalidScrollbarRange 1448
#define kNtErrorInvalidShowwinCommand 1449
#define kNtErrorNoSystemResources 1450
#define kNtErrorNonpagedSystemResources 1451
#define kNtErrorPagedSystemResources 1452
#define kNtErrorWorkingSetQuota 1453
#define kNtErrorPagefileQuota 1454
#define kNtErrorCommitmentLimit 1455
#define kNtErrorMenuItemNotFound 1456
#define kNtErrorInvalidKeyboardHandle 1457
#define kNtErrorHookTypeNotAllowed 1458
#define kNtErrorRequiresInteractiveWindowstation 1459
#define kNtErrorTimeout 1460
#define kNtErrorInvalidMonitorHandle 1461
#define kNtErrorIncorrectSize 1462
#define kNtErrorSymlinkClassDisabled 1463
#define kNtErrorSymlinkNotSupported 1464
#define kNtErrorXmlParseError 1465
#define kNtErrorXmldsigError 1466
#define kNtErrorRestartApplication 1467
#define kNtErrorWrongCompartment 1468
#define kNtErrorAuthipFailure 1469
#define kNtErrorNoNvramResources 1470
#define kNtErrorNotGuiProcess 1471
#define kNtErrorEventlogFileCorrupt 1500
#define kNtErrorEventlogCantStart 1501
#define kNtErrorLogFileFull 1502
#define kNtErrorEventlogFileChanged 1503
#define kNtErrorContainerAssigned 1504
#define kNtErrorJobNoContainer 1505
#define kNtErrorInvalidTaskName 1550
#define kNtErrorInvalidTaskIndex 1551
#define kNtErrorThreadAlreadyInTask 1552
#define kNtErrorInstallServiceFailure 1601
#define kNtErrorInstallUserexit 1602
#define kNtErrorInstallFailure 1603
#define kNtErrorInstallSuspend 1604
#define kNtErrorUnknownProduct 1605
#define kNtErrorUnknownFeature 1606
#define kNtErrorUnknownComponent 1607
#define kNtErrorUnknownProperty 1608
#define kNtErrorInvalidHandleState 1609
#define kNtErrorBadConfiguration 1610
#define kNtErrorIndexAbsent 1611
#define kNtErrorInstallSourceAbsent 1612
#define kNtErrorInstallPackageVersion 1613
#define kNtErrorProductUninstalled 1614
#define kNtErrorBadQuerySyntax 1615
#define kNtErrorInvalidField 1616
#define kNtErrorDeviceRemoved 1617
#define kNtErrorInstallAlreadyRunning 1618
#define kNtErrorInstallPackageOpenFailed 1619
#define kNtErrorInstallPackageInvalid 1620
#define kNtErrorInstallUiFailure 1621
#define kNtErrorInstallLogFailure 1622
#define kNtErrorInstallLanguageUnsupported 1623
#define kNtErrorInstallTransformFailure 1624
#define kNtErrorInstallPackageRejected 1625
#define kNtErrorFunctionNotCalled 1626
#define kNtErrorFunctionFailed 1627
#define kNtErrorInvalidTable 1628
#define kNtErrorDatatypeMismatch 1629
#define kNtErrorUnsupportedType 1630
#define kNtErrorCreateFailed 1631
#define kNtErrorInstallTempUnwritable 1632
#define kNtErrorInstallPlatformUnsupported 1633
#define kNtErrorInstallNotused 1634
#define kNtErrorPatchPackageOpenFailed 1635
#define kNtErrorPatchPackageInvalid 1636
#define kNtErrorPatchPackageUnsupported 1637
#define kNtErrorProductVersion 1638
#define kNtErrorInvalidCommandLine 1639 /* E2BIG */
#define kNtErrorInstallRemoteDisallowed 1640
#define kNtErrorSuccessRebootInitiated 1641
#define kNtErrorPatchTargetNotFound 1642
#define kNtErrorPatchPackageRejected 1643
#define kNtErrorInstallTransformRejected 1644
#define kNtErrorInstallRemoteProhibited 1645
#define kNtErrorPatchRemovalUnsupported 1646
#define kNtErrorUnknownPatch 1647
#define kNtErrorPatchNoSequence 1648
#define kNtErrorPatchRemovalDisallowed 1649
#define kNtErrorInvalidPatchXml 1650
#define kNtErrorPatchManagedAdvertisedProduct 1651
#define kNtErrorInstallServiceSafeboot 1652
#define kNtErrorFailFastException 1653
#define kNtErrorInstallRejected 1654
#define kNtErrorDynamicCodeBlocked 1655
#define kNtErrorNotSameObject 1656
#define kNtErrorStrictCfgViolation 1657
#define kNtErrorSetContextDenied 1660
#define kNtErrorCrossPartitionViolation 1661
#define kNtErrorInvalidUserBuffer 1784
#define kNtErrorUnrecognizedMedia 1785
#define kNtErrorNoTrustLsaSecret 1786
#define kNtErrorNoTrustSamAccount 1787
#define kNtErrorTrustedDomainFailure 1788
#define kNtErrorTrustedRelationshipFailure 1789
#define kNtErrorTrustFailure 1790
#define kNtErrorNetlogonNotStarted 1792
#define kNtErrorAccountExpired 1793
#define kNtErrorRedirectorHasOpenHandles 1794
#define kNtErrorPrinterDriverAlreadyInstalled 1795
#define kNtErrorUnknownPort 1796
#define kNtErrorUnknownPrinterDriver 1797
#define kNtErrorUnknownPrintprocessor 1798
#define kNtErrorInvalidSeparatorFile 1799
#define kNtErrorInvalidPriority 1800
#define kNtErrorInvalidPrinterName 1801
#define kNtErrorPrinterAlreadyExists 1802
#define kNtErrorInvalidPrinterCommand 1803
#define kNtErrorInvalidDatatype 1804
#define kNtErrorInvalidEnvironment 1805
#define kNtErrorNologonInterdomainTrustAccount 1807
#define kNtErrorNologonWorkstationTrustAccount 1808
#define kNtErrorNologonServerTrustAccount 1809
#define kNtErrorDomainTrustInconsistent 1810
#define kNtErrorServerHasOpenHandles 1811
#define kNtErrorResourceDataNotFound 1812
#define kNtErrorResourceTypeNotFound 1813
#define kNtErrorResourceNameNotFound 1814
#define kNtErrorResourceLangNotFound 1815
#define kNtErrorNotEnoughQuota 1816 /* EDQUOT */
#define kNtErrorInvalidTime 1901
#define kNtErrorInvalidFormName 1902
#define kNtErrorInvalidFormSize 1903
#define kNtErrorAlreadyWaiting 1904
#define kNtErrorPrinterDeleted 1905
#define kNtErrorInvalidPrinterState 1906
#define kNtErrorPasswordMustChange 1907
#define kNtErrorDomainControllerNotFound 1908
#define kNtErrorAccountLockedOut 1909
#define kNtErrorNoSitename 1919
#define kNtErrorCantAccessFile 1920
#define kNtErrorCantResolveFilename 1921
#define kNtErrorKmDriverBlocked 1930
#define kNtErrorContextExpired 1931
#define kNtErrorPerUserTrustQuotaExceeded 1932
#define kNtErrorAllUserTrustQuotaExceeded 1933
#define kNtErrorUserDeleteTrustQuotaExceeded 1934
#define kNtErrorAuthenticationFirewallFailed 1935
#define kNtErrorRemotePrintConnectionsBlocked 1936
#define kNtErrorNtlmBlocked 1937
#define kNtErrorPasswordChangeRequired 1938
#define kNtErrorLostModeLogonRestriction 1939
#define kNtErrorInvalidPixelFormat 2000
#define kNtErrorBadDriver 2001
#define kNtErrorInvalidWindowStyle 2002
#define kNtErrorMetafileNotSupported 2003
#define kNtErrorTransformNotSupported 2004
#define kNtErrorClippingNotSupported 2005
#define kNtErrorInvalidCmm 2010
#define kNtErrorInvalidProfile 2011
#define kNtErrorTagNotFound 2012
#define kNtErrorTagNotPresent 2013
#define kNtErrorDuplicateTag 2014
#define kNtErrorProfileNotAssociatedWithDevice 2015
#define kNtErrorProfileNotFound 2016
#define kNtErrorInvalidColorspace 2017
#define kNtErrorIcmNotEnabled 2018
#define kNtErrorDeletingIcmXform 2019
#define kNtErrorInvalidTransform 2020
#define kNtErrorColorspaceMismatch 2021
#define kNtErrorInvalidColorindex 2022
#define kNtErrorProfileDoesNotMatchDevice 2023
#define kNtErrorConnectedOtherPassword 2108
#define kNtErrorConnectedOtherPasswordDefault 2109
#define kNtErrorBadUsername 2202
#define kNtErrorNotConnected 2250
#define kNtErrorOpenFiles 2401
#define kNtErrorActiveConnections 2402
#define kNtErrorDeviceInUse 2404
#define kNtErrorUnknownPrintMonitor 3000
#define kNtErrorPrinterDriverInUse 3001
#define kNtErrorSpoolFileNotFound 3002
#define kNtErrorSplNoStartdoc 3003
#define kNtErrorSplNoAddjob 3004
#define kNtErrorPrintProcessorAlreadyInstalled 3005
#define kNtErrorPrintMonitorAlreadyInstalled 3006
#define kNtErrorInvalidPrintMonitor 3007
#define kNtErrorPrintMonitorInUse 3008
#define kNtErrorPrinterHasJobsQueued 3009
#define kNtErrorSuccessRebootRequired 3010
#define kNtErrorSuccessRestartRequired 3011
#define kNtErrorPrinterNotFound 3012
#define kNtErrorPrinterDriverWarned 3013
#define kNtErrorPrinterDriverBlocked 3014
#define kNtErrorPrinterDriverPackageInUse 3015
#define kNtErrorCoreDriverPackageNotFound 3016
#define kNtErrorFailRebootRequired 3017
#define kNtErrorFailRebootInitiated 3018
#define kNtErrorPrinterDriverDownloadNeeded 3019
#define kNtErrorPrintJobRestartRequired 3020
#define kNtErrorInvalidPrinterDriverManifest 3021
#define kNtErrorPrinterNotShareable 3022
#define kNtErrorRequestPaused 3050
#define kNtErrorAppexecConditionNotSatisfied 3060
#define kNtErrorAppexecHandleInvalidated 3061
#define kNtErrorAppexecInvalidHostGeneration 3062
#define kNtErrorAppexecUnexpectedProcessRegistration 3063
#define kNtErrorAppexecInvalidHostState 3064
#define kNtErrorAppexecNoDonor 3065
#define kNtErrorAppexecHostIdMismatch 3066
#define kNtErrorIoReissueAsCached 3950
#define kNtErrorWinsInternal 4000
#define kNtErrorCanNotDelLocalWins 4001
#define kNtErrorStaticInit 4002
#define kNtErrorIncBackup 4003
#define kNtErrorFullBackup 4004
#define kNtErrorRecNonExistent 4005
#define kNtErrorRplNotAllowed 4006
#define kNtErrorDhcpAddressConflict 4100
#define kNtErrorWmiGuidNotFound 4200
#define kNtErrorWmiInstanceNotFound 4201
#define kNtErrorWmiItemidNotFound 4202
#define kNtErrorWmiTryAgain 4203
#define kNtErrorWmiDpNotFound 4204
#define kNtErrorWmiUnresolvedInstanceRef 4205
#define kNtErrorWmiAlreadyEnabled 4206
#define kNtErrorWmiGuidDisconnected 4207
#define kNtErrorWmiServerUnavailable 4208
#define kNtErrorWmiDpFailed 4209
#define kNtErrorWmiInvalidMof 4210
#define kNtErrorWmiInvalidReginfo 4211
#define kNtErrorWmiAlreadyDisabled 4212
#define kNtErrorWmiReadOnly 4213
#define kNtErrorWmiSetFailure 4214
#define kNtErrorNotAppcontainer 4250
#define kNtErrorAppcontainerRequired 4251
#define kNtErrorNotSupportedInAppcontainer 4252
#define kNtErrorInvalidPackageSidLength 4253
#define kNtErrorInvalidMedia 4300
#define kNtErrorInvalidLibrary 4301
#define kNtErrorInvalidMediaPool 4302
#define kNtErrorDriveMediaMismatch 4303
#define kNtErrorMediaOffline 4304
#define kNtErrorLibraryOffline 4305
#define kNtErrorEmpty 4306
#define kNtErrorNotEmpty 4307
#define kNtErrorMediaUnavailable 4308
#define kNtErrorResourceDisabled 4309
#define kNtErrorInvalidCleaner 4310
#define kNtErrorUnableToClean 4311
#define kNtErrorObjectNotFound 4312
#define kNtErrorDatabaseFailure 4313
#define kNtErrorDatabaseFull 4314
#define kNtErrorMediaIncompatible 4315
#define kNtErrorResourceNotPresent 4316
#define kNtErrorInvalidOperation 4317
#define kNtErrorMediaNotAvailable 4318
#define kNtErrorDeviceNotAvailable 4319
#define kNtErrorRequestRefused 4320
#define kNtErrorInvalidDriveObject 4321
#define kNtErrorLibraryFull 4322
#define kNtErrorMediumNotAccessible 4323
#define kNtErrorUnableToLoadMedium 4324
#define kNtErrorUnableToInventoryDrive 4325
#define kNtErrorUnableToInventorySlot 4326
#define kNtErrorUnableToInventoryTransport 4327
#define kNtErrorTransportFull 4328
#define kNtErrorControllingIeport 4329
#define kNtErrorUnableToEjectMountedMedia 4330
#define kNtErrorCleanerSlotSet 4331
#define kNtErrorCleanerSlotNotSet 4332
#define kNtErrorCleanerCartridgeSpent 4333
#define kNtErrorUnexpectedOmid 4334
#define kNtErrorCantDeleteLastItem 4335
#define kNtErrorMessageExceedsMaxSize 4336
#define kNtErrorVolumeContainsSysFiles 4337
#define kNtErrorIndigenousType 4338
#define kNtErrorNoSupportingDrives 4339
#define kNtErrorCleanerCartridgeInstalled 4340
#define kNtErrorIeportFull 4341
#define kNtErrorFileOffline 4350
#define kNtErrorRemoteStorageNotActive 4351
#define kNtErrorRemoteStorageMediaError 4352
#define kNtErrorNotAReparsePoint 4390
#define kNtErrorReparseAttributeConflict 4391
#define kNtErrorInvalidReparseData 4392
#define kNtErrorReparseTagInvalid 4393
#define kNtErrorReparseTagMismatch 4394
#define kNtErrorReparsePointEncountered 4395
#define kNtErrorAppDataNotFound 4400
#define kNtErrorAppDataExpired 4401
#define kNtErrorAppDataCorrupt 4402
#define kNtErrorAppDataLimitExceeded 4403
#define kNtErrorAppDataRebootRequired 4404
#define kNtErrorSecurebootRollbackDetected 4420
#define kNtErrorSecurebootPolicyViolation 4421
#define kNtErrorSecurebootInvalidPolicy 4422
#define kNtErrorSecurebootPolicyPublisherNotFound 4423
#define kNtErrorSecurebootPolicyNotSigned 4424
#define kNtErrorSecurebootNotEnabled 4425
#define kNtErrorSecurebootFileReplaced 4426
#define kNtErrorSecurebootPolicyNotAuthorized 4427
#define kNtErrorSecurebootPolicyUnknown 4428
#define kNtErrorSecurebootPolicyMissingAntirollbackversion 4429
#define kNtErrorSecurebootPlatformIdMismatch 4430
#define kNtErrorSecurebootPolicyRollbackDetected 4431
#define kNtErrorSecurebootPolicyUpgradeMismatch 4432
#define kNtErrorSecurebootRequiredPolicyFileMissing 4433
#define kNtErrorSecurebootNotBasePolicy 4434
#define kNtErrorSecurebootNotSupplementalPolicy 4435
#define kNtErrorOffloadReadFltNotSupported 4440
#define kNtErrorOffloadWriteFltNotSupported 4441
#define kNtErrorOffloadReadFileNotSupported 4442
#define kNtErrorOffloadWriteFileNotSupported 4443
#define kNtErrorAlreadyHasStreamId 4444
#define kNtErrorSmrGarbageCollectionRequired 4445
#define kNtErrorWofWimHeaderCorrupt 4446
#define kNtErrorWofWimResourceTableCorrupt 4447
#define kNtErrorWofFileResourceTableCorrupt 4448
#define kNtErrorVolumeNotSisEnabled 4500
#define kNtErrorSystemIntegrityRollbackDetected 4550
#define kNtErrorSystemIntegrityPolicyViolation 4551
#define kNtErrorSystemIntegrityInvalidPolicy 4552
#define kNtErrorSystemIntegrityPolicyNotSigned 4553
#define kNtErrorVsmNotInitialized 4560
#define kNtErrorVsmDmaProtectionNotInUse 4561
#define kNtErrorPlatformManifestNotAuthorized 4570
#define kNtErrorPlatformManifestInvalid 4571
#define kNtErrorPlatformManifestFileNotAuthorized 4572
#define kNtErrorPlatformManifestCatalogNotAuthorized 4573
#define kNtErrorPlatformManifestBinaryIdNotFound 4574
#define kNtErrorPlatformManifestNotActive 4575
#define kNtErrorPlatformManifestNotSigned 4576
#define kNtErrorDependentResourceExists 5001
#define kNtErrorDependencyNotFound 5002
#define kNtErrorDependencyAlreadyExists 5003
#define kNtErrorResourceNotOnline 5004
#define kNtErrorHostNodeNotAvailable 5005
#define kNtErrorResourceNotAvailable 5006
#define kNtErrorResourceNotFound 5007
#define kNtErrorShutdownCluster 5008
#define kNtErrorCantEvictActiveNode 5009
#define kNtErrorObjectAlreadyExists 5010
#define kNtErrorObjectInList 5011
#define kNtErrorGroupNotAvailable 5012
#define kNtErrorGroupNotFound 5013
#define kNtErrorGroupNotOnline 5014
#define kNtErrorHostNodeNotResourceOwner 5015
#define kNtErrorHostNodeNotGroupOwner 5016
#define kNtErrorResmonCreateFailed 5017
#define kNtErrorResmonOnlineFailed 5018
#define kNtErrorResourceOnline 5019
#define kNtErrorQuorumResource 5020
#define kNtErrorNotQuorumCapable 5021
#define kNtErrorClusterShuttingDown 5022
#define kNtErrorInvalidState 5023
#define kNtErrorResourcePropertiesStored 5024
#define kNtErrorNotQuorumClass 5025
#define kNtErrorCoreResource 5026
#define kNtErrorQuorumResourceOnlineFailed 5027
#define kNtErrorQuorumlogOpenFailed 5028
#define kNtErrorClusterlogCorrupt 5029
#define kNtErrorClusterlogRecordExceedsMaxsize 5030
#define kNtErrorClusterlogExceedsMaxsize 5031
#define kNtErrorClusterlogChkpointNotFound 5032
#define kNtErrorClusterlogNotEnoughSpace 5033
#define kNtErrorQuorumOwnerAlive 5034
#define kNtErrorNetworkNotAvailable 5035
#define kNtErrorNodeNotAvailable 5036
#define kNtErrorAllNodesNotAvailable 5037
#define kNtErrorResourceFailed 5038
#define kNtErrorClusterInvalidNode 5039
#define kNtErrorClusterNodeExists 5040
#define kNtErrorClusterJoinInProgress 5041
#define kNtErrorClusterNodeNotFound 5042
#define kNtErrorClusterLocalNodeNotFound 5043
#define kNtErrorClusterNetworkExists 5044
#define kNtErrorClusterNetworkNotFound 5045
#define kNtErrorClusterNetinterfaceExists 5046
#define kNtErrorClusterNetinterfaceNotFound 5047
#define kNtErrorClusterInvalidRequest 5048
#define kNtErrorClusterInvalidNetworkProvider 5049
#define kNtErrorClusterNodeDown 5050
#define kNtErrorClusterNodeUnreachable 5051
#define kNtErrorClusterNodeNotMember 5052
#define kNtErrorClusterJoinNotInProgress 5053
#define kNtErrorClusterInvalidNetwork 5054
#define kNtErrorClusterNodeUp 5056
#define kNtErrorClusterIpaddrInUse 5057
#define kNtErrorClusterNodeNotPaused 5058
#define kNtErrorClusterNoSecurityContext 5059
#define kNtErrorClusterNetworkNotInternal 5060
#define kNtErrorClusterNodeAlreadyUp 5061
#define kNtErrorClusterNodeAlreadyDown 5062
#define kNtErrorClusterNetworkAlreadyOnline 5063
#define kNtErrorClusterNetworkAlreadyOffline 5064
#define kNtErrorClusterNodeAlreadyMember 5065
#define kNtErrorClusterLastInternalNetwork 5066
#define kNtErrorClusterNetworkHasDependents 5067
#define kNtErrorInvalidOperationOnQuorum 5068
#define kNtErrorDependencyNotAllowed 5069
#define kNtErrorClusterNodePaused 5070
#define kNtErrorNodeCantHostResource 5071
#define kNtErrorClusterNodeNotReady 5072
#define kNtErrorClusterNodeShuttingDown 5073
#define kNtErrorClusterJoinAborted 5074
#define kNtErrorClusterIncompatibleVersions 5075
#define kNtErrorClusterMaxnumOfResourcesExceeded 5076
#define kNtErrorClusterSystemConfigChanged 5077
#define kNtErrorClusterResourceTypeNotFound 5078
#define kNtErrorClusterRestypeNotSupported 5079
#define kNtErrorClusterResnameNotFound 5080
#define kNtErrorClusterNoRpcPackagesRegistered 5081
#define kNtErrorClusterOwnerNotInPreflist 5082
#define kNtErrorClusterDatabaseSeqmismatch 5083
#define kNtErrorResmonInvalidState 5084
#define kNtErrorClusterGumNotLocker 5085
#define kNtErrorQuorumDiskNotFound 5086
#define kNtErrorDatabaseBackupCorrupt 5087
#define kNtErrorClusterNodeAlreadyHasDfsRoot 5088
#define kNtErrorResourcePropertyUnchangeable 5089
#define kNtErrorNoAdminAccessPoint 5090
#define kNtErrorClusterMembershipInvalidState 5890
#define kNtErrorClusterQuorumlogNotFound 5891
#define kNtErrorClusterMembershipHalt 5892
#define kNtErrorClusterInstanceIdMismatch 5893
#define kNtErrorClusterNetworkNotFoundForIp 5894
#define kNtErrorClusterPropertyDataTypeMismatch 5895
#define kNtErrorClusterEvictWithoutCleanup 5896
#define kNtErrorClusterParameterMismatch 5897
#define kNtErrorNodeCannotBeClustered 5898
#define kNtErrorClusterWrongOsVersion 5899
#define kNtErrorClusterCantCreateDupClusterName 5900
#define kNtErrorCluscfgAlreadyCommitted 5901
#define kNtErrorCluscfgRollbackFailed 5902
#define kNtErrorCluscfgSystemDiskDriveLetterConflict 5903
#define kNtErrorClusterOldVersion 5904
#define kNtErrorClusterMismatchedComputerAcctName 5905
#define kNtErrorClusterNoNetAdapters 5906
#define kNtErrorClusterPoisoned 5907
#define kNtErrorClusterGroupMoving 5908
#define kNtErrorClusterResourceTypeBusy 5909
#define kNtErrorResourceCallTimedOut 5910
#define kNtErrorInvalidClusterIpv6Address 5911
#define kNtErrorClusterInternalInvalidFunction 5912
#define kNtErrorClusterParameterOutOfBounds 5913
#define kNtErrorClusterPartialSend 5914
#define kNtErrorClusterRegistryInvalidFunction 5915
#define kNtErrorClusterInvalidStringTermination 5916
#define kNtErrorClusterInvalidStringFormat 5917
#define kNtErrorClusterDatabaseTransactionInProgress 5918
#define kNtErrorClusterDatabaseTransactionNotInProgress 5919
#define kNtErrorClusterNullData 5920
#define kNtErrorClusterPartialRead 5921
#define kNtErrorClusterPartialWrite 5922
#define kNtErrorClusterCantDeserializeData 5923
#define kNtErrorDependentResourcePropertyConflict 5924
#define kNtErrorClusterNoQuorum 5925
#define kNtErrorClusterInvalidIpv6Network 5926
#define kNtErrorClusterInvalidIpv6TunnelNetwork 5927
#define kNtErrorQuorumNotAllowedInThisGroup 5928
#define kNtErrorDependencyTreeTooComplex 5929
#define kNtErrorExceptionInResourceCall 5930
#define kNtErrorClusterRhsFailedInitialization 5931
#define kNtErrorClusterNotInstalled 5932
#define kNtErrorClusterResourcesMustBeOnlineOnTheSameNode 5933
#define kNtErrorClusterMaxNodesInCluster 5934
#define kNtErrorClusterTooManyNodes 5935
#define kNtErrorClusterObjectAlreadyUsed 5936
#define kNtErrorNoncoreGroupsFound 5937
#define kNtErrorFileShareResourceConflict 5938
#define kNtErrorClusterEvictInvalidRequest 5939
#define kNtErrorClusterSingletonResource 5940
#define kNtErrorClusterGroupSingletonResource 5941
#define kNtErrorClusterResourceProviderFailed 5942
#define kNtErrorClusterResourceConfigurationError 5943
#define kNtErrorClusterGroupBusy 5944
#define kNtErrorClusterNotSharedVolume 5945
#define kNtErrorClusterInvalidSecurityDescriptor 5946
#define kNtErrorClusterSharedVolumesInUse 5947
#define kNtErrorClusterUseSharedVolumesApi 5948
#define kNtErrorClusterBackupInProgress 5949
#define kNtErrorNonCsvPath 5950
#define kNtErrorCsvVolumeNotLocal 5951
#define kNtErrorClusterWatchdogTerminating 5952
#define kNtErrorClusterResourceVetoedMoveIncompatibleNodes 5953
#define kNtErrorClusterInvalidNodeWeight 5954
#define kNtErrorClusterResourceVetoedCall 5955
#define kNtErrorResmonSystemResourcesLacking 5956
#define kNtErrorClusterResourceVetoedMoveNotEnoughResourcesOnSource 5958
#define kNtErrorClusterGroupQueued 5959
#define kNtErrorClusterResourceLockedStatus 5960
#define kNtErrorClusterSharedVolumeFailoverNotAllowed 5961
#define kNtErrorClusterNodeDrainInProgress 5962
#define kNtErrorClusterDiskNotConnected 5963
#define kNtErrorDiskNotCsvCapable 5964
#define kNtErrorResourceNotInAvailableStorage 5965
#define kNtErrorClusterSharedVolumeRedirected 5966
#define kNtErrorClusterSharedVolumeNotRedirected 5967
#define kNtErrorClusterCannotReturnProperties 5968
#define kNtErrorClusterResourceIsInMaintenanceMode 5970
#define kNtErrorClusterAffinityConflict 5971
#define kNtErrorClusterResourceIsReplicaVirtualMachine 5972
#define kNtErrorClusterUpgradeIncompatibleVersions 5973
#define kNtErrorClusterUpgradeFixQuorumNotSupported 5974
#define kNtErrorClusterUpgradeRestartRequired 5975
#define kNtErrorClusterUpgradeInProgress 5976
#define kNtErrorClusterUpgradeIncomplete 5977
#define kNtErrorClusterNodeInGracePeriod 5978
#define kNtErrorClusterCsvIoPauseTimeout 5979
#define kNtErrorNodeNotActiveClusterMember 5980
#define kNtErrorClusterResourceNotMonitored 5981
#define kNtErrorClusterResourceDoesNotSupportUnmonitored 5982
#define kNtErrorClusterResourceIsReplicated 5983
#define kNtErrorClusterNodeIsolated 5984
#define kNtErrorClusterNodeQuarantined 5985
#define kNtErrorClusterDatabaseUpdateConditionFailed 5986
#define kNtErrorClusterSpaceDegraded 5987
#define kNtErrorClusterTokenDelegationNotSupported 5988
#define kNtErrorClusterCsvInvalidHandle 5989
#define kNtErrorClusterCsvSupportedOnlyOnCoordinator 5990
#define kNtErrorGroupsetNotAvailable 5991
#define kNtErrorGroupsetNotFound 5992
#define kNtErrorGroupsetCantProvide 5993
#define kNtErrorClusterFaultDomainParentNotFound 5994
#define kNtErrorClusterFaultDomainInvalidHierarchy 5995
#define kNtErrorClusterFaultDomainFailedS2dValidation 5996
#define kNtErrorClusterFaultDomainS2dConnectivityLoss 5997
#define kNtErrorClusterInvalidInfrastructureFileserverName 5998
#define kNtErrorClustersetManagementClusterUnreachable 5999
#define kNtErrorEncryptionFailed 6000
#define kNtErrorDecryptionFailed 6001
#define kNtErrorFileEncrypted 6002
#define kNtErrorNoRecoveryPolicy 6003
#define kNtErrorNoEfs 6004
#define kNtErrorWrongEfs 6005
#define kNtErrorNoUserKeys 6006
#define kNtErrorFileNotEncrypted 6007
#define kNtErrorNotExportFormat 6008
#define kNtErrorFileReadOnly 6009 /* EROFS */
#define kNtErrorDirEfsDisallowed 6010
#define kNtErrorEfsServerNotTrusted 6011
#define kNtErrorBadRecoveryPolicy 6012
#define kNtErrorEfsAlgBlobTooBig 6013
#define kNtErrorVolumeNotSupportEfs 6014
#define kNtErrorEfsDisabled 6015
#define kNtErrorEfsVersionNotSupport 6016
#define kNtErrorCsEncryptionInvalidServerResponse 6017
#define kNtErrorCsEncryptionUnsupportedServer 6018
#define kNtErrorCsEncryptionExistingEncryptedFile 6019
#define kNtErrorCsEncryptionNewEncryptedFile 6020
#define kNtErrorCsEncryptionFileNotCse 6021
#define kNtErrorEncryptionPolicyDeniesOperation 6022
#define kNtErrorNoBrowserServersFound 6118
#define kNtErrorLogSectorInvalid 6600
#define kNtErrorLogSectorParityInvalid 6601
#define kNtErrorLogSectorRemapped 6602
#define kNtErrorLogBlockIncomplete 6603
#define kNtErrorLogInvalidRange 6604
#define kNtErrorLogBlocksExhausted 6605
#define kNtErrorLogReadContextInvalid 6606
#define kNtErrorLogRestartInvalid 6607
#define kNtErrorLogBlockVersion 6608
#define kNtErrorLogBlockInvalid 6609
#define kNtErrorLogReadModeInvalid 6610
#define kNtErrorLogNoRestart 6611
#define kNtErrorLogMetadataCorrupt 6612
#define kNtErrorLogMetadataInvalid 6613
#define kNtErrorLogMetadataInconsistent 6614
#define kNtErrorLogReservationInvalid 6615
#define kNtErrorLogCantDelete 6616
#define kNtErrorLogContainerLimitExceeded 6617
#define kNtErrorLogStartOfLog 6618
#define kNtErrorLogPolicyAlreadyInstalled 6619
#define kNtErrorLogPolicyNotInstalled 6620
#define kNtErrorLogPolicyInvalid 6621
#define kNtErrorLogPolicyConflict 6622
#define kNtErrorLogPinnedArchiveTail 6623
#define kNtErrorLogRecordNonexistent 6624
#define kNtErrorLogRecordsReservedInvalid 6625
#define kNtErrorLogSpaceReservedInvalid 6626
#define kNtErrorLogTailInvalid 6627
#define kNtErrorLogFull 6628
#define kNtErrorCouldNotResizeLog 6629
#define kNtErrorLogMultiplexed 6630
#define kNtErrorLogDedicated 6631
#define kNtErrorLogArchiveNotInProgress 6632
#define kNtErrorLogArchiveInProgress 6633
#define kNtErrorLogEphemeral 6634
#define kNtErrorLogNotEnoughContainers 6635
#define kNtErrorLogClientAlreadyRegistered 6636
#define kNtErrorLogClientNotRegistered 6637
#define kNtErrorLogFullHandlerInProgress 6638
#define kNtErrorLogContainerReadFailed 6639
#define kNtErrorLogContainerWriteFailed 6640
#define kNtErrorLogContainerOpenFailed 6641
#define kNtErrorLogContainerStateInvalid 6642
#define kNtErrorLogStateInvalid 6643
#define kNtErrorLogPinned 6644
#define kNtErrorLogMetadataFlushFailed 6645
#define kNtErrorLogInconsistentSecurity 6646
#define kNtErrorLogAppendedFlushFailed 6647
#define kNtErrorLogPinnedReservation 6648
#define kNtErrorInvalidTransaction 6700
#define kNtErrorTransactionNotActive 6701
#define kNtErrorTransactionRequestNotValid 6702
#define kNtErrorTransactionNotRequested 6703
#define kNtErrorTransactionAlreadyAborted 6704
#define kNtErrorTransactionAlreadyCommitted 6705
#define kNtErrorTmInitializationFailed 6706
#define kNtErrorResourcemanagerReadOnly 6707
#define kNtErrorTransactionNotJoined 6708
#define kNtErrorTransactionSuperiorExists 6709
#define kNtErrorCrmProtocolAlreadyExists 6710
#define kNtErrorTransactionPropagationFailed 6711
#define kNtErrorCrmProtocolNotFound 6712
#define kNtErrorTransactionInvalidMarshallBuffer 6713
#define kNtErrorCurrentTransactionNotValid 6714
#define kNtErrorTransactionNotFound 6715
#define kNtErrorResourcemanagerNotFound 6716
#define kNtErrorEnlistmentNotFound 6717
#define kNtErrorTransactionmanagerNotFound 6718
#define kNtErrorTransactionmanagerNotOnline 6719
#define kNtErrorTransactionmanagerRecoveryNameCollision 6720
#define kNtErrorTransactionNotRoot 6721
#define kNtErrorTransactionObjectExpired 6722
#define kNtErrorTransactionResponseNotEnlisted 6723
#define kNtErrorTransactionRecordTooLong 6724
#define kNtErrorImplicitTransactionNotSupported 6725
#define kNtErrorTransactionIntegrityViolated 6726
#define kNtErrorTransactionmanagerIdentityMismatch 6727
#define kNtErrorRmCannotBeFrozenForSnapshot 6728
#define kNtErrorTransactionMustWritethrough 6729
#define kNtErrorTransactionNoSuperior 6730
#define kNtErrorHeuristicDamagePossible 6731
#define kNtErrorTransactionalConflict 6800
#define kNtErrorRmNotActive 6801
#define kNtErrorRmMetadataCorrupt 6802
#define kNtErrorDirectoryNotRm 6803
#define kNtErrorTransactionsUnsupportedRemote 6805
#define kNtErrorLogResizeInvalidSize 6806
#define kNtErrorObjectNoLongerExists 6807
#define kNtErrorStreamMiniversionNotFound 6808
#define kNtErrorStreamMiniversionNotValid 6809
#define kNtErrorMiniversionInaccessibleFromSpecifiedTransaction 6810
#define kNtErrorCantOpenMiniversionWithModifyIntent 6811
#define kNtErrorCantCreateMoreStreamMiniversions 6812
#define kNtErrorRemoteFileVersionMismatch 6814
#define kNtErrorHandleNoLongerValid 6815
#define kNtErrorNoTxfMetadata 6816
#define kNtErrorLogCorruptionDetected 6817
#define kNtErrorCantRecoverWithHandleOpen 6818
#define kNtErrorRmDisconnected 6819
#define kNtErrorEnlistmentNotSuperior 6820
#define kNtErrorRecoveryNotNeeded 6821
#define kNtErrorRmAlreadyStarted 6822
#define kNtErrorFileIdentityNotPersistent 6823
#define kNtErrorCantBreakTransactionalDependency 6824
#define kNtErrorCantCrossRmBoundary 6825
#define kNtErrorTxfDirNotEmpty 6826
#define kNtErrorIndoubtTransactionsExist 6827
#define kNtErrorTmVolatile 6828
#define kNtErrorRollbackTimerExpired 6829
#define kNtErrorTxfAttributeCorrupt 6830
#define kNtErrorEfsNotAllowedInTransaction 6831
#define kNtErrorTransactionalOpenNotAllowed 6832
#define kNtErrorLogGrowthFailed 6833
#define kNtErrorTransactedMappingUnsupportedRemote 6834
#define kNtErrorTxfMetadataAlreadyPresent 6835
#define kNtErrorTransactionScopeCallbacksNotSet 6836
#define kNtErrorTransactionRequiredPromotion 6837
#define kNtErrorCannotExecuteFileInTransaction 6838
#define kNtErrorTransactionsNotFrozen 6839
#define kNtErrorTransactionFreezeInProgress 6840
#define kNtErrorNotSnapshotVolume 6841
#define kNtErrorNoSavepointWithOpenFiles 6842
#define kNtErrorDataLostRepair 6843
#define kNtErrorSparseNotAllowedInTransaction 6844
#define kNtErrorTmIdentityMismatch 6845
#define kNtErrorFloatedSection 6846
#define kNtErrorCannotAcceptTransactedWork 6847
#define kNtErrorCannotAbortTransactions 6848
#define kNtErrorBadClusters 6849
#define kNtErrorCompressionNotAllowedInTransaction 6850
#define kNtErrorVolumeDirty 6851
#define kNtErrorNoLinkTrackingInTransaction 6852
#define kNtErrorOperationNotSupportedInTransaction 6853
#define kNtErrorExpiredHandle 6854
#define kNtErrorTransactionNotEnlisted 6855
#define kNtErrorCtxWinstationNameInvalid 7001
#define kNtErrorCtxInvalidPd 7002
#define kNtErrorCtxPdNotFound 7003
#define kNtErrorCtxWdNotFound 7004
#define kNtErrorCtxCannotMakeEventlogEntry 7005
#define kNtErrorCtxServiceNameCollision 7006
#define kNtErrorCtxClosePending 7007
#define kNtErrorCtxNoOutbuf 7008
#define kNtErrorCtxModemInfNotFound 7009
#define kNtErrorCtxInvalidModemname 7010
#define kNtErrorCtxModemResponseError 7011
#define kNtErrorCtxModemResponseTimeout 7012
#define kNtErrorCtxModemResponseNoCarrier 7013
#define kNtErrorCtxModemResponseNoDialtone 7014
#define kNtErrorCtxModemResponseBusy 7015
#define kNtErrorCtxModemResponseVoice 7016
#define kNtErrorCtxTdError 7017
#define kNtErrorCtxWinstationNotFound 7022
#define kNtErrorCtxWinstationAlreadyExists 7023
#define kNtErrorCtxWinstationBusy 7024
#define kNtErrorCtxBadVideoMode 7025
#define kNtErrorCtxGraphicsInvalid 7035
#define kNtErrorCtxLogonDisabled 7037
#define kNtErrorCtxNotConsole 7038
#define kNtErrorCtxClientQueryTimeout 7040
#define kNtErrorCtxConsoleDisconnect 7041
#define kNtErrorCtxConsoleConnect 7042
#define kNtErrorCtxShadowDenied 7044
#define kNtErrorCtxWinstationAccessDenied 7045
#define kNtErrorCtxInvalidWd 7049
#define kNtErrorCtxShadowInvalid 7050
#define kNtErrorCtxShadowDisabled 7051
#define kNtErrorCtxClientLicenseInUse 7052
#define kNtErrorCtxClientLicenseNotSet 7053
#define kNtErrorCtxLicenseNotAvailable 7054
#define kNtErrorCtxLicenseClientInvalid 7055
#define kNtErrorCtxLicenseExpired 7056
#define kNtErrorCtxShadowNotRunning 7057
#define kNtErrorCtxShadowEndedByModeChange 7058
#define kNtErrorActivationCountExceeded 7059
#define kNtErrorCtxWinstationsDisabled 7060
#define kNtErrorCtxEncryptionLevelRequired 7061
#define kNtErrorCtxSessionInUse 7062
#define kNtErrorCtxNoForceLogoff 7063
#define kNtErrorCtxAccountRestriction 7064
#define kNtErrorRdpProtocolError 7065
#define kNtErrorCtxCdmConnect 7066
#define kNtErrorCtxCdmDisconnect 7067
#define kNtErrorCtxSecurityLayerError 7068
#define kNtErrorTsIncompatibleSessions 7069
#define kNtErrorTsVideoSubsystemError 7070
#define kNtErrorDsNotInstalled 8200
#define kNtErrorDsMembershipEvaluatedLocally 8201
#define kNtErrorDsNoAttributeOrValue 8202
#define kNtErrorDsInvalidAttributeSyntax 8203
#define kNtErrorDsAttributeTypeUndefined 8204
#define kNtErrorDsAttributeOrValueExists 8205
#define kNtErrorDsBusy 8206
#define kNtErrorDsUnavailable 8207
#define kNtErrorDsNoRidsAllocated 8208
#define kNtErrorDsNoMoreRids 8209
#define kNtErrorDsIncorrectRoleOwner 8210
#define kNtErrorDsRidmgrInitError 8211
#define kNtErrorDsObjClassViolation 8212
#define kNtErrorDsCantOnNonLeaf 8213
#define kNtErrorDsCantOnRdn 8214
#define kNtErrorDsCantModObjClass 8215
#define kNtErrorDsCrossDomMoveError 8216
#define kNtErrorDsGcNotAvailable 8217
#define kNtErrorSharedPolicy 8218
#define kNtErrorPolicyObjectNotFound 8219
#define kNtErrorPolicyOnlyInDs 8220
#define kNtErrorPromotionActive 8221
#define kNtErrorNoPromotionActive 8222
#define kNtErrorDsOperationsError 8224
#define kNtErrorDsProtocolError 8225
#define kNtErrorDsTimelimitExceeded 8226
#define kNtErrorDsSizelimitExceeded 8227
#define kNtErrorDsAdminLimitExceeded 8228
#define kNtErrorDsCompareFalse 8229
#define kNtErrorDsCompareTrue 8230
#define kNtErrorDsAuthMethodNotSupported 8231
#define kNtErrorDsStrongAuthRequired 8232
#define kNtErrorDsInappropriateAuth 8233
#define kNtErrorDsAuthUnknown 8234
#define kNtErrorDsReferral 8235
#define kNtErrorDsUnavailableCritExtension 8236
#define kNtErrorDsConfidentialityRequired 8237
#define kNtErrorDsInappropriateMatching 8238
#define kNtErrorDsConstraintViolation 8239
#define kNtErrorDsNoSuchObject 8240
#define kNtErrorDsAliasProblem 8241
#define kNtErrorDsInvalidDnSyntax 8242
#define kNtErrorDsIsLeaf 8243
#define kNtErrorDsAliasDerefProblem 8244
#define kNtErrorDsUnwillingToPerform 8245
#define kNtErrorDsLoopDetect 8246
#define kNtErrorDsNamingViolation 8247
#define kNtErrorDsObjectResultsTooLarge 8248
#define kNtErrorDsAffectsMultipleDsas 8249
#define kNtErrorDsServerDown 8250
#define kNtErrorDsLocalError 8251
#define kNtErrorDsEncodingError 8252
#define kNtErrorDsDecodingError 8253
#define kNtErrorDsFilterUnknown 8254
#define kNtErrorDsParamError 8255
#define kNtErrorDsNotSupported 8256
#define kNtErrorDsNoResultsReturned 8257
#define kNtErrorDsControlNotFound 8258
#define kNtErrorDsClientLoop 8259
#define kNtErrorDsReferralLimitExceeded 8260
#define kNtErrorDsSortControlMissing 8261
#define kNtErrorDsOffsetRangeError 8262
#define kNtErrorDsRidmgrDisabled 8263
#define kNtErrorDsRootMustBeNc 8301
#define kNtErrorDsAddReplicaInhibited 8302
#define kNtErrorDsAttNotDefInSchema 8303
#define kNtErrorDsMaxObjSizeExceeded 8304
#define kNtErrorDsObjStringNameExists 8305
#define kNtErrorDsNoRdnDefinedInSchema 8306
#define kNtErrorDsRdnDoesntMatchSchema 8307
#define kNtErrorDsNoRequestedAttsFound 8308
#define kNtErrorDsUserBufferToSmall 8309
#define kNtErrorDsAttIsNotOnObj 8310
#define kNtErrorDsIllegalModOperation 8311
#define kNtErrorDsObjTooLarge 8312
#define kNtErrorDsBadInstanceType 8313
#define kNtErrorDsMasterdsaRequired 8314
#define kNtErrorDsObjectClassRequired 8315
#define kNtErrorDsMissingRequiredAtt 8316
#define kNtErrorDsAttNotDefForClass 8317
#define kNtErrorDsAttAlreadyExists 8318
#define kNtErrorDsCantAddAttValues 8320
#define kNtErrorDsSingleValueConstraint 8321
#define kNtErrorDsRangeConstraint 8322
#define kNtErrorDsAttValAlreadyExists 8323
#define kNtErrorDsCantRemMissingAtt 8324
#define kNtErrorDsCantRemMissingAttVal 8325
#define kNtErrorDsRootCantBeSubref 8326
#define kNtErrorDsNoChaining 8327
#define kNtErrorDsNoChainedEval 8328
#define kNtErrorDsNoParentObject 8329
#define kNtErrorDsParentIsAnAlias 8330
#define kNtErrorDsCantMixMasterAndReps 8331
#define kNtErrorDsChildrenExist 8332
#define kNtErrorDsObjNotFound 8333
#define kNtErrorDsAliasedObjMissing 8334
#define kNtErrorDsBadNameSyntax 8335
#define kNtErrorDsAliasPointsToAlias 8336
#define kNtErrorDsCantDerefAlias 8337
#define kNtErrorDsOutOfScope 8338
#define kNtErrorDsObjectBeingRemoved 8339
#define kNtErrorDsCantDeleteDsaObj 8340
#define kNtErrorDsGenericError 8341
#define kNtErrorDsDsaMustBeIntMaster 8342
#define kNtErrorDsClassNotDsa 8343
#define kNtErrorDsInsuffAccessRights 8344
#define kNtErrorDsIllegalSuperior 8345
#define kNtErrorDsAttributeOwnedBySam 8346
#define kNtErrorDsNameTooManyParts 8347
#define kNtErrorDsNameTooLong 8348
#define kNtErrorDsNameValueTooLong 8349
#define kNtErrorDsNameUnparseable 8350
#define kNtErrorDsNameTypeUnknown 8351
#define kNtErrorDsNotAnObject 8352
#define kNtErrorDsSecDescTooShort 8353
#define kNtErrorDsSecDescInvalid 8354
#define kNtErrorDsNoDeletedName 8355
#define kNtErrorDsSubrefMustHaveParent 8356
#define kNtErrorDsNcnameMustBeNc 8357
#define kNtErrorDsCantAddSystemOnly 8358
#define kNtErrorDsClassMustBeConcrete 8359
#define kNtErrorDsInvalidDmd 8360
#define kNtErrorDsObjGuidExists 8361
#define kNtErrorDsNotOnBacklink 8362
#define kNtErrorDsNoCrossrefForNc 8363
#define kNtErrorDsShuttingDown 8364
#define kNtErrorDsUnknownOperation 8365
#define kNtErrorDsInvalidRoleOwner 8366
#define kNtErrorDsCouldntContactFsmo 8367
#define kNtErrorDsCrossNcDnRename 8368
#define kNtErrorDsCantModSystemOnly 8369
#define kNtErrorDsReplicatorOnly 8370
#define kNtErrorDsObjClassNotDefined 8371
#define kNtErrorDsObjClassNotSubclass 8372
#define kNtErrorDsNameReferenceInvalid 8373
#define kNtErrorDsCrossRefExists 8374
#define kNtErrorDsCantDelMasterCrossref 8375
#define kNtErrorDsSubtreeNotifyNotNcHead 8376
#define kNtErrorDsNotifyFilterTooComplex 8377
#define kNtErrorDsDupRdn 8378
#define kNtErrorDsDupOid 8379
#define kNtErrorDsDupMapiId 8380
#define kNtErrorDsDupSchemaIdGuid 8381
#define kNtErrorDsDupLdapDisplayName 8382
#define kNtErrorDsSemanticAttTest 8383
#define kNtErrorDsSyntaxMismatch 8384
#define kNtErrorDsExistsInMustHave 8385
#define kNtErrorDsExistsInMayHave 8386
#define kNtErrorDsNonexistentMayHave 8387
#define kNtErrorDsNonexistentMustHave 8388
#define kNtErrorDsAuxClsTestFail 8389
#define kNtErrorDsNonexistentPossSup 8390
#define kNtErrorDsSubClsTestFail 8391
#define kNtErrorDsBadRdnAttIdSyntax 8392
#define kNtErrorDsExistsInAuxCls 8393
#define kNtErrorDsExistsInSubCls 8394
#define kNtErrorDsExistsInPossSup 8395
#define kNtErrorDsRecalcschemaFailed 8396
#define kNtErrorDsTreeDeleteNotFinished 8397
#define kNtErrorDsCantDelete 8398
#define kNtErrorDsAttSchemaReqId 8399
#define kNtErrorDsBadAttSchemaSyntax 8400
#define kNtErrorDsCantCacheAtt 8401
#define kNtErrorDsCantCacheClass 8402
#define kNtErrorDsCantRemoveAttCache 8403
#define kNtErrorDsCantRemoveClassCache 8404
#define kNtErrorDsCantRetrieveDn 8405
#define kNtErrorDsMissingSupref 8406
#define kNtErrorDsCantRetrieveInstance 8407
#define kNtErrorDsCodeInconsistency 8408
#define kNtErrorDsDatabaseError 8409
#define kNtErrorDsGovernsidMissing 8410
#define kNtErrorDsMissingExpectedAtt 8411
#define kNtErrorDsNcnameMissingCrRef 8412
#define kNtErrorDsSecurityCheckingError 8413
#define kNtErrorDsSchemaNotLoaded 8414
#define kNtErrorDsSchemaAllocFailed 8415
#define kNtErrorDsAttSchemaReqSyntax 8416
#define kNtErrorDsGcverifyError 8417
#define kNtErrorDsDraSchemaMismatch 8418
#define kNtErrorDsCantFindDsaObj 8419
#define kNtErrorDsCantFindExpectedNc 8420
#define kNtErrorDsCantFindNcInCache 8421
#define kNtErrorDsCantRetrieveChild 8422
#define kNtErrorDsSecurityIllegalModify 8423
#define kNtErrorDsCantReplaceHiddenRec 8424
#define kNtErrorDsBadHierarchyFile 8425
#define kNtErrorDsBuildHierarchyTableFailed 8426
#define kNtErrorDsConfigParamMissing 8427
#define kNtErrorDsCountingAbIndicesFailed 8428
#define kNtErrorDsHierarchyTableMallocFailed 8429
#define kNtErrorDsInternalFailure 8430
#define kNtErrorDsUnknownError 8431
#define kNtErrorDsRootRequiresClassTop 8432
#define kNtErrorDsRefusingFsmoRoles 8433
#define kNtErrorDsMissingFsmoSettings 8434
#define kNtErrorDsUnableToSurrenderRoles 8435
#define kNtErrorDsDraGeneric 8436
#define kNtErrorDsDraInvalidParameter 8437
#define kNtErrorDsDraBusy 8438
#define kNtErrorDsDraBadDn 8439
#define kNtErrorDsDraBadNc 8440
#define kNtErrorDsDraDnExists 8441
#define kNtErrorDsDraInternalError 8442
#define kNtErrorDsDraInconsistentDit 8443
#define kNtErrorDsDraConnectionFailed 8444
#define kNtErrorDsDraBadInstanceType 8445
#define kNtErrorDsDraOutOfMem 8446
#define kNtErrorDsDraMailProblem 8447
#define kNtErrorDsDraRefAlreadyExists 8448
#define kNtErrorDsDraRefNotFound 8449
#define kNtErrorDsDraObjIsRepSource 8450
#define kNtErrorDsDraDbError 8451
#define kNtErrorDsDraNoReplica 8452
#define kNtErrorDsDraAccessDenied 8453
#define kNtErrorDsDraNotSupported 8454
#define kNtErrorDsDraRpcCancelled 8455
#define kNtErrorDsDraSourceDisabled 8456
#define kNtErrorDsDraSinkDisabled 8457
#define kNtErrorDsDraNameCollision 8458
#define kNtErrorDsDraSourceReinstalled 8459
#define kNtErrorDsDraMissingParent 8460
#define kNtErrorDsDraPreempted 8461
#define kNtErrorDsDraAbandonSync 8462
#define kNtErrorDsDraShutdown 8463
#define kNtErrorDsDraIncompatiblePartialSet 8464
#define kNtErrorDsDraSourceIsPartialReplica 8465
#define kNtErrorDsDraExtnConnectionFailed 8466
#define kNtErrorDsInstallSchemaMismatch 8467
#define kNtErrorDsDupLinkId 8468
#define kNtErrorDsNameErrorResolving 8469
#define kNtErrorDsNameErrorNotFound 8470
#define kNtErrorDsNameErrorNotUnique 8471
#define kNtErrorDsNameErrorNoMapping 8472
#define kNtErrorDsNameErrorDomainOnly 8473
#define kNtErrorDsNameErrorNoSyntacticalMapping 8474
#define kNtErrorDsConstructedAttMod 8475
#define kNtErrorDsWrongOmObjClass 8476
#define kNtErrorDsDraReplPending 8477
#define kNtErrorDsDsRequired 8478
#define kNtErrorDsInvalidLdapDisplayName 8479
#define kNtErrorDsNonBaseSearch 8480
#define kNtErrorDsCantRetrieveAtts 8481
#define kNtErrorDsBacklinkWithoutLink 8482
#define kNtErrorDsEpochMismatch 8483
#define kNtErrorDsSrcNameMismatch 8484
#define kNtErrorDsSrcAndDstNcIdentical 8485
#define kNtErrorDsDstNcMismatch 8486
#define kNtErrorDsNotAuthoritiveForDstNc 8487
#define kNtErrorDsSrcGuidMismatch 8488
#define kNtErrorDsCantMoveDeletedObject 8489
#define kNtErrorDsPdcOperationInProgress 8490
#define kNtErrorDsCrossDomainCleanupReqd 8491
#define kNtErrorDsIllegalXdomMoveOperation 8492
#define kNtErrorDsCantWithAcctGroupMembershps 8493
#define kNtErrorDsNcMustHaveNcParent 8494
#define kNtErrorDsCrImpossibleToValidate 8495
#define kNtErrorDsDstDomainNotNative 8496
#define kNtErrorDsMissingInfrastructureContainer 8497
#define kNtErrorDsCantMoveAccountGroup 8498
#define kNtErrorDsCantMoveResourceGroup 8499
#define kNtErrorDsInvalidSearchFlag 8500
#define kNtErrorDsNoTreeDeleteAboveNc 8501
#define kNtErrorDsCouldntLockTreeForDelete 8502
#define kNtErrorDsCouldntIdentifyObjectsForTreeDelete 8503
#define kNtErrorDsSamInitFailure 8504
#define kNtErrorDsSensitiveGroupViolation 8505
#define kNtErrorDsCantModPrimarygroupid 8506
#define kNtErrorDsIllegalBaseSchemaMod 8507
#define kNtErrorDsNonsafeSchemaChange 8508
#define kNtErrorDsSchemaUpdateDisallowed 8509
#define kNtErrorDsCantCreateUnderSchema 8510
#define kNtErrorDsInstallNoSrcSchVersion 8511
#define kNtErrorDsInstallNoSchVersionInInifile 8512
#define kNtErrorDsInvalidGroupType 8513
#define kNtErrorDsNoNestGlobalgroupInMixeddomain 8514
#define kNtErrorDsNoNestLocalgroupInMixeddomain 8515
#define kNtErrorDsGlobalCantHaveLocalMember 8516
#define kNtErrorDsGlobalCantHaveUniversalMember 8517
#define kNtErrorDsUniversalCantHaveLocalMember 8518
#define kNtErrorDsGlobalCantHaveCrossdomainMember 8519
#define kNtErrorDsLocalCantHaveCrossdomainLocalMember 8520
#define kNtErrorDsHavePrimaryMembers 8521
#define kNtErrorDsStringSdConversionFailed 8522
#define kNtErrorDsNamingMasterGc 8523
#define kNtErrorDsDnsLookupFailure 8524
#define kNtErrorDsCouldntUpdateSpns 8525
#define kNtErrorDsCantRetrieveSd 8526
#define kNtErrorDsKeyNotUnique 8527
#define kNtErrorDsWrongLinkedAttSyntax 8528
#define kNtErrorDsSamNeedBootkeyPassword 8529
#define kNtErrorDsSamNeedBootkeyFloppy 8530
#define kNtErrorDsCantStart 8531
#define kNtErrorDsInitFailure 8532
#define kNtErrorDsNoPktPrivacyOnConnection 8533
#define kNtErrorDsSourceDomainInForest 8534
#define kNtErrorDsDestinationDomainNotInForest 8535
#define kNtErrorDsDestinationAuditingNotEnabled 8536
#define kNtErrorDsCantFindDcForSrcDomain 8537
#define kNtErrorDsSrcObjNotGroupOrUser 8538
#define kNtErrorDsSrcSidExistsInForest 8539
#define kNtErrorDsSrcAndDstObjectClassMismatch 8540
#define kNtErrorSamInitFailure 8541
#define kNtErrorDsDraSchemaInfoShip 8542
#define kNtErrorDsDraSchemaConflict 8543
#define kNtErrorDsDraEarlierSchemaConflict 8544
#define kNtErrorDsDraObjNcMismatch 8545
#define kNtErrorDsNcStillHasDsas 8546
#define kNtErrorDsGcRequired 8547
#define kNtErrorDsLocalMemberOfLocalOnly 8548
#define kNtErrorDsNoFpoInUniversalGroups 8549
#define kNtErrorDsCantAddToGc 8550
#define kNtErrorDsNoCheckpointWithPdc 8551
#define kNtErrorDsSourceAuditingNotEnabled 8552
#define kNtErrorDsCantCreateInNondomainNc 8553
#define kNtErrorDsInvalidNameForSpn 8554
#define kNtErrorDsFilterUsesContructedAttrs 8555
#define kNtErrorDsUnicodepwdNotInQuotes 8556
#define kNtErrorDsMachineAccountQuotaExceeded 8557
#define kNtErrorDsMustBeRunOnDstDc 8558
#define kNtErrorDsSrcDcMustBeSp4OrGreater 8559
#define kNtErrorDsCantTreeDeleteCriticalObj 8560
#define kNtErrorDsInitFailureConsole 8561
#define kNtErrorDsSamInitFailureConsole 8562
#define kNtErrorDsForestVersionTooHigh 8563
#define kNtErrorDsDomainVersionTooHigh 8564
#define kNtErrorDsForestVersionTooLow 8565
#define kNtErrorDsDomainVersionTooLow 8566
#define kNtErrorDsIncompatibleVersion 8567
#define kNtErrorDsLowDsaVersion 8568
#define kNtErrorDsNoBehaviorVersionInMixeddomain 8569
#define kNtErrorDsNotSupportedSortOrder 8570
#define kNtErrorDsNameNotUnique 8571
#define kNtErrorDsMachineAccountCreatedPrent4 8572
#define kNtErrorDsOutOfVersionStore 8573
#define kNtErrorDsIncompatibleControlsUsed 8574
#define kNtErrorDsNoRefDomain 8575
#define kNtErrorDsReservedLinkId 8576
#define kNtErrorDsLinkIdNotAvailable 8577
#define kNtErrorDsAgCantHaveUniversalMember 8578
#define kNtErrorDsModifydnDisallowedByInstanceType 8579
#define kNtErrorDsNoObjectMoveInSchemaNc 8580
#define kNtErrorDsModifydnDisallowedByFlag 8581
#define kNtErrorDsModifydnWrongGrandparent 8582
#define kNtErrorDsNameErrorTrustReferral 8583
#define kNtErrorNotSupportedOnStandardServer 8584
#define kNtErrorDsCantAccessRemotePartOfAd 8585
#define kNtErrorDsCrImpossibleToValidateV2 8586
#define kNtErrorDsThreadLimitExceeded 8587
#define kNtErrorDsNotClosest 8588
#define kNtErrorDsCantDeriveSpnWithoutServerRef 8589
#define kNtErrorDsSingleUserModeFailed 8590
#define kNtErrorDsNtdscriptSyntaxError 8591
#define kNtErrorDsNtdscriptProcessError 8592
#define kNtErrorDsDifferentReplEpochs 8593
#define kNtErrorDsDrsExtensionsChanged 8594
#define kNtErrorDsReplicaSetChangeNotAllowedOnDisabledCr 8595
#define kNtErrorDsNoMsdsIntid 8596
#define kNtErrorDsDupMsdsIntid 8597
#define kNtErrorDsExistsInRdnattid 8598
#define kNtErrorDsAuthorizationFailed 8599
#define kNtErrorDsInvalidScript 8600
#define kNtErrorDsRemoteCrossrefOpFailed 8601
#define kNtErrorDsCrossRefBusy 8602
#define kNtErrorDsCantDeriveSpnForDeletedDomain 8603
#define kNtErrorDsCantDemoteWithWriteableNc 8604
#define kNtErrorDsDuplicateIdFound 8605
#define kNtErrorDsInsufficientAttrToCreateObject 8606
#define kNtErrorDsGroupConversionError 8607
#define kNtErrorDsCantMoveAppBasicGroup 8608
#define kNtErrorDsCantMoveAppQueryGroup 8609
#define kNtErrorDsRoleNotVerified 8610
#define kNtErrorDsWkoContainerCannotBeSpecial 8611
#define kNtErrorDsDomainRenameInProgress 8612
#define kNtErrorDsExistingAdChildNc 8613
#define kNtErrorDsReplLifetimeExceeded 8614
#define kNtErrorDsDisallowedInSystemContainer 8615
#define kNtErrorDsLdapSendQueueFull 8616
#define kNtErrorDsDraOutScheduleWindow 8617
#define kNtErrorDsPolicyNotKnown 8618
#define kNtErrorNoSiteSettingsObject 8619
#define kNtErrorNoSecrets 8620
#define kNtErrorNoWritableDcFound 8621
#define kNtErrorDsNoServerObject 8622
#define kNtErrorDsNoNtdsaObject 8623
#define kNtErrorDsNonAsqSearch 8624
#define kNtErrorDsAuditFailure 8625
#define kNtErrorDsInvalidSearchFlagSubtree 8626
#define kNtErrorDsInvalidSearchFlagTuple 8627
#define kNtErrorDsHierarchyTableTooDeep 8628
#define kNtErrorDsDraCorruptUtdVector 8629
#define kNtErrorDsDraSecretsDenied 8630
#define kNtErrorDsReservedMapiId 8631
#define kNtErrorDsMapiIdNotAvailable 8632
#define kNtErrorDsDraMissingKrbtgtSecret 8633
#define kNtErrorDsDomainNameExistsInForest 8634
#define kNtErrorDsFlatNameExistsInForest 8635
#define kNtErrorInvalidUserPrincipalName 8636
#define kNtErrorDsOidMappedGroupCantHaveMembers 8637
#define kNtErrorDsOidNotFound 8638
#define kNtErrorDsDraRecycledTarget 8639
#define kNtErrorDsDisallowedNcRedirect 8640
#define kNtErrorDsHighAdldsFfl 8641
#define kNtErrorDsHighDsaVersion 8642
#define kNtErrorDsLowAdldsFfl 8643
#define kNtErrorDomainSidSameAsLocalWorkstation 8644
#define kNtErrorDsUndeleteSamValidationFailed 8645
#define kNtErrorIncorrectAccountType 8646
#define kNtErrorDsSpnValueNotUniqueInForest 8647
#define kNtErrorDsUpnValueNotUniqueInForest 8648
#define kNtErrorDsMissingForestTrust 8649
#define kNtErrorDsValueKeyNotUnique 8650
#define kNtErrorIpsecQmPolicyExists 13000
#define kNtErrorIpsecQmPolicyNotFound 13001
#define kNtErrorIpsecQmPolicyInUse 13002
#define kNtErrorIpsecMmPolicyExists 13003
#define kNtErrorIpsecMmPolicyNotFound 13004
#define kNtErrorIpsecMmPolicyInUse 13005
#define kNtErrorIpsecMmFilterExists 13006
#define kNtErrorIpsecMmFilterNotFound 13007
#define kNtErrorIpsecTransportFilterExists 13008
#define kNtErrorIpsecTransportFilterNotFound 13009
#define kNtErrorIpsecMmAuthExists 13010
#define kNtErrorIpsecMmAuthNotFound 13011
#define kNtErrorIpsecMmAuthInUse 13012
#define kNtErrorIpsecDefaultMmPolicyNotFound 13013
#define kNtErrorIpsecDefaultMmAuthNotFound 13014
#define kNtErrorIpsecDefaultQmPolicyNotFound 13015
#define kNtErrorIpsecTunnelFilterExists 13016
#define kNtErrorIpsecTunnelFilterNotFound 13017
#define kNtErrorIpsecMmFilterPendingDeletion 13018
#define kNtErrorIpsecTransportFilterPendingDeletion 13019
#define kNtErrorIpsecTunnelFilterPendingDeletion 13020
#define kNtErrorIpsecMmPolicyPendingDeletion 13021
#define kNtErrorIpsecMmAuthPendingDeletion 13022
#define kNtErrorIpsecQmPolicyPendingDeletion 13023
#define kNtErrorIpsecIkeNegStatusBegin 13800
#define kNtErrorIpsecIkeAuthFail 13801
#define kNtErrorIpsecIkeAttribFail 13802
#define kNtErrorIpsecIkeNegotiationPending 13803
#define kNtErrorIpsecIkeGeneralProcessingError 13804
#define kNtErrorIpsecIkeTimedOut 13805
#define kNtErrorIpsecIkeNoCert 13806
#define kNtErrorIpsecIkeSaDeleted 13807
#define kNtErrorIpsecIkeSaReaped 13808
#define kNtErrorIpsecIkeMmAcquireDrop 13809
#define kNtErrorIpsecIkeQmAcquireDrop 13810
#define kNtErrorIpsecIkeQueueDropMm 13811
#define kNtErrorIpsecIkeQueueDropNoMm 13812
#define kNtErrorIpsecIkeDropNoResponse 13813
#define kNtErrorIpsecIkeMmDelayDrop 13814
#define kNtErrorIpsecIkeQmDelayDrop 13815
#define kNtErrorIpsecIkeError 13816
#define kNtErrorIpsecIkeCrlFailed 13817
#define kNtErrorIpsecIkeInvalidKeyUsage 13818
#define kNtErrorIpsecIkeInvalidCertType 13819
#define kNtErrorIpsecIkeNoPrivateKey 13820
#define kNtErrorIpsecIkeSimultaneousRekey 13821
#define kNtErrorIpsecIkeDhFail 13822
#define kNtErrorIpsecIkeCriticalPayloadNotRecognized 13823
#define kNtErrorIpsecIkeInvalidHeader 13824
#define kNtErrorIpsecIkeNoPolicy 13825
#define kNtErrorIpsecIkeInvalidSignature 13826
#define kNtErrorIpsecIkeKerberosError 13827
#define kNtErrorIpsecIkeNoPublicKey 13828
#define kNtErrorIpsecIkeProcessErr 13829
#define kNtErrorIpsecIkeProcessErrSa 13830
#define kNtErrorIpsecIkeProcessErrProp 13831
#define kNtErrorIpsecIkeProcessErrTrans 13832
#define kNtErrorIpsecIkeProcessErrKe 13833
#define kNtErrorIpsecIkeProcessErrId 13834
#define kNtErrorIpsecIkeProcessErrCert 13835
#define kNtErrorIpsecIkeProcessErrCertReq 13836
#define kNtErrorIpsecIkeProcessErrHash 13837
#define kNtErrorIpsecIkeProcessErrSig 13838
#define kNtErrorIpsecIkeProcessErrNonce 13839
#define kNtErrorIpsecIkeProcessErrNotify 13840
#define kNtErrorIpsecIkeProcessErrDelete 13841
#define kNtErrorIpsecIkeProcessErrVendor 13842
#define kNtErrorIpsecIkeInvalidPayload 13843
#define kNtErrorIpsecIkeLoadSoftSa 13844
#define kNtErrorIpsecIkeSoftSaTornDown 13845
#define kNtErrorIpsecIkeInvalidCookie 13846
#define kNtErrorIpsecIkeNoPeerCert 13847
#define kNtErrorIpsecIkePeerCrlFailed 13848
#define kNtErrorIpsecIkePolicyChange 13849
#define kNtErrorIpsecIkeNoMmPolicy 13850
#define kNtErrorIpsecIkeNotcbpriv 13851
#define kNtErrorIpsecIkeSecloadfail 13852
#define kNtErrorIpsecIkeFailsspinit 13853
#define kNtErrorIpsecIkeFailqueryssp 13854
#define kNtErrorIpsecIkeSrvacqfail 13855
#define kNtErrorIpsecIkeSrvquerycred 13856
#define kNtErrorIpsecIkeGetspifail 13857
#define kNtErrorIpsecIkeInvalidFilter 13858
#define kNtErrorIpsecIkeOutOfMemory 13859
#define kNtErrorIpsecIkeAddUpdateKeyFailed 13860
#define kNtErrorIpsecIkeInvalidPolicy 13861
#define kNtErrorIpsecIkeUnknownDoi 13862
#define kNtErrorIpsecIkeInvalidSituation 13863
#define kNtErrorIpsecIkeDhFailure 13864
#define kNtErrorIpsecIkeInvalidGroup 13865
#define kNtErrorIpsecIkeEncrypt 13866
#define kNtErrorIpsecIkeDecrypt 13867
#define kNtErrorIpsecIkePolicyMatch 13868
#define kNtErrorIpsecIkeUnsupportedId 13869
#define kNtErrorIpsecIkeInvalidHash 13870
#define kNtErrorIpsecIkeInvalidHashAlg 13871
#define kNtErrorIpsecIkeInvalidHashSize 13872
#define kNtErrorIpsecIkeInvalidEncryptAlg 13873
#define kNtErrorIpsecIkeInvalidAuthAlg 13874
#define kNtErrorIpsecIkeInvalidSig 13875
#define kNtErrorIpsecIkeLoadFailed 13876
#define kNtErrorIpsecIkeRpcDelete 13877
#define kNtErrorIpsecIkeBenignReinit 13878
#define kNtErrorIpsecIkeInvalidResponderLifetimeNotify 13879
#define kNtErrorIpsecIkeInvalidMajorVersion 13880
#define kNtErrorIpsecIkeInvalidCertKeylen 13881
#define kNtErrorIpsecIkeMmLimit 13882
#define kNtErrorIpsecIkeNegotiationDisabled 13883
#define kNtErrorIpsecIkeQmLimit 13884
#define kNtErrorIpsecIkeMmExpired 13885
#define kNtErrorIpsecIkePeerMmAssumedInvalid 13886
#define kNtErrorIpsecIkeCertChainPolicyMismatch 13887
#define kNtErrorIpsecIkeUnexpectedMessageId 13888
#define kNtErrorIpsecIkeInvalidAuthPayload 13889
#define kNtErrorIpsecIkeDosCookieSent 13890
#define kNtErrorIpsecIkeShuttingDown 13891
#define kNtErrorIpsecIkeCgaAuthFailed 13892
#define kNtErrorIpsecIkeProcessErrNatoa 13893
#define kNtErrorIpsecIkeInvalidMmForQm 13894
#define kNtErrorIpsecIkeQmExpired 13895
#define kNtErrorIpsecIkeTooManyFilters 13896
#define kNtErrorIpsecIkeNegStatusEnd 13897
#define kNtErrorIpsecIkeKillDummyNapTunnel 13898
#define kNtErrorIpsecIkeInnerIpAssignmentFailure 13899
#define kNtErrorIpsecIkeRequireCpPayloadMissing 13900
#define kNtErrorIpsecKeyModuleImpersonationNegotiationPending 13901
#define kNtErrorIpsecIkeCoexistenceSuppress 13902
#define kNtErrorIpsecIkeRatelimitDrop 13903
#define kNtErrorIpsecIkePeerDoesntSupportMobike 13904
#define kNtErrorIpsecIkeAuthorizationFailure 13905
#define kNtErrorIpsecIkeStrongCredAuthorizationFailure 13906
#define kNtErrorIpsecIkeAuthorizationFailureWithOptionalRetry 13907
#define kNtErrorIpsecIkeStrongCredAuthorizationAndCertmapFailure 13908
#define kNtErrorIpsecIkeNegStatusExtendedEnd 13909
#define kNtErrorIpsecBadSpi 13910
#define kNtErrorIpsecSaLifetimeExpired 13911
#define kNtErrorIpsecWrongSa 13912
#define kNtErrorIpsecReplayCheckFailed 13913
#define kNtErrorIpsecInvalidPacket 13914
#define kNtErrorIpsecIntegrityCheckFailed 13915
#define kNtErrorIpsecClearTextDrop 13916
#define kNtErrorIpsecAuthFirewallDrop 13917
#define kNtErrorIpsecThrottleDrop 13918
#define kNtErrorIpsecDospBlock 13925
#define kNtErrorIpsecDospReceivedMulticast 13926
#define kNtErrorIpsecDospInvalidPacket 13927
#define kNtErrorIpsecDospStateLookupFailed 13928
#define kNtErrorIpsecDospMaxEntries 13929
#define kNtErrorIpsecDospKeymodNotAllowed 13930
#define kNtErrorIpsecDospNotInstalled 13931
#define kNtErrorIpsecDospMaxPerIpRatelimitQueues 13932
#define kNtErrorSxsSectionNotFound 14000
#define kNtErrorSxsCantGenActctx 14001
#define kNtErrorSxsInvalidActctxdataFormat 14002
#define kNtErrorSxsAssemblyNotFound 14003
#define kNtErrorSxsManifestFormatError 14004
#define kNtErrorSxsManifestParseError 14005
#define kNtErrorSxsActivationContextDisabled 14006
#define kNtErrorSxsKeyNotFound 14007
#define kNtErrorSxsVersionConflict 14008
#define kNtErrorSxsWrongSectionType 14009
#define kNtErrorSxsThreadQueriesDisabled 14010
#define kNtErrorSxsProcessDefaultAlreadySet 14011
#define kNtErrorSxsUnknownEncodingGroup 14012
#define kNtErrorSxsUnknownEncoding 14013
#define kNtErrorSxsInvalidXmlNamespaceUri 14014
#define kNtErrorSxsRootManifestDependencyNotInstalled 14015
#define kNtErrorSxsLeafManifestDependencyNotInstalled 14016
#define kNtErrorSxsInvalidAssemblyIdentityAttribute 14017
#define kNtErrorSxsManifestMissingRequiredDefaultNamespace 14018
#define kNtErrorSxsManifestInvalidRequiredDefaultNamespace 14019
#define kNtErrorSxsPrivateManifestCrossPathWithReparsePoint 14020
#define kNtErrorSxsDuplicateDllName 14021
#define kNtErrorSxsDuplicateWindowclassName 14022
#define kNtErrorSxsDuplicateClsid 14023
#define kNtErrorSxsDuplicateIid 14024
#define kNtErrorSxsDuplicateTlbid 14025
#define kNtErrorSxsDuplicateProgid 14026
#define kNtErrorSxsDuplicateAssemblyName 14027
#define kNtErrorSxsFileHashMismatch 14028
#define kNtErrorSxsPolicyParseError 14029
#define kNtErrorSxsXmlEMissingquote 14030
#define kNtErrorSxsXmlECommentsyntax 14031
#define kNtErrorSxsXmlEBadstartnamechar 14032
#define kNtErrorSxsXmlEBadnamechar 14033
#define kNtErrorSxsXmlEBadcharinstring 14034
#define kNtErrorSxsXmlEXmldeclsyntax 14035
#define kNtErrorSxsXmlEBadchardata 14036
#define kNtErrorSxsXmlEMissingwhitespace 14037
#define kNtErrorSxsXmlEExpectingtagend 14038
#define kNtErrorSxsXmlEMissingsemicolon 14039
#define kNtErrorSxsXmlEUnbalancedparen 14040
#define kNtErrorSxsXmlEInternalerror 14041
#define kNtErrorSxsXmlEUnexpectedWhitespace 14042
#define kNtErrorSxsXmlEIncompleteEncoding 14043
#define kNtErrorSxsXmlEMissingParen 14044
#define kNtErrorSxsXmlEExpectingclosequote 14045
#define kNtErrorSxsXmlEMultipleColons 14046
#define kNtErrorSxsXmlEInvalidDecimal 14047
#define kNtErrorSxsXmlEInvalidHexidecimal 14048
#define kNtErrorSxsXmlEInvalidUnicode 14049
#define kNtErrorSxsXmlEWhitespaceorquestionmark 14050
#define kNtErrorSxsXmlEUnexpectedendtag 14051
#define kNtErrorSxsXmlEUnclosedtag 14052
#define kNtErrorSxsXmlEDuplicateattribute 14053
#define kNtErrorSxsXmlEMultipleroots 14054
#define kNtErrorSxsXmlEInvalidatrootlevel 14055
#define kNtErrorSxsXmlEBadxmldecl 14056
#define kNtErrorSxsXmlEMissingroot 14057
#define kNtErrorSxsXmlEUnexpectedeof 14058
#define kNtErrorSxsXmlEBadperefinsubset 14059
#define kNtErrorSxsXmlEUnclosedstarttag 14060
#define kNtErrorSxsXmlEUnclosedendtag 14061
#define kNtErrorSxsXmlEUnclosedstring 14062
#define kNtErrorSxsXmlEUnclosedcomment 14063
#define kNtErrorSxsXmlEUncloseddecl 14064
#define kNtErrorSxsXmlEUnclosedcdata 14065
#define kNtErrorSxsXmlEReservednamespace 14066
#define kNtErrorSxsXmlEInvalidencoding 14067
#define kNtErrorSxsXmlEInvalidswitch 14068
#define kNtErrorSxsXmlEBadxmlcase 14069
#define kNtErrorSxsXmlEInvalidStandalone 14070
#define kNtErrorSxsXmlEUnexpectedStandalone 14071
#define kNtErrorSxsXmlEInvalidVersion 14072
#define kNtErrorSxsXmlEMissingequals 14073
#define kNtErrorSxsProtectionRecoveryFailed 14074
#define kNtErrorSxsProtectionPublicKeyTooShort 14075
#define kNtErrorSxsProtectionCatalogNotValid 14076
#define kNtErrorSxsUntranslatableHresult 14077
#define kNtErrorSxsProtectionCatalogFileMissing 14078
#define kNtErrorSxsMissingAssemblyIdentityAttribute 14079
#define kNtErrorSxsInvalidAssemblyIdentityAttributeName 14080
#define kNtErrorSxsAssemblyMissing 14081
#define kNtErrorSxsCorruptActivationStack 14082
#define kNtErrorSxsCorruption 14083
#define kNtErrorSxsEarlyDeactivation 14084
#define kNtErrorSxsInvalidDeactivation 14085
#define kNtErrorSxsMultipleDeactivation 14086
#define kNtErrorSxsProcessTerminationRequested 14087
#define kNtErrorSxsReleaseActivationContext 14088
#define kNtErrorSxsSystemDefaultActivationContextEmpty 14089
#define kNtErrorSxsInvalidIdentityAttributeValue 14090
#define kNtErrorSxsInvalidIdentityAttributeName 14091
#define kNtErrorSxsIdentityDuplicateAttribute 14092
#define kNtErrorSxsIdentityParseError 14093
#define kNtErrorMalformedSubstitutionString 14094
#define kNtErrorSxsIncorrectPublicKeyToken 14095
#define kNtErrorUnmappedSubstitutionString 14096
#define kNtErrorSxsAssemblyNotLocked 14097
#define kNtErrorSxsComponentStoreCorrupt 14098
#define kNtErrorAdvancedInstallerFailed 14099
#define kNtErrorXmlEncodingMismatch 14100
#define kNtErrorSxsManifestIdentitySameButContentsDifferent 14101
#define kNtErrorSxsIdentitiesDifferent 14102
#define kNtErrorSxsAssemblyIsNotADeployment 14103
#define kNtErrorSxsFileNotPartOfAssembly 14104
#define kNtErrorSxsManifestTooBig 14105
#define kNtErrorSxsSettingNotRegistered 14106
#define kNtErrorSxsTransactionClosureIncomplete 14107
#define kNtErrorSmiPrimitiveInstallerFailed 14108
#define kNtErrorGenericCommandFailed 14109
#define kNtErrorSxsFileHashMissing 14110
#define kNtErrorEvtInvalidChannelPath 15000
#define kNtErrorEvtInvalidQuery 15001
#define kNtErrorEvtPublisherMetadataNotFound 15002
#define kNtErrorEvtEventTemplateNotFound 15003
#define kNtErrorEvtInvalidPublisherName 15004
#define kNtErrorEvtInvalidEventData 15005
#define kNtErrorEvtChannelNotFound 15007
#define kNtErrorEvtMalformedXmlText 15008
#define kNtErrorEvtSubscriptionToDirectChannel 15009
#define kNtErrorEvtConfigurationError 15010
#define kNtErrorEvtQueryResultStale 15011
#define kNtErrorEvtQueryResultInvalidPosition 15012
#define kNtErrorEvtNonValidatingMsxml 15013
#define kNtErrorEvtFilterAlreadyscoped 15014
#define kNtErrorEvtFilterNoteltset 15015
#define kNtErrorEvtFilterInvarg 15016
#define kNtErrorEvtFilterInvtest 15017
#define kNtErrorEvtFilterInvtype 15018
#define kNtErrorEvtFilterParseerr 15019
#define kNtErrorEvtFilterUnsupportedop 15020
#define kNtErrorEvtFilterUnexpectedtoken 15021
#define kNtErrorEvtInvalidOperationOverEnabledDirectChannel 15022
#define kNtErrorEvtInvalidChannelPropertyValue 15023
#define kNtErrorEvtInvalidPublisherPropertyValue 15024
#define kNtErrorEvtChannelCannotActivate 15025
#define kNtErrorEvtFilterTooComplex 15026
#define kNtErrorEvtMessageNotFound 15027
#define kNtErrorEvtMessageIdNotFound 15028
#define kNtErrorEvtUnresolvedValueInsert 15029
#define kNtErrorEvtUnresolvedParameterInsert 15030
#define kNtErrorEvtMaxInsertsReached 15031
#define kNtErrorEvtEventDefinitionNotFound 15032
#define kNtErrorEvtMessageLocaleNotFound 15033
#define kNtErrorEvtVersionTooOld 15034
#define kNtErrorEvtVersionTooNew 15035
#define kNtErrorEvtCannotOpenChannelOfQuery 15036
#define kNtErrorEvtPublisherDisabled 15037
#define kNtErrorEvtFilterOutOfRange 15038
#define kNtErrorEcSubscriptionCannotActivate 15080
#define kNtErrorEcLogDisabled 15081
#define kNtErrorEcCircularForwarding 15082
#define kNtErrorEcCredstoreFull 15083
#define kNtErrorEcCredNotFound 15084
#define kNtErrorEcNoActiveChannel 15085
#define kNtErrorMuiFileNotFound 15100
#define kNtErrorMuiInvalidFile 15101
#define kNtErrorMuiInvalidRcConfig 15102
#define kNtErrorMuiInvalidLocaleName 15103
#define kNtErrorMuiInvalidUltimatefallbackName 15104
#define kNtErrorMuiFileNotLoaded 15105
#define kNtErrorResourceEnumUserStop 15106
#define kNtErrorMuiIntlsettingsUilangNotInstalled 15107
#define kNtErrorMuiIntlsettingsInvalidLocaleName 15108
#define kNtErrorMrmRuntimeNoDefaultOrNeutralResource 15110
#define kNtErrorMrmInvalidPriconfig 15111
#define kNtErrorMrmInvalidFileType 15112
#define kNtErrorMrmUnknownQualifier 15113
#define kNtErrorMrmInvalidQualifierValue 15114
#define kNtErrorMrmNoCandidate 15115
#define kNtErrorMrmNoMatchOrDefaultCandidate 15116
#define kNtErrorMrmResourceTypeMismatch 15117
#define kNtErrorMrmDuplicateMapName 15118
#define kNtErrorMrmDuplicateEntry 15119
#define kNtErrorMrmInvalidResourceIdentifier 15120
#define kNtErrorMrmFilepathTooLong 15121
#define kNtErrorMrmUnsupportedDirectoryType 15122
#define kNtErrorMrmInvalidPriFile 15126
#define kNtErrorMrmNamedResourceNotFound 15127
#define kNtErrorMrmMapNotFound 15135
#define kNtErrorMrmUnsupportedProfileType 15136
#define kNtErrorMrmInvalidQualifierOperator 15137
#define kNtErrorMrmIndeterminateQualifierValue 15138
#define kNtErrorMrmAutomergeEnabled 15139
#define kNtErrorMrmTooManyResources 15140
#define kNtErrorMrmUnsupportedFileTypeForMerge 15141
#define kNtErrorMrmUnsupportedFileTypeForLoadUnloadPriFile 15142
#define kNtErrorMrmNoCurrentViewOnThread 15143
#define kNtErrorDifferentProfileResourceManagerExist 15144
#define kNtErrorOperationNotAllowedFromSystemComponent 15145
#define kNtErrorMrmDirectRefToNonDefaultResource 15146
#define kNtErrorMrmGenerationCountMismatch 15147
#define kNtErrorPriMergeVersionMismatch 15148
#define kNtErrorPriMergeMissingSchema 15149
#define kNtErrorPriMergeLoadFileFailed 15150
#define kNtErrorPriMergeAddFileFailed 15151
#define kNtErrorPriMergeWriteFileFailed 15152
#define kNtErrorPriMergeMultiplePackageFamiliesNotAllowed 15153
#define kNtErrorPriMergeMultipleMainPackagesNotAllowed 15154
#define kNtErrorPriMergeBundlePackagesNotAllowed 15155
#define kNtErrorPriMergeMainPackageRequired 15156
#define kNtErrorPriMergeResourcePackageRequired 15157
#define kNtErrorPriMergeInvalidFileName 15158
#define kNtErrorMcaInvalidCapabilitiesString 15200
#define kNtErrorMcaInvalidVcpVersion 15201
#define kNtErrorMcaMonitorViolatesMccsSpecification 15202
#define kNtErrorMcaMccsVersionMismatch 15203
#define kNtErrorMcaUnsupportedMccsVersion 15204
#define kNtErrorMcaInternalError 15205
#define kNtErrorMcaInvalidTechnologyTypeReturned 15206
#define kNtErrorMcaUnsupportedColorTemperature 15207
#define kNtErrorAmbiguousSystemDevice 15250
#define kNtErrorSystemDeviceNotFound 15299
#define kNtErrorHashNotSupported 15300
#define kNtErrorHashNotPresent 15301
#define kNtErrorSecondaryIcProviderNotRegistered 15321
#define kNtErrorGpioClientInformationInvalid 15322
#define kNtErrorGpioVersionNotSupported 15323
#define kNtErrorGpioInvalidRegistrationPacket 15324
#define kNtErrorGpioOperationDenied 15325
#define kNtErrorGpioIncompatibleConnectMode 15326
#define kNtErrorGpioInterruptAlreadyUnmasked 15327
#define kNtErrorCannotSwitchRunlevel 15400
#define kNtErrorInvalidRunlevelSetting 15401
#define kNtErrorRunlevelSwitchTimeout 15402
#define kNtErrorRunlevelSwitchAgentTimeout 15403
#define kNtErrorRunlevelSwitchInProgress 15404
#define kNtErrorServicesFailedAutostart 15405
#define kNtErrorComTaskStopPending 15501
#define kNtErrorInstallOpenPackageFailed 15600
#define kNtErrorInstallPackageNotFound 15601
#define kNtErrorInstallInvalidPackage 15602
#define kNtErrorInstallResolveDependencyFailed 15603
#define kNtErrorInstallOutOfDiskSpace 15604
#define kNtErrorInstallNetworkFailure 15605
#define kNtErrorInstallRegistrationFailure 15606
#define kNtErrorInstallDeregistrationFailure 15607
#define kNtErrorInstallCancel 15608
#define kNtErrorInstallFailed 15609
#define kNtErrorRemoveFailed 15610
#define kNtErrorPackageAlreadyExists 15611
#define kNtErrorNeedsRemediation 15612
#define kNtErrorInstallPrerequisiteFailed 15613
#define kNtErrorPackageRepositoryCorrupted 15614
#define kNtErrorInstallPolicyFailure 15615
#define kNtErrorPackageUpdating 15616
#define kNtErrorDeploymentBlockedByPolicy 15617
#define kNtErrorPackagesInUse 15618
#define kNtErrorRecoveryFileCorrupt 15619
#define kNtErrorInvalidStagedSignature 15620
#define kNtErrorDeletingExistingApplicationdataStoreFailed 15621
#define kNtErrorInstallPackageDowngrade 15622
#define kNtErrorSystemNeedsRemediation 15623
#define kNtErrorAppxIntegrityFailureClrNgen 15624
#define kNtErrorResiliencyFileCorrupt 15625
#define kNtErrorInstallFirewallServiceNotRunning 15626
#define kNtErrorPackageMoveFailed 15627
#define kNtErrorInstallVolumeNotEmpty 15628
#define kNtErrorInstallVolumeOffline 15629
#define kNtErrorInstallVolumeCorrupt 15630
#define kNtErrorNeedsRegistration 15631
#define kNtErrorInstallWrongProcessorArchitecture 15632
#define kNtErrorDevSideloadLimitExceeded 15633
#define kNtErrorInstallOptionalPackageRequiresMainPackage 15634
#define kNtErrorPackageNotSupportedOnFilesystem 15635
#define kNtErrorPackageMoveBlockedByStreaming 15636
#define kNtErrorInstallOptionalPackageApplicationidNotUnique 15637
#define kNtErrorPackageStagingOnhold 15638
#define kNtErrorInstallInvalidRelatedSetUpdate 15639
#define kNtErrorPackagesReputationCheckFailed 15643
#define kNtErrorPackagesReputationCheckTimedout 15644
#define kNtErrorStateLoadStoreFailed 15800
#define kNtErrorStateGetVersionFailed 15801
#define kNtErrorStateSetVersionFailed 15802
#define kNtErrorStateStructuredResetFailed 15803
#define kNtErrorStateOpenContainerFailed 15804
#define kNtErrorStateCreateContainerFailed 15805
#define kNtErrorStateDeleteContainerFailed 15806
#define kNtErrorStateReadSettingFailed 15807
#define kNtErrorStateWriteSettingFailed 15808
#define kNtErrorStateDeleteSettingFailed 15809
#define kNtErrorStateQuerySettingFailed 15810
#define kNtErrorStateReadCompositeSettingFailed 15811
#define kNtErrorStateWriteCompositeSettingFailed 15812
#define kNtErrorStateEnumerateContainerFailed 15813
#define kNtErrorStateEnumerateSettingsFailed 15814
#define kNtErrorStateCompositeSettingValueSizeLimitExceeded 15815
#define kNtErrorStateSettingValueSizeLimitExceeded 15816
#define kNtErrorStateSettingNameSizeLimitExceeded 15817
#define kNtErrorStateContainerNameSizeLimitExceeded 15818
#define kNtErrorApiUnavailable 15841

#define kNtWaitIoCompletion 0xc0

/* WinSock Error Codes: 10000-11999 */
#define WSABASEERR 10000
#define WSAEINTR 10004
#define WSAEBADF 10009
#define WSAEACCES 10013
#define WSAEFAULT 10014
#define WSAEINVAL 10022
#define WSAEMFILE 10024
#define WSAEWOULDBLOCK 10035
#define WSAEINPROGRESS 10036
#define WSAEALREADY 10037
#define WSAENOTSOCK 10038
#define WSAEDESTADDRREQ 10039
#define WSAEMSGSIZE 10040
#define WSAEPROTOTYPE 10041
#define WSAENOPROTOOPT 10042
#define WSAEPROTONOSUPPORT 10043
#define WSAESOCKTNOSUPPORT 10044
#define WSAEOPNOTSUPP 10045
#define WSAEPFNOSUPPORT 10046
#define WSAEAFNOSUPPORT 10047
#define WSAEADDRINUSE 10048
#define WSAEADDRNOTAVAIL 10049
#define WSAENETDOWN 10050
#define WSAENETUNREACH 10051
#define WSAENETRESET 10052
#define WSAECONNABORTED 10053
#define WSAECONNRESET 10054
#define WSAENOBUFS 10055
#define WSAEISCONN 10056
#define WSAENOTCONN 10057
#define WSAESHUTDOWN 10058
#define WSAETOOMANYREFS 10059
#define WSAETIMEDOUT 10060
#define WSAECONNREFUSED 10061
#define WSAELOOP 10062
#define WSAENAMETOOLONG 10063
#define WSAEHOSTDOWN 10064
#define WSAEHOSTUNREACH 10065
#define WSAENOTEMPTY 10066
#define WSAEPROCLIM 10067
#define WSAEUSERS 10068
#define WSAEDQUOT 10069
#define WSAESTALE 10070
#define WSAEREMOTE 10071
#define WSASYSNOTREADY 10091
#define WSAVERNOTSUPPORTED 10092
#define WSANOTINITIALISED 10093
#define WSAEDISCON 10101
#define WSAENOMORE 10102
#define WSAECANCELLED 10103
#define WSAEINVALIDPROCTABLE 10104
#define WSAEINVALIDPROVIDER 10105
#define WSAEPROVIDERFAILEDINIT 10106
#define WSASYSCALLFAILURE 10107
#define WSASERVICE_NOT_FOUND 10108
#define WSATYPE_NOT_FOUND 10109
#define WSA_E_NO_MORE 10110
#define WSA_E_CANCELLED 10111
#define WSAEREFUSED 10112
#define WSAHOST_NOT_FOUND 11001
#define WSATRY_AGAIN 11002
#define WSANO_RECOVERY 11003
#define WSANO_DATA 11004
#define WSA_QOS_RECEIVERS 11005
#define WSA_QOS_SENDERS 11006
#define WSA_QOS_NO_SENDERS 11007
#define WSA_QOS_NO_RECEIVERS 11008
#define WSA_QOS_REQUEST_CONFIRMED 11009
#define WSA_QOS_ADMISSION_FAILURE 11010
#define WSA_QOS_POLICY_FAILURE 11011
#define WSA_QOS_BAD_STYLE 11012
#define WSA_QOS_BAD_OBJECT 11013
#define WSA_QOS_TRAFFIC_CTRL_ERROR 11014
#define WSA_QOS_GENERIC_ERROR 11015
#define WSA_QOS_ESERVICETYPE 11016
#define WSA_QOS_EFLOWSPEC 11017
#define WSA_QOS_EPROVSPECBUF 11018
#define WSA_QOS_EFILTERSTYLE 11019
#define WSA_QOS_EFILTERTYPE 11020
#define WSA_QOS_EFILTERCOUNT 11021
#define WSA_QOS_EOBJLENGTH 11022
#define WSA_QOS_EFLOWCOUNT 11023
#define WSA_QOS_EUNKOWNPSOBJ 11024
#define WSA_QOS_EPOLICYOBJ 11025
#define WSA_QOS_EFLOWDESC 11026
#define WSA_QOS_EPSFLOWSPEC 11027
#define WSA_QOS_EPSFILTERSPEC 11028
#define WSA_QOS_ESDMODEOBJ 11029
#define WSA_QOS_ESHAPERATEOBJ 11030
#define WSA_QOS_RESERVED_PETYPE 11031
#define WSA_SECURE_HOST_NOT_FOUND 11032
#define WSA_IPSEC_NAME_POLICY_ERROR 11033

#define WSA_WAIT_FAILED -1u
#define WSA_WAIT_EVENT_0 0
#define WSA_WAIT_IO_COMPLETION 0xc0
#define WSA_WAIT_TIMEOUT 258
#define WSA_MAXIMUM_WAIT_EVENTS 64
#define WSA_IO_PENDING 997


#define kNtWsaInvalidHandle    kNtErrorInvalidHandle
#define kNtWsaNotEnoughMemory  kNtErrorNotEnoughMemory
#define kNtWsaInvalidParameter kNtErrorInvalidParameter
#define kNtWsaIoPending        kNtErrorIoPending
#define kNtWsaIoIncomplete     kNtErrorIoIncomplete
#define kNtWsaOperationAborted kNtErrorOperationAborted



/*!BEGIN libc/nt/enum/wsaid.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WSAID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define WSAID_WSAPOLL                                \
  {                                                  \
    0x18C76F85, 0xDC66, 0x4964, {                    \
      0x97, 0x2E, 0x23, 0xC2, 0x72, 0x38, 0x31, 0x2B \
    }                                                \
  }

#define WSAID_WSARECVMSG                             \
  {                                                  \
    0xf689d7c8, 0x6f1f, 0x436b, {                    \
      0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22 \
    }                                                \
  }

#define WSAID_WSASENDMSG                             \
  {                                                  \
    0xa441e712, 0x754f, 0x43ca, {                    \
      0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d \
    }                                                \
  }

#define WSAID_CONNECTEX                              \
  {                                                  \
    0x25a207b9, 0xddf3, 0x4660, {                    \
      0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e \
    }                                                \
  }

#define WSAID_ACCEPTEX                               \
  {                                                  \
    0xb5367df1, 0xcbac, 0x11cf, {                    \
      0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 \
    }                                                \
  }

#define WSAID_GETACCEPTEXSOCKADDRS                   \
  {                                                  \
    0xb5367df2, 0xcbac, 0x11cf, {                    \
      0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 \
    }                                                \
  }

#define WSAID_TRANSMITFILE                           \
  {                                                  \
    0xb5367df0, 0xcbac, 0x11cf, {                    \
      0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 \
    }                                                \
  }

#define WSAID_TRANSMITPACKETS                        \
  {                                                  \
    0xd9689da0, 0x1f90, 0x11d3, {                    \
      0x99, 0x71, 0x00, 0xc0, 0x4f, 0x68, 0xc8, 0x76 \
    }                                                \
  }

#define WSAID_DISCONNECTEX                           \
  {                                                  \
    0x7fda2e11, 0x8630, 0x436f, {                    \
      0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57 \
    }                                                \
  }

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/wt.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WT_H_

#define kNtWtExecutedefault            0x00000000u
#define kNtWtExecuteonlyonce           0x00000008u
#define kNtWtExecuteintimerthread      0x00000020u
#define kNtWtExecuteinpersistentthread 0x00000080u
#define kNtWtExecutelongfunction       0x00000010u
#define kNtWtTransferImpersonation     0𝔵00000100𝔲



/*!BEGIN libc/nt/struct/afd.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_AFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtAfdPollHandleInfo {
  int64_t Handle;
  uint32_t Events;
  NtStatus Status;
};

struct NtAfdPollInfo {
  int64_t Timeout;
  uint32_t NumberOfHandles;
  uint32_t Exclusive;
  struct NtAfdPollHandleInfo Handles[1];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ansistring.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_ANSISTRING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtAnsiString {
  unsigned short Length;
  unsigned short MaximumLength;
  char *Buffer;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/byhandlefileinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_BYHANDLEFILEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtByHandleFileInformation {
  uint32_t dwFileAttributes; /* ←NtFileFlagAndAttributes */
  struct NtFileTime ftCreationFileTime;
  struct NtFileTime ftLastAccessFileTime;
  struct NtFileTime ftLastWriteFileTime;
  uint32_t dwVolumeSerialNumber;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
  uint32_t nNumberOfLinks;
  uint32_t nFileIndexHigh;
  uint32_t nFileIndexLow;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/charinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CHARINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCharInfo {
  union {
    char16_t UnicodeChar;
    char AsciiChar;
  } Char;
  uint16_t Attributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/clientid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CLIENTID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtClientId {
  void *UniqueProcess;
  void *UniqueThread;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolecursorinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLECURSORINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleCursorInfo {
  uint32_t dwSize;
  bool32 bVisible;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolescreenbufferinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESCREENBUFFERINFO_H_


/*!BEGIN libc/nt/struct/coord.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COORD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCoord {
  int16_t X;
  int16_t Y;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/smallrect.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SMALLRECT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSmallRect {
  int16_t Left;
  int16_t Top;
  int16_t Right;
  int16_t Bottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleScreenBufferInfo {
  struct NtCoord dwSize;
  struct NtCoord dwCursorPosition;
  uint16_t wAttributes;
  struct NtSmallRect srWindow;
  struct NtCoord dwMaximumWindowSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolescreenbufferinfoex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESCREENBUFFERINFOEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleScreenBufferInfoEx {
  uint32_t cbSize; /* sizeof(struct NtConsoleScreenBufferInfoEx) */
  struct NtCoord dwSize;
  struct NtCoord dwCursorPosition;
  uint16_t wAttributes; /* kNt{Foreground,Background}... */
  struct NtSmallRect srWindow;
  struct NtCoord dwMaximumWindowSize;
  uint16_t wPopupAttributes;
  bool32 bFullscreenSupported;
  uint32_t ColorTable[16]; /* 0x00BBGGRR */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consoleselectioninfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESELECTIONINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleSelectionInfo {
  uint32_t dwFlags;
  struct NtCoord dwSelectionAnchor;
  struct NtSmallRect srSelection;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/context.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONTEXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtM128A {
  uint64_t Low;
  int64_t High;
};

struct NtXmmSaveArea32 { /* basically same as struct FpuState */
  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr;
  uint32_t MxCsr_Mask;
  struct NtM128A FloatRegisters[8];
  struct NtM128A XmmRegisters[16];
  uint8_t Reserved4[96];
};

struct NtContext {
  uint64_t P1Home, P2Home, P3Home, P4Home, P5Home, P6Home;
  uint32_t ContextFlags;
  uint32_t MxCsr;
  uint16_t SegCs, SegDs, SegEs, SegFs, SegGs, SegSs;
  uint32_t EFlags;
  uint64_t Dr0, Dr1, Dr2, Dr3, Dr6, Dr7;
  uint64_t Rax, Rcx, Rdx, Rbx, Rsp, Rbp, Rsi, Rdi;
  uint64_t R8, R9, R10, R11, R12, R13, R14, R15;
  uint64_t Rip;
  union {
    struct NtXmmSaveArea32 FltSave;
    struct NtXmmSaveArea32 FloatSave;
    struct {
      struct NtM128A Header[2];
      struct NtM128A Legacy[8];
      struct NtM128A Xmm0, Xmm1, Xmm2, Xmm3, Xmm4, Xmm5, Xmm6, Xmm7;
      struct NtM128A Xmm8, Xmm9, Xmm10, Xmm11, Xmm12, Xmm13, Xmm14, Xmm15;
    };
  };
  struct NtM128A VectorRegister[26];
  uint64_t VectorControl;
  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/criticalsection.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CRITICALSECTION_H_


/*!BEGIN libc/nt/struct/criticalsectiondebug.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CRITICALSECTIONDEBUG_H_


/*!BEGIN libc/nt/struct/linkedlist.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LINKEDLIST_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Dynamic linked list overlay.
 */
struct NtLinkedList {
  struct NtLinkedList *Next;
  struct NtLinkedList *Prev;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCriticalSectionDebug {
  uint16_t Type;
  uint16_t CreatorBackTraceIndex;
  struct NtCriticalSection *CriticalSection;
  struct NtLinkedList ProcessLocksList;
  uint32_t EntryCount;
  uint32_t ContentionCount;
  uint32_t Spare[2];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCriticalSection {
  struct NtCriticalSectionDebug *DebugInfo;
  int32_t LockCount;
  int32_t RecursionCount;
  void *OwningThread;
  void *LockSemaphore;
  uintptr_t SpinCount;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/drawtextparams.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_DRAWTEXTPARAMS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtDrawTextParams {
  uint32_t cbSize;
  int32_t iTabLength;
  int32_t iLeftMargin;
  int32_t iRightMargin;
  uint32_t uiLengthDrawn;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/editmenu.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_EDITMENU_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtEditMenu {
  int64_t hmenu;
  uint16_t idEdit;
  uint16_t idCut;
  uint16_t idCopy;
  uint16_t idPaste;
  uint16_t idClear;
  uint16_t idUndo;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/exceptionframe.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_EXCEPTIONFRAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionFrame {
  struct NtExceptionFrame *Prev;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fdset.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FDSET_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtFdSet {
  uint32_t fd_count;
  int64_t fd_array[64];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileaccessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEACCESSINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAccessInformation {
  uint32_t AccessFlags;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filealignmentinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALIGNMENTINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAlignmentInformation {
  uint32_t AlignmentRequirement;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileallinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALLINFORMATION_H_


/*!BEGIN libc/nt/struct/filebasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileBasicInformation {
  int64_t CreationTime;    /* in 100ns units */
  int64_t LastAccessTime;  /* in 100ns units */
  int64_t LastWriteTime;   /* in 100ns units */
  int64_t ChangeTime;      /* in 100ns units */
  uint32_t FileAttributes; /* kNtFileAttributeXXX */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileeainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEEAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileEaInformation {
  uint32_t EaSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileinternalinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEINTERNALINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileInternalInformation {
  int64_t IndexNumber;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemodeinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMODEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileModeInformation {
  uint32_t Mode;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNameInformation {
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filepositioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEPOSITIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFilePositionInformation {
  int64_t CurrentByteOffset;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filestandardinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESTANDARDINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileStandardInformation {
  int64_t AllocationSize;
  int64_t EndOfFile;
  uint32_t NumberOfLinks;
  bool32 DeletePending;
  bool32 Directory;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAllInformation {
  struct NtFileBasicInformation BasicInformation;
  struct NtFileStandardInformation StandardInformation;
  struct NtFileInternalInformation InternalInformation;
  struct NtFileEaInformation EaInformation;
  struct NtFileAccessInformation AccessInformation;
  struct NtFilePositionInformation PositionInformation;
  struct NtFileModeInformation ModeInformation;
  struct NtFileAlignmentInformation AlignmentInformation;
  struct NtFileNameInformation NameInformation;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileallocationinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALLOCATIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAllocationInformation {
  int64_t AllocationSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileattributetaginformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEATTRIBUTETAGINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAttributeTagInformation {
  uint32_t FileAttributes;
  uint32_t ReparseTag;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filebasicinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBASICINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileBasicInfo {
  int64_t CreationTime;    /* in 100ns units */
  int64_t LastAccessTime;  /* in 100ns units */
  int64_t LastWriteTime;   /* in 100ns units */
  int64_t ChangeTime;      /* in 100ns units */
  uint32_t FileAttributes; /* kNtFileAttributeXXX */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filebothdirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBOTHDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtFileBothDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  uint32_t EaSize;
  unsigned char ShortNameLength;
  char16_t ShortName[12];
  char16_t FileName[1];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filecompressioninfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILECOMPRESSIONINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileCompressionInfo {
  int64_t CompressedFileSize;
  uint16_t CompressionFormat;
  uint8_t CompressionUnitShift;
  uint8_t ChunkShift;
  uint8_t ClusterShift;
  uint8_t Reserved[3];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filedirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filedispositioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEDISPOSITIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileDispositionInformation {
  bool32 DoDeleteFile;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileendoffileinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEENDOFFILEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FileEndOfFileInformation {
  int64_t EndOfFile;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filefulldirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEFULLDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileFullDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  uint32_t EaSize;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filefulleainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEFULLEAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileFullEaInformation {
  uint32_t NextEntryOffset;
  uint8_t Flags;
  uint8_t EaNameLength;
  uint16_t EaValueLength;
  char EaName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemailslotqueryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMAILSLOTQUERYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileMailslotQueryInformation {
  uint32_t MaximumMessageSize;
  uint32_t MailslotQuota;
  uint32_t NextMessageSize;
  uint32_t MessagesAvailable;
  int64_t ReadTimeout;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemailslotsetinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMAILSLOTSETINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileMailslotSetInformation {
  int64_t ReadTimeout;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenamesinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENAMESINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNamesInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenetworkopeninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENETWORKOPENINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNetworkOpenInformation {
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t AllocationSize;
  int64_t EndOfFile;
  uint32_t FileAttributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filepipelocalinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEPIPELOCALINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFilePipeLocalInformation {
  uint32_t NamedPipeType;
  uint32_t NamedPipeConfiguration;
  uint32_t MaximumInstances;
  uint32_t CurrentInstances;
  uint32_t InboundQuota;
  uint32_t ReadDataAvailable;
  uint32_t OutboundQuota;
  uint32_t WriteQuotaAvailable;
  uint32_t NamedPipeState;
  uint32_t NamedPipeEnd;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filerenameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILERENAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileRenameInformation {
  bool32 Replace;
  void *RootDir;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filesegmentelement.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESEGMENTELEMENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

union NtFileSegmentElement {
  void *Buffer;
  uint64_t Alignment;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filestreaminformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESTREAMINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileStreamInformation {
  uint32_t NextEntryOffset;
  uint32_t StreamNameLength;
  int64_t StreamSize;
  int64_t StreamAllocationSize;
  char16_t StreamName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filezerodatainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEZERODATAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileZeroDataInformation {
  uint64_t FileOffset;
  uint64_t BeyondFinalZero;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fpodata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FPODATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFpoData {
  /* TODO(jart): No bitfields. */
  uint32_t ulOffStart;
  uint32_t cbProcSize;
  uint32_t cdwLocals;
  uint16_t cdwParams;
  uint16_t cbProlog : 8;
  uint16_t cbRegs : 3;
  uint16_t fHasSEH : 1;
  uint16_t fUseBP : 1;
  uint16_t reserved : 1;
  uint16_t cbFrame : 2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/genericmapping.h */

#define COSMOPOLITAN_LIBC_NT_GENERICMAPPING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtGenericMapping {
  unsigned int GenericRead;
  unsigned int GenericWrite;
  unsigned int GenericExecute;
  unsigned int GenericAll;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/guid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_GUID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtGuid {
  uint32_t Data1;
  uint16_t Data2;
  uint16_t Data3;
  uint8_t Data4[8];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/inputrecord.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_INPUTRECORD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtKeyEventRecord {
  bool32 bKeyDown;
  uint16_t wRepeatCount;
  uint16_t wVirtualKeyCode;
  uint16_t wVirtualScanCode;
  union {
    int16_t UnicodeChar;
    char AsciiChar;
  } uChar;
  unsigned int dwControlKeyState;
};

struct NtMouseEventRecord {
  struct NtCoord dwMousePosition;
  uint32_t dwButtonState;
  uint32_t dwControlKeyState;
  uint32_t dwEventFlags;
};

struct NtWindowBufferSizeRecord {
  struct NtCoord dwSize;
};

struct NtMenuEventRecord {
  uint32_t dwCommandId;
};

struct NtFocusEventRecord {
  bool32 bSetFocus;
};

struct NtInputRecord {
  uint16_t EventType;
  union {
    struct NtKeyEventRecord KeyEvent;
    struct NtMouseEventRecord MouseEvent;
    struct NtWindowBufferSizeRecord WindowBufferSizeEvent;
    struct NtMenuEventRecord MenuEvent;
    struct NtFocusEventRecord FocusEvent;
  } Event;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/iocounters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IOCOUNTERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtIoCounters {
  uint64_t ReadOperationCount;
  uint64_t WriteOperationCount;
  uint64_t OtherOperationCount;
  uint64_t ReadTransferCount;
  uint64_t WriteTransferCount;
  uint64_t OtherTransferCount;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/iostatusblock.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IOSTATUSBLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtIoStatusBlock {
  union {
    NtStatus Status;
    void *Pointer; /* reserved for internal use */
  };
  uint32_t *Information; /* request dependent */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/iovec.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IOVEC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtIovec {
  uint32_t len;
  char *buf;
};

void DescribeIovNt(const struct NtIovec *, uint32_t, ssize_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ipadapteraddresses.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IP_ADAPTER_ADDRESSES_H_


/*!BEGIN libc/nt/winsock.h */

#define COSMOPOLITAN_LIBC_NT_WINSOCK_H_


/*!BEGIN libc/nt/struct/overlapped.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OVERLAPPED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtOverlapped {
  uintptr_t Internal;
  uintptr_t InternalHigh;
  union {
    struct {
      uint32_t Offset;
      uint32_t OffsetHigh;
    };
    void *Pointer;
  };
  int64_t hEvent;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/pollfd.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_POLLFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sys_pollfd_nt {
  int64_t handle;
  int16_t events;
  int16_t revents;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/timeval.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_TIMEVAL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtTimeval {
  int32_t tv_sec; /* [sic] */
  int32_t tv_usec;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
/* ░▓█████████████████████████████████████████████▓▒
   ░█▓░░░░░░░░░▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▒░
   ░█▓░ ░▒▒▒▒  ▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▓▒▒
   ░█▓░ ░▓▓▓▒  ▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▓▒▒
   ░█▓░       ░▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▒▒
   ░███████████████████████████████████████████████▓▒▒
   ░█▓░                                          ▒█▓▒▒
   ░█▓░                                          ▒█▓▒▒
   ░█▓░          ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░             ▒█▓▒▒
   ░█▓░        ░▒░                 ▒█▓░          ▒█▓▒▒
   ░█▓░      ░░░░    ░░░░░░░░      ▒▓▓▓▒░        ▒█▓▒▒
   ░█▓░    ░░░░  ░░░░░▒▒▓███▓░░░░░░░░▒▓▓▓▓▒      ▒█▓▒▒
   ░█▓░   ░▒▒  ░░░░░░░▒▒████▓░░░░░░░░░░▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒  ░░░░░░░▒▒▓▓▓▓▓░░░░░░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▒▒▒░░░░░ ░▒▒▒▒░░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓   ░▓█▓▒▒▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░░▒██▓   ░████▓▒░
   ░█▓░     ░░░░░░░░▒▒░░░░░░░░░▒▒░░░▒▒▓▓▒░░    ░░▓███▓▒░
   ░█▓░      ░░░░░░░░░░░░░░░░░░░░░░▒▓▓▓▒░        ▒████▓▒░░░░░░
   ░█▓░        ░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░        ░▓▓▓▓██▒░░░░░░░░
   ░█▓░          ▒█████████████████▒  ▓█▓▒░      ▒█▓ ░█▓      ░▓▓░
   ░█▓░                              ░▓████▒░    ▒█▓▒░  ░░░░░░░  ▓█▓░
   ░█▓░                                ░▓████▒░  ░▒░  ░░░░░░░░░░░  ░█▓
   ░█▓                                    ▒███▓▒▒░  ░░░░░░░░░░░░░░░  ▒▓▓
   ░██████████████████████████████████████▓▒▓█▓░  ░░░░░░░░░░░░░░░░░░ ▒█▓
    ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░ ░░░░░░░░░░░░░░░░░░░░▒█▓
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒██▒▒▒░░░░░░░░░░░░░░░░░░░░░▒█▓
                                          ░██▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒█▓
                                          ░▓▓▓▒▒▒▒▒▒░░░░░░░░░░░░░░░░▒▓█▓
                                            ░▓▓▓▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▒▓▓▒
                                              ░██▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  ░█▓
                                                 ▒█▓▒▒▒▒▒▒▒▒▒▒▒██▓▒░ ░█▓
                                                   ▒█████████████▓▒▒░  ░██▒
╔────────────────────────────────────────────────────────────────▀▀▀▀───▀▀▀▀─│─╗
│ cosmopolitan § new technology » winsock                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtWsaFlagOverlapped      0x01
#define kNtWsaFlagNoHandleInherit 0x80

#define kNtCompEqual   0
#define kNtCompNotless 1

#define kNtTfDisconnect       0x01
#define kNtTfReuseSocket      0x02
#define kNtTfWriteBehind      0x04
#define kNtTfUseDefaultWorker 0x00
#define kNtTfUseSystemThread  0x10
#define kNtTfUseKernelApc     0x20

#define kNtSoConnectTime          0x700C
#define kNtSoUpdateAcceptContext  0x700B
#define kNtSoUpdateConnectContext 0x7010

#define kNtNspNotifyImmediately 0
#define kNtNspNotifyHwnd        1
#define kNtNspNotifyEvent       2
#define kNtNspNotifyPort        3
#define kNtNspNotifyApc         4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtMsgHdr {
  struct sockaddr *name;
  int32_t namelen;
  struct NtIovec *lpBuffers;
  uint32_t dwBufferCount;
  struct NtIovec Control;
  uint32_t dwFlags;
};

struct NtWsaData {
  uint16_t wVersion;
  uint16_t wHighVersion;
  uint16_t iMaxSockets;
  uint16_t iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[257];
  char szSystemStatus[129];
};

struct NtSocketAddress {
  struct sockaddr *lpSockaddr;
  int32_t iSockaddrLength;
};

struct NtSocketAddressList {
  int32_t iAddressCount;
  struct NtSocketAddress Address[1];
};

struct NtAddrInfoEx {  /* win8+ */
  int32_t ai_flags;    /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
  int32_t ai_family;   /* PF_XXX */
  int32_t ai_socktype; /* SOCK_XXX */
  int32_t ai_protocol;
  uint64_t ai_addrlen;
  char16_t *ai_canonname;
  struct sockaddr *ai_addr;
  void *ai_blob;
  uint64_t ai_bloblen;
  struct NtGuid *ai_provider;
  struct NtAddrInfoEx *ai_next;
  int32_t ai_version;          /* v2 */
  char16_t *ai_fqdn;           /* v2 */
  int32_t ai_interfaceindex;   /* v3 */
  int64_t ai_resolutionhandle; /* v4 */
};

struct NtWsaProtocolChain {
  int32_t ChainLen;
  uint32_t ChainEntries[7];
};

struct NtWsaProtocolInfo {
  uint32_t dwServiceFlags1;
  uint32_t dwServiceFlags2;
  uint32_t dwServiceFlags3;
  uint32_t dwServiceFlags4;
  uint32_t dwProviderFlags;
  struct NtGuid ProviderId;
  uint32_t dwCatalogEntryId;
  struct NtWsaProtocolChain ProtocolChain;
  int32_t iVersion;
  int32_t iAddressFamily;
  int32_t iMaxSockAddr;
  int32_t iMinSockAddr;
  int32_t iSocketType;
  int32_t iProtocol;
  int32_t iProtocolMaxOffset;
  int32_t iNetworkByteOrder;
  int32_t iSecurityScheme;
  uint32_t dwMessageSize;
  uint32_t dwProviderReserved;
  char16_t szProtocol[256];
};

struct NtFlowSpec {
  uint32_t TokenRate;          /* bytes/sec */
  uint32_t TokenBucketSize;    /* bytes */
  uint32_t PeakBandwidth;      /* bytes/sec */
  uint32_t Latency;            /* µs */
  uint32_t DelayVariation;     /* µs */
  uint32_t ServiceType;        /* kNtServicetypeXxx */
  uint32_t MaxSduSize;         /* bytes */
  uint32_t MinimumPolicedSize; /* bytes */
};

struct NtQos {
  struct NtFlowSpec SendingFlowspec;
  struct NtFlowSpec ReceivingFlowspec;
  struct NtIovec ProviderSpecific;
};

struct NtWsaVersion {
  uint32_t dwVersion;
  int ecHow;
};

struct NtAfProtocols {
  int32_t iAddressFamily;
  int32_t iProtocol;
};

struct NtBlob {
  uint32_t cbSize;
  uint8_t pBlobData;
};

struct NtCsAddrInfo {
  struct NtSocketAddress LocalAddr;
  struct NtSocketAddress RemoteAddr;
  int32_t iSocketType;
  int32_t iProtocol;
};

struct NtWsaQuerySet {
  uint32_t dwSize; /* of this */
  char16_t *lpszServiceInstanceName;
  struct NtGuid *lpServiceClassId;
  struct NtWsaVersion *lpVersion;
  char16_t *lpszComment;
  uint32_t dwNameSpace;
  struct NtGuid *lpNSProviderId;
  char16_t *lpszContext;
  uint32_t dwNumberOfProtocols;
  struct NtAfProtocols *lpafpProtocols /*[dwNumberOfProtocols]*/;
  char16_t *lpszQueryString;
  uint32_t dwNumberOfCsAddrs;
  struct NtCsAddrInfo *lpcsaBuffer /*[dwNumberOfCsAddrs]*/;
  uint32_t dwOutputFlags;
  struct NtBlob *lpBlob;
};

struct NtWsaNamespaceInfoEx {
  struct NtGuid NSProviderId;
  uint32_t dwNameSpace;
  bool32 fActive;
  uint32_t dwVersion;
  char16_t *lpszIdentifier;
  struct NtBlob *ProviderSpecific;
};

struct NtWsansClassInfo {
  char16_t *lpszName;
  uint32_t dwNameSpace;
  uint32_t dwValueType;
  uint32_t dwValueSize;
  void *lpValue;
};

struct NtWsaServiceClassInfo {
  struct NtGuid *lpServiceClassId;
  char16_t *lpszServiceClassName;
  uint32_t dwCount;
  struct NtWsansClassInfo *lpClassInfos;
};

struct NtWsaNetworkEvents {
  int32_t lNetworkEvents;
  int32_t iErrorCode[10];
};

struct NtTransmitFileBuffers {
  void *Head;
  uint32_t HeadLength;
  void *Tail;
  uint32_t TailLength;
};

typedef int (*NtConditionProc)(
    const struct NtIovec *lpCallerId, const struct NtIovec *lpCallerData,
    struct NtQos *inout_lpSQOS, struct NtQos *inout_lpGQOS,
    const struct NtIovec *lpCalleeId, const struct NtIovec *lpCalleeData,
    uint32_t *out_group, const uint32_t *dwCallbackData);

typedef void (*NtWsaOverlappedCompletionRoutine)(
    uint32_t dwError, uint32_t cbTransferred,
    const struct NtOverlapped *lpOverlapped, uint32_t dwFlags);

struct NtWsaCompletion {
  int Type;
  union {
    struct {
      int64_t hWnd;
      uint32_t uMsg;
      uintptr_t context;
    } WindowMessage;
    struct {
      struct NtOverlapped *lpOverlapped;
    } Event;
    struct {
      struct NtOverlapped *lpOverlapped;
      NtWsaOverlappedCompletionRoutine lpfnCompletionProc;
    } Apc;
    struct {
      struct NtOverlapped *lpOverlapped;
      int64_t hPort;
      uint32_t Key;
    } Port;
  } Parameters;
};

struct NtInterfaceInfo {
  uint64_t iiFlags;
  struct sockaddr_in iiAddress;
  struct sockaddr_in iiBroadcastAddress;
  struct sockaddr_in iiNetmask;
};

/**
 * Winsock2 prototypes.
 *
 * @note Some of the functions exported by WS2_32.DLL, e.g. bind(),
 *       overlap with the names used by System V. Prototypes for these
 *       functions are declared within their respective wrappers.
 */

int32_t WSAStartup(uint16_t wVersionRequested, struct NtWsaData *lpWSAData)
    paramsnonnull() dontdiscard;

int WSACleanup(void);
int WSAGetLastError(void);
void WSASetLastError(int);

int __sys_bind_nt(uint64_t, const void *, int);
int __sys_closesocket_nt(uint64_t);
int __sys_getpeername_nt(uint64_t, void *, uint32_t *);
int __sys_getsockname_nt(uint64_t, void *, uint32_t *);
int __sys_getsockopt_nt(uint64_t, int, int, void *, uint32_t *);
int __sys_ioctlsocket_nt(uint64_t, int32_t, uint32_t *);
int __sys_listen_nt(uint64_t, int);
int __sys_setsockopt_nt(uint64_t, int, int, const void *, int);
int __sys_shutdown_nt(uint64_t, int);
int __sys_select_nt(int, struct NtFdSet *, struct NtFdSet *, struct NtFdSet *,
                    struct NtTimeval *);

uint64_t WSASocket(int af, int type, int protocol,
                   const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                   const uint32_t opt_group, uint32_t dwFlags) dontdiscard;

int WSAConnect(uint64_t s, const struct sockaddr *name, const int namelen,
               const struct NtIovec *opt_lpCallerData,
               struct NtIovec *opt_out_lpCalleeData,
               const struct NtQos *opt_lpSQOS, const struct NtQos *opt_lpGQOS)
    paramsnonnull((2));

bool32 WSAConnectByName(uint64_t s, const char16_t *nodename,
                        const char16_t *servicename,
                        uint32_t *opt_inout_LocalAddressLength,
                        struct sockaddr *out_LocalAddress,
                        uint32_t *opt_inout_RemoteAddressLength,
                        struct sockaddr *out_RemoteAddress,
                        const struct NtTimeval *opt_timeout,
                        struct NtOverlapped *__Reserved) paramsnonnull((2, 3));

bool32 WSAConnectByList(uint64_t s,
                        const struct NtSocketAddressList *SocketAddress,
                        uint32_t *opt_inout_LocalAddressLength,
                        struct sockaddr *out_LocalAddress,
                        uint32_t *opt_inout_RemoteAddressLength,
                        struct sockaddr *out_RemoteAddress,
                        const struct NtTimeval *opt_timeout,
                        struct NtOverlapped *__Reserved) paramsnonnull((2));

int64_t WSAAccept(uint64_t s, struct sockaddr *out_addr,
                  int32_t *opt_inout_addrlen,
                  const NtConditionProc opt_lpfnCondition,
                  const uint32_t *opt_dwCallbackData)
    paramsnonnull((2)) dontdiscard;

int WSASend(uint64_t s, const struct NtIovec *lpBuffers, uint32_t dwBufferCount,
            uint32_t *opt_out_lpNumberOfBytesSent, uint32_t dwFlags,
            struct NtOverlapped *opt_inout_lpOverlapped,
            const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSASendMsg(int64_t Handle, const struct NtMsgHdr *lpMsg, uint32_t dwFlags,
               uint32_t *opt_out_lpNumberOfBytesSent,
               struct NtOverlapped *opt_inout_lpOverlapped,
               const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSASendTo(uint64_t s, const struct NtIovec *lpBuffers,
              uint32_t dwBufferCount,
              uint32_t *opt_out_lpNumberOfBytesSent /* opt if !overlapped */,
              uint32_t dwFlags, const void *opt_tosockaddr,
              int32_t tosockaddrlen,
              struct NtOverlapped *opt_inout_lpOverlapped,
              const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSAPoll(struct sys_pollfd_nt *inout_fdArray, uint32_t nfds,
            signed timeout_ms) paramsnonnull();

int WSARecv(uint64_t s, const struct NtIovec *inout_lpBuffers,
            uint32_t dwBufferCount, uint32_t *opt_out_lpNumberOfBytesRecvd,
            uint32_t *inout_lpFlags,
            struct NtOverlapped *opt_inout_lpOverlapped,
            const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2, 5));

int WSARecvFrom(uint64_t s, const struct NtIovec *inout_lpBuffers,
                uint32_t dwBufferCount, uint32_t *opt_out_lpNumberOfBytesRecvd,
                uint32_t *inout_lpFlags, void *out_fromsockaddr,
                uint32_t *opt_inout_fromsockaddrlen,
                struct NtOverlapped *opt_inout_lpOverlapped,
                const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2, 5));

int WSARecvDisconnect(uint64_t s, struct NtIovec *out_InboundDisconnectData);
int WSASendDisconnect(int64_t s, struct NtIovec *opt_OutboundDisconnectData);

int WSADuplicateSocket(uint64_t s, uint32_t dwProcessId,
                       struct NtWsaProtocolInfo *out_lpProtocolInfo)
    paramsnonnull((3));

int WSAIoctl(uint64_t s, uint32_t dwIoControlCode, const void *lpvInBuffer,
             uint32_t cbInBuffer, void *out_lpvOutBuffer, uint32_t cbOutBuffer,
             uint32_t *out_lpcbBytesReturned,
             struct NtOverlapped *opt_inout_lpOverlapped,
             const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((5, 7));

int WSANSPIoctl(int64_t hLookup, uint32_t dwControlCode,
                const void *lpvInBuffer, uint32_t cbInBuffer,
                void *out_lpvOutBuffer, uint32_t cbOutBuffer,
                uint32_t *out_lpcbBytesReturned,
                const struct NtWsaCompletion *opt_lpCompletion)
    paramsnonnull((3, 5, 7));

int64_t WSACreateEvent(void) dontdiscard;
bool32 WSACloseEvent(const int64_t hEvent);
bool32 WSAResetEvent(const int64_t hEvent);
bool32 WSASetEvent(const int64_t hEvent);

int WSAEventSelect(uint64_t s, const int64_t opt_hEventObject,
                   long lNetworkEvents);

uint32_t WSAWaitForMultipleEvents(uint32_t cEvents, const int64_t *lphEvents,
                                  bool32 fWaitAll, uint32_t dwTimeout_ms,
                                  bool32 fAlertable) paramsnonnull();

int WSAEnumNetworkEvents(uint64_t s, const int64_t hEventObject,
                         struct NtWsaNetworkEvents *out_lpNetworkEvents)
    paramsnonnull();

bool32 WSAGetOverlappedResult(uint64_t s,
                              const struct NtOverlapped *lpOverlapped,
                              uint32_t *out_lpcbTransfer, bool32 fWait,
                              uint32_t *out_lpdwFlags) paramsnonnull();

int WSAEnumProtocols(const int32_t *opt_lpiProtocols,
                     struct NtWsaProtocolInfo *out_lpProtocolBuffer,
                     uint32_t *inout_lpdwBufferLength) paramsnonnull();

bool32 WSAGetQOSByName(uint64_t s, const struct NtIovec *lpQOSName,
                       struct NtQos *out_lpQOS) paramsnonnull();

uint64_t WSAJoinLeaf(uint64_t s, const struct sockaddr *name, const int namelen,
                     const struct NtIovec *opt_lpCallerData,
                     struct NtIovec *opt_out_lpCalleeData,
                     const struct NtQos *opt_lpSQOS,
                     const struct NtQos *opt_lpGQOS, uint32_t dwFlags)
    paramsnonnull((2, 4));

int WSALookupServiceBegin(const struct NtWsaQuerySet *lpqsRestrictions,
                          uint32_t dwControlFlags, int64_t *out_lphLookup)
    paramsnonnull();

int WSALookupServiceNext(const int64_t hLookup, uint32_t dwControlFlags,
                         uint32_t *inout_lpdwBufferLength,
                         struct NtWsaQuerySet *out_lpqsResults) paramsnonnull();

int WSALookupServiceEnd(int64_t hLookup);

int WSAAddressToString(const struct sockaddr *lpsaAddress,
                       uint32_t dwAddressLength,
                       const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                       char16_t *out_lpszAddressString,
                       uint32_t *inout_lpdwAddressStringLength)
    paramsnonnull((1, 4, 5));

int WSAStringToAddress(const char16_t *AddressString, int AddressFamily,
                       const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                       struct sockaddr *out_lpAddress,
                       int *inout_lpAddressLength) paramsnonnull((1, 3, 4));

int WSAEnumNameSpaceProvidersEx(uint32_t *inout_lpdwBufferLength,
                                struct NtWsaNamespaceInfoEx *out_lpnspBuffer)
    paramsnonnull();

int WSAProviderConfigChange(
    int64_t *inout_lpNotificationHandle,
    struct NtOverlapped *opt_inout_lpOverlapped,
    NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((1));

int WSAInstallServiceClass(
    const struct NtWsaServiceClassInfo *lpServiceClassInfo) paramsnonnull();

int WSARemoveServiceClass(const struct NtGuid *lpServiceClassId)
    paramsnonnull();

int WSAGetServiceClassInfo(const struct NtGuid *lpProviderId,
                           const struct NtGuid *lpServiceClassId,
                           uint32_t *inout_lpdwBufSize,
                           struct NtWsaServiceClassInfo *out_lpServiceClassInfo)
    paramsnonnull((1, 2, 3));

int WSASetService(const struct NtWsaQuerySet *lpqsRegInfo, int essoperation,
                  uint32_t dwControlFlags) paramsnonnull();

int /* success==0 */ WSAGetServiceClassNameByClassId(
    const struct NtGuid *lpServiceClassId, char16_t *out_lpszServiceClassName,
    uint32_t *inout_lpdwBufferLength) paramsnonnull();

bool32 TransmitFile(int64_t hSocket, int64_t hFile,
                    uint32_t opt_nNumberOfBytesToWrite,
                    uint32_t opt_nNumberOfBytesPerSend,
                    struct NtOverlapped *opt_inout_lpOverlapped,
                    const struct NtTransmitFileBuffers *opt_lpTransmitBuffers,
                    uint32_t dwReserved);

bool32 AcceptEx(int64_t sListenSocket, int64_t sAcceptSocket,
                void *out_lpOutputBuffer /*[recvlen+local+remoteaddrlen]*/,
                uint32_t dwReceiveDataLength, uint32_t dwLocalAddressLength,
                uint32_t dwRemoteAddressLength, uint32_t *out_lpdwBytesReceived,
                struct NtOverlapped *inout_lpOverlapped);

void GetAcceptExSockaddrs(
    const void *lpOutputBuffer /*[recvsize+addrsize+addrlen]*/,
    uint32_t dwReceiveDataLength, uint32_t dwLocalAddressLength,
    uint32_t dwRemoteAddressLength,
    struct sockaddr **out_LocalSockaddr /*[*LocalSockaddrLength]*/,
    int *out_LocalSockaddrLength,
    struct sockaddr **out_RemoteSockaddr /*[*RemoteSockaddrLength]*/,
    int *out_RemoteSockaddrLength);

bool32 DisconnectEx(int64_t s, struct NtOverlapped *inout_opt_lpOverlapped,
                    uint32_t dwFlags, uint32_t dwReserved);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/* Constants ----------------------------------------------------------- */

#define kNtMaxAdapterAddressLength  8
#define kNtMaxDnsSuffixStringLength 256
#define kNtMaxDhcpv6DuidLength      130

/* Values for the 'Flags' parameter of GetAdaptersAddresses */
#define kNtGaaFlagSkipUnicast               0x0001
#define kNtGaaFlagSkipAnycast               0x0002
#define kNtGaaFlagSkipMulticast             0x0004
#define kNtGaaFlagSkipDnsServer             0x0008
#define kNtGaaFlagIncludePrefix             0x0010
#define kNtGaaFlagSkipFriendlyName          0x0020
#define kNtGaaFlagIncludeWinsInfo           0x0040
#define kNtGaaFlagIncludeGateways           0x0080
#define kNtGaaFlagIncludeAllInterfaces      0x0100
#define kNtGaaFlagIncludeAllCompartments    0x0200
#define kNtGaaFlagIncludeTunnelBindingorder 0x0400
#define kNtGaaFlagSkipDnsInfo               0x0800

/* Values for the IfType parameter
 * See:
 * https://docs.microsoft.com/en-us/windows/win32/api/iptypes/ns-iptypes-ip_adapter_addresses_lh
 */
#define kNtIfTypeOther             1
#define kNtIfTypeEthernetCsmacd    6
#define kNtIfTypeIso88025Tokenring 9
#define kNtIfTypePpp               23
#define kNtIfTypeSoftwareLoopback  24
#define kNtIfTypeAtm               37
#define kNtIfTypeIeee80211         71 /* wifi */
#define kNtIfTypeTunnel            131
#define kNtIfTypeIeee1394          144 /* firewire */

#define kNtIpAdapterDdnsEnabled             0x0001
#define kNtIpAdapterRegisterAdapterSuffix   0x0002
#define kNtIpAdapterDhcpv4Enabled           0x0004
#define kNtIpAdapterReceiveOnly             0x0008
#define kNtIpAdapterNoMulticast             0x0010
#define kNtIpAdapterIpv6OtherStatefulConfig 0x0020
#define kNtIpAdapterNetbiosOverTcpipEnabled 0x0040
#define kNtIpAdapterIpv4Enabled             0x0080
#define kNtIpAdapterIpv6Enabled             0x0100
#define kNtIpAdapterIpv6Managed             0x0200

#define kNtIpPrefixOriginOther               0
#define kNtIpPrefixOriginManual              1
#define kNtIpPrefixOriginWellKnown           2
#define kNtIpPrefixOriginDhcp                3
#define kNtIpPrefixOriginRouterAdvertisement 4
#define kNtIpPrefixOriginUnchanged           16

#define kNtIpSuffixOriginOther            0
#define kNtIpSuffixOriginManual           1
#define kNtIpSuffixOriginWellKnown        2
#define kNtIpSuffixOriginDhcp             3
#define kNtIpSuffixOriginLinkLayerAddress 4
#define kNtIpSuffixOriginRandom           5
#define kNtIpSuffixOriginUnchanged        16

#define kNtIpDadStateInvalid    0
#define kNtIpDadStateTentative  1
#define kNtIpDadStateDuplicate  2
#define kNtIpDadStateDeprecated 3
#define kNtIpDadStatePreferred  4

#define kNtIfOperStatusUp             1
#define kNtIfOperStatusDown           2
#define kNtIfOperStatusTesting        3
#define kNtIfOperStatusUnknown        4
#define kNtIfOperStatusDormant        5
#define kNtIfOperStatusNotPresent     6
#define kNtIfOperStatusLowerLayerDown 7

#define kNtNetIfConnectionDedicated 1
#define kNtNetIfConnectionPassive   2
#define kNtNetIfConnectionDemand    3
#define kNtNetIfConnectionMaximum   4

#define kNtTunnelTypeNone    0
#define kNtTunnelTypeOther   1
#define kNtTunnelTypeDirect  2
#define kNtTunnelType6to4    11
#define kNtTunnelTypeIsatap  13
#define kNtTunnelTypeTeredo  14
#define kNtTunnelTypeIphttps 15

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/* Inner Types --------------------------------------------------------- */

struct NtIpAdapterUnicastAddress {
  uint32_t Length;
  uint32_t Flags;
  struct NtIpAdapterUnicastAddress *Next;
  struct NtSocketAddress Address;
  uint32_t PrefixOrigin; /* kNtIpPrefixOrigin... */
  uint32_t SuffixOrigin; /* kNtIpSuffixOrigin... */
  uint32_t DadState;     /* kNtIpDadState... */
  uint32_t ValidLifetime;
  uint32_t PreferredLifetime;
  uint32_t LeaseLifetime;
  uint8_t OnLinkPrefixLength;
};

struct NtIpAdapterAnycastAddress {
  uint32_t Length;
  uint32_t Flags;
  struct NtIpAdapterAnycastAddress *Next;
  struct NtSocketAddress Address;
};

struct NtIpAdapterMulticastAddress {
  uint32_t Length;
  uint32_t Flags;
  struct NtIpAdapterMulticastAddress *Next;
  struct NtSocketAddress Address;
};

struct NtIpAdapterDnsServerAddress {
  uint32_t Length;
  uint32_t Reserved;
  struct NtIpAdapterDnsServerAddress *Next;
  struct NtSocketAddress Address;
};

struct NtIpAdapterPrefix {
  uint32_t Length;
  uint32_t Flags;
  struct NtIpAdapterPrefix *Next;
  struct NtSocketAddress Address;
  uint32_t PrefixLength;
};

struct NtIpAdapterWinsServerAddress {
  uint32_t Length;
  uint32_t Reserved;
  struct NtIpAdapterWinsServerAddress *Next;
  struct NtSocketAddress Address;
};

struct NtIpAdapterGatewayAddress {
  uint32_t Length;
  uint32_t Reserved;
  struct NtIpAdapterGatewayAddress *Next;
  struct NtSocketAddress Address;
};

struct NtIpAdapterDnsSuffix {
  struct NtIpAdapterDnsSuffix *Next;
  uint16_t String[kNtMaxDnsSuffixStringLength];
};

/* Top level ----------------------------------------------------------- */

struct NtIpAdapterAddresses {
  uint32_t Length;
  uint32_t IfIndex;
  struct NtIpAdapterAddresses *Next;
  char *AdapterName;
  struct NtIpAdapterUnicastAddress *FirstUnicastAddress;
  struct NtIpAdapterAnycastAddress *FirstAnycastAddress;
  struct NtIpAdapterMulticastAddress *FirstMulticastAddress;
  struct NtIpAdapterDnsServerAddress *FirstDnsServerAddress;
  uint16_t *DnsSuffix;
  uint16_t *Description;
  uint16_t *FriendlyName;
  uint8_t PhysicalAddress[kNtMaxAdapterAddressLength];
  uint32_t PhysicalAddressLength;
  uint32_t Flags; /* kNtIpAdapter... */
  uint32_t Mtu;
  uint32_t IfType;     /* kNtIfType... */
  uint32_t OperStatus; /* kNtIfOperStatus... */
  uint32_t Ipv6IfIndex;
  uint32_t ZoneIndices[16];
  struct NtIpAdapterPrefix *FirstPrefix;
  uint64_t TransmitLinkSpeed;
  uint64_t ReceiveLinkSpeed;
  struct NtIpAdapterWinsServerAddress *FirstWinsServerAddress;
  struct NtIpAdapterGatewayAddress *FirstGatewayAddress;
  uint32_t Ipv4Metric;
  uint32_t Ipv6Metric;
  uint64_t Luid; /* reserved(24bits),NetLuidIndex(24b),IfType(16b) */
  struct NtSocketAddress Dhcpv4Server;
  uint32_t CompartmentId;
  struct NtGuid NetworkGuid;
  uint32_t ConnectionType; /* kNtNetIfConnection... */
  uint32_t TunnelType;     /* kNtTunnelType... */
  struct NtSocketAddress Dhcpv6Server;
  uint8_t Dhcpv6ClientDuid[kNtMaxDhcpv6DuidLength];
  uint32_t Dhcpv6ClientDuidLength;
  uint32_t Dhcpv6Iaid;
  struct NtIpAdapterDnsSuffix *FirstDnsSuffix;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/kernelusertimes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_KERNELUSERTIMES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtKernelUserTimes {
  uint64_t CreateFileTime;
  uint64_t ExitFileTime;
  int64_t KernelTime;
  int64_t UserTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ldr.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLdr {
  uint32_t SizeOfThis;                       /* msdn:reserved */
  uint32_t IsInitialized;                    /* msdn:reserved */
  void *SsHandle;                            /* msdn:reserved */
  struct NtLinkedList InLoadOrderModuleList; /* msdn:reserved */
  struct NtLinkedList /*∩NtLdrDataTableEntry*/ InMemoryOrderModuleList;
  struct NtLinkedList InInitOrderModuleList; /* msdn:reserved */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ldrdatatableentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LDRDATATABLEENTRY_H_


/*!BEGIN libc/nt/struct/unicodestring.h */

#define COSMOPOLITAN_LIBC_NT_UNICODE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtUnicodeString {
  uint16_t Length;
  uint16_t MaxLength;
  char16_t *Data;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLdrDataTableEntry {
  struct NtLinkedList InLoadOrderLinks; /* msdn:reserved */
  struct NtLinkedList InMemoryOrderLinks;
  struct NtLinkedList InInitOrderLinks; /* msdn:reserved */
  void *DllBase;
  void *EntryPoint;
  union {
    uint32_t SizeOfImage;
    unsigned char SizeOfImagePadding[__SIZEOF_POINTER__];
  };
  struct NtUnicodeString FullDllName;
  struct NtUnicodeString BaseDllName;
  uint32_t Flags;
  uint16_t Load_Count;
  uint16_t TlsIndex;
  union {
    struct NtLinkedList HashLinks;
    struct {
      void *SectionPointer;
      uint32_t CheckSum;
    };
  };
  union {
    void *LoadedImports;
    uint32_t TimeDateStamp;
  };
  void *EntryPointActivationContext;
  void *PatchInformation;
  struct NtLinkedList ForwarderLinks;
  struct NtLinkedList ServiceTagLinks;
  struct NtLinkedList StaticLinks;
  void *ContextInformation;
  uintptr_t OriginalBase;
  int64_t LoadTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/linger.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LINGER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct linger_nt {
  uint16_t l_onoff;  /* on/off */
  uint16_t l_linger; /* seconds */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/luid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LUID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLuid {
  uint32_t LowPart;
  int32_t HighPart;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/luidandattributes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LUIDANDATTRIBUTES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLuidAndAttributes {
  struct NtLuid Luid;
  uint32_t Attributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memorybasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryBasicInformation {
  void *BaseAddress;
  void *AllocationBase;
  uint32_t AllocationProtect;
  uint64_t RegionSize;
  uint32_t State;
  uint32_t Protect;
  uint32_t Type;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memoryrangeentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYRANGEENTRY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryRangeEntry {
  void *VirtualAddress;
  size_t NumberOfBytes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memorystatusex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYSTATUSEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryStatusEx {
  uint32_t dwLength;
  uint32_t dwMemoryLoad;
  uint64_t ullTotalPhys;
  uint64_t ullAvailPhys;
  uint64_t ullTotalPageFile;
  uint64_t ullAvailPageFile;
  uint64_t ullTotalVirtual;
  uint64_t ullAvailVirtual;
  uint64_t ullAvailExtendedVirtual;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/msg.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MSG_H_


/*!BEGIN libc/nt/struct/point.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_POINT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPoint {
  int32_t x;
  int32_t y;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMsg {
  int64_t hwnd;
  uint32_t message;
  uint64_t wParam;
  int64_t lParam;
  uint32_t time;
  struct NtPoint pt;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/nonpageddebuginfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NONPAGEDDEBUGINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtNonPagedDebugInfo {
  uint16_t Signature;
  uint16_t Flags;
  uint32_t Size;
  uint16_t Machine;
  uint16_t Characteristics;
  uint32_t TimeDateStamp;
  uint32_t CheckSum;
  uint32_t SizeOfImage;
  uint64_t ImageBase;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ntexceptionpointers.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTEXCEPTIONPOINTERS_H_


/*!BEGIN libc/nt/struct/ntexceptionrecord.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTEXCEPTIONRECORD_H_

#define kNtExceptionMaximumParameters 15
#define kNtExceptionNoncontinuable 1

#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionRecord {
  uint32_t ExceptionCode;                    /* kNtException... */
  uint32_t ExceptionFlags;                   /* kNtExceptionNoncontinuable */
  struct NtExceptionRecord *ExceptionRecord; /* nested exceptions */
  void *ExceptionAddress;                    /* %rip */
  uint32_t NumberParameters;                 /* #ExceptionInformation */
  uint32_t *ExceptionInformation[kNtExceptionMaximumParameters];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionPointers {
  struct NtExceptionRecord *ExceptionRecord;
  struct NtContext *ContextRecord;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectallinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTALLINFORMATION_H_


/*!BEGIN libc/nt/struct/objecttypeinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTTYPEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectTypeInformation {
  struct NtUnicodeString TypeName;
  uint32_t TotalNumberOfObjects;
  uint32_t TotalNumberOfHandles;
  uint32_t TotalPagedPoolUsage;
  uint32_t TotalNonPagedPoolUsage;
  uint32_t TotalNamePoolUsage;
  uint32_t TotalHandleTableUsage;
  uint32_t HighWaterNumberOfObjects;
  uint32_t HighWaterNumberOfHandles;
  uint32_t HighWaterPagedPoolUsage;
  uint32_t HighWaterNonPagedPoolUsage;
  uint32_t HighWaterNamePoolUsage;
  uint32_t HighWaterHandleTableUsage;
  uint32_t InvalidAttributes;
  struct NtGenericMapping GenericMapping;
  uint32_t ValidAccessMask;
  bool32 SecurityRequired;
  bool32 MaintainHandleCount;
  uint32_t PoolType;
  uint32_t DefaultPagedPoolCharge;
  uint32_t DefaultNonPagedPoolCharge;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectAllInformation {
  uint32_t NumberOfObjects;
  struct NtObjectTypeInformation ObjectTypeInformation[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectattributes.h */

#define COSMOPOLITAN_LIBC_NT_I_OBJECTATTRIBUTES_H_


/*!BEGIN libc/nt/struct/rtluserprocessparameters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RTLUSERPROCESSPARAMETERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRtlUserProcessParameters {
  uint32_t MaximumLength;
  uint32_t Length;
  uint32_t Flags;
  uint32_t DebugFlags;
  int64_t ConsoleHandle;
  uint32_t ConsoleFlags;
  int64_t StdInputHandle;
  int64_t StdOutputHandle;
  int64_t StdErrorHandle;
  struct NtUnicodeString *CurrentDirectoryPath;
  int64_t CurrentDirectoryHandle;
  struct NtUnicodeString *DllPath;
  struct NtUnicodeString *ImagePathName;
  struct NtUnicodeString *CommandLine;
  void *Environment;
  uint32_t StartingPositionLeft;
  uint32_t StartingPositionTop;
  uint32_t Width;
  uint32_t Height;
  uint32_t CharWidth;
  uint32_t CharHeight;
  uint32_t ConsoleTextAttributes;
  uint32_t WindowFlags;
  uint32_t ShowWindowFlags;
  struct NtUnicodeString *WindowTitle;
  struct NtUnicodeString *DesktopName;
  struct NtUnicodeString *ShellInfo;
  struct NtUnicodeString *RuntimeData;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectAttributes {
  uint32_t Length;
  int64_t RootDirectory;
  struct NtUnicodeString *ObjectName;
  uint32_t Attributes; /* OBJ_INHERIT, etc. */
  struct NtSecurityDescriptor *SecurityDescriptor;
  void *SecurityQualityOfService;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectbasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectBasicInformation {
  uint32_t Attributes;
  uint32_t GrantedAccess;
  uint32_t HandleCount;
  uint32_t PointerCount;
  uint32_t PagedPoolUsage;
  uint32_t NonPagedPoolUsage;
  uint32_t Reserved[3];
  uint32_t NameInformationLength;
  uint32_t TypeInformationLength;
  uint32_t SecurityDescriptorLength;
  int64_t CreateTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectnameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTNAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectNameInformation {
  struct NtUnicodeString Name;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/openfilename.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OPENFILENAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtOpenFilename {
  uint32_t lStructSize;
  int64_t hwndOwner;
  int64_t hInstance;
  const char16_t *lpstrFilter;
  char16_t *lpstrCustomFilter;
  uint32_t nMaxCustFilter;
  uint32_t nFilterIndex;
  char16_t *lpstrFile;
  uint32_t nMaxFile;
  char16_t *lpstrFileTitle;
  uint32_t nMaxFileTitle;
  const char16_t *lpstrInitialDir;
  const char16_t *lpstrTitle;
  uint32_t Flags;
  uint16_t nFileOffset;
  uint16_t nFileExtension;
  const char16_t *lpstrDefExt;
  intptr_t lCustData;
  uint64_t (*lpfnHook)(int64_t, uint32_t, uint64_t, int64_t);
  const char16_t *lpTemplateName;
  void *pvReserved;
  uint32_t dwReserved;
  uint32_t FlagsEx;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/osversioninfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OSVERSIONINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtOsVersionInfo {
  uint32_t dwOSVersionInfoSize;
  uint32_t dwMajorVersion;
  uint32_t dwMinorVersion;
  uint32_t dwBuildNumber;
  uint32_t dwPlatformId;
  char16_t szCSDVersion[128];
  uint16_t wServicePackMajor;
  uint16_t wServicePackMinor;
  uint16_t wSuiteMask;
  uint8_t wProductType;
  uint8_t wReserved;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/overlappedentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OVERLAPPEDENTRY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtOverlappedEntry {
  uint32_t *lpCompletionKey;
  struct NtOverlapped *lpOverlapped;
  uint32_t *Internal;
  uint32_t dwNumberOfBytesTransferred;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/paintstruct.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PAINTSTRUCT_H_


/*!BEGIN libc/nt/struct/rect.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RECT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRect {
  int32_t left;
  int32_t top;
  int32_t right;
  int32_t bottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPaintStruct {
  int64_t hdc;
  bool32 fErase;
  struct NtRect rcPaint;
  bool32 fRestore;
  bool32 fIncUpdate;
  uint8_t rgbReserved[32];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/pdhfmtcountervalue.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PDHFMTCOUNTERVALUE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtPdhFmtCountervalue {
  uint32_t CStatus;
  union {
    int32_t longValue;
    double doubleValue;
    int64_t largeValue;
    const char *AnsiStringValue;
    const char16_t *WideStringValue;
  };
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/peb.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PEB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPeb {
  union {
    struct {
      unsigned char InheritedAddressSpace;
      unsigned char ReadImageFileExecOptions;
      unsigned char BeingDebugged;
      unsigned char __wut1;
    };
    uint64_t __wut2;
  };
  uint64_t Mutant;
  uint64_t ImageBaseAddress;
  struct NtLdr *Ldr;
  uint64_t ProcessParameters;
  uint64_t SubSystemData;
  uint64_t ProcessHeap;
  uint64_t FastPebLock;
  uint64_t __wut3;
  uint64_t __wut4;
  uint64_t __wut5;
  union {
    uint64_t KernelCallbackTable;
    uint64_t UserSharedInfoPtr;
  };
  uint32_t SystemReserved;
  uint32_t __wut6;
  uint64_t __wut7;
  uint64_t TlsExpansionCounter;
  uint64_t TlsBitmap;
  uint32_t TlsBitmapBits[2];
  uint64_t ReadOnlySharedMemoryBase;
  uint64_t __wut8;
  uint64_t ReadOnlyStaticServerData;
  uint64_t AnsiCodePageData;
  uint64_t OemCodePageData;
  uint64_t UnicodeCaseTableData;
  uint32_t NumberOfProcessors;
#ifdef __x86_64__
  uint32_t NtGlobalFlag;
#else
  uint64_t NtGlobalFlag;
#endif
  int64_t CriticalSectionTimeout;
  uint64_t HeapSegmentReserve;
  uint64_t HeapSegmentCommit;
  uint64_t HeapDeCommitTotalFreeThreshold;
  uint64_t HeapDeCommitFreeBlockThreshold;
  uint32_t NumberOfHeaps;
  uint32_t MaximumNumberOfHeaps;
  uint64_t ProcessHeaps;
  uint64_t GdiSharedHandleTable;
  uint64_t ProcessStarterHelper;
  uint64_t GdiDCAttributeList;
  uint64_t LoaderLock;
  union {
    struct {
      uint32_t OSMajorVersion;
      uint32_t OSMinorVersion;
    };
    uint64_t OSVersion;
  };
  uint16_t OSBuildNumber;
  uint16_t OSCSDVersion;
  uint32_t OSPlatformId;
  uint32_t ImageSubsystem;
  uint32_t ImageSubsystemMajorVersion;
  uint64_t ImageSubsystemMinorVersion;
  union {
    uint64_t ImageProcessAffinityMask;
    uint64_t ActiveProcessAffinityMask;
  };
  uint64_t GdiHandleBuffer[38 - __SIZEOF_POINTER__];
  uint64_t PostProcessInitRoutine;
  uint64_t TlsExpansionBitmap;
  uint32_t TlsExpansionBitmapBits[32];
  uint64_t SessionId;
  uint64_t AppCompatFlags;
  uint64_t AppCompatFlagsUser;
  uint64_t pShimData;
  uint64_t AppCompatInfo;
  struct NtUnicodeString CSDVersion;
  uint64_t ActivationContextData;
  uint64_t ProcessAssemblyStorageMap;
  uint64_t SystemDefaultActivationContextData;
  uint64_t SystemAssemblyStorageMap;
  uint64_t MinimumStackCommit;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/privilegeset.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PRIVILEGESET_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPrivilegeSet {
  uint32_t PrivilegeCount;
  uint32_t Control;
  struct NtLuidAndAttributes Privilege[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/processbasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtProcessBasicInformation {
  int32_t ExitStatus;
  struct NtPeb *PebBaseAddress;
  uint32_t *AffinityMask;
  int32_t BasePriority;
  int64_t UniqueProcessId;
  int64_t InheritedFromUniqueProcessId;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/processentry32.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSENTRY32_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtProcessEntry32 {
  uint32_t dwSize;
  uint32_t cntUsage; /* unused */
  uint32_t th32ProcessID;
  uint64_t th32DefaultHeapID; /* unused */
  uint32_t th32ModuleID;      /* unused */
  uint32_t cntThreads;
  uint32_t th32ParentProcessID;
  int32_t cPriClassBase;
  uint32_t dwFlags; /* unused */
  char16_t szExeFile[260];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/processmemorycounters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSMEMORYCOUNTERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtProcessMemoryCountersEx {
  uint32_t cb; /* count bytes */
  uint32_t PageFaultCount;
  uint64_t PeakWorkingSetSize;
  uint64_t WorkingSetSize;
  uint64_t QuotaPeakPagedPoolUsage;
  uint64_t QuotaPagedPoolUsage;
  uint64_t QuotaPeakNonPagedPoolUsage;
  uint64_t QuotaNonPagedPoolUsage;
  uint64_t PagefileUsage;
  uint64_t PeakPagefileUsage;
  uint64_t PrivateUsage;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/procthreadattributelist.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCTHREADATTRIBUTELIST_H_

struct NtProcThreadAttributeList;



/*!BEGIN libc/nt/struct/reparsedatabuffer.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_REPARSEDATABUFFER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtReparseDataBuffer {
  uint32_t ReparseTag;
  uint16_t ReparseDataLength;
  uint16_t Reserved;
  union {
    struct {
      uint16_t SubstituteNameOffset;
      uint16_t SubstituteNameLength;
      uint16_t PrintNameOffset;
      uint16_t PrintNameLength;
      uint32_t Flags;
      char16_t PathBuffer[1];
    } SymbolicLinkReparseBuffer;
    struct {
      uint16_t SubstituteNameOffset;
      uint16_t SubstituteNameLength;
      uint16_t PrintNameOffset;
      uint16_t PrintNameLength;
      char16_t PathBuffer[1];
    } MountPointReparseBuffer;
    struct {
      uint8_t DataBuffer[1];
    } GenericReparseBuffer;
  };
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/rtluserprocessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RTLUSERPROCESSINFORMATION_H_


/*!BEGIN libc/nt/struct/sectionimageinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECTIONIMAGEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSectionImageInformation {
  void *EntryPoint;
  uint32_t Unknown1;
  uint32_t StackReserve;
  uint32_t StackCommit;
  uint32_t Subsystem;
  uint16_t MinorSubsystemVersion;
  uint16_t MajorSubsystemVersion;
  uint32_t Unknown2;
  uint32_t Characteristics;
  uint16_t ImageNumber;
  uint32_t IsExecutable;
  uint8_t __wut1;
  uint32_t __wut2[3];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRtlUserProcessInformation {
  uint32_t SizeOfThis;
  int64_t ProcessHandle;
  int64_t ThreadHandle;
  struct NtClientId ClientId;
  struct NtSectionImageInformation ImageInformation;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/size.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SIZE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtSize {
  int32_t cx;
  int32_t cy;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/startupinfoex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_STARTUPINFOEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtStartupInfoEx {
  struct NtStartupInfo StartupInfo;
  struct NtProcThreadAttributeList *lpAttributeList;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systembasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemBasicInformation {
  unsigned char Reserved1[4];
  uint32_t MaximumIncrement;
  uint32_t PhysicalPageSize;
  uint32_t NumberOfPhysicalPages;
  uint32_t LowestPhysicalPage;
  uint32_t HighestPhysicalPage;
  uint32_t AllocationGranularity;
  uint32_t LowestUserAddress;
  uint32_t HighestUserAddress;
  uint32_t ActiveProcessors;
  char NumberOfProcessors;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemexceptioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMEXCEPTIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemExceptionInformation {
  unsigned char Reserved1[16];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemhandleentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMHANDLEENTRY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemHandleEntry {
  uint32_t OwnerPid;
  unsigned char ObjectType;
  unsigned char HandleFlags;
  unsigned short HandleValue;
  void *ObjectPointer;
  uint32_t AccessMask;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemhandleinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMHANDLEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemHandleInformation {
  uint32_t Count;
  struct NtSystemHandleEntry Handle[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systeminfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemInfo {
  union {
    uint32_t dwOemId;
    struct {
      uint16_t wProcessorArchitecture;
      uint16_t wReserved;
    };
  };
  uint32_t dwPageSize;
  void *lpMinimumApplicationAddress;
  void *lpMaximumApplicationAddress;
  uintptr_t dwActiveProcessorMask;
  uint32_t dwNumberOfProcessors;
  uint32_t dwProcessorType;
  uint32_t dwAllocationGranularity;
  uint16_t wProcessorLevel;
  uint16_t wProcessorRevision;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systeminterruptinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMINTERRUPTINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemInterruptInformation {
  unsigned char Reserved1[24];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemlookasideinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMLOOKASIDEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemLookasideInformation {
  unsigned char Reserved1[32];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemperformanceinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPERFORMANCEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemPerformanceInformation {
  int64_t IdleTime;
  int64_t ReadTransferCount;
  int64_t WriteTransferCount;
  int64_t OtherTransferCount;
  uint32_t ReadOperationCount;
  uint32_t WriteOperationCount;
  uint32_t OtherOperationCount;
  uint32_t AvailablePages;
  uint32_t TotalCommittedPages;
  uint32_t TotalCommitLimit;
  uint32_t PeakCommitment;
  uint32_t PageFaults;
  uint32_t WriteCopyFaults;
  uint32_t TransitionFaults;
  uint32_t CacheTransitionFaults;
  uint32_t DemandZeroFaults;
  uint32_t PagesRead;
  uint32_t PageReadIos;
  uint32_t CacheReads;
  uint32_t CacheIos;
  uint32_t PagefilePagesWritten;
  uint32_t PagefilePageWriteIos;
  uint32_t MappedFilePagesWritten;
  uint32_t MappedFilePageWriteIos;
  uint32_t PagedPoolUsage;
  uint32_t NonPagedPoolUsage;
  uint32_t PagedPoolAllocs;
  uint32_t PagedPoolFrees;
  uint32_t NonPagedPoolAllocs;
  uint32_t NonPagedPoolFrees;
  uint32_t TotalFreeSystemPtes;
  uint32_t SystemCodePage;
  uint32_t TotalSystemDriverPages;
  uint32_t TotalSystemCodePages;
  uint32_t SmallNonPagedLookasideListAllocateHits;
  uint32_t SmallPagedLookasideListAllocateHits;
  uint32_t Reserved3;
  uint32_t MmSystemCachePage;
  uint32_t PagedPoolPage;
  uint32_t SystemDriverPage;
  uint32_t FastReadNoWait;
  uint32_t FastReadWait;
  uint32_t FastReadResourceMiss;
  uint32_t FastReadNotPossible;
  uint32_t FastMdlReadNoWait;
  uint32_t FastMdlReadWait;
  uint32_t FastMdlReadResourceMiss;
  uint32_t FastMdlReadNotPossible;
  uint32_t MapDataNoWait;
  uint32_t MapDataWait;
  uint32_t MapDataNoWaitMiss;
  uint32_t MapDataWaitMiss;
  uint32_t PinMappedDataCount;
  uint32_t PinReadNoWait;
  uint32_t PinReadWait;
  uint32_t PinReadNoWaitMiss;
  uint32_t PinReadWaitMiss;
  uint32_t CopyReadNoWait;
  uint32_t CopyReadWait;
  uint32_t CopyReadNoWaitMiss;
  uint32_t CopyReadWaitMiss;
  uint32_t MdlReadNoWait;
  uint32_t MdlReadWait;
  uint32_t MdlReadNoWaitMiss;
  uint32_t MdlReadWaitMiss;
  uint32_t ReadAheadIos;
  uint32_t LazyWriteIos;
  uint32_t LazyWritePages;
  uint32_t DataFlushes;
  uint32_t DataPages;
  uint32_t ContextSwitches;
  uint32_t FirstLevelTbFills;
  uint32_t SecondLevelTbFills;
  uint32_t SystemCalls;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSINFORMATION_H_


/*!BEGIN libc/nt/struct/vmcounters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_VMCOUNTERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtVmCounters {
  size_t PeakVirtualSize;
  size_t VirtualSize;
  uint32_t PageFaultCount;
  size_t PeakWorkingSetSize;
  size_t WorkingSetSize;
  size_t QuotaPeakPagedPoolUsage;
  size_t QuotaPagedPoolUsage;
  size_t QuotaPeakNonPagedPoolUsage;
  size_t QuotaNonPagedPoolUsage;
  size_t PagefileUsage;
  size_t PeakPagefileUsage;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessInformation {
  uint32_t NextEntryOffset;
  uint32_t NumberOfThreads;
  int64_t Reserved[3];
  int64_t CreateTime;
  int64_t UserTime;
  int64_t KernelTime;
  struct NtUnicodeString ImageName;
  int32_t BasePriority;
  int64_t UniqueProcessId;
  int64_t InheritedFromUniqueProcessId;
  uint32_t HandleCount;
  uint32_t SessionId;
  uint32_t PageDirectoryBase;
  struct NtVmCounters VirtualMemoryCounters;
  size_t PrivatePageCount;
  struct NtIoCounters IoCounters;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessorinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSORINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessorInformation {
  unsigned short ProcessorArchitecture;
  unsigned short ProcessorLevel;
  unsigned short ProcessorRevision;
  unsigned short Unknown;
  uint32_t FeatureBits;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessorperformanceinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSORPERFORMANCEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessorPerformanceInformation {
  int64_t IdleTime;
  int64_t KernelTime;
  int64_t UserTime;
  int64_t Reserved1[2];
  uint32_t Reserved2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemregistryquotainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMREGISTRYQUOTAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemRegistryQuotaInformation {
  uint32_t RegistryQuotaAllowed;
  uint32_t RegistryQuotaUsed;
  void *Reserved1;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemthreads.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTHREADS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemThreads {
  int64_t KernelTime;
  int64_t UserTime;
  int64_t CreateTime;
  uint32_t WaitTime;
  void *StartAddress;
  struct NtClientId ClientId;
  int32_t Priority;
  int32_t BasePriority;
  uint32_t ContextSwitchCount;
  int State;
  uint32_t WaitReason;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemtime.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemTime {
  uint16_t wYear;
  uint16_t wMonth;
  uint16_t wDayOfWeek;
  uint16_t wDay;
  uint16_t wHour;
  uint16_t wMinute;
  uint16_t wSecond;
  uint16_t wMilliseconds;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemtimeofdayinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTIMEOFDAYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemTimeofdayInformation {
  int64_t BootTime;
  int64_t CurrentTime;
  int64_t TimeZoneBias;
  uint32_t CurrentTimeZoneId;
  unsigned char Reserved1[20];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/teb.h */

#define COSMOPOLITAN_LIBC_NT_TEB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

/*
 * These macros address directly into NT's TEB a.k.a. TIB
 * Any function that does this needs the `noasan` keyword
 */
#define NtGetPeb()           gs((struct NtPeb **)(0x60ULL))
#define NtGetTeb()           gs((void **)(0x30))    /* %gs:0 linear address */
#define NtGetPid()           gs((uint32_t *)(0x40)) /* GetCurrentProcessId() */
#define NtGetTid()           gs((uint32_t *)(0x48)) /* GetCurrentThreadId() */
#define NtGetErr()           gs((int *)(0x68))
#define _NtGetSeh()          gs((void **)(0x00))
#define _NtGetStackHigh()    gs((void **)(0x08))
#define _NtGetStackLow()     gs((void **)(0x10))
#define _NtGetSubsystemTib() gs((void **)(0x18))
#define _NtGetFib()          gs((void **)(0x20))
#define _NtGetEnv()          gs((char16_t **)(0x38))
#define _NtGetRpc()          gs((void **)(0x50))
#define _NtGetTls()          gs((void **)(0x58)) /* cf. gs((long *)0x1480 + i0..64) */

#endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/tokenprivileges.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_TOKENPRIVILEGES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtTokenPrivileges {
  uint32_t PrivilegeCount;
  struct NtLuidAndAttributes Privileges[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/userstack.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTUSERSTACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtUserStack {
  void *FixedStackBase;
  void *FixedStackLimit;
  void *ExpandableStackBase;
  void *ExpandableStackLimit;
  void *ExpandableStackBottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/valent.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_VALENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtValent {
  char16_t *ve_valuename;
  uint32_t ve_valuelen;
  uintptr_t ve_valueptr;
  uint32_t ve_type;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/win32fileattributedata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WIN32FILEATTRIBUTEDATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWin32FileAttributeData {
  uint32_t dwFileAttributes; /* ←NtFileFlagAndAttributes */
  struct NtFileTime ftCreationTime;
  struct NtFileTime ftLastAccessTime;
  struct NtFileTime ftLastWriteTime;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/win32finddata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WIN32FINDDATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWin32FindData {
  uint32_t dwFileAttributes;
  struct NtFileTime ftCreationTime;
  struct NtFileTime ftLastAccessTime;
  struct NtFileTime ftLastWriteTime;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
  uint32_t dwReserved0;
  uint32_t dwReserved1;
  char16_t cFileName[260];
  char16_t cAlternateFileName[14];
  uint32_t dwFileType;
  uint32_t dwCreatorType;
  uint16_t wFinderFlags;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/windowplacement.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WINDOWPLACEMENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWindowPlacement {
  uint32_t length;
  uint32_t flags;
  uint32_t showCmd;
  struct NtPoint ptMinPosition;
  struct NtPoint ptMaxPosition;
  struct NtRect rcNormalPosition;
  struct NtRect rcDevice;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/wndclass.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WNDCLASS_H_


/*!BEGIN libc/nt/typedef/wndproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_WNDPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int64_t (*NtWndProc)(int64_t, uint32_t, uint64_t, int64_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtWndClass {
  uint32_t style;
  NtWndProc lpfnWndProc;
  int32_t cbClsExtra;
  int32_t cbWndExtra;
  int64_t hInstance;
  int64_t hIcon;
  int64_t hCursor;
  int64_t hbrBackground;
  const char16_t *lpszMenuName;
  const char16_t *lpszClassName;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/wndclassex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WNDCLASSEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtWndClassEx {
  uint32_t cbSize;
  uint32_t style;
  NtWndProc lpfnWndProc;
  int32_t cbClsExtra;
  int32_t cbWndExtra;
  int64_t hInstance;
  int64_t hIcon;
  int64_t hCursor;
  int64_t hbrBackground;
  const char16_t *lpszMenuName;
  const char16_t *lpszClassName;
  int64_t hIconSm;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/exceptionhandler.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_EXCEPTIONHANDLER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef unsigned (*NtExceptionHandler)(struct NtExceptionRecord *,
                                       struct NtExceptionFrame *,
                                       struct NtContext *, void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/handlerroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_HANDLERROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef bool32 (*NtHandlerRoutine)(uint32_t);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/hookproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_HOOKPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef intptr_t (*NtHookProc)(int code, uintptr_t wParam, intptr_t lParam);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/imagetlscallback.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_IMAGETLSCALLBACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtImageTlsCallback)(void *DllHandle, uint32_t Reason,
                                   void *Reserved);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/ioapcroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_IOAPCROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtIoApcRoutine)(void *ApcContext,
                               struct NtIoStatusBlock *IoStatusBlock,
                               uint32_t Reserved);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/pknormalroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_PKNORMALROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtPkNormalRoutine)(void *NormalContext, void *SystemArgument1,
                                  void *SystemArgument2);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/timerproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_TIMERPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtTimerProc)(int64_t, uint32_t, uintptr_t, uint32_t);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/wambda.h */

#define COSMOPOLITAN_LIBC_NT_WAMBDA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef intptr_t (*wambda)();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/wndenumproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_WNDENUMPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef int (*NtWndEnumProc)(int64_t foo, intptr_t bar);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/thunk/msabi.h */

#define COSMOPOLITAN_LIBC_NT_THUNK_MSABI_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if !defined(__STRICT_ANSI__) &&               \
    (__GNUC__ * 100 + __GNUC_MINOR__ >= 408 || \
     (__has_attribute(__ms_abi__) || defined(__llvm__)))
/**
 * Defines function as using Microsoft x64 calling convention.
 *
 * This can be used to define prototypes that allow modern compilers to
 * generate code that calls MS ABI functions directly, without needing
 * to jump through the assembly thunks.
 */
#define __msabi __attribute__((__ms_abi__))
#endif

/*
 * Returns true if header should provide MS-ABI overrides.
 */
#ifndef ShouldUseMsabiAttribute
#if defined(__msabi) && defined(NDEBUG) && !defined(__PG__)
#define ShouldUseMsabiAttribute() 1
#else
#define ShouldUseMsabiAttribute() 0
#endif
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/debug.h */

#define COSMOPOLITAN_LIBC_NT_NT_DEBUG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » debugging              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtContinue(struct NtContext *Context, int32_t TestAlert);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/file.h */

#define COSMOPOLITAN_LIBC_NT_NT_FILE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » files                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtIoStatusBlock;
struct NtObjectAttributes;

NtStatus NtClose(int64_t handle);

NtStatus NtCreateFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                      struct NtObjectAttributes *ObjectAttributes,
                      struct NtIoStatusBlock *out_IoStatusBlock,
                      int64_t *opt_AllocationSize, uint32_t FileAttributes,
                      uint32_t ShareAccess, uint32_t CreateDisposition,
                      uint32_t CreateOptions, void *opt_EaBuffer,
                      uint32_t EaLength);

NtStatus NtReadFile(int64_t FileHandle, void *opt_Event,
                    NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                    struct NtIoStatusBlock *out_IoStatusBlock, void *out_Buffer,
                    uint32_t Length, int64_t *opt_ByteOffset,
                    uint32_t *opt_Key);

NtStatus NtWriteFile(int64_t FileHandle, void *opt_Event,
                     NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                     struct NtIoStatusBlock *out_IoStatusBlock,
                     const void *Buffer, uint32_t Length,
                     int64_t *opt_ByteOffset, uint32_t *opt_Key);

NtStatus NtDuplicateObject(int64_t SourceProcessHandle, void *SourceHandle,
                           void *TargetProcessHandle,
                           void **opt_out_TargetHandle, uint32_t DesiredAcess,
                           uint32_t Attributes, uint32_t options_t);

NtStatus NtQueryInformationFile(int64_t FileHandle,
                                struct NtIoStatusBlock *out_IoStatusBlock,
                                void *out_FileInformation,
                                uint32_t FileInformationLength,
                                uint32_t FileInformationClass);

NtStatus NtSetInformationFile(int64_t FileHandle,
                              struct NtIoStatusBlock *out_IoStatusBlock,
                              void *FileInformation,
                              uint32_t FileInformationLength,
                              uint32_t FileInformationClass);

NtStatus NtDeviceIoControlFile(
    int64_t FileHandle, int64_t opt_Event, NtIoApcRoutine opt_ApcRoutine,
    void *opt_ApcContext, struct NtIoStatusBlock *out_IoStatusBlock,
    uint32_t IoControlCode, void *opt_InputBuffer, uint32_t InputBufferLength,
    void *opt_out_OutputBuffer, uint32_t OutputBufferLength);

NtStatus NtCancelIoFileEx(int64_t FileHandle,
                          struct NtIoStatusBlock *IoRequestToCancel,
                          struct NtIoStatusBlock *IoStatusBlock);

NtStatus RtlNtStatusToDosError(NtStatus Status);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/ntfile.inc */

#define NtQueryInformationFile(...) __imp_NtQueryInformationFile(__VA_ARGS__)

extern typeof(NtQueryInformationFile) *const
    __imp_NtQueryInformationFile __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/ipc.h */

#define COSMOPOLITAN_LIBC_NT_NT_IPC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » ipc                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtIoStatusBlock;
struct NtObjectAttributes;

NtStatus NtCreateNamedPipeFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                               struct NtObjectAttributes *ObjectAttributes,
                               struct NtIoStatusBlock *out_IoStatusBlock,
                               uint32_t ShareAccess, uint32_t CreateDisposition,
                               uint32_t CreateOptions, int32_t TypeMessage,
                               int32_t ReadmodeMessage, int32_t Nonblocking,
                               uint32_t MaxInstances, uint32_t InBufferSize,
                               uint32_t OutBufferSize,
                               int64_t *opt_DefaultTimeout);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/key.h */

#define COSMOPOLITAN_LIBC_NT_NT_EVENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » files                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtCreateKeyedEvent(int64_t *KeyedEventHandle, uint32_t DesiredAccess,
                            struct NtObjectAttributes *ObjectAttributes,
                            uint32_t Flags);

NtStatus NtReleaseKeyedEvent(int64_t KeyedEventHandle, void *KeyValue,
                             bool32 Alertable, int64_t *Timeout);

NtStatus NtWaitForKeyedEvent(int64_t KeyedEventHandle, void *KeyValue,
                             bool32 Alertable, int64_t *Timeout);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/loader.h */

#define COSMOPOLITAN_LIBC_NT_NT_LOADER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » loader                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtAnsiString;
struct NtLdrDataTableEntry;
struct NtUnicodeString;

NtStatus LdrLoadDll(const char16_t *opt_PathToFile, uint32_t *opt_Flags,
                    struct NtUnicodeString *ModuleFileName,
                    void **out_ModuleHandle);
NtStatus LdrUnloadDll(void *ModuleHandle);
NtStatus LdrGetProcedureAddress(void *ModuleHandle,
                                struct NtAnsiString *opt_ProcedureName,
                                uint32_t opt_Ordinal,
                                wambda *out_ProcedureAddress);
NtStatus LdrGetDllHandle(const char16_t *opt_PathToFile, uint32_t opt_Unused,
                         struct NtUnicodeString *ModuleFileName,
                         void **out_ModuleHandle);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/memory.h */

#define COSMOPOLITAN_LIBC_NT_NT_MEMORY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » memory                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtAllocateVirtualMemory(int64_t ProcessHandle,
                                 void **inout_BaseAddress, uint32_t dwZeroBits,
                                 uint32_t *inout_AllocationSize,
                                 uint32_t dwMemAllocationType,
                                 uint32_t dwPageProtect);
NtStatus NtFreeVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                             size_t *inout_FreeSize, uint32_t FreeType);
NtStatus NtQueryVirtualMemory(int64_t ProcessHandle, const void *BaseAddress,
                              int MemoryInformationClass,
                              void *out_MemoryInformation,
                              size_t MemoryInformationLength,
                              size_t *opt_out_ReturnLength);
NtStatus NtProtectVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                                uint32_t *inout_ProtectSize,
                                uint32_t NewProtect, uint32_t *out_OldProtect);
NtStatus NtWriteVirtualMemory(int64_t ProcessHandle, void *BaseAddress,
                              const void *Buffer, size_t BufferLength,
                              size_t *opt_out_ReturnLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/process.h */

#define COSMOPOLITAN_LIBC_NT_NT_PROCESS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » processes              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtClientId;
struct NtObjectAttributes;
struct NtRtlUserProcessInformation;
struct NtRtlUserProcessParameters;
struct NtSecurityDescriptor;
struct NtUnicodeString;

NtStatus NtCreateProcess(int64_t *out_ProcessHandle, uint32_t dwDesiredAccess,
                         struct NtObjectAttributes *opt_ObjectAttributes,
                         void *InheritFromProcessHandle, int32_t InheritHandles,
                         void *opt_SectionHandle, void *opt_DebugPort,
                         void *opt_ExceptionPort);
NtStatus NtTerminateProcess(int64_t opt_ProcessHandle, int32_t ExitStatus);

NtStatus NtQueryInformationProcess(int64_t ProcessHandle,
                                   int ProcessInformationClass,
                                   void *out_ProcessInformation,
                                   uint32_t ProcessInformationLength,
                                   uint32_t *opt_out_ReturnLength);
NtStatus NtOpenProcessToken(int64_t ProcessToken, uint32_t DesiredAccess,
                            int64_t *out_TokenHandle);
NtStatus NtOpenProcess(int64_t *out_ProcessHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       struct NtClientId *ClientId);

NtStatus RtlCreateProcessParameters(
    struct NtRtlUserProcessParameters **out_ProcessParameters,
    struct NtUnicodeString *ImageFile, struct NtUnicodeString *opt_DllPath,
    struct NtUnicodeString *opt_CurrentDirectory,
    struct NtUnicodeString *opt_CommandLine, uint32_t CreationFlags,
    struct NtUnicodeString *opt_WindowTitle,
    struct NtUnicodeString *opt_Desktop, struct NtUnicodeString *opt_Reserved,
    struct NtUnicodeString *opt_Reserved2);

NtStatus RtlDestroyProcessParameters(
    struct NtRtlUserProcessParameters *ProcessParameters);

NtStatus RtlCloneUserProcess(
    uint32_t ProcessFlags,
    struct NtSecurityDescriptor *opt_ProcessSecurityDescriptor,
    struct NtSecurityDescriptor *opt_ThreadSecurityDescriptor,
    void *opt_DebugPort,
    struct NtRtlUserProcessInformation *ProcessInformation);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/nt/thunk/process.inc */

#define NtQueryInformationProcess(...) \
  __imp_NtQueryInformationProcess(__VA_ARGS__)

extern typeof(NtQueryInformationProcess) *const
    __imp_NtQueryInformationProcess __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/sections.h */

#define COSMOPOLITAN_LIBC_NT_NT_SECTIONS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

NtStatus NtCreateSection(int64_t *out_SectionHandle, uint32_t DesiredAccess,
                         struct NtObjectAttributes *ObjectAttributes,
                         int64_t *opt_SectionSize, uint32_t Protect,
                         uint32_t Attributes, int64_t FileHandle);
NtStatus NtOpenSection(int64_t *out_SectionHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes);
NtStatus NtMapViewOfSection(int64_t SectionHandle, int64_t ProcessHandle,
                            void **inout_BaseAddress, uint32_t *ZeroBits,
                            size_t CommitSize, int64_t *opt_inout_SectionOffset,
                            size_t *inout_ViewSize, int InheritDisposition,
                            uint32_t AllocationType, uint32_t Protect);
NtStatus NtUnmapViewOfSection(int64_t ProcessHandle, void *BaseAddress);
NtStatus NtQuerySection(int64_t SectionHandle, int SectionInformationClass,
                        void *out_SectionInformation,
                        uint32_t SectionInformationLength,
                        uint32_t *opt_out_ResultLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/signing.h */

#define COSMOPOLITAN_LIBC_NT_NT_SIGNING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » code signing           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus CsrClientCallServer(void *inout_Message, void *unknown,
                             uint32_t Opcode, uint32_t Size);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/thread.h */

#define COSMOPOLITAN_LIBC_NT_NT_THREAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » threads                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtClientId;
struct NtContext;
struct NtObjectAttributes;
struct NtUserStack;

NtStatus NtCreateThread(int64_t *out_ThreadHandle, uint32_t DesiredAccess,
                        struct NtObjectAttributes *ObjectAttributes,
                        int64_t ProcessHandle, struct NtClientId *out_ClientId,
                        struct NtContext *ThreadContext,
                        struct NtUserStack *UserStack, int32_t CreateSuspended);

NtStatus NtTerminateThread(void *opt_ThreadHandle, int32_t ExitStatus);

NtStatus NtOpenThread(int64_t *out_ThreadHandle, uint32_t DesiredAccess,
                      struct NtObjectAttributes *ObjectAttributes,
                      struct NtClientId *ClientId);

NtStatus NtQueryInformationThread(int64_t ThreadHandle,
                                  enum NtThreadInfoClass ThreadInformationClass,
                                  void *out_ThreadInformation,
                                  uint32_t ThreadInformationLength,
                                  uint32_t *opt_out_ReturnLength);

NtStatus NtGetContextThread(int64_t ThreadHandle,
                            struct NtContext *out_Context);
NtStatus NtSetContextThread(int64_t ThreadHandle, struct NtContext *Context);
NtStatus NtSuspendThread(int64_t ThreadHandle,
                         uint32_t *opt_out_PreviousSuspendCount);
NtStatus NtResumeThread(int64_t ThreadHandle,
                        uint32_t *opt_out_PreviousSuspendCount);

NtStatus NtOpenThreadToken(int64_t ThreadHandle, uint32_t DesiredAccess,
                           int32_t OpenAsSelf, int64_t *out_TokenHandle);

NtStatus NtSetInformationThread(int64_t ThreadHandle,
                                enum NtThreadInfoClass ThreadInformationClass,
                                void *ThreadInformation,
                                uint32_t ThreadInformationLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/time.h */

#define COSMOPOLITAN_LIBC_NT_NT_THREAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » time                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtDelayExecution(bool32 alertable, int64_t *AbsCobolOrNegRelHectoNano);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/nt/thunk/time.inc */

#define NtDelayExecution(...) __imp_NtDelayExecution(__VA_ARGS__)

extern typeof(NtDelayExecution) *const __imp_NtDelayExecution __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/accounting.h */

#define COSMOPOLITAN_LIBC_NT_ACCOUNTING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » accounting                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

uint32_t GetMaximumProcessorCount(uint16_t GroupNumber);
int GetUserName(char16_t (*buf)[257], uint32_t *in_out_size);
bool32 GlobalMemoryStatusEx(struct NtMemoryStatusEx *lpBuffer);
int32_t GetExitCodeProcess(int64_t hProcess, uint32_t *lpExitCode);
int32_t GetProcessHandleCount(int64_t hProcess, uint32_t *pdwHandleCount);
bool32 GetSystemTimes(struct NtFileTime *opt_out_lpIdleTime,
                      struct NtFileTime *opt_out_lpKernelTime,
                      struct NtFileTime *opt_out_lpUserTime);
bool32 GetProcessTimes(int64_t hProcess,
                       struct NtFileTime *out_lpCreationFileTime,
                       struct NtFileTime *out_lpExitFileTime,
                       struct NtFileTime *out_lpKernelFileTime,
                       struct NtFileTime *out_lpUserFileTime);
bool32 GetThreadTimes(int64_t hThread,
                      struct NtFileTime *out_lpCreationFileTime,
                      struct NtFileTime *out_lpExitFileTime,
                      struct NtFileTime *out_lpKernelFileTime,
                      struct NtFileTime *out_lpUserFileTime);
int32_t GetProcessIoCounters(int64_t hProcess,
                             struct NtIoCounters *lpIoCounters);
int32_t GetProcessWorkingSetSize(int64_t hProcess,
                                 uint64_t *lpMinimumWorkingSetSize,
                                 uint64_t *lpMaximumWorkingSetSize);
int32_t GetProcessWorkingSetSizeEx(int64_t hProcess,
                                   uint64_t *lpMinimumWorkingSetSize,
                                   uint64_t *lpMaximumWorkingSetSize,
                                   uint32_t *Flags);
int32_t SetProcessWorkingSetSize(int64_t hProcess,
                                 uint64_t dwMinimumWorkingSetSize,
                                 uint64_t dwMaximumWorkingSetSize);
int32_t SetProcessWorkingSetSizeEx(int64_t hProcess,
                                   uint64_t dwMinimumWorkingSetSize,
                                   uint64_t dwMaximumWorkingSetSize,
                                   uint32_t Flags);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/accounting.inc */

#define GetProcessTimes(...) __imp_GetProcessTimes(__VA_ARGS__)
extern typeof(GetProcessTimes) *const __imp_GetProcessTimes __msabi;

#define GetThreadTimes(...) __imp_GetThreadTimes(__VA_ARGS__)
extern typeof(GetThreadTimes) *const __imp_GetThreadTimes __msabi;

#define GetUserName(...) __imp_GetUserNameW(__VA_ARGS__)
extern typeof(GetUserName) *const __imp_GetUserNameW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/automation.h */

#define COSMOPOLITAN_LIBC_NT_AUTOMATION_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » aol hacking                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t GetShellWindow(void);
int64_t GetDesktopWindow(void);
int64_t GetParent(int64_t hWnd);
int64_t SetParent(int64_t hWndChild, int64_t hWndNewParent);
int32_t EnumChildWindows(int64_t hWndParent, NtWndEnumProc lpEnumFunc,
                         intptr_t lParam);
int64_t FindWindow(const char16_t *lpClassName, const char16_t *lpWindowName);
int64_t FindWindowEx(int64_t hWndParent, int64_t hWndChildAfter,
                     const char16_t *lpszClass, const char16_t *lpszWindow);
int64_t GetWindow(int64_t hWnd, uint32_t uCmd);
int64_t SetWindowsHook(int nFilterType, NtHookProc pfnFilterProc);
int32_t UnhookWindowsHook(int nCode, NtHookProc pfnFilterProc);
int64_t SetWindowsHookEx(int idHook, NtHookProc lpfn, int64_t hmod,
                         uint32_t dwThreadId);
int32_t UnhookWindowsHookEx(int64_t hhk);
intptr_t CallNextHookEx(int64_t hhk, int nCode, uintptr_t wParam,
                        intptr_t lParam);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/codegen.h */

#define COSMOPOLITAN_LIBC_NT_CODEGEN_H_


/*!BEGIN libc/nt/comdlg.h */

#define COSMOPOLITAN_LIBC_NT_COMDLG_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » common dialogs                           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 GetOpenFileName(struct NtOpenFilename *arg);
bool32 GetSaveFileName(struct NtOpenFilename *arg);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/console.h */

#define COSMOPOLITAN_LIBC_NT_CONSOLE_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » console                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtAttachParentProcess -1u

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 WriteConsoleOutput(int64_t hConsoleOutput,
                          const struct NtCharInfo *lpBuffer,
                          struct NtCoord dwBufferSize,
                          struct NtCoord dwBufferCoord,
                          struct NtSmallRect *lpWriteRegion);
bool32 ReadConsoleInput(int64_t hConsoleInput, struct NtInputRecord *lpBuffer,
                        uint32_t nLength, uint32_t *lpNumberOfEventsRead);
bool32 PeekConsoleInput(int64_t hConsoleInput, struct NtInputRecord *lpBuffer,
                        uint32_t nLength, uint32_t *lpNumberOfEventsRead);
bool32 GetNumberOfConsoleInputEvent(int64_t hConsoleInput,
                                    uint32_t *lpNumberOfEvents);
bool32 ReadConsoleOutput(int64_t hConsoleOutput, struct NtCharInfo *lpBuffer,
                         struct NtCoord dwBufferSize,
                         struct NtCoord dwBufferCoord,
                         struct NtSmallRect *lpReadRegion);
bool32 WriteConsoleInput(int64_t hConsoleInput,
                         const struct NtInputRecord *lpBuffer, uint32_t nLength,
                         uint32_t *lpNumberOfEventsWritten);
bool32 FlushConsoleInputBuffer(int64_t hConsoleInput);

int64_t GetConsoleWindow(void);
bool32 GetConsoleMode(int64_t hConsoleHandle, uint32_t *lpMode);
bool32 SetConsoleMode(int64_t hConsoleHandle, uint32_t dwMode);
int32_t AllocConsole(void);
int32_t FreeConsole(void);
int32_t AttachConsole(uint32_t dwProcessId);
uint32_t GetConsoleTitle(char16_t *lpConsoleTitle, uint32_t nSize);
int32_t SetConsoleTitle(const char16_t *lpConsoleTitle);
bool32 GetConsoleScreenBufferInfo(
    int64_t hConsoleOutput,
    struct NtConsoleScreenBufferInfo *out_lpConsoleScreenBufferInfo);
bool32 GetConsoleScreenBufferInfoEx(
    int64_t hConsoleOutput,
    struct NtConsoleScreenBufferInfoEx *in_out_lpConsoleScreenBufferInfo);
bool32 SetConsoleScreenBufferInfoEx(
    int64_t hConsoleOutput,
    const struct NtConsoleScreenBufferInfoEx *lpConsoleScreenBufferInfo);
bool32 SetConsoleScreenBufferSize(int64_t lpConsoleOutput,
                                  struct NtCoord dwSize);
struct NtCoord GetLargestConsoleWindowSize(int64_t hConsoleHandle);
int32_t ReadConsole(int64_t hConsoleInput, void *lpBuffer,
                    uint32_t nNumberOfCharsToRead,
                    uint32_t *lpNumberOfCharsRead, void *lpReserved);
int32_t WriteConsole(int64_t hConsoleOutput, const void *lpBuffer,
                     uint32_t nNumberOfCharsToWrite,
                     uint32_t *lpNumberOfCharsWritten, void *lpReserved)
    paramsnonnull((2, 4));
bool32 GetNumberOfConsoleMouseButtons(uint32_t *out_lpNumberOfMouseButtons)
    paramsnonnull();
bool32 GetConsoleSelectionInfo(
    struct NtConsoleSelectionInfo *out_lpConsoleSelectionInfo);
uint32_t WaitForInputIdle(int64_t hProcess, uint32_t dwMilliseconds);
uint32_t GetConsoleCP(void);
bool32 SetConsoleCP(uint32_t wCodePageID);
bool32 SetConsoleOutputCP(uint32_t wCodePageID);
uint32_t GetConsoleOutputCP(void);
bool32 SetConsoleCtrlHandler(NtHandlerRoutine opt_HandlerRoutine, bool32 Add);
bool32 GenerateConsoleCtrlEvent(uint32_t dwCtrlEvent,
                                uint32_t dwProcessGroupId);

bool32 GetConsoleCursorInfo(
    int64_t hConsoleOutput,
    struct NtConsoleCursorInfo *out_lpConsoleCursorInfo);
bool32 SetConsoleCursorInfo(
    int64_t hConsoleOutput,
    const struct NtConsoleCursorInfo *lpConsoleCursorInfo);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/console.inc */

#define GetConsoleMode(...) __imp_GetConsoleMode(__VA_ARGS__)
extern typeof(GetConsoleMode) *const __imp_GetConsoleMode __msabi;

#define SetConsoleCP(...) __imp_SetConsoleCP(__VA_ARGS__)
extern typeof(SetConsoleCP) *const __imp_SetConsoleCP __msabi;

#define GetConsoleCP(...) __imp_GetConsoleCP(__VA_ARGS__)
extern typeof(GetConsoleCP) *const __imp_GetConsoleCP __msabi;

#define SetConsoleCtrlHandler(...) __imp_SetConsoleCtrlHandler(__VA_ARGS__)
extern typeof(SetConsoleCtrlHandler) *const __imp_SetConsoleCtrlHandler __msabi;

#define SetConsoleMode(...) __imp_SetConsoleMode(__VA_ARGS__)
extern typeof(SetConsoleMode) *const __imp_SetConsoleMode __msabi;

#define SetConsoleOutputCP(...) __imp_SetConsoleOutputCP(__VA_ARGS__)
extern typeof(SetConsoleOutputCP) *const __imp_SetConsoleOutputCP __msabi;

#define GetConsoleOutputCP(...) __imp_GetConsoleOutputCP(__VA_ARGS__)
extern typeof(GetConsoleOutputCP) *const __imp_GetConsoleOutputCP __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/createfile.h */

#define COSMOPOLITAN_LIBC_NT_CREATEFILE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t CreateFile(
    const char16_t *lpFileName, uint32_t dwDesiredAccess, uint32_t dwShareMode,
    struct NtSecurityAttributes *opt_lpSecurityAttributes,
    int dwCreationDisposition,
    uint32_t dwFlagsAndAttributes, /* libc/nt/enum/fileflagandattributes.h */
    int64_t opt_hTemplateFile) paramsnonnull((1));

int64_t CreateFileA(
    const char *lpFileName, uint32_t dwDesiredAccess, uint32_t dwShareMode,
    struct NtSecurityAttributes *opt_lpSecurityAttributes,
    int dwCreationDisposition,
    uint32_t dwFlagsAndAttributes, /* libc/nt/enum/fileflagandattributes.h */
    int64_t opt_hTemplateFile) paramsnonnull((1));

int GetNtOpenFlags(int flags, int mode, uint32_t *out_perm, uint32_t *out_share,
                   uint32_t *out_disp, uint32_t *out_attr);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/debug.h */

#define COSMOPOLITAN_LIBC_NT_DEBUG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » debugging                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/* Some of these APIs were moved to system.h and libc.h */
int32_t DebugBreakProcess(void *Process);
int32_t DebugActiveProcess(uint32_t dwProcessId);
int32_t DebugActiveProcessStop(uint32_t dwProcessId);
int32_t CheckRemoteDebuggerPresent(int64_t hProcess, int *pbDebuggerPresent);
int32_t ContinueDebugEvent(uint32_t dwProcessId, uint32_t dwThreadId,
                           uint32_t dwContinueStatus);
void FatalExit(int uExitCode);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/dll.h */

#define COSMOPOLITAN_LIBC_NT_DLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » dynamic link libraries                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int64_t LoadLibrary(const char16_t *lpLibFileName);
int64_t LoadLibraryEx(const char16_t *lpLibFileName, int64_t hFile,
                      uint32_t dwFlags);
uint32_t GetModuleFileNameA(int64_t hModule, char *lpFilename, uint32_t nSize);
intptr_t GetModuleHandle(const char *opt_lpModuleName);
intptr_t GetModuleHandleW(const char16_t *opt_lpModuleName);
void *GetProcAddress(int64_t hModule, const char *lpProcName);
int32_t FreeResource(int64_t hResData);
intptr_t LockResource(int64_t hResData);
int32_t FreeLibrary(int64_t hLibModule);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/efi.h */

#define COSMOPOLITAN_LIBC_NT_EFI_H_
/*
    ▐██ ░█████████▓   ▐██▌     ██▓░   ▐█▌  ▐██  ░██░    ▓█▌  ▓██▒     ▓██
    ▐██     ░██░     ▒█▓██░    ████░  ▐█▌  ▐██  ░██░    ▓█▌  ▓███░   ▓███
    ▐██     ░██░     ██░▐█▓    ██▒▓█░ ▐█▌  ▐██  ░██░    ▓█▌  ▓█▌▓█░ ▓█▒██
    ▐██     ░██░    ▐█▌  ▓█▌   ██░░▓█░▐█▌  ▐██  ░██░    ▓█▌  ▓█▌░█▓▓█▒░██
    ▐██     ░██░   ▒██▓█████░  ██░ ░▓▓▓█▌  ▐██  ░██░    ██░  ▓█▌ ░██▌ ░██
    ▐██     ░██░   ▓█▌    ▓█▓  ██░  ░███▌  ▐██   ▐██▄▄▄▓█▓   ▓█▌      ░██
╔────────────────────────────────────────────────────────────────────────────│─╗
│ αcτµαlly pδrταblε εxεcµταblε § the unified extensible firmware interface ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define EFI_SUCCESS           0x8000000000000000
#define EFI_LOAD_ERROR        0x8000000000000001
#define EFI_INVALID_PARAMETER 0x8000000000000002
#define EFI_UNSUPPORTED       0x8000000000000003
#define EFI_BAD_BUFFER_SIZE   0x8000000000000004
#define EFI_BUFFER_TOO_SMALL  0x8000000000000005
#define EFI_NOT_READY         0x8000000000000006
#define EFI_DEVICE_ERROR      0x8000000000000007
#define EFI_WRITE_PROTECTED   0x8000000000000008
#define EFI_OUT_OF_RESOURCES  0x8000000000000009
#define EFI_VOLUME_CORRUPTED  0x800000000000000a
#define EFI_VOLUME_FULL       0x800000000000000b
#define EFI_NO_MEDIA          0x800000000000000c
#define EFI_MEDIA_CHANGED     0x800000000000000d
#define EFI_NOT_FOUND         0x800000000000000e
#define EFI_ACCESS_DENIED     0x800000000000000f
#define EFI_NO_RESPONSE       0x8000000000000010
#define EFI_NO_MAPPING        0x8000000000000011
#define EFI_TIMEOUT           0x8000000000000012
#define EFI_NOT_STARTED       0x8000000000000013
#define EFI_ALREADY_STARTED   0x8000000000000014
#define EFI_ABORTED           0x8000000000000015
#define EFI_ICMP_ERROR        0x8000000000000016
#define EFI_TFTP_ERROR        0x8000000000000017
#define EFI_PROTOCOL_ERROR    0x8000000000000018

#define EFI_VARIABLE_NON_VOLATILE                          0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS                        0x00000004
#define EFI_VARIABLE_HARDWARE_ERROR_RECORD                 0x00000008
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define EFI_VARIABLE_APPEND_WRITE                          0x00000040

#define EFI_MEMORY_UC            0x0000000000000001U
#define EFI_MEMORY_WC            0x0000000000000002U
#define EFI_MEMORY_WT            0x0000000000000004U
#define EFI_MEMORY_WB            0x0000000000000008U
#define EFI_MEMORY_UCE           0x0000000000000010U
#define EFI_MEMORY_WP            0x0000000000001000U
#define EFI_MEMORY_RP            0x0000000000002000U
#define EFI_MEMORY_XP            0x0000000000004000U
#define EFI_MEMORY_RO            0x0000000000020000U
#define EFI_MEMORY_NV            0x0000000000008000U
#define EFI_MEMORY_MORE_RELIABLE 0x0000000000010000U
#define EFI_MEMORY_RUNTIME       0x8000000000000000U

#define EFI_OPTIONAL_PTR 0x00000001

#define EFI_SCAN_NULL      0x0000
#define EFI_SCAN_UP        0x0001
#define EFI_SCAN_DOWN      0x0002
#define EFI_SCAN_RIGHT     0x0003
#define EFI_SCAN_LEFT      0x0004
#define EFI_SCAN_HOME      0x0005
#define EFI_SCAN_END       0x0006
#define EFI_SCAN_INSERT    0x0007
#define EFI_SCAN_DELETE    0x0008
#define EFI_SCAN_PAGE_UP   0x0009
#define EFI_SCAN_PAGE_DOWN 0x000A
#define EFI_SCAN_F1        0x000B
#define EFI_SCAN_F2        0x000C
#define EFI_SCAN_F3        0x000D
#define EFI_SCAN_F4        0x000E
#define EFI_SCAN_F5        0x000F
#define EFI_SCAN_F6        0x0010
#define EFI_SCAN_F7        0x0011
#define EFI_SCAN_F8        0x0012
#define EFI_SCAN_F9        0x0013
#define EFI_SCAN_F10       0x0014
#define EFI_SCAN_ESC       0x0017

#define EFI_EVT_TIMER                         0x80000000
#define EFI_EVT_RUNTIME                       0x40000000
#define EFI_EVT_NOTIFY_WAIT                   0x00000100
#define EFI_EVT_NOTIFY_SIGNAL                 0x00000200
#define EFI_EVT_SIGNAL_EXIT_BOOT_SERVICES     0x00000201
#define EFI_EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE 0x60000202
#define EFI_EVT_RUNTIME_CONTEXT               0x20000000

#define LOADED_IMAGE_PROTOCOL                        \
  {                                                  \
    0x5B1B31A1, 0x9562, 0x11d2, {                    \
      0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B \
    }                                                \
  }

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if defined(__GNUC__) && __GNUC__ >= 6 && !defined(__chibicc__)
#define EFIAPI __attribute__((__ms_abi__))
#else
#define EFIAPI /* TODO(jart): fix me */
#endif

#define EFI_STATUS uint64_t
#define EFI_EVENT  uintptr_t
#define EFI_HANDLE uintptr_t

typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL EFI_SIMPLE_TEXT_INPUT_PROTOCOL;
typedef struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

typedef enum {
  EfiReservedMemoryType,
  EfiLoaderCode,
  EfiLoaderData,
  EfiBootServicesCode,
  EfiBootServicesData,
  EfiRuntimeServicesCode,
  EfiRuntimeServicesData,
  EfiConventionalMemory,
  EfiUnusableMemory,
  EfiACPIReclaimMemory,
  EfiACPIMemoryNVS,
  EfiMemoryMappedIO,
  EfiMemoryMappedIOPortSpace,
  EfiPalCode,
  EfiPersistentMemory,
  EfiMaxMemoryType
} EFI_MEMORY_TYPE;

typedef enum {
  EfiResetCold,
  EfiResetWarm,
  EfiResetShutdown,
  EfiResetPlatformSpecific
} EFI_RESET_TYPE;

typedef enum {
  AllocateAnyPages,
  AllocateMaxAddress,
  AllocateAddress,
  MaxAllocateType
} EFI_ALLOCATE_TYPE;

typedef enum {
  TimerCancel,
  TimerPeriodic,
  TimerRelative,
} EFI_TIMER_DELAY;

typedef struct {
  uint32_t Resolution;
  uint32_t Accuracy;
  bool SetsToZero;
} EFI_TIME_CAPABILITIES;

typedef struct {
  uint32_t Data1;
  uint16_t Data2;
  uint16_t Data3;
  uint8_t Data4[8];
} EFI_GUID;

typedef struct {
  uint16_t Year;
  uint8_t Month;
  uint8_t Day;
  uint8_t Hour;
  uint8_t Minute;
  uint8_t Second;
  uint8_t Pad1;
  uint32_t Nanosecond;
  int16_t TimeZone;
  uint8_t Daylight;
  uint8_t Pad2;
} EFI_TIME;

typedef struct {
  uint32_t Type;
  uint64_t PhysicalStart;
  uint64_t VirtualStart;
  uint64_t NumberOfPages;
  uint64_t Attribute;
} EFI_MEMORY_DESCRIPTOR;

typedef struct {
  EFI_GUID VendorGuid;
  void *VendorTable;
} EFI_CONFIGURATION_TABLE;

typedef struct {
  EFI_GUID CapsuleGuid;
  uint32_t HeaderSize;
  uint32_t Flags;
  uint32_t CapsuleImageSize;
} EFI_CAPSULE_HEADER;

typedef struct {
  uint16_t ScanCode;
  char16_t UnicodeChar;
} EFI_INPUT_KEY;

typedef struct {
  int32_t MaxMode;
  int32_t Mode;
  int32_t Attribute;
  int32_t CursorColumn;
  int32_t CursorRow;
  bool CursorVisible;
} EFI_SIMPLE_TEXT_OUTPUT_MODE;

typedef struct {
  uint64_t Signature;
  uint32_t Revision;
  uint32_t HeaderSize;
  uint32_t CRC32;
  uint32_t Reserved;
} EFI_TABLE_HEADER;

typedef struct {
  uint8_t Type;
  uint8_t SubType;
  uint8_t Length[2];
} EFI_DEVICE_PATH_PROTOCOL;

typedef EFI_STATUS(EFIAPI *EFI_EXIT)(EFI_HANDLE ImageHandle,
                                     EFI_STATUS ExitStatus,
                                     uintptr_t ExitDataSize,
                                     char16_t *opt_ExitData);

typedef EFI_STATUS(EFIAPI *EFI_GET_VARIABLE)(char16_t *VariableName,
                                             EFI_GUID *VendorGuid,
                                             uint32_t *outopt_Attributes,
                                             uintptr_t *inout_DataSize,
                                             void *outopt_Data);
typedef EFI_STATUS(EFIAPI *EFI_SET_VARIABLE)(char16_t *VariableName,
                                             EFI_GUID *VendorGuid,
                                             uint32_t Attributes,
                                             uintptr_t DataSize, void *Data);
typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME)(
    uintptr_t *inout_VariableNameSize, char16_t *inout_VariableName,
    EFI_GUID *inout_VendorGuid);
typedef EFI_STATUS(EFIAPI *EFI_QUERY_VARIABLE_INFO)(
    uint32_t Attributes, uint64_t *out_MaximumVariableStorageSize,
    uint64_t *out_RemainingVariableStorageSize,
    uint64_t *out_MaximumVariableSize);

typedef EFI_STATUS(EFIAPI *EFI_ALLOCATE_PAGES)(EFI_ALLOCATE_TYPE Type,
                                               EFI_MEMORY_TYPE MemoryType,
                                               uintptr_t Pages,
                                               uint64_t *inout_Memory);
typedef EFI_STATUS(EFIAPI *EFI_FREE_PAGES)(uint64_t Memory, uintptr_t Pages);
typedef EFI_STATUS(EFIAPI *EFI_GET_MEMORY_MAP)(
    uintptr_t *inout_MemoryMapSize, EFI_MEMORY_DESCRIPTOR *inout_MemoryMap,
    uintptr_t *out_MapKey, uintptr_t *out_DescriptorSize,
    uint32_t *out_DescriptorVersion);

typedef EFI_STATUS(EFIAPI *EFI_ALLOCATE_POOL)(EFI_MEMORY_TYPE PoolType,
                                              uintptr_t Size, void *out_Buffer);
typedef EFI_STATUS(EFIAPI *EFI_FREE_POOL)(void *Buffer);
typedef void(EFIAPI *EFI_SET_MEM)(void *Buffer, uintptr_t Size, uint8_t Value);
typedef void(EFIAPI *EFI_COPY_MEM)(void *Destination, void *Source,
                                   uintptr_t Length);

typedef EFI_STATUS(EFIAPI *EFI_CHECK_EVENT)(EFI_EVENT Event);
typedef EFI_STATUS(EFIAPI *EFI_CLOSE_EVENT)(EFI_EVENT Event);
typedef EFI_STATUS(EFIAPI *EFI_SIGNAL_EVENT)(EFI_EVENT Event);
typedef EFI_STATUS(EFIAPI *EFI_WAIT_FOR_EVENT)(uintptr_t NumberOfEvents,
                                               EFI_EVENT *Events,
                                               uintptr_t *out_Index);
typedef EFI_STATUS(EFIAPI *EFI_SET_TIMER)(EFI_EVENT Event, EFI_TIMER_DELAY Type,
                                          uint64_t TriggerTime);
typedef void(EFIAPI *EFI_EVENT_NOTIFY)(EFI_EVENT Event, void *Context);
typedef EFI_STATUS(EFIAPI *EFI_CREATE_EVENT)(uint32_t Type, uintptr_t NotifyTpl,
                                             EFI_EVENT_NOTIFY NotifyFunction,
                                             void *NotifyContext,
                                             EFI_EVENT *out_Event);
typedef EFI_STATUS(EFIAPI *EFI_CREATE_EVENT_EX)(
    uint32_t Type, uintptr_t NotifyTpl, EFI_EVENT_NOTIFY opt_NotifyFunction,
    const void *opt_NotifyContext, const EFI_GUID *opt_EventGroup,
    EFI_EVENT *out_Event);

typedef EFI_STATUS(EFIAPI *EFI_UPDATE_CAPSULE)(
    EFI_CAPSULE_HEADER **CapsuleHeaderArray, uintptr_t CapsuleCount,
    uint64_t opt_ScatterGatherList);
typedef EFI_STATUS(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES)(
    EFI_CAPSULE_HEADER **CapsuleHeaderArray, uintptr_t CapsuleCount,
    uint64_t *out_MaximumCapsuleSize, EFI_RESET_TYPE *out_ResetType);
typedef EFI_STATUS(EFIAPI *EFI_GET_WAKEUP_TIME)(bool *out_Enabled,
                                                bool *out_Pending,
                                                EFI_TIME *out_Time);
typedef EFI_STATUS(EFIAPI *EFI_SET_WAKEUP_TIME)(bool Enable,
                                                EFI_TIME *opt_Time);
typedef EFI_STATUS(EFIAPI *EFI_SET_WATCHDOG_TIMER)(uintptr_t Timeout,
                                                   uint64_t WatchdogCode,
                                                   uintptr_t DataSize,
                                                   char16_t *opt_WatchdogData);

typedef EFI_STATUS(EFIAPI *EFI_SET_TIME)(EFI_TIME *Time);
typedef EFI_STATUS(EFIAPI *EFI_GET_TIME)(
    EFI_TIME *out_Time, EFI_TIME_CAPABILITIES *outopt_Capabilities);
typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT)(
    uint32_t *out_HighCount);
typedef EFI_STATUS(EFIAPI *EFI_STALL)(uintptr_t Microseconds);
typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT)(uint64_t *out_Count);

typedef EFI_STATUS(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP)(
    uintptr_t MemoryMapSize, uintptr_t DescriptorSize,
    uint32_t DescriptorVersion, EFI_MEMORY_DESCRIPTOR *VirtualMap);
typedef void(EFIAPI *EFI_RESET_SYSTEM)(EFI_RESET_TYPE ResetType,
                                       EFI_STATUS ResetStatus,
                                       uintptr_t DataSize, void *opt_ResetData);
typedef EFI_STATUS(EFIAPI *EFI_CONVERT_POINTER)(uintptr_t DebugDisposition,
                                                void **inout_Address);

typedef EFI_STATUS(EFIAPI *EFI_INPUT_RESET)(
    EFI_SIMPLE_TEXT_INPUT_PROTOCOL *This, bool ExtendedVerification);
typedef EFI_STATUS(EFIAPI *EFI_INPUT_READ_KEY)(
    EFI_SIMPLE_TEXT_INPUT_PROTOCOL *This, EFI_INPUT_KEY *out_Key);

typedef EFI_STATUS(EFIAPI *EFI_TEXT_RESET)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, bool ExtendedVerification);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_STRING)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, char16_t *String);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_TEST_STRING)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, char16_t *String);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_QUERY_MODE)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, uint64_t ModeNumber,
    uint64_t *out_Columns, uint64_t *out_Rows);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_MODE)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, uint64_t ModeNumber);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_ATTRIBUTE)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, uint64_t Attribute);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_CLEAR_SCREEN)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, uint64_t Column, uint64_t Row);
typedef EFI_STATUS(EFIAPI *EFI_TEXT_ENABLE_CURSOR)(
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, bool Visible);

typedef EFI_STATUS(EFIAPI *EFI_HANDLE_PROTOCOL)(EFI_HANDLE Handle,
                                                EFI_GUID *Protocol,
                                                void *out_Interface);

typedef EFI_STATUS(EFIAPI *EFI_IMAGE_LOAD)(bool BootPolicy,
                                           EFI_HANDLE ParentImageHandle,
                                           EFI_DEVICE_PATH_PROTOCOL *DevicePath,
                                           void *opt_SourceBuffer,
                                           uintptr_t SourceSize,
                                           EFI_HANDLE *out_ImageHandle);
typedef EFI_STATUS(EFIAPI *EFI_IMAGE_UNLOAD)(EFI_HANDLE ImageHandle);
typedef EFI_STATUS(EFIAPI *EFI_EXIT_BOOT_SERVICES)(EFI_HANDLE ImageHandle,
                                                   uintptr_t MapKey);

typedef struct {
  EFI_TABLE_HEADER Hdr;
  EFI_GET_TIME GetTime;
  EFI_SET_TIME SetTime;
  EFI_GET_WAKEUP_TIME GetWakeupTime;
  EFI_SET_WAKEUP_TIME SetWakeupTime;
  EFI_SET_VIRTUAL_ADDRESS_MAP SetVirtualAddressMap;
  EFI_CONVERT_POINTER ConvertPointer;
  EFI_GET_VARIABLE GetVariable;
  EFI_GET_NEXT_VARIABLE_NAME GetNextVariableName;
  EFI_SET_VARIABLE SetVariable;
  EFI_GET_NEXT_HIGH_MONO_COUNT GetNextHighMonotonicCount;
  EFI_RESET_SYSTEM ResetSystem;
  EFI_UPDATE_CAPSULE UpdateCapsule;
  EFI_QUERY_CAPSULE_CAPABILITIES QueryCapsuleCapabilities;
  EFI_QUERY_VARIABLE_INFO QueryVariableInfo;
} EFI_RUNTIME_SERVICES;

typedef struct {
  EFI_TABLE_HEADER Hdr;
  void *RaiseTPL;
  void *RestoreTPL;
  EFI_ALLOCATE_PAGES AllocatePages;
  EFI_FREE_PAGES FreePages;
  EFI_GET_MEMORY_MAP GetMemoryMap;
  EFI_ALLOCATE_POOL AllocatePool;
  EFI_FREE_POOL FreePool;
  EFI_CREATE_EVENT CreateEvent;
  EFI_SET_TIMER SetTimer;
  EFI_WAIT_FOR_EVENT WaitForEvent;
  EFI_SIGNAL_EVENT SignalEvent;
  EFI_CLOSE_EVENT CloseEvent;
  EFI_CHECK_EVENT CheckEvent;
  void *InstallProtocolInterface;
  void *ReinstallProtocolInterface;
  void *UninstallProtocolInterface;
  EFI_HANDLE_PROTOCOL HandleProtocol;
  void *Reserved;
  void *RegisterProtocolNotify;
  void *LocateHandle;
  void *LocateDevicePath;
  void *InstallConfigurationTable;
  EFI_IMAGE_LOAD LoadImage;
  void *StartImage;
  EFI_EXIT Exit;
  EFI_IMAGE_UNLOAD UnloadImage;
  EFI_EXIT_BOOT_SERVICES ExitBootServices;
  EFI_GET_NEXT_MONOTONIC_COUNT GetNextMonotonicCount;
  EFI_STALL Stall;
  EFI_SET_WATCHDOG_TIMER SetWatchdogTimer;
  void *ConnectController;
  void *DisconnectController;
  void *OpenProtocol;
  void *CloseProtocol;
  void *OpenProtocolInformation;
  void *ProtocolsPerHandle;
  void *LocateHandleBuffer;
  void *LocateProtocol;
  void *InstallMultipleProtocolInterfaces;
  void *UninstallMultipleProtocolInterfaces;
  void *CalculateCrc32;
  EFI_COPY_MEM CopyMem;
  EFI_SET_MEM SetMem;
  EFI_CREATE_EVENT_EX CreateEventEx;
} EFI_BOOT_SERVICES;

typedef struct {
  EFI_TABLE_HEADER Hdr;
  char16_t *FirmwareVendor;
  uint32_t FirmwareRevision;
  EFI_HANDLE ConsoleInHandle;
  EFI_SIMPLE_TEXT_INPUT_PROTOCOL *ConIn;
  EFI_HANDLE ConsoleOutHandle;
  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *ConOut;
  EFI_HANDLE StandardErrorHandle;
  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *StdErr;
  EFI_RUNTIME_SERVICES *RuntimeServices;
  EFI_BOOT_SERVICES *BootServices;
  uintptr_t NumberOfTableEntries;
  EFI_CONFIGURATION_TABLE *ConfigurationTable;
} EFI_SYSTEM_TABLE;

struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL {
  EFI_INPUT_RESET Reset;
  EFI_INPUT_READ_KEY ReadKeyStroke;
  EFI_EVENT WaitForKey;
};

struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
  EFI_TEXT_RESET Reset;
  EFI_TEXT_STRING OutputString;
  EFI_TEXT_TEST_STRING TestString;
  EFI_TEXT_QUERY_MODE QueryMode;
  EFI_TEXT_SET_MODE SetMode;
  EFI_TEXT_SET_ATTRIBUTE SetAttribute;
  EFI_TEXT_CLEAR_SCREEN ClearScreen;
  EFI_TEXT_SET_CURSOR_POSITION SetCursorPosition;
  EFI_TEXT_ENABLE_CURSOR EnableCursor;
  EFI_SIMPLE_TEXT_OUTPUT_MODE *Mode;
};

typedef struct {
  uint32_t Revision;
  EFI_HANDLE ParentHandle;
  EFI_SYSTEM_TABLE *SystemTable;
  EFI_HANDLE DeviceHandle;
  EFI_DEVICE_PATH_PROTOCOL *FilePath;
  void *Reserved;
  uint32_t LoadOptionsSize;
  void *LoadOptions;
  void *ImageBase;
  uint64_t ImageSize;
  EFI_MEMORY_TYPE ImageCodeType;
  EFI_MEMORY_TYPE ImageDataType;
  EFI_IMAGE_UNLOAD Unload;
} EFI_LOADED_IMAGE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/events.h */

#define COSMOPOLITAN_LIBC_NT_EVENTS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » events                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int32_t GetMessage(struct NtMsg *lpMsg, int64_t hWnd, uint32_t wMsgFilterMin,
                   uint32_t wMsgFilterMax);
int32_t TranslateMessage(const struct NtMsg *lpMsg);
intptr_t DispatchMessage(const struct NtMsg *lpMsg);
void PostQuitMessage(int nExitCode);
bool32 GetCursorPos(struct NtPoint *lpPoint);
int64_t SendMessage(int64_t hWnd, uint32_t Msg, uint64_t wParam,
                    int64_t lParam);

#define EVENTLOG_SUCCESS          0x00000000
#define EVENTLOG_ERROR_TYPE       0x00000001
#define EVENTLOG_WARNING_TYPE     0x00000002
#define EVENTLOG_INFORMATION_TYPE 0x00000004
#define EVENTLOG_AUDIT_SUCCESS    0x00000008
#define EVENTLOG_AUDIT_FAILURE    0x00000010

int32_t ReportEventA(int64_t handle, uint16_t wType, uint16_t wCategory,
                     uint32_t dwEventID, const char *lpUserId,
                     uint16_t wNumStrings, uint32_t dwDataSize,
                     const char **lpStrings, void **lpRawData);
int64_t RegisterEventSource(const char16_t *lpUNCServerName,
                            const char16_t *lpSourceName);
int32_t DeregisterEventSource(uint64_t handle);

int64_t CreateEvent(struct NtSecurityAttributes *lpEventAttributes,
                    bool32 bManualReset, bool32 bInitialState,
                    const char16_t *lpName);
int64_t CreateEventEx(struct NtSecurityAttributes *lpEventAttributes,
                      const char16_t *lpName, uint32_t dwFlags,
                      uint32_t dwDesiredAccess);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/files.h */

#define COSMOPOLITAN_LIBC_NT_FILES_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » files                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtHandleFlagInherit          1 /* SetHandleInformation */
#define kNtHandleFlagProtectFromClose 2

#define kNtFindFirstExCaseSensitive 1
#define kNtFindFirstExLargeFetch    2

#define kNtDuplicateCloseSource 1
#define kNtDuplicateSameAccess  2

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

intptr_t LoadResource(int64_t hModule, int64_t hResInfo);
uint32_t SetHandleCount(uint32_t uNumber);
uint32_t GetLogicalDrives(void);
bool32 FlushFileBuffers(int64_t hFile);

int64_t ReOpenFile(int64_t hOriginalFile, uint32_t dwDesiredAccess,
                   uint32_t dwShareMode, uint32_t dwFlagsAndAttributes);

bool32 DeleteFile(const char16_t *lpFileName) paramsnonnull();

bool32 CopyFile(const char16_t *lpExistingFileName,
                const char16_t *lpNewFileName, bool32 bFailIfExists)
    paramsnonnull();

bool32 MoveFile(const char16_t *lpExistingFileName,
                const char16_t *lpNewFileName) paramsnonnull();
bool32 MoveFileEx(const char16_t *lpExistingFileName,
                  const char16_t *lpNewFileName, int dwFlags) paramsnonnull();

bool32 SetCurrentDirectory(const char16_t *lpPathName);
uint32_t GetCurrentDirectory(uint32_t nBufferLength, char16_t *out_lpBuffer);

bool32 CreateDirectory(const char16_t *lpPathName,
                       struct NtSecurityAttributes *lpSecurityAttributes);
bool32 RemoveDirectory(const char16_t *lpPathName);

bool32 DuplicateHandle(int64_t hSourceProcessHandle, int64_t hSourceHandle,
                       int64_t hTargetProcessHandle, int64_t *lpTargetHandle,
                       uint32_t dwDesiredAccess, bool32 bInheritHandle,
                       uint32_t dwOptions);

bool32 GetHandleInformation(int64_t hObject, uint32_t *out_lpdwFlags);
bool32 SetHandleInformation(int64_t hObject, uint32_t dwMask, uint32_t dwFlags);
int GetFileType(int64_t hFile);

bool32 GetFileInformationByHandleEx(int64_t hFile,
                                    uint32_t FileInformationClass,
                                    void *out_lpFileInformation,
                                    uint32_t dwBufferSize);

bool32 GetFileInformationByHandle(
    int64_t hFile, struct NtByHandleFileInformation *lpFileInformation);

uint32_t GetFileAttributes(const char16_t *lpFileName);
bool32 GetFileAttributesEx(
    const char16_t *lpFileName, int fInfoLevelId /* kNtGetFileExInfoStandard */,
    void *out_lpFileInformation /* → struct NtWin32FileAttributeData * */)
    paramsnonnull();

uint32_t GetCompressedFileSize(const char16_t *lpFileName,
                               uint32_t *lpFileSizeHigh);
bool32 SetFileAttributes(const char16_t *lpFileName, uint32_t dwFileAttributes);
bool32 GetFileTime(int64_t hFile, struct NtFileTime *opt_lpCreationFileTime,
                   struct NtFileTime *opt_lpLastAccessFileTime,
                   struct NtFileTime *opt_lpLastWriteFileTime);
bool32 SetFileTime(int64_t hFile,
                   const struct NtFileTime *opt_lpCreationFileTime,
                   const struct NtFileTime *opt_lpLastAccessFileTime,
                   const struct NtFileTime *opt_lpLastWriteFileTime);

bool32 DeviceIoControl(int64_t hDevice, uint32_t dwIoControlCode,
                       void *lpInBuffer, uint32_t nInBufferSize,
                       void *lpOutBuffer, uint32_t nOutBufferSize,
                       uint32_t *lpBytesReturned,
                       struct NtOverlapped *lpOverlapped);

bool32 LockFile(int64_t hFile, uint32_t dwFileOffsetLow,
                uint32_t dwFileOffsetHigh, uint32_t nNumberOfBytesToLockLow,
                uint32_t nNumberOfBytesToLockHigh);
bool32 LockFileEx(int64_t hFile, uint32_t dwFlags, uint32_t dwReserved,
                  uint32_t nNumberOfBytesToLockLow,
                  uint32_t nNumberOfBytesToLockHigh,
                  struct NtOverlapped *lpOverlapped) paramsnonnull();
bool32 UnlockFile(int64_t hFile, uint32_t dwFileOffsetLow,
                  uint32_t dwFileOffsetHigh, uint32_t nNumberOfBytesToUnlockLow,
                  uint32_t nNumberOfBytesToUnlockHigh);
bool32 UnlockFileEx(int64_t hFile, uint32_t dwReserved,
                    uint32_t nNumberOfBytesToUnlockLow,
                    uint32_t nNumberOfBytesToUnlockHigh,
                    struct NtOverlapped *lpOverlapped) paramsnonnull();

bool32 CreateHardLink(const char16_t *lpFileName,
                      const char16_t *lpExistingFileName,
                      struct NtSecurityAttributes *reserved)
    paramsnonnull((1, 2));
bool32 CreateSymbolicLink(const char16_t *lpSymlinkFileName,
                          const char16_t *lpTargetPathName, uint32_t dwFlags)
    paramsnonnull();

uint32_t SetFilePointer(int64_t hFile, int32_t lDistanceToMove,
                        int32_t *optional_lpDistanceToMoveHigh,
                        int dwMoveMethod);
bool32 SetFilePointerEx(int64_t hFile, int64_t liDistanceToMove,
                        int64_t *optional_lpNewFilePointer, int dwMoveMethod);

bool32 SetEndOfFile(int64_t hFile);
bool32 SetFileValidData(int64_t hFile, int64_t ValidDataLength);

bool32 GetFileSecurity(const char16_t *lpFileName,
                       uint32_t RequestedInformation,
                       struct NtSecurityDescriptor *pSecurityDescriptor,
                       uint32_t nLength, uint32_t *lpnLengthNeeded);

bool32 OpenProcessToken(int64_t hProcessHandle, uint32_t dwDesiredAccess,
                        int64_t *out_hTokenHandle);
bool32 DuplicateToken(int64_t hExistingTokenHandle, int dwImpersonationLevel,
                      int64_t *out_hDuplicateTokenHandle);
bool32 DuplicateTokenEx(int64_t hExistingToken, unsigned int dwDesiredAccess,
                        struct NtSecurityAttributes *lpTokenAttributes,
                        int ImpersonationLevel, int TokenType,
                        int64_t *out_phNewToken);

bool32 AccessCheck(struct NtSecurityDescriptor *pSecurityDescriptor,
                   int64_t ClientToken, unsigned int DesiredAccess,
                   struct NtGenericMapping *lpGenericMapping,
                   struct NtPrivilegeSet *lpPrivilegeSet,
                   unsigned int *PrivilegeSetLength,
                   unsigned int *GrantedAccess, bool32 *AccessStatus);

void MapGenericMask(uint32_t *AccessMask,
                    struct NtGenericMapping *GenericMapping);

int64_t FindFirstFile(const char16_t *lpFileName,
                      struct NtWin32FindData *out_lpFindFileData);
int64_t FindFirstFileEx(const char16_t *lpFileName, int fInfoLevelId,
                        void *out_lpFindFileData, int fSearchOp,
                        void *reserved_lpSearchFilter,
                        uint32_t dwAdditionalFlags);
bool32 FindNextFile(int64_t hFindFile,
                    struct NtWin32FindData *out_lpFindFileData);
bool32 FindClose(int64_t hFindFile);

int64_t FindFirstVolume(char16_t *out_lpszVolumeName, uint32_t cchBufferLength);
bool32 FindNextVolume(int64_t inout_hFindVolume, char16_t *out_lpszVolumeName,
                      uint32_t cchBufferLength);
bool32 FindVolumeClose(int64_t hFindVolume);

bool32 ReadFileScatter(
    int64_t hFileOpenedWithOverlappedAndNoBuffering,
    const union NtFileSegmentElement
        aNullTerminatedPageAlignedSizedSegmentArray[],
    uint32_t nNumberOfBytesToReadThatsMultipleOfFileVolumeSectorSize,
    uint32_t *lpReserved, struct NtOverlapped *inout_lpOverlapped)
    paramsnonnull();

bool32 WriteFileGather(int64_t hFileOpenedWithOverlappedAndNoBuffering,
                       const union NtFileSegmentElement aSegmentArray[],
                       uint32_t nNumberOfBytesToWrite, uint32_t *lpReserved,
                       struct NtOverlapped inout_lpOverlapped) paramsnonnull();

#define kNtFileNameNormalized 0x0
#define kNtFileNameOpened     0x8
#define kNtVolumeNameDos      0x0 /* e.g. \\?\C:\Users\jart */
#define kNtVolumeNameGuid     0x1 /* e.g. \\?\Volume{ea38-etc.}\Users\jart */
#define kNtVolumeNameNt       0x2 /* e.g. \Device\HarddiskVolume4\Users\jart */
#define kNtVolumeNameNone     0x4 /* e.g. \Users\jart */
uint32_t GetFinalPathNameByHandle(int64_t hFile, char16_t *out_path,
                                  uint32_t arraylen, uint32_t flags);

uint32_t GetFullPathName(const char16_t *lpFileName, uint32_t nBufferLength,
                         char16_t *lpBuffer, char16_t **lpFilePart);

bool32 GetOverlappedResult(int64_t hFile, struct NtOverlapped *lpOverlapped,
                           uint32_t *lpNumberOfBytesTransferred, bool32 bWait);
bool32 GetOverlappedResultEx(int64_t hFile, struct NtOverlapped *lpOverlapped,
                             uint32_t *lpNumberOfBytesTransferred,
                             uint32_t dwMilliseconds, bool32 bAlertable);

bool32 GetVolumePathName(const char16_t *lpszFileName,
                         char16_t *lpszVolumePathName,
                         uint32_t cchBufferLength);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/files.inc */

#define CopyFile(...) __imp_CopyFileW(__VA_ARGS__)
extern typeof(CopyFile) *const __imp_CopyFileW __msabi;

#define GetFileType(...) __imp_GetFileType(__VA_ARGS__)
extern typeof(GetFileType) *const __imp_GetFileType __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/iocp.h */

#define COSMOPOLITAN_LIBC_NT_IOCP_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » i/o completion ports                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtFileSkipCompletionPortOnSuccess 1
#define kNtFileSkipSetEventOnHandle        2

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef void (*NtOverlappedCompletionRoutine)(
    uint32_t dwErrorCode, uint32_t dwNumberOfBytesTransfered,
    struct NtOverlapped *inout_lpOverlapped);

int64_t CreateIoCompletionPort(int64_t FileHandleOrNeg1,
                               int64_t opt_ExistingCompletionPortOrZero,
                               void *StatePointer,
                               uint32_t NumberOfConcurrentThreads);

bool32 GetQueuedCompletionStatus(int64_t CompletionPort,
                                 uint32_t *lpNumberOfBytesTransferred,
                                 void *StatePointerPointer,
                                 struct NtOverlapped **lpOverlapped,
                                 uint32_t dwMilliseconds);

bool32 GetQueuedCompletionStatusEx(
    int64_t CompletionPort,
    struct NtOverlappedEntry *out_lpCompletionPortEntries, uint32_t ulCount,
    uint32_t *out_ulNumEntriesRemoved, uint32_t dwMilliseconds,
    bool32 fAlertable);

bool32 PostQueuedCompletionStatus(int64_t CompletionPort,
                                  uint32_t dwNumberOfBytesTransferred,
                                  uint32_t *dwCompletionKey,
                                  struct NtOverlapped *opt_lpOverlapped);

bool32 SetFileCompletionNotificationModes(int64_t FileHandle,
                                          unsigned char Flags);

bool32 ReadFileEx(int64_t hFile, void *lpBuffer, uint32_t nNumberOfBytesToRead,
                  uint32_t *lpNumberOfBytesRead,
                  struct NtOverlapped *opt_lpOverlapped,
                  NtOverlappedCompletionRoutine lpCompletionRoutine);

bool32 WriteFileEx(int64_t hFile, const void *lpBuffer,
                   uint32_t nNumberOfBytesToWrite,
                   struct NtOverlapped *lpOverlapped,
                   NtOverlappedCompletionRoutine lpCompletionRoutine);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ipc.h */

#define COSMOPOLITAN_LIBC_NT_IPC_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » ipc                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/* CreateNamedPipe:dwOpenMode */
#define kNtPipeAccessInbound  0x00000001
#define kNtPipeAccessOutbound 0x00000002
#define kNtPipeAccessDuplex   0x00000003

/* CreateNamedPipe::dwPipeMode */
#define kNtPipeWait                0x00000000
#define kNtPipeNowait              0x00000001
#define kNtPipeReadmodeByte        0x00000000
#define kNtPipeReadmodeMessage     0x00000002
#define kNtPipeTypeByte            0x00000000
#define kNtPipeTypeMessage         0x00000004
#define kNtPipeAcceptRemoteClients 0x00000000
#define kNtPipeRejectRemoteClients 0x00000008

/* CreateNamedPipe::nMaxInstances */
#define kNtPipeUnlimitedInstances 255

/* GetNamedPipeInfo */
#define kNtPipeClientEnd 0x00000000
#define kNtPipeServerEnd 0x00000001

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 CreatePipe(int64_t *out_hReadPipe, int64_t *out_hWritePipe,
                  const struct NtSecurityAttributes *opt_lpPipeAttributes,
                  uint32_t nSize) paramsnonnull((1, 2));

int64_t CreateNamedPipe(
    const char16_t *lpName, uint32_t dwOpenMode, uint32_t dwPipeMode,
    uint32_t nMaxInstances, uint32_t nOutBufferSize, uint32_t nInBufferSize,
    uint32_t nDefaultTimeOut,
    const struct NtSecurityAttributes *opt_lpSecurityAttributes)
    paramsnonnull((1));

bool32 CallNamedPipe(const char16_t *lpNamedPipeName, void *lpInBuffer,
                     uint32_t nInBufferSize, void *lpOutBuffer,
                     uint32_t nOutBufferSize, uint32_t *lpBytesRead,
                     uint32_t nTimeOut);

bool32 ConnectNamedPipe(int64_t hNamedPipe, struct NtOverlapped *lpOverlapped);
bool32 WaitNamedPipe(const char16_t *lpNamedPipeName, uint32_t nTimeOut);
bool32 DisconnectNamedPipe(int64_t hNamedPipe);

bool32 SetNamedPipeHandleState(int64_t hNamedPipe, uint32_t *lpMode,
                               uint32_t *lpMaxCollectionCount,
                               uint32_t *lpCollectDataTimeout);

bool32 PeekNamedPipe(int64_t hNamedPipe, void *lpBuffer, uint32_t nBufferSize,
                     uint32_t *lpBytesRead, uint32_t *lpTotalBytesAvail,
                     uint32_t *lpBytesLeftThisMessage);

bool32 TransactNamedPipe(int64_t hNamedPipe, void *lpInBuffer,
                         uint32_t nInBufferSize, void *lpOutBuffer,
                         uint32_t nOutBufferSize, uint32_t *lpBytesRead,
                         struct NtOverlapped *lpOverlapped);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/iphlpapi.h */

#define COSMOPOLITAN_LIBC_NT_IPHLPAPI_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » ip helper api                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

uint32_t GetAdaptersAddresses(uint32_t Family, uint32_t Flags, void *Reserved,
                              struct NtIpAdapterAddresses *AdapterAddresses,
                              uint32_t *SizePointer);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/memory.h */

#define COSMOPOLITAN_LIBC_NT_MEMORY_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » memory                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtNumaNoPreferredNode 0xffffffffu

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void *LocalFree(void *hMem);

int64_t CreateFileMapping(
    int64_t opt_hFile,
    const struct NtSecurityAttributes *opt_lpFileMappingAttributes,
    uint32_t flProtect, uint32_t dwMaximumSizeHigh, uint32_t dwMaximumSizeLow,
    const char16_t *opt_lpName);
int64_t CreateFileMappingNuma(
    int64_t opt_hFile,
    const struct NtSecurityAttributes *opt_lpFileMappingAttributes,
    uint32_t flProtect, uint32_t dwMaximumSizeHigh, uint32_t dwMaximumSizeLow,
    const char16_t *opt_lpName, uint32_t nndDesiredNumaNode);

void *MapViewOfFileEx(int64_t hFileMappingObject, uint32_t dwDesiredAccess,
                      uint32_t dwFileOffsetHigh, uint32_t dwFileOffsetLow,
                      size_t dwNumberOfBytesToMap,
                      void *opt_lpDesiredBaseAddress);
void *MapViewOfFileExNuma(int64_t hFileMappingObject, uint32_t dwDesiredAccess,
                          uint32_t dwFileOffsetHigh, uint32_t dwFileOffsetLow,
                          size_t dwNumberOfBytesToMap,
                          void *opt_lpDesiredBaseAddress,
                          uint32_t nndDesiredNumaNode);

bool32 UnmapViewOfFile(const void *lpBaseAddress);
bool32 FlushViewOfFile(const void *lpBaseAddress,
                       size_t dwNumberOfBytesToFlush);

void *VirtualAlloc(void *opt_lpAddress, uint64_t dwSize,
                   uint32_t flAllocationType, uint32_t flProtect);
bool32 VirtualFree(void *lpAddress, uint64_t dwSize, uint32_t dwFreeType);
bool32 VirtualProtect(void *lpAddress, uint64_t dwSize, uint32_t flNewProtect,
                      uint32_t *lpflOldProtect) paramsnonnull();
uint64_t VirtualQuery(const void *lpAddress,
                      struct NtMemoryBasicInformation *lpBuffer,
                      uint64_t dwLength);
void *VirtualAllocEx(int64_t hProcess, void *lpAddress, uint64_t dwSize,
                     uint32_t flAllocationType, uint32_t flProtect);

bool32 PrefetchVirtualMemory(int64_t hProcess, const uint32_t *NumberOfEntries,
                             struct NtMemoryRangeEntry *VirtualAddresses,
                             uint32_t reserved_Flags);
bool32 OfferVirtualMemory(void *inout_VirtualAddress, size_t Size,
                          int Priority);

int64_t GetProcessHeap(void);
void *HeapAlloc(int64_t hHeap, uint32_t dwFlags, size_t dwBytes) dontdiscard;
bool32 HeapFree(int64_t hHeap, uint32_t dwFlags, void *opt_lpMem);
void *HeapReAlloc(int64_t hHeap, uint32_t dwFlags, void *lpMem,
                  size_t dwBytes) dontdiscard;

void *GlobalAlloc(uint32_t uFlags, uint64_t dwBytes) dontdiscard;
void *GlobalFree(void *hMem);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/memory.inc */

extern typeof(LocalFree) *const __imp_LocalFree __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/messagebox.h */

#define COSMOPOLITAN_LIBC_NT_MESSAGEBOX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int MessageBox(int64_t hWnd, const char16_t *lpText, const char16_t *lpCaption,
               uint32_t mbType);
int MessageBoxEx(int64_t hWnd, const char16_t *lpText,
                 const char16_t *lpCaption, uint32_t mbType,
                 uint16_t wLanguageId);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ntdll.h */

#define COSMOPOLITAN_LIBC_NT_NTDLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

#define __nt_system_call_dispatcher (wambda *)0x7ffe0308

extern const struct NtUnicodeString *const RtlNtdllName;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » beyond the pale » eponymous runtime      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define NT_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define NT_PROCESS_FLAGS_INHERIT_HANDLES  0x00000002
#define NT_PROCESS_FLAGS_NO_SYNCHRONIZE   0x00000004
#define NT_RTL_CLONE_PARENT               0
#define NT_RTL_CLONE_CHILD                297

NtStatus NtCallbackReturn(void *opt_Result, uint32_t ResultLength,
                          int32_t Status);
NtStatus NtTestAlert(void);

NtStatus NtOpenFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                    struct NtObjectAttributes *ObjectAttributes,
                    struct NtIoStatusBlock *out_IoStatusBlock,
                    uint32_t ShareAccess, uint32_t OpenOptions);

NtStatus NtQueryInformationToken(int64_t TokenHandle,
                                 uint32_t TokenInformationClass,
                                 void *out_TokenInformation,
                                 uint32_t TokenInformationLength,
                                 uint32_t *out_ReturnLength);
NtStatus NtYieldExecution(void);
NtStatus NtQuerySystemInformation(uint32_t info_class, void *out_info,
                                  uint32_t info_size,
                                  uint32_t *out_bytes_received);
NtStatus NtReadVirtualMemory(int64_t ProcessHandle, const void *BaseAddress,
                             void *out_Buffer, size_t BufferLength,
                             size_t *opt_out_ReturnLength);
NtStatus NtCreateTimer(void **out_TimerHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       uint32_t TimerType);
NtStatus NtSetTimer(void *TimerHandle, int64_t *DueTime, void *TimerApcRoutine,
                    void *TimerContext, int32_t Resume, int32_t Period,
                    int32_t *out_PreviousState);
NtStatus NtQueryObject(void *ObjectHandle, int ObjectInformationClass,
                       void *out_ObjectInformation,
                       uint32_t ObjectInformationLength,
                       uint32_t *opt_out_ReturnLength);
NtStatus NtQueryFullAttributesFile(
    struct NtObjectAttributes *attributes,
    struct NtFileNetworkOpenInformation *out_info);
NtStatus NtCreateKey(void **out_KeyHandle, uint32_t DesiredAccess,
                     struct NtObjectAttributes *ObjectAttributes,
                     uint32_t TitleIndex, struct NtUnicodeString *opt_Class,
                     uint32_t CreateOptions, uint32_t *opt_out_Disposition);
NtStatus NtOpenKey(void **out_KeyHandle, uint32_t DesiredAccess,
                   struct NtObjectAttributes *ObjectAttributes);
NtStatus NtSetValueKey(void *KeyHandle, struct NtUnicodeString *ValueName,
                       uint32_t opt_TitleIndex, uint32_t Type, void *Data,
                       uint32_t DataSize);
NtStatus NtDeleteKey(void *KeyHandle);
NtStatus NtQueryValueKey(void *KeyHandle, struct NtUnicodeString *ValueName,
                         int KeyValueInformationClass,
                         void *out_KeyValueInformation, uint32_t Length,
                         uint32_t *out_ResultLength);
NtStatus NtFlushKey(void *KeyHandle);
NtStatus NtEnumerateKey(int64_t hkey, uint32_t index, int info_class,
                        void *out_key_info, uint32_t key_info_size,
                        uint32_t *out_bytes_received);
NtStatus NtEnumerateValueKey(int64_t hKey, uint32_t index, int info_class,
                             void *out_key_info, uint32_t key_info_size,
                             uint32_t *out_bytes_received);
NtStatus NtQuerySystemTime(int64_t *SystemTime);
NtStatus NtDeleteFile(struct NtObjectAttributes *ObjectAttributes);
NtStatus NtFlushBuffersFile(int64_t FileHandle,
                            struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtCreateIoCompletion(void **out_IoCompletionHandle,
                              uint32_t DesiredAccess,
                              struct NtObjectAttributes *ObjectAttributes,
                              uint32_t NumberOfConcurrentThreads);
NtStatus NtRaiseHardError(int32_t ErrorStatus, uint32_t NumberOfArguments,
                          uint32_t UnicodeStringArgumentsMask, void *Arguments,
                          uint32_t MessageBoxType,
                          uint32_t *out_MessageBoxResult);
NtStatus NtRaiseException(struct NtExceptionRecord *ExceptionRecord,
                          struct NtContext *Context, int32_t SearchFrames);
NtStatus NtCreateEvent(void **out_EventHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       int EventType, int32_t InitialState);
NtStatus NtWaitForSingleObject(void *ObjectHandle, int32_t Alertable,
                               int64_t *TimeOut);
NtStatus NtSetEvent(void *EventHandle, int32_t *opt_out_PreviousState);
NtStatus NtClearEvent(void *EventHandle);
NtStatus NtSignalAndWaitForSingleObject(void *ObjectToSignal,
                                        void *WaitableObject, int32_t Alertable,
                                        int64_t *opt_Time);
NtStatus NtQueryPerformanceCounter(int64_t *out_PerformanceCount,
                                   int64_t *opt_out_PerformanceFrequency);
NtStatus NtFsControlFile(int64_t FileHandle, void *opt_Event,
                         NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                         struct NtIoStatusBlock *out_IoStatusBlock,
                         uint32_t FsControlCode, void *opt_InputBuffer,
                         uint32_t InputBufferLength, void *opt_out_OutputBuffer,
                         uint32_t OutputBufferLength);
NtStatus NtCancelIoFile(int64_t FileHandle,
                        struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtCreateProfile(void **out_ProfileHandle, int64_t ProcessHandle,
                         void *Base, uint32_t Size, uint32_t BucketShift,
                         uint32_t *Buffer, uint32_t BufferLength, int Source,
                         uint32_t ProcessorMask);
NtStatus NtSetIntervalProfile(uint32_t Interval, int Source);
NtStatus NtQueryIntervalProfile(int Source, uint32_t *out_Interval);
NtStatus NtStartProfile(void *ProfileHandle);
NtStatus NtStopProfile(void *ProfileHandle);
NtStatus NtCreateDirectoryObject(int64_t *out_DirectoryHandle,
                                 uint32_t DesiredAccess,
                                 struct NtObjectAttributes *ObjectAttributes);
NtStatus NtOpenDirectoryObject(int64_t *out_DirectoryHandle,
                               uint32_t DesiredAccess,
                               struct NtObjectAttributes *ObjectAttributes);
NtStatus NtOpenSymbolicLinkObject(int64_t *out_DirectoryHandle,
                                  uint32_t DesiredAccess,
                                  struct NtObjectAttributes *ObjectAttributes);
NtStatus NtQuerySymbolicLinkObject(int64_t DirectoryHandle,
                                   struct NtUnicodeString *inout_TargetName,
                                   uint32_t *opt_out_ReturnLength);
NtStatus ZwAreMappedFilesTheSame(void *Address1, void *Address2);
NtStatus NtQueryVolumeInformationFile(int64_t FileHandle,
                                      struct NtIoStatusBlock *out_IoStatusBlock,
                                      void *out_FsInformation, uint32_t Length,
                                      uint32_t FsInformationClass);
NtStatus NtQuerySecurityObject(
    int64_t handle, int RequestedInformation,
    struct NtSecurityDescriptor *out_SecurityDescriptor,
    uint32_t SecurityDescriptorLength, uint32_t *out_ReturnLength);
NtStatus NtQueueApcThread(int64_t ThreadHandle, NtPkNormalRoutine ApcRoutine,
                          void *opt_ApcContext, void *opt_Argument1,
                          void *opt_Argument2);
NtStatus NtFlushInstructionCache(int64_t ProcessHandle, void *opt_BaseAddress,
                                 size_t FlushSize);
NtStatus NtQueryAttributesFile(const struct NtObjectAttributes *object,
                               struct NtFileBasicInformation *file_information);
NtStatus NtQueryDirectoryFile(
    int64_t FileHandle, void *opt_Event, NtIoApcRoutine opt_ApcRoutine,
    void *opt_ApcContext, struct NtIoStatusBlock *out_IoStatusBlock,
    void *out_FileInformation, uint32_t FileInformationLength,
    uint32_t FileInformationClass, int32_t ReturnSingleEntry,
    struct NtUnicodeString *opt_FileName, int32_t RestartScan);
NtStatus NtFlushVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                              uint32_t **inout_FlushSize,
                              struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtQueryInformationJobObject(void *JobHandle, int JobInformationClass,
                                     void *out_JobInformation,
                                     uint32_t JobInformationLength,
                                     uint32_t *opt_out_ReturnLength);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » beyond the pale » runtime library        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

NtStatus RtlInitializeCriticalSection(struct NtCriticalSection *out_crit);
NtStatus RtlDeleteCriticalSection(struct NtCriticalSection *crit);
NtStatus RtlEnterCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlLeaveCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlTryEnterCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlInitUnicodeString(struct NtUnicodeString *inout_DestinationString,
                              const char16_t *SourceString);
void RtlFreeUnicodeString(struct NtUnicodeString **string);
NtStatus RtlQueryEnvironmentVariable_U(char16_t *Environment,
                                       struct NtUnicodeString *Name,
                                       struct NtUnicodeString *Value);
NtStatus RtlConvertSidToUnicodeString(struct NtUnicodeString *out_UnicodeString,
                                      void *Sid,
                                      int32_t AllocateDestinationString);
void *RtlCreateHeap(uint32_t flags, void *base, size_t reserve_sz,
                    size_t commit_sz, void *lock, void *params);
NtStatus RtlDestroyHeap(void *base);
void *RtlAllocateHeap(int64_t heap, uint32_t flags, size_t size);
void *RtlReAllocateHeap(int64_t heap, uint32_t flags, void *ptr, size_t size);
NtStatus RtlFreeHeap(int64_t heap, uint32_t flags, void *ptr);
size_t RtlSizeHeap(int64_t heap, uint32_t flags, void *ptr);
NtStatus RtlValidateHeap(int64_t heap, uint32_t flags, void *ptr);
NtStatus RtlLockHeap(int64_t heap);
NtStatus RtlUnlockHeap(int64_t heap);
NtStatus RtlGetProcessHeaps(uint32_t count, void **out_Heaps);
NtStatus RtlWalkHeap(int64_t heap, void *out_Info);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/ntdll.inc */

#define NtYieldExecution(...) __imp_NtYieldExecution(__VA_ARGS__)

extern typeof(NtYieldExecution) *const __imp_NtYieldExecution __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ntdllimport.h */

/*-*- mode:unix-assembly; indent-tabs-mode:t; tab-width:8; coding:utf-8     -*-│
│vi: set et ft=asm ts=8 tw=8 fenc=utf-8                                     :vi│
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#define COSMOPOLITAN_LIBC_NT_NTDLLIMPORT_H_
#ifdef __ASSEMBLER__
/* clang-format off */

.macro	.ntimp	fn:req
	yoink	_init_ntdll
	.initbss 202,_init_ntdll.\fn
__imp_\fn:
	.quad	0
	.endobj	__imp_\fn,globl,hidden
	.previous
	.initro 202,_init_ntdll.2.\fn
	.quad	RVA(.L\fn)
	.previous
	.section .rodata.str1.1,"aSM",@progbits,1
.L\fn:
	.asciz	"\fn"
	.previous
.endm

/* clang-format on */
#endif /* __ASSEMBLER__ */


/*!BEGIN libc/nt/paint.h */

#define COSMOPOLITAN_LIBC_NT_PAINT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » cpu graphics                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int64_t BeginPaint(int64_t hWnd, struct NtPaintStruct *lpPaint);
int32_t EndPaint(int64_t hWnd, const struct NtPaintStruct *lpPaint);
int32_t BitBlt(int64_t hdc, int x, int y, int cx, int cy, int64_t hdcSrc,
               int x1, int y1, uint32_t rop);
int32_t GetClientRect(int64_t hWnd, struct NtRect *lpRect);
int32_t GetWindowRect(int64_t hWnd, struct NtRect *lpRect);
int32_t SetBkMode(int64_t hdc, int mode);
uint32_t SetTextColor(int64_t hdc, uint32_t color);
uint32_t SetTextAlign(int64_t hdc, uint32_t align);
int32_t SetTextJustification(int64_t hdc, int extra, int count);
int32_t DrawText(int64_t hdc, const char16_t *lpchText, int cchText,
                 struct NtRect *lprc, uint32_t format);
int32_t DrawTextEx(int64_t hdc, char16_t *lpchText, int cchText,
                   struct NtRect *lprc, uint32_t format,
                   struct NtDrawTextParams *lpdtp);
int32_t FillRect(int64_t hDC, const struct NtRect *lpRC, int64_t hBrush);
uint32_t GetPixel(int64_t hdc, int x, int y);
uint32_t SetPixel(int64_t hdc, int x, int y, uint32_t color);
bool32 RedrawWindow(int64_t hWnd, const struct NtRect *opt_lprcUpdate,
                    int64_t opt_hrgnUpdate, uint32_t rdwFlags);
int64_t CreateCompatibleDC(int64_t hdc);
int64_t CreateCompatibleBitmap(int64_t hdc, int cx, int cy);
int64_t SelectObject(int64_t hdc, int64_t h);
bool32 DeleteObject(int64_t ho);
bool32 DeleteDC(int64_t hdc);
int SaveDC(int64_t hdc);
bool32 RestoreDC(int64_t hdc, int nSavedDC);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/paint.inc */

#define SetPixel(...) __imp_SetPixel(__VA_ARGS__)
#define GetPixel(...) __imp_GetPixel(__VA_ARGS__)

extern typeof(SetPixel) *const __imp_SetPixel __msabi;
extern typeof(GetPixel) *const __imp_GetPixel __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/pdh.h */

#define COSMOPOLITAN_LIBC_NT_PDH_H_

/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » performance counters                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int PdhOpenQuery(const char16_t *opt_szDataSource, uint32_t *dwUserData,
                 int64_t *out_phQuery);

int PdhAddEnglishCounter(int64_t hQuery, const char16_t *szFullCounterPath,
                         uint32_t *dwUserData, int64_t *out_phCounter);

int PdhCollectQueryDataEx(int64_t hQuery, uint32_t dwIntervalTime,
                          int64_t hNewDataEvent);

int PdhGetFormattedCounterValue(int64_t hCounter, uint32_t dwFormat,
                                uint32_t *out_opt_lpdwType,
                                struct NtPdhFmtCountervalue *out_pValue);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/privilege.h */

#define COSMOPOLITAN_LIBC_NT_PRIVILEGE_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » check your privilege                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtSePrivilegeEnabledByDefault 0x00000001u
#define kNtSePrivilegeEnabled          0x00000002u
#define kNtSePrivilegeRemoved          0x00000004u
#define kNtSePrivilegeUsedForAccess    0x80000000u

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 LookupPrivilegeValue(const char16_t *opt_lpSystemName,
                            const char16_t *lpName, struct NtLuid *out_lpLuid);

bool32 AdjustTokenPrivileges(int64_t TokenHandle, bool32 DisableAllPrivileges,
                             const struct NtTokenPrivileges *opt_NewState,
                             uint32_t BufferLength,
                             struct NtTokenPrivileges *opt_out_PreviousState,
                             uint32_t *opt_out_ReturnLength);

bool32 ImpersonateSelf(int kNtSecurityImpersonationLevel);
bool32 RevertToSelf(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/process.h */

#define COSMOPOLITAN_LIBC_NT_PROCESS_H_


/*!BEGIN libc/nt/startupinfo.h */

#define COSMOPOLITAN_LIBC_NT_NTSTARTUPINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void GetStartupInfo(struct NtStartupInfo *lpStartupInfo);

bool32 InitializeProcThreadAttributeList(
    struct NtProcThreadAttributeList *opt_inout_lpAttributeList,
    uint32_t dwAttributeCount, uint32_t reserved_dwFlags, size_t *inout_lpSize)
    paramsnonnull((4));
bool32 UpdateProcThreadAttribute(
    struct NtProcThreadAttributeList *inout_lpAttributeList, uint32_t dwFlags,
    const uint32_t *Attribute, const void *lpValue, size_t cbSize,
    void *reserved_lpPreviousValue, size_t *reserved_lpReturnSize)
    paramsnonnull((1, 3, 4));
void DeleteProcThreadAttributeList(
    struct NtProcThreadAttributeList *inout_lpAttributeList) paramsnonnull();

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/startupinfo.inc */

#define GetStartupInfo(...) __imp_GetStartupInfoW(__VA_ARGS__)

extern typeof(GetStartupInfo) *const __imp_GetStartupInfoW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » processes                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 CreateProcess(const char16_t *opt_lpApplicationName,
                     char16_t *lpCommandLine,
                     struct NtSecurityAttributes *opt_lpProcessAttributes,
                     struct NtSecurityAttributes *opt_lpThreadAttributes,
                     bool32 bInheritHandles, uint32_t dwCreationFlags,
                     void *opt_lpEnvironment,
                     const char16_t *opt_lpCurrentDirectory,
                     const struct NtStartupInfo *lpStartupInfo,
                     struct NtProcessInformation *opt_out_lpProcessInformation)
    paramsnonnull((9));

uint32_t GetThreadId(int64_t hThread);   /* cf. NT_TID */
uint32_t GetProcessId(int64_t hProcess); /* cf. NT_PID */
void SetLastError(uint32_t dwErrCode);
uint32_t FormatMessage(uint32_t dwFlags, const void *lpSource,
                       uint32_t dwMessageId, uint32_t dwLanguageId,
                       char16_t *lpBuffer, uint32_t nSize, va_list *Arguments);
int64_t OpenProcess(uint32_t dwDesiredAccess, bool32 bInheritHandle,
                    uint32_t dwProcessId);
uint32_t GetCurrentProcessId(void); /* %gs:0x40 */
uint32_t GetEnvironmentVariable(const char16_t *lpName, char16_t *lpBuffer,
                                uint32_t nSize);
uint32_t SetEnvironmentVariable(const char16_t *lpName, char16_t *lpValue);
int32_t SetEnvironmentStrings(char16_t *NewEnvironment);
bool32 GetProcessAffinityMask(int64_t hProcess,
                              uintptr_t *lpProcessAffinityMask,
                              uintptr_t *lpSystemAffinityMask);
uint64_t /*bool32*/ SetProcessAffinityMask(int64_t hProcess,
                                           uintptr_t dwProcessAffinityMask);

/* e.g. kNtAboveNormalPriorityClass, kNtHighPriorityClass */
uint32_t GetPriorityClass(int64_t hProcess);
bool32 SetPriorityClass(int64_t hProcess, uint32_t dwPriorityClass);
bool32 SetProcessPriorityBoost(int64_t hProcess, bool32 bDisablePriorityBoost);
bool32 GetProcessPriorityBoost(int64_t hProcess, bool32 *pDisablePriorityBoost);

bool32 GetProcessMemoryInfo(
    int64_t hProcess, struct NtProcessMemoryCountersEx *out_ppsmemCounters,
    uint32_t cb);

int64_t CreateToolhelp32Snapshot(uint32_t dwFlags, uint32_t th32ProcessID);
bool32 Process32First(int64_t hSnapshot, struct NtProcessEntry32 *in_out_lppe);
bool32 Process32Next(int64_t hSnapshot, struct NtProcessEntry32 *out_lppe);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/process.inc */

#define GetEnvironmentVariable(...) __imp_GetEnvironmentVariableW(__VA_ARGS__)
extern typeof(GetEnvironmentVariable) *const
    __imp_GetEnvironmentVariableW __msabi;

#define SetEnvironmentVariable(...) __imp_SetEnvironmentVariableW(__VA_ARGS__)
extern typeof(SetEnvironmentVariable) *const
    __imp_SetEnvironmentVariableW __msabi;

#define GetPriorityClass(...) __imp_GetPriorityClass(__VA_ARGS__)
extern typeof(GetPriorityClass) *const __imp_GetPriorityClass __msabi;

#define SetPriorityClass(...) __imp_SetPriorityClass(__VA_ARGS__)
extern typeof(SetPriorityClass) *const __imp_SetPriorityClass __msabi;

#define GetCurrentProcessId(...) __imp_GetCurrentProcessId(__VA_ARGS__)
extern typeof(GetCurrentProcessId) *const __imp_GetCurrentProcessId __msabi;

extern typeof(FormatMessage) *const __imp_FormatMessageW __msabi;
extern typeof(SetLastError) *const __imp_SetLastError __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/registry.h */

#define COSMOPOLITAN_LIBC_NT_REGISTRY_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » registry                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtMaxKeyNameChars   255
#define kNtMaxValueNameChars 16383
#define kNtMaxValueBytes     0x100000

#define kNtHkeyClassesRoot              0x80000000l
#define kNtHkeyCurrentUser              0x80000001l
#define kNtHkeyLocalMachine             0x80000002l
#define kNtHkeyUsers                    0x80000003l
#define kNtHkeyPerformanceData          0x80000004l
#define kNtHkeyPerformanceText          0x80000050l
#define kNtHkeyPerformanceNlstext       0x80000060l
#define kNtHkeyCurrentConfig            0x80000005l
#define kNtHkeyDynData                  0x80000006l
#define kNtHkeyCurrentUserLocalSettings 0x80000007l

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int RegOpenKey(int64_t hKey, const char16_t *opt_lpSubKey,
               int64_t *out_phkResult) paramsnonnull((3));
int RegOpenKeyEx(int64_t hKey, const char16_t *opt_lpSubKey,
                 uint32_t opt_ulOptions, int samDesired, int64_t *out_phkResult)
    paramsnonnull((5));
int RegCloseKey(int64_t hKey);

int RegGetValue(int64_t hkey, const char16_t *opt_lpSubKey,
                const char16_t *opt_lpValue, unsigned dwFlags, int *opt_pdwType,
                void *opt_out_pvData, uint32_t *opt_inout_pcbDataBytes);
int RegSetValue(int64_t hKey, const char16_t *lpSubKey, int dwType,
                const char16_t *lpData, uint32_t cbData);
int RegSetValueEx(int64_t hKey, const char16_t *lpValueName, uint32_t Reserved,
                  int dwType, const unsigned char *lpData, uint32_t cbData);

int RegQueryInfoKey(int64_t hKey, char16_t *opt_out_lpClass,
                    uint32_t *opt_inout_lpClassLen, uint32_t *lpReserved,
                    uint32_t *opt_out_lpcSubKeys,
                    uint32_t *opt_out_lpcbMaxSubKeyBytes,
                    uint32_t *opt_out_lpcbMaxClassBytes,
                    uint32_t *opt_out_lpcValues,
                    uint32_t *opt_out_lpcbMaxValueNameBytes,
                    uint32_t *opt_out_lpcbMaxValueBytes,
                    uint32_t *opt_out_lpcbSecurityDescriptorBytes,
                    struct NtFileTime *opt_out_lpftLastWriteTime);
int RegEnumKey(int64_t hKey, uint32_t dwIndex, char16_t *opt_lpName,
               uint32_t NameLen);
int RegEnumKeyEx(int64_t hKey, uint32_t dwIndex, char16_t *out_lpName,
                 uint32_t *inout_lpcchName, uint32_t *lpReserved,
                 char16_t *opt_out_lpClass, uint32_t *opt_inout_lpcchClassLen,
                 struct NtFileTime *opt_out_lpftLastWriteTime);

int RegEnumValue(int64_t hKey, uint32_t dwIndex, char16_t *lpValueName,
                 uint32_t *lpValueNameLen, uint32_t *lpReserved,
                 int *opt_out_lpType, unsigned char *opt_out_lpData,
                 uint32_t *opt_inout_lpcbDataBytes);
int RegQueryValue(int64_t hKey, const char16_t *opt_lpSubKey,
                  char16_t *opt_out_lpData, int32_t *opt_inout_lpcbDataBytes);
int RegQueryValueEx(int64_t hKey, const char16_t *opt_lpValueName,
                    uint32_t *lpReserved, int *opt_out_lpType,
                    unsigned char *opt_out_lpData,
                    uint32_t *opt_inout_lpcbDataBytes);

int RegOverridePredefKey(int64_t hKey, int64_t hNewHKey);
int RegOpenUserClassesRoot(void *hToken, uint32_t dwOptions, int samDesired,
                           int64_t *phkResult);
int RegOpenCurrentUser(int samDesired, int64_t *phkResult);
int RegDisablePredefinedCache();
int RegConnectRegistry(const char16_t *lpMachineName, int64_t hKey,
                       int64_t *phkResult);
int RegConnectRegistryEx(const char16_t *lpMachineName, int64_t hKey,
                         uint32_t Flags, int64_t *phkResult);
int RegCreateKey(int64_t hKey, const char16_t *lpSubKey, int64_t *phkResult);
int RegCreateKeyEx(int64_t hKey, const char16_t *lpSubKey, uint32_t Reserved,
                   int16_t *lpClass, uint32_t dwOptions, int samDesired,
                   struct NtSecurityAttributes *lpSecurityAttributes,
                   int64_t *phkResult, uint32_t *lpdwDisposition);
int RegDeleteKey(int64_t hKey, const char16_t *lpSubKey);
int RegDeleteKeyEx(int64_t hKey, const char16_t *lpSubKey, int samDesired,
                   uint32_t Reserved);
int RegDeleteTree(int64_t hKey, const char16_t *opt_lpSubKey);
int RegDisableReflectionKey(int64_t hBase);
int RegEnableReflectionKey(int64_t hBase);
int RegQueryReflectionKey(int64_t hBase, bool32 *bIsReflectionDisabled);
int RegDeleteValue(int64_t hKey, const char16_t *lpValueName);
int RegFlushKey(int64_t hKey);
int RegGetKeySecurity(int64_t hKey, uint32_t SecurityInformation,
                      void *pSecurityDescriptor,
                      uint32_t *lpcbSecurityDescriptorBytes);
int RegLoadKey(int64_t hKey, const char16_t *lpSubKey, const char16_t *lpFile);
int RegNotifyChangeKeyValue(int64_t hKey, bool32 bWatchSubtree,
                            uint32_t dwNotifyFilter, void *hEvent,
                            int fAsynchronous);
int RegQueryMultipleValues(int64_t hKey, struct NtValent *inout_val_list,
                           uint32_t num_vals, int16_t *out_lpValueBuf,
                           uint32_t *inout_ldwTotsize) paramsnonnull();
int RegReplaceKey(int64_t hKey, const char16_t *lpSubKey,
                  const char16_t *lpNewFile, const char16_t *lpOldFile);
int RegRestoreKey(int64_t hKey, const char16_t *lpFile, uint32_t dwFlags);
int RegSaveKey(int64_t hKey, const char16_t *lpFile,
               struct NtSecurityAttributes *lpSecurityAttributes);
int RegSetKeySecurity(int64_t hKey, uint32_t SecurityInformation,
                      void *pSecurityDescriptor);
int RegUnLoadKey(int64_t hKey, const char16_t *lpSubKey);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/runtime.h */

#define COSMOPOLITAN_LIBC_NT_RUNTIME_H_

/**
 * @fileoverview NT Obligatory Runtime Functions.
 *
 * These functions are placed in their own file because they're (a)
 * abstracted by the Cosmopolitan runtime; and (b) it helps GCC avoid
 * bloating binaries with debug information the user doesn't need.
 */

#define kNtCpUtf8             65001
#define kNtInvalidHandleValue -1L
#define kNtStdInputHandle     -10L
#define kNtStdOutputHandle    -11L
#define kNtStdErrorHandle     -12L

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

char16_t *GetCommandLine(void) nosideeffect;
char16_t *GetEnvironmentStrings(void) dontdiscard;
bool32 FreeEnvironmentStrings(char16_t *) paramsnonnull();
bool32 ReadFile(int64_t hFile, void *lpBuffer, uint32_t nNumberOfBytesToRead,
                uint32_t *lpNumberOfBytesRead,
                struct NtOverlapped *opt_lpOverlapped);
bool32 WriteFile(int64_t hFile, const void *lpBuffer,
                 uint32_t nNumberOfBytesToWrite,
                 uint32_t *lpNumberOfBytesWritten,
                 struct NtOverlapped *opt_lpOverlapped);
bool32 TerminateProcess(int64_t hProcess, uint32_t uExitCode);
int64_t GetCurrentProcess(void) pureconst;
void ExitProcess(uint32_t uExitCode) wontreturn;
uint32_t GetLastError(void) nosideeffect;
bool32 CloseHandle(int64_t hObject) dontthrow nocallback;
intptr_t GetStdHandle(int64_t nStdHandle) nosideeffect;
bool32 SetStdHandle(int64_t nStdHandle, int64_t hHandle);
bool32 SetDefaultDllDirectories(unsigned dirflags);
bool32 RtlGenRandom(void *RandomBuffer, uint32_t RandomBufferLength);
uint32_t GetModuleFileName(int64_t hModule, char16_t *lpFilename,
                           uint32_t nSize);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/runtime.inc */

#define FreeEnvironmentStrings(...) __imp_FreeEnvironmentStringsW(__VA_ARGS__)
extern typeof(FreeEnvironmentStrings) *const
    __imp_FreeEnvironmentStringsW __msabi;

#define GetCommandLine(...) __imp_GetCommandLineW(__VA_ARGS__)
extern typeof(GetCommandLine) *const __imp_GetCommandLineW __msabi;

#define GetEnvironmentStrings(...) __imp_GetEnvironmentStringsW(__VA_ARGS__)
extern typeof(GetEnvironmentStrings) *const
    __imp_GetEnvironmentStringsW __msabi;

#define GetStdHandle(...) __imp_GetStdHandle(__VA_ARGS__)
extern typeof(GetStdHandle) *const __imp_GetStdHandle __msabi;

#define SetStdHandle(...) __imp_SetStdHandle(__VA_ARGS__)
extern typeof(SetStdHandle) *const __imp_SetStdHandle __msabi;

#define ReadFile(...) __imp_ReadFile(__VA_ARGS__)
extern typeof(ReadFile) *const __imp_ReadFile __msabi;

#define WriteFile(...) __imp_WriteFile(__VA_ARGS__)
extern typeof(WriteFile) *const __imp_WriteFile __msabi;

#define SetDefaultDllDirectories(...) \
  __imp_SetDefaultDllDirectories(__VA_ARGS__)
extern typeof(SetDefaultDllDirectories) *const
    __imp_SetDefaultDllDirectories __msabi;

#define GetCurrentProcess(...) __imp_GetCurrentProcess(__VA_ARGS__)
extern typeof(GetCurrentProcess) *const __imp_GetCurrentProcess __msabi;

#define GetModuleFileName(...) __imp_GetModuleFileNameW(__VA_ARGS__)
extern typeof(GetModuleFileName) *const __imp_GetModuleFileNameW __msabi;

extern typeof(GetLastError) *const __imp_GetLastError __msabi;
extern typeof(ExitProcess) *const __imp_ExitProcess __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/signals.h */

#define COSMOPOLITAN_LIBC_NT_EXCEPTIONS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » signals                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int (*NtTopLevelExceptionFilter)(const struct NtExceptionPointers *);
typedef int32_t (*NtVectoredExceptionHandler)(struct NtExceptionPointers *);

int SetErrorMode(int uMode);

int64_t AddVectoredExceptionHandler(uint32_t First,
                                    NtVectoredExceptionHandler pHandler);
int64_t AddVectoredContinueHandler(uint32_t First,
                                   NtVectoredExceptionHandler pHandler);

uint32_t RemoveVectoredExceptionHandler(int64_t hHandle);
uint32_t RemoveVectoredContinueHandler(int64_t hHandle);

NtTopLevelExceptionFilter SetUnhandledExceptionFilter(
    NtTopLevelExceptionFilter opt_lpTopLevelExceptionFilter);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/signals.inc */

#define SetErrorMode(...) __imp_SetErrorMode(__VA_ARGS__)
#define AddVectoredExceptionHandler(...) \
  __imp_AddVectoredExceptionHandler(__VA_ARGS__)
#define AddVectoredContinueHandler(...) \
  __imp_AddVectoredContinueHandler(__VA_ARGS__)
#define RemoveVectoredExceptionHandler(...) \
  __imp_RemoveVectoredExceptionHandler(__VA_ARGS__)
#define RemoveVectoredContinueHandler(...) \
  __imp_RemoveVectoredContinueHandler(__VA_ARGS__)
#define SetUnhandledExceptionFilter(...) \
  __imp_SetUnhandledExceptionFilter(__VA_ARGS__)

extern typeof(SetErrorMode) *const __imp_SetErrorMode __msabi;
extern typeof(AddVectoredExceptionHandler) *const
    __imp_AddVectoredExceptionHandler __msabi;
extern typeof(AddVectoredContinueHandler) *const
    __imp_AddVectoredContinueHandler __msabi;
extern typeof(RemoveVectoredExceptionHandler) *const
    __imp_RemoveVectoredExceptionHandler __msabi;
extern typeof(RemoveVectoredContinueHandler) *const
    __imp_RemoveVectoredContinueHandler __msabi;
extern typeof(SetUnhandledExceptionFilter) *const
    __imp_SetUnhandledExceptionFilter __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/synchronization.h */

#define COSMOPOLITAN_LIBC_NT_SYNCHRONIZATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » synchronization                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define InterlockedAdd(PTR, VAL)                                           \
  ({                                                                       \
    typeof(*(PTR)) Res;                                                    \
    typeof(Res) Val = (VAL);                                               \
    asm volatile("lock xadd\t%0,%1" : "=r"(Res), "+m"(*(PTR)) : "0"(Val)); \
    Res + Val;                                                             \
  })

#define InterlockedExchange(PTR, VAL)                      \
  ({                                                       \
    typeof(*(PTR)) Res = (VAL);                            \
    asm volatile("xchg\t%0,%1" : "+r"(Res), "+m"(*(PTR))); \
    Res;                                                   \
  })

typedef void (*NtTimerapcroutine)(void *lpArgToCompletionRoutine,
                                  uint32_t dwTimerLowValue,
                                  uint32_t dwTimerHighValue);
typedef void (*NtWaitOrTimerCallback)(void *lpParameter,
                                      bool32 TimerOrWaitFired);

void Sleep(uint32_t dwMilliseconds);
uint32_t SleepEx(uint32_t dwMilliseconds, bool32 bAlertable);

void GetSystemTime(struct NtSystemTime *lpSystemTime);
bool32 SystemTimeToFileTime(const struct NtSystemTime *lpSystemTime,
                            struct NtFileTime *lpFileTime);
void GetSystemTimeAsFileTime(struct NtFileTime *);        /* win8+ */
void GetSystemTimePreciseAsFileTime(struct NtFileTime *); /* win8+ */

uint32_t WaitForSingleObject(int64_t hHandle, uint32_t dwMilliseconds);
uint32_t WaitForMultipleObjects(uint32_t nCount, const int64_t *lpHandles,
                                bool32 bWaitAll, uint32_t dwMilliseconds);
uint32_t WaitForSingleObjectEx(int64_t hHandle, uint32_t dwMilliseconds,
                               bool32 bAlertable);
uint32_t WaitForMultipleObjectsEx(unsigned int nCount, const int64_t *lpHandles,
                                  bool32 bWaitAll, uint32_t dwMilliseconds,
                                  bool32 bAlertable);
bool32 RegisterWaitForSingleObject(int64_t *phNewWaitObject, int64_t hObject,
                                   NtWaitOrTimerCallback Callback,
                                   void *Context, uint32_t dwMilliseconds,
                                   uint32_t dwFlags);

int64_t CreateWaitableTimer(struct NtSecurityAttributes *lpTimerAttributes,
                            bool32 bManualReset, const char16_t *lpTimerName);
bool32 SetWaitableTimer(int64_t hTimer, const int64_t *lpDueTimeAsFtOrNegRela,
                        int32_t opt_lPeriodMs, NtTimerapcroutine opt_callback,
                        void *lpArgToCallback, bool32 fUnsleepSystem);

int32_t SetEvent(int64_t hEvent);
int32_t ResetEvent(int64_t hEvent);
int32_t PulseEvent(int64_t hEvent);

int32_t ReleaseMutex(int64_t hMutex);
int32_t ReleaseSemaphore(int64_t hSemaphore, int32_t lReleaseCount,
                         int *lpPreviousCount);

void InitializeCriticalSection(struct NtCriticalSection *lpCriticalSection);
void EnterCriticalSection(struct NtCriticalSection *lpCriticalSection);
void LeaveCriticalSection(struct NtCriticalSection *lpCriticalSection);
int32_t TryEnterCriticalSection(struct NtCriticalSection *lpCriticalSection);
void DeleteCriticalSection(struct NtCriticalSection *lpCriticalSection);
int32_t InitializeCriticalSectionAndSpinCount(
    struct NtCriticalSection *lpCriticalSection, uint32_t dwSpinCount);
uint32_t SetCriticalSectionSpinCount(
    struct NtCriticalSection *lpCriticalSection, uint32_t dwSpinCount);

void InitializeSRWLock(intptr_t *);
void AcquireSRWLockExclusive(intptr_t *);
void AcquireSRWLockShared(intptr_t *);
void ReleaseSRWLockExclusive(intptr_t *);
void ReleaseSRWLockShared(intptr_t *);
void TryAcquireSRWLockExclusive(intptr_t *);
void TryAcquireSRWLockShared(intptr_t *);

uint64_t GetTickCount64(void);

bool32 QueryPerformanceFrequency(int64_t *lpFrequency);
bool32 QueryPerformanceCounter(int64_t *lpPerformanceCount);
bool32 GetSystemTimeAdjustment(uint32_t *lpTimeAdjustment,
                               uint32_t *lpTimeIncrement,
                               bool32 *lpTimeAdjustmentDisabled);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/synchronization.inc */

extern typeof(SleepEx) *const __imp_SleepEx __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/system.h */

#define COSMOPOLITAN_LIBC_NT_SYSTEM_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » system control                           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 SetSuspendState(bool32 bHibernate, bool32 bForce,
                       bool32 bWakeupEventsDisabled);

uint32_t InitiateShutdown(const char16_t *lpMachineName,
                          const char16_t *lpMessage, uint32_t dwGracePeriod,
                          uint32_t dwShutdownFlags, uint32_t dwReason);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/systeminfo.h */

#define COSMOPOLITAN_LIBC_NT_INFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void GetSystemInfo(struct NtSystemInfo *lpSystemInfo);
uint32_t GetSystemDirectory(char16_t *lpBuffer, uint32_t uSize);
uint32_t GetSystemDirectoryA(char *lpBuffer, uint32_t uSize);
uint32_t GetWindowsDirectory(char16_t *lpBuffer, uint32_t uSize);
uint32_t GetTempPath(uint32_t uSize, char16_t *lpBuffer);

bool32 GetComputerNameEx(/* enum/computernameformat.h */ int NameType,
                         char16_t *opt_lpBuffer, uint32_t *nSize);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/systeminfo.inc */

#define GetSystemInfo(...) __imp_GetSystemInfo(__VA_ARGS__)
#define GetTempPath(...) __imp_GetTempPathW(__VA_ARGS__)

extern typeof(GetSystemInfo) *const __imp_GetSystemInfo __msabi;
extern typeof(GetTempPath) *const __imp_GetTempPathW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/thread.h */

#define COSMOPOLITAN_LIBC_NT_THREADS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » threads                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef uint32_t (*NtThreadStartRoutine)(void *lpParameter);

int64_t CreateThread(struct NtSecurityAttributes *lpThreadAttributes,
                     size_t dwStackSize, NtThreadStartRoutine lpStartAddress,
                     void *lpParameter, uint32_t dwCreationFlags,
                     uint32_t *opt_lpThreadId);

void ExitThread(uint32_t dwExitCode) wontreturn;
int64_t GetCurrentThread(void);
uint32_t GetCurrentThreadId(void);
uint64_t SetThreadAffinityMask(int64_t hThread, uintptr_t dwThreadAffinityMask);
int64_t OpenThread(uint32_t dwDesiredAccess, bool32 bInheritHandle,
                   uint32_t dwThreadId);
bool32 TerminateThread(int64_t hThread, uint32_t dwExitCode);
bool32 GetExitCodeThread(int64_t hThread, uint32_t *lpExitCode);

/* e.g. kNtThreadPriorityAboveNormal, -1u on error */
uint32_t GetThreadPriority(int64_t hThread);
bool32 SetThreadPriority(int64_t hThread, int32_t nPriority);
bool32 SetThreadPriorityBoost(int64_t hThread, bool32 bDisablePriorityBoost);
bool32 GetThreadPriorityBoost(int64_t hThread, bool32 *pDisablePriorityBoost);
bool32 GetThreadIOPendingFlag(int64_t hThread, bool32 *lpIOIsPending);

bool32 CancelSynchronousIo(int64_t hThread);
bool32 CancelIo(int64_t hFile);
bool32 CancelIoEx(int64_t hFile, struct NtOverlapped *opt_lpOverlapped);

uint32_t TlsAlloc(void);
bool32 TlsFree(uint32_t);
bool32 TlsSetValue(uint32_t, void *);
void *TlsGetValue(uint32_t);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/thread.inc */

#define GetCurrentThread(...)  __imp_GetCurrentThread(__VA_ARGS__)
#define GetThreadPriority(...) __imp_GetThreadPriority(__VA_ARGS__)
#define SetThreadPriority(...) __imp_SetThreadPriority(__VA_ARGS__)

extern typeof(GetCurrentThread) *const __imp_GetCurrentThread __msabi;
extern typeof(GetThreadPriority) *const __imp_GetThreadPriority __msabi;
extern typeof(SetThreadPriority) *const __imp_SetThreadPriority __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/version.h */

#define COSMOPOLITAN_LIBC_NT_VERSION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool IsAtLeastWindows10(void) pureconst;
bool32 GetVersionEx(struct NtOsVersionInfo *lpVersionInformation);

#if defined(__GCC_ASM_FLAG_OUTPUTS__) && !defined(__STRICT_ANSI__)
#define IsAtLeastWindows10() (GetNtMajorVersion() >= 10)
#define GetNtMajorVersion()    \
  ({                           \
    uintptr_t __x;             \
    asm("mov\t%%gs:96,%q0\r\n" \
        "mov\t280(%q0),%b0"    \
        : "=q"(__x));          \
    (unsigned char)__x;        \
  })
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/windows.h */

#define COSMOPOLITAN_LIBC_NT_WINDOWS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » windows                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t CreateWindowEx(uint32_t dwExStyle, const char16_t *lpClassName,
                       const char16_t *lpWindowName, uint32_t dwStyle, int X,
                       int Y, int nWidth, int nHeight, int64_t hWndParent,
                       int64_t hMenu, int64_t hInstance, int64_t lpParam);

uint16_t RegisterClass(const struct NtWndClass *lpWndClass);

int64_t DefWindowProc(int64_t hWnd, uint32_t Msg, uint64_t wParam,
                      int64_t lParam);

int32_t CloseWindow(int64_t hWnd);
int32_t DestroyWindow(int64_t hWnd);
int32_t ShowWindow(int64_t hWnd, int sw);
int32_t ShowCaret(bool32 bShow);
int32_t AnimateWindow(int64_t hWnd, uint32_t dwTime, uint32_t dwFlags);
int64_t LoadIcon(int64_t hInstance, const char16_t *lpIconName);
int32_t MoveWindow(int64_t hWnd, int X, int Y, int nWidth, int nHeight,
                   bool32 bRepaint);
int32_t BringWindowToTop(int64_t hWnd);
int32_t IsWindowVisible(int64_t hWnd);
int32_t SetWindowText(int64_t hWnd, const char16_t *lpString);
int32_t GetWindowText(int64_t hWnd, char16_t *lpString, int nMaxCount);
int32_t SetWindowPos(int64_t hWnd, int64_t hWndInsertAfter, int X, int Y,
                     int cx, int cy, uint32_t uFlags);
bool32 GetWindowPlacement(int64_t hWnd, struct NtWindowPlacement *lpwndpl);
bool32 SetWindowPlacement(int64_t hWnd,
                          const struct NtWindowPlacement *lpwndpl);

int64_t GetCursor(void);
int64_t SetCursor(int64_t hCursor);
int32_t ShowCursor(bool32 bShow);
int64_t LoadCursor(int64_t opt_hInstance, const char16_t *lpCursorNameOrIdc);

bool32 IsWindow(int64_t hWnd);
bool32 IsMenu(int64_t hMenu);
bool32 IsChild(int64_t hWndParent, int64_t hWnd);
bool32 IsZoomed(int64_t hWnd);
bool32 IsIconic(int64_t hWnd);

uintptr_t SetTimer(int64_t opt_hWnd, uintptr_t nIDEvent, uint32_t uElapseMs,
                   NtTimerProc lpTimerFunc);
int32_t KillTimer(int64_t hWnd, uintptr_t uIDEvent);

int64_t SetCapture(int64_t hWnd);
bool32 ReleaseCapture(void);
int16_t GetKeyState(int32_t nVirtKey);

int64_t CreateMenu(void);
int64_t CreatePopupMenu(void);
int64_t GetMenu(int64_t hWnd);
bool32 DestroyMenu(int64_t hMenu);
int64_t GetSystemMenu(int64_t hWnd, bool32 bRevert);
bool32 AppendMenu(int64_t hMenu, uint32_t mfFlags, uintptr_t uIDNewItem,
                  const char16_t *lpNewItem);
bool32 InsertMenu(int64_t hMenu, uint32_t uPosition, uint32_t uFlags,
                  uintptr_t uIDNewItem, const char16_t *lpNewItem);
bool32 TrackPopupMenu(int64_t hMenu, uint32_t uFlags, int32_t x, int32_t y,
                      int32_t nReserved, int64_t hWnd,
                      const struct NtRect *prcRect);

int WideCharToMultiByte(unsigned int CodePage,
    uint32_t dwFlags,
    uint16_t * lpWideCharStr,
    int cchWideChar,
    char * lpMultiByteStr,
    int cbMultiByte,
    uint16_t * lpDefaultChar,
    int * lpUsedDefaultChar
);


COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/buffer.h */

#define COSMOPOLITAN_LIBC_RUNTIME_BUFFER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct GuardedBuffer {
  void *p;
};

void *balloc(struct GuardedBuffer *, unsigned, size_t);
void bfree(struct GuardedBuffer *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/clktck.h */

#define COSMOPOLITAN_LIBC_RUNTIME_CLKTCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define CLK_TCK (__clk_tck())

int __clk_tck(void) pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/dlfcn.h */

#define COSMOPOLITAN_LIBC_RUNTIME_DLFCN_H_

#define RTLD_LOCAL  0
#define RTLD_LAZY   1
#define RTLD_NOW    2
#define RTLD_GLOBAL 256

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define RTLD_NEXT    ((void *)-1)
#define RTLD_DEFAULT ((void *)0)

char *dlerror(void);
void *dlopen(const char *, int);
void *dlsym(void *, const char *);
int dlclose(void *);
int dl_iterate_phdr(int (*)(void *, size_t, void *), void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/fenv.h */

#define COSMOPOLITAN_LIBC_RUNTIME_FENV_H_

#define FE_TONEAREST  0x0000
#define FE_DOWNWARD   0x0400
#define FE_UPWARD     0x0800
#define FE_TOWARDZERO 0x0c00

#define FE_INVALID    1
#define FE_DIVBYZERO  4
#define FE_OVERFLOW   8
#define FE_UNDERFLOW  16
#define FE_INEXACT    32
#define FE_ALL_EXCEPT 61

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define FLT_ROUNDS (__flt_rounds())

typedef void *fenv_t;
typedef uint16_t fexcept_t;

int feclearexcept(int);
int fegetenv(fenv_t *);
int fegetexceptflag(fexcept_t *, int);
int fegetround(void);
int feholdexcept(fenv_t *);
int feraiseexcept(int);
int fesetenv(const fenv_t *);
int fesetexceptflag(const fexcept_t *, int);
int fesetround(int);
int fetestexcept(int);
int feupdateenv(const fenv_t *);
int __flt_rounds(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/gc.h */

#define COSMOPOLITAN_LIBC_RUNTIME_GC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void *_gc(void *) hidden;
void *_defer(void *, void *) hidden;
void __defer(struct StackFrame *, void *, void *) hidden;
void __deferer(struct StackFrame *, void *, void *) hidden;
void _gclongjmp(jmp_buf, int) dontthrow wontreturn;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define _gc(THING) _defer((void *)_weakfree, (void *)(THING))
#define _defer(FN, ARG)                                                \
  ({                                                                   \
    autotype(ARG) Arg = (ARG);                                         \
    /* prevent weird opts like tail call */                            \
    asm volatile("" : "+g"(Arg) : : "memory");                         \
    __defer((struct StackFrame *)__builtin_frame_address(0), FN, Arg); \
    asm volatile("" : "+g"(Arg) : : "memory");                         \
    Arg;                                                               \
  })
#endif /* defined(__GNUC__) && !defined(__STRICT_ANSI__) */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/stack.h */

#define COSMOPOLITAN_LIBC_RUNTIME_STACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Tunes APE stack maximum size.
 *
 * This defaults to `STACKSIZE`. The bottom-most page will be protected
 * to ensure your stack does not magically grow beyond this value. It's
 * possible to detect stack overflows, by calling `ShowCrashReports()`.
 * Your stack size must be a power of two; the linker will check this.
 *
 * If you want to know how much stack your programs needs, then
 *
 *     STATIC_YOINK("stack_usage_logging");
 *
 * will install an atexit() handler that appends to `o/$MODE/stack.log`
 *
 * @see libc/sysv/systemfive.S
 * @see ape/ape.lds
 */
#define STATIC_STACK_SIZE(BYTES) \
  STATIC_SYMBOL("ape_stack_memsz", _STACK_STRINGIFY(BYTES) _STACK_EXTRA)

/**
 * Tunes APE stack virtual address.
 *
 * This value must be aligned according to your stack size, and that's
 * checked by your linker script. This defaults to `0x700000000000` so
 *
 * 1. It's easy to see how close you are to the bottom
 * 2. The linker script error is unlikely to happen
 *
 * This macro will be respected, with two exceptions
 *
 * 1. In MODE=tiny the operating system provided stack is used instead
 * 2. Windows 7 doesn't support 64-bit addresses, so we'll instead use
 *    `0x10000000 - GetStackSize()` as the stack address
 *
 * @see libc/sysv/systemfive.S
 * @see libc/nt/winmain.greg.c
 * @see ape/ape.lds
 */
#define STATIC_STACK_ADDR(ADDR) \
  STATIC_SYMBOL("ape_stack_vaddr", _STACK_STRINGIFY(ADDR))

/**
 * Makes program stack executable if declared, e.g.
 *
 *     STATIC_EXEC_STACK();
 *     int main() {
 *       char code[16] = {
 *           0x55,                          // push %rbp
 *           0xb8, 0007, 0x00, 0x00, 0x00,  // mov  $7,%eax
 *           0x5d,                          // push %rbp
 *           0xc3,                          // ret
 *       };
 *       int (*func)(void) = (void *)code;
 *       printf("result %d should be 7\n", func());
 *     }
 */
#define STATIC_EXEC_STACK() STATIC_SYMBOL("ape_stack_pf", "7")

#define _STACK_STRINGIFY(ADDR) #ADDR

#if IsAsan()
#define _STACK_EXTRA "*2"
#else
#define _STACK_EXTRA ""
#endif

#if defined(__GNUC__) && defined(__ELF__) && !defined(__STRICT_ANSI__)
COSMOPOLITAN_C_START_

extern char ape_stack_prot[] __attribute__((__weak__));
extern char ape_stack_memsz[] __attribute__((__weak__));
extern char ape_stack_align[] __attribute__((__weak__));

/**
 * Returns size of stack, which is always a two power.
 */
#define GetStackSize() ((uintptr_t)ape_stack_memsz)

/**
 * Returns address of bottom of stack.
 *
 * This takes into consideration threads and sigaltstack. This is
 * implemented as a fast pure expression, since we're able to make the
 * assumption that stack sizes are two powers and aligned. This is
 * thanks to (1) the linker script checks the statically chosen sizes,
 * and (2) the mmap() address picker will choose aligned addresses when
 * the provided size is a two power.
 */
#define GetStackAddr() \
  (((intptr_t)__builtin_frame_address(0) - 1) & -GetStackSize())

/**
 * Returns preferred bottom address of stack.
 *
 * This is the stakc address of the main process. The only time that
 * isn't guaranteed to be the case is in MODE=tiny, since it doesn't
 * link the code for stack creation at startup. This generally isn't
 * problematic, since MODE=tiny doesn't use any of the runtime codes
 * which want the stack to be cheaply knowable, e.g. ftrace, kprintf
 */
#define GetStaticStackAddr(ADDEND)              \
  ({                                            \
    intptr_t vAddr;                             \
    if (!IsWindows() || IsAtLeastWindows10()) { \
      __asm__(".weak\tape_stack_vaddr\n\t"      \
              "movabs\t%1+ape_stack_vaddr,%0"   \
              : "=r"(vAddr)                     \
              : "i"(ADDEND));                   \
    } else {                                    \
      vAddr = 0x100000000 - GetStackSize();     \
    }                                           \
    vAddr;                                      \
  })

/**
 * Returns true if at least `n` bytes of stack are available.
 */
#define HaveStackMemory(n) \
  (IsTiny() ||             \
   (intptr_t)__builtin_frame_address(0) >= GetStackAddr() + PAGESIZE + (n))

forceinline void CheckLargeStackAllocation(void *p, ssize_t n) {
  for (; n > 0; n -= 4096) {
    ((char *)p)[n - 1] = 0;
  }
}

COSMOPOLITAN_C_END_
#endif /* GNU ELF */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/sysconf.h */

#define COSMOPOLITAN_LIBC_RUNTIME_SYSCONF_H_

#define _SC_ARG_MAX          0
#define _SC_CHILD_MAX        1
#define _SC_CLK_TCK          2
#define _SC_OPEN_MAX         4
#define _SC_PAGESIZE         30
#define _SC_PAGE_SIZE        30
#define _SC_NPROCESSORS_ONLN 1002

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

long sysconf(int);
unsigned GetCpuCount(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/unwind.h */

#define COSMOPOLITAN_LIBC_RUNTIME_UNWIND_H_

#define UNW_TDEP_CURSOR_LEN 127

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef enum {
  _URC_NO_REASON = 0,
  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
  _URC_FATAL_PHASE2_ERROR = 2,
  _URC_FATAL_PHASE1_ERROR = 3,
  _URC_NORMAL_STOP = 4,
  _URC_END_OF_STACK = 5,
  _URC_HANDLER_FOUND = 6,
  _URC_INSTALL_CONTEXT = 7,
  _URC_CONTINUE_UNWIND = 8
} _Unwind_Reason_Code;

typedef uint64_t unw_word_t;

typedef struct unw_cursor {
  unw_word_t opaque[UNW_TDEP_CURSOR_LEN];
} unw_cursor_t;

struct _Unwind_Context {
  unw_cursor_t cursor;
  int end_of_stack;
};

typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)(struct _Unwind_Context *,
                                                void *);

uintptr_t _Unwind_GetCFA(struct _Unwind_Context *);
uintptr_t _Unwind_GetIP(struct _Unwind_Context *);
_Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
void *_Unwind_FindEnclosingFunction(void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/utmp.h */

#define COSMOPOLITAN_LIBC_RUNTIME_UTMP_H_


/*!BEGIN libc/runtime/utmpx.h */

#define COSMOPOLITAN_LIBC_RUNTIME_UTMPX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct utmpx {
  short ut_type;
  pid_t ut_pid;
  char ut_line[32];
  char ut_id[4];
  char ut_user[32];
  char ut_host[256];
  struct {
    short __e_termination;
    short __e_exit;
  } ut_exit;
  long ut_session;
  struct timeval ut_tv;
  unsigned ut_addr_v6[4];
  char __unused[20];
};

void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *);
struct utmpx *getutxline(const struct utmpx *);
struct utmpx *pututxline(const struct utmpx *);
void setutxent(void);

#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
#define e_exit        __e_exit
#define e_termination __e_termination
void updwtmpx(const char *, const struct utmpx *);
int utmpxname(const char *);
#endif

#define EMPTY         0
#define RUN_LVL       1
#define BOOT_TIME     2
#define NEW_TIME      3
#define OLD_TIME      4
#define INIT_PROCESS  5
#define LOGIN_PROCESS 6
#define USER_PROCESS  7
#define DEAD_PROCESS  8

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define ACCOUNTING  9
#define UT_NAMESIZE 32
#define UT_HOSTSIZE 256
#define UT_LINESIZE 32

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct lastlog {
  time_t ll_time;
  char ll_line[UT_LINESIZE];
  char ll_host[UT_HOSTSIZE];
};

#define ut_time       ut_tv.tv_sec
#define ut_name       ut_user
#define ut_addr       ut_addr_v6[0]
#define utmp          utmpx
#define e_exit        __e_exit
#define e_termination __e_termination

int login_tty(int);
int utmpname(const char *);
struct utmp *getutent(void);
struct utmp *getutid(const struct utmp *);
struct utmp *getutline(const struct utmp *);
struct utmp *pututline(const struct utmp *);
void endutent(void);
void setutent(void);
void updwtmp(const char *, const struct utmp *);

#define _PATH_UTMP "/dev/null/utmp"
#define _PATH_WTMP "/dev/null/wtmp"

#define UTMP_FILE     _PATH_UTMP
#define WTMP_FILE     _PATH_WTMP
#define UTMP_FILENAME _PATH_UTMP
#define WTMP_FILENAME _PATH_WTMP

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/alg.h */

#define COSMOPOLITAN_LIBC_SOCK_ALG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sockaddr_alg {
  uint16_t salg_family;
  uint8_t salg_type[14];
  uint32_t salg_feat;
  uint32_t salg_mask;
  uint8_t salg_name[64];
};

struct sockaddr_alg_new {
  uint16_t salg_family;
  uint8_t salg_type[14];
  uint32_t salg_feat;
  uint32_t salg_mask;
  uint8_t salg_name[]; /* Linux v4.12+ */
};

struct af_alg_iv {
  uint32_t ivlen;
  uint8_t iv[0];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/epoll.h */

#define COSMOPOLITAN_LIBC_SOCK_WEPOLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef union epoll_data {
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;

struct thatispacked epoll_event {
  uint32_t events;
  epoll_data_t data;
};

int epoll_create(int);
int epoll_create1(int);
int epoll_ctl(int, int, int, struct epoll_event *);
int epoll_wait(int, struct epoll_event *, int, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/ppoll.h */

#define COSMOPOLITAN_LIBC_SOCK_PPOLL_H_


/*!BEGIN libc/sock/struct/pollfd.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_POLLFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct pollfd {
  int32_t fd;
  int16_t events;
  int16_t revents;
};

int poll(struct pollfd *, uint64_t, int32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int ppoll(struct pollfd *, uint64_t, const struct timespec *,
          const struct sigset *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/select.h */

#define COSMOPOLITAN_LIBC_SOCK_SELECT_H_

#define FD_SETSIZE 1024 /* it's 64 on windows */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef struct fd_set {
  uint64_t fds_bits[FD_SETSIZE / 64];
} fd_set;

#define FD_ISSET(FD, SET) (((SET)->fds_bits[(FD) >> 6] >> ((FD)&63)) & 1)
#define FD_SET(FD, SET)   ((SET)->fds_bits[(FD) >> 6] |= 1ull << ((FD)&63))
#define FD_CLR(FD, SET)   ((SET)->fds_bits[(FD) >> 6] &= ~(1ull << ((FD)&63)))
#define FD_ZERO(SET)      bzero((SET)->fds_bits, sizeof((SET)->fds_bits))

int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
int pselect(int, fd_set *, fd_set *, fd_set *, const struct timespec *,
            const sigset_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/syslog.h */

#define COSMOPOLITAN_LIBC_SOCK_SYSLOG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int setlogmask(int);
void openlog(const char *, int, int);
void syslog(int, const char *, ...);
void closelog(void);
void vsyslog(int, const char *, va_list);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/ifconf.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_IFCONF_H_


/*!BEGIN libc/sock/struct/ifreq.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_IFREQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct ifreq {
  union {
    char ifrn_name[IFNAMSIZ]; /* Interface name, e.g. "en0".  */
  } ifr_ifrn;
  union {
    struct sockaddr ifru_addr;      /* SIOCGIFADDR */
    struct sockaddr ifru_dstaddr;   /* SIOCGIFDSTADDR */
    struct sockaddr ifru_netmask;   /* SIOCGIFNETMASK */
    struct sockaddr ifru_broadaddr; /* SIOCGIFBRDADDR */
    short ifru_flags;               /* SIOCGIFFLAGS */
    char ifru_pad[24];              /* ifru_map is the largest, just pad */
  } ifr_ifru;
};

#define ifr_name      ifr_ifrn.ifrn_name /* interface name */
#define ifr_addr      ifr_ifru.ifru_addr /* address */
#define ifr_netmask   ifr_ifru.ifru_netmask /* netmask */
#define ifr_broadaddr ifr_ifru.ifru_broadaddr /* broadcast address */
#define ifr_dstaddr   ifr_ifru.ifru_dstaddr /* destination address */
#define ifr_flags     ifr_ifru.ifru_flags /* flags */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */
struct ifconf {
  uint64_t ifc_len; /* size of buffer   */
  union {
    char *ifcu_buf;
    struct ifreq *ifcu_req;
  } ifc_ifcu;
};

/* Shortcuts to the ifconf buffer or ifreq array */
#define ifc_buf ifc_ifcu.ifcu_buf /* buffer address   */
#define ifc_req ifc_ifcu.ifcu_req /* array of structures  */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/ip_mreq.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_IP_MREQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct ip_mreq {
  struct in_addr imr_multiaddr; /* IP multicast address of group */
  struct in_addr imr_interface; /* local IP address of interface */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/linger.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_LINGER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct linger {     /* Linux+XNU+BSD ABI */
  int32_t l_onoff;  /* on/off */
  int32_t l_linger; /* seconds */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/msghdr.h */

#define COSMOPOLITAN_LIBC_SOCK_STRUCT_MSGHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct msghdr {            /* Linux+NT ABI */
  void *msg_name;          /* optional address */
  uint32_t msg_namelen;    /* size of msg_name */
  struct iovec *msg_iov;   /* scatter/gather array */
  uint64_t msg_iovlen;     /* iovec count */
  void *msg_control;       /* credentials and stuff */
  uint64_t msg_controllen; /* size of msg_control */
  uint32_t msg_flags;      /* MSG_XXX */
};

ssize_t recvmsg(int, struct msghdr *, int);
ssize_t sendmsg(int, const struct msghdr *, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/struct/sockaddr6.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SOCKADDR6_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct in6_addr {
  union {
    uint8_t s6_addr[16];
    uint16_t s6_addr16[8];
    uint32_t s6_addr32[4];
  };
};

struct sockaddr_in6 { /* Linux+NT ABI */
  uint16_t sin6_family;
  uint16_t sin6_port;
  uint32_t sin6_flowinfo;
  struct in6_addr sin6_addr;
  uint32_t sin6_scope_id; /* rfc2553 */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/iconv.h */

#define COSMOPOLITAN_LIBC_STDIO_ICONV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef void *iconv_t;

iconv_t iconv_open(const char *, const char *);
size_t iconv(iconv_t, char **, size_t *, char **, size_t *);
int iconv_close(iconv_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/lock.h */

#define COSMOPOLITAN_LIBC_STDIO_LOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void flockfile(FILE *) paramsnonnull();
void funlockfile(FILE *) paramsnonnull();
int ftrylockfile(FILE *) paramsnonnull();

#ifdef _NOPL1
#define flockfile(f)    _NOPL1("__threadcalls", flockfile, f)
#define funlockfile(f)  _NOPL1("__threadcalls", funlockfile, f)
#define ftrylockfile(f) _NOPL1("__threadcalls", ftrylockfile, f)
#else
#define flockfile(f)    (__threaded ? flockfile(f) : 0)
#define funlockfile(f)  (__threaded ? funlockfile(f) : 0)
#define ftrylockfile(f) (__threaded ? ftrylockfile(f) : 0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/rand.h */

#define COSMOPOLITAN_LIBC_RAND_RAND_H_
#define RAND_MAX __INT_MAX__
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § random                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int rand(void);
void srand(uint64_t);
double poz(double);
double pochisq(double, int);
void rt_init(int);
void rt_add(void *, int);
void rt_end(double *, double *, double *, double *, double *);
char *strfry(char *);
int getentropy(void *, size_t);
ssize_t getrandom(void *, size_t, unsigned);
char *initstate(unsigned, char *, size_t);
char *setstate(char *);
long random(void);
void srandom(unsigned);

uint64_t lemur64(void);
uint64_t rand64(void);
uint64_t vigna(void);
uint64_t vigna_r(uint64_t[hasatleast 1]);
void svigna(uint64_t);
uint64_t rdrand(void);
uint64_t rdseed(void);
void _smt19937(uint64_t);
void _Smt19937(uint64_t[], size_t);
uint64_t _mt19937(void);
double _real1(uint64_t);
double _real2(uint64_t);
double _real3(uint64_t);
double MeasureEntropy(const char *, size_t);
void *rngset(void *, size_t, uint64_t (*)(void), size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/spawn.h */

#define COSMOPOLITAN_LIBC_STDIO_SPAWN_H_

#define POSIX_SPAWN_RESETIDS      0x01
#define POSIX_SPAWN_SETPGROUP     0x02
#define POSIX_SPAWN_SETSIGDEF     0x04
#define POSIX_SPAWN_SETSIGMASK    0x08
#define POSIX_SPAWN_SETSCHEDPARAM 0x10
#define POSIX_SPAWN_SETSCHEDULER  0x20

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef char *posix_spawn_file_actions_t;
typedef struct _posix_spawnattr posix_spawnattr_t;

int posix_spawn(int *, const char *, const posix_spawn_file_actions_t *,
                const posix_spawnattr_t *, char *const[], char *const[]);
int posix_spawnp(int *, const char *, const posix_spawn_file_actions_t *,
                 const posix_spawnattr_t *, char *const[], char *const[]);

int posix_spawn_file_actions_init(posix_spawn_file_actions_t *);
int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *);
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *, int);
int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *, int, int);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *, int,
                                     const char *, int, unsigned);

int posix_spawnattr_init(posix_spawnattr_t *);
int posix_spawnattr_destroy(posix_spawnattr_t *);
int posix_spawnattr_getflags(const posix_spawnattr_t *, short *);
int posix_spawnattr_setflags(posix_spawnattr_t *, short);
int posix_spawnattr_getpgroup(const posix_spawnattr_t *, int *);
int posix_spawnattr_setpgroup(posix_spawnattr_t *, int);
int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *, int *);
int posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int);
int posix_spawnattr_getschedparam(const posix_spawnattr_t *,
                                  struct sched_param *);
int posix_spawnattr_setschedparam(posix_spawnattr_t *,
                                  const struct sched_param *);
int posix_spawnattr_getsigmask(const posix_spawnattr_t *, sigset_t *);
int posix_spawnattr_setsigmask(posix_spawnattr_t *, const sigset_t *);
int posix_spawnattr_getdefault(const posix_spawnattr_t *, sigset_t *);
int posix_spawnattr_setsigdefault(posix_spawnattr_t *, const sigset_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/stdio_ext.h */

#define COSMOPOLITAN_LIBC_STDIO_STDIO_EXT_H_

#define FSETLOCKING_QUERY    0
#define FSETLOCKING_INTERNAL 1
#define FSETLOCKING_BYCALLER 2

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

size_t __fbufsize(FILE *);
size_t __fpending(FILE *);
int __flbf(FILE *);
int __freadable(FILE *);
int __fwritable(FILE *);
int __freading(FILE *);
int __fwriting(FILE *);
int __fsetlocking(FILE *, int);
void _flushlbf(void);
void __fpurge(FILE *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/temp.h */

#define COSMOPOLITAN_LIBC_STDIO_TEMP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

FILE *tmpfile(void);
char *mkdtemp(char *);
char *mktemp(char *);
char *tmpnam(char *);
int mkostemp(char *, unsigned);
int mkostemps(char *, int, unsigned);
int mkostempsm(char *, int, unsigned, int);
int mkstemp(char *);
int mkstemps(char *, int);

int mkostempsmi(char *, int, unsigned, uint64_t *, int,
                int (*)(const char *, int, ...)) hidden dontdiscard;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/xorshift.h */

#define COSMOPOLITAN_LIBC_RAND_XORSHIFT_H_

#define kMarsagliaXorshift64Seed 88172645463325252
#define kMarsagliaXorshift32Seed 2463534242

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint32_t MarsagliaXorshift32(uint32_t[hasatleast 1]);
uint64_t MarsagliaXorshift64(uint64_t[hasatleast 1]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/xed/avx.h */

#define COSMOPOLITAN_THIRD_PARTY_XED_AVX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

union XedAvxC4Payload1 {
  struct {
    unsigned map : 5;
    unsigned b_inv : 1;
    unsigned x_inv : 1;
    unsigned r_inv : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

union XedAvxC4Payload2 {
  struct {
    unsigned pp : 2;
    unsigned l : 1;
    unsigned vvv210 : 3;
    unsigned v3 : 1;
    unsigned w : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

union XedAvxC5Payload {
  struct {
    unsigned pp : 2;
    unsigned l : 1;
    unsigned vvv210 : 3;
    unsigned v3 : 1;
    unsigned r_inv : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/xed/avx512.h */

#define COSMOPOLITAN_THIRD_PARTY_XED_AVX512_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

union XedAvx512Payload1 {
  struct {
    unsigned map : 4;
    unsigned rr_inv : 1;
    unsigned b_inv : 1;
    unsigned x_inv : 1;
    unsigned r_inv : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

union XedAvx512Payload2 {
  struct {
    unsigned pp : 2;
    unsigned ubit : 1;
    unsigned vexdest210 : 3;
    unsigned vexdest3 : 1;
    unsigned rexw : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

union XedAvx512Payload3 {
  struct {
    unsigned mask : 3;
    unsigned vexdest4p : 1;
    unsigned bcrc : 1;
    unsigned llrc : 2;
    unsigned z : 1;
    unsigned pad : 24;
  } s;
  unsigned u32;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/xed/private.h */

#define COSMOPOLITAN_THIRD_PARTY_XED_PRIVATE_H_


/*!BEGIN third_party/xed/x86.h */

#define COSMOPOLITAN_THIRD_PARTY_XED_X86_H_
/*           ▓▓▓▓▓▓▓▓▓▓▓▓▓                      ▄▄▄▄
             ▓▓▓▓▓▓▓▓▓▓▓▓▓     ▄▓▓▓▓▓▓▄      ▄▓▓▓▓▓▓▓▓            ▄▓▓▓▀
             ▓▓▓▓    ▓▓▓▓▓    ▓     ▓▓▓▓    ▓▓       ▓▓▓      ▄▓▓▓▓
▬▬▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓▓▓▓▓▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬▬▓▓▓▬▬▬▓▓▓▬▬▬▬▬▬▬▬▓▓▬▬▬▬▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
        │    ▓▓▓▓    ▓▓▓▓▓          ▓▓▓     ▓▓▓▄     ▓▓▓   ▓▓▓▓             │
▬▬▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓    ▓▓▓▓▓▬▬▬▬▬▬▬▬▓▓▓▓▓▓▓▬▬▬▀▓▓▓▓▄▄▄▓▓▓▬▬▓▓▓▓▓▓▓▓▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬
        │    ▓▓▓▓    ▓▓▓▓▓          ▓▓▓▓▓▄   ▄▄▓▓▓▓▓▓▓▓▓  ▓▓▓▓      ▓▓▓▄    │
▬▬▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓    ▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓▓▄▄▓▓▀  ▀▀▓▓▓▓▓▓▓▓▓▓▬▬▬▬▬▬▬▬▓▓▓▬▬▬▬▬▬▬▬
▬▬▬▬▬▬▬▬║▬▬▬▬▓▓▓▓    ▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓▓▓▓▬▬▬▬▬▬▬▬▬▓▓▓ ▓▓▓▬▬▬▬▬▬▬▬▓▓▓▬▬▬▬║▬▬▬
▬▬▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓    ▓▓▓▓▓▬▬▬▬▬▬▬▬▬▬▬▓▓▓▓▬▬▓▓▓▬▬▬▬▬▬▬▬▓▓▓▬▓▓▓▓▬▬▬▬▬▬▬▓▓▓▬▬▬▬▬▬▬▬
■■■■■■■■║■■■■▓▓▓▓    ▓▓▓▓▓■■■▓▓▓▄▄▄▓▓▓▓■■■■▬▓▓▓▓▄▄▄▄▓▓▓■■■■▬▓▓▓▓▄▄▄▓▓▓▓▀■■■■║■■■
■■■■■■■■■■■■■▓▓▓▓▓▓▓▓▓▓▓▓▓■■■■■▀▓▓▓■■■■■■■■■■■■■■▀▀■■■■■■■■■■■■▀▓▓▀■■■■■■■■■■■■■
        ║▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓║
╔───────╨───────────────────────────────────────────────────────────────────╨──╗
│ cosmopolitan § virtual machine » byte code language                          │
╚─────────────────────────────────────────────────────────────────────────────*/

#define XED_MAX_INSTRUCTION_BYTES 15

#define XED_MODE_REAL   0
#define XED_MODE_LEGACY 1
#define XED_MODE_LONG   2

#define XED_HINT_NTAKEN 2
#define XED_HINT_TAKEN  4
#define XED_HINT_ALTER  6

#define xed_modrm_mod(M)           (((M)&0xff) >> 6)
#define xed_modrm_reg(M)           (((M)&0b00111000) >> 3)
#define xed_modrm_rm(M)            ((M)&7)
#define xed_sib_base(M)            ((M)&7)
#define xed_sib_index(M)           (((M)&0b00111000) >> 3)
#define xed_sib_scale(M)           (((M)&0xff) >> 6)
#define xed_get_modrm_reg_field(M) (((M)&0x38) >> 3)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define XED_MACHINE_MODE_REAL           XED_MODE_REAL
#define XED_MACHINE_MODE_LEGACY_32      XED_MODE_LEGACY
#define XED_MACHINE_MODE_LONG_64        XED_MODE_LONG
#define XED_MACHINE_MODE_UNREAL         (1 << 2 | XED_MODE_REAL)
#define XED_MACHINE_MODE_LEGACY_16      (2 << 2 | XED_MODE_REAL)
#define XED_MACHINE_MODE_LONG_COMPAT_16 (3 << 2 | XED_MODE_REAL)
#define XED_MACHINE_MODE_LONG_COMPAT_32 (4 << 2 | XED_MODE_LEGACY)
#define XED_MACHINE_MODE_LAST           (XED_MACHINE_MODE_LONG_COMPAT_32 + 1)

#define XED_ERROR_NONE                         0
#define XED_ERROR_BUFFER_TOO_SHORT             1
#define XED_ERROR_GENERAL_ERROR                2
#define XED_ERROR_INVALID_FOR_CHIP             3
#define XED_ERROR_BAD_REGISTER                 4
#define XED_ERROR_BAD_LOCK_PREFIX              5
#define XED_ERROR_BAD_REP_PREFIX               6
#define XED_ERROR_BAD_LEGACY_PREFIX            7
#define XED_ERROR_BAD_REX_PREFIX               8
#define XED_ERROR_BAD_EVEX_UBIT                9
#define XED_ERROR_BAD_MAP                      10
#define XED_ERROR_BAD_EVEX_V_PRIME             11
#define XED_ERROR_BAD_EVEX_Z_NO_MASKING        12
#define XED_ERROR_NO_OUTPUT_POINTER            13
#define XED_ERROR_NO_AGEN_CALL_BACK_REGISTERED 14
#define XED_ERROR_BAD_MEMOP_INDEX              15
#define XED_ERROR_CALLBACK_PROBLEM             16
#define XED_ERROR_GATHER_REGS                  17
#define XED_ERROR_INSTR_TOO_LONG               18
#define XED_ERROR_INVALID_MODE                 19
#define XED_ERROR_BAD_EVEX_LL                  20
#define XED_ERROR_UNIMPLEMENTED                21
#define XED_ERROR_LAST                         22

#define XED_ADDRESS_WIDTH_INVALID 0
#define XED_ADDRESS_WIDTH_16b     2
#define XED_ADDRESS_WIDTH_32b     4
#define XED_ADDRESS_WIDTH_64b     8
#define XED_ADDRESS_WIDTH_LAST    9

#define XED_ILD_MAP0        0 /* 8086+  ... */
#define XED_ILD_MAP1        1 /* 286+   0x0F,... */
#define XED_ILD_MAP2        2 /* Core2+ 0x0F,0x38,... */
#define XED_ILD_MAP3        3 /* Core2+ 0x0F,0x3A,... */
#define XED_ILD_MAP4        4
#define XED_ILD_MAP5        5
#define XED_ILD_MAP6        6
#define XED_ILD_MAPAMD      7
#define XED_ILD_MAP_XOP8    8
#define XED_ILD_MAP_XOP9    9
#define XED_ILD_MAP_XOPA    10
#define XED_ILD_MAP_LAST    11
#define XED_ILD_MAP_INVALID 12

struct XedOperands { /*
  ┌rep
  │ ┌log₂𝑏
  │ │ ┌mode
  │ │ │ ┌eamode
  │ │ │ │ ┌mod
  │ │ │ │ │
  │ │ │ │ │  ┌sego
  │ │ │ │ │  │
  │ │ │ │ │  │   ┌rex         REGISTER
  │ │ │ │ │  │   │┌rexb       DISPATCH
  │ │ │ │ │  │   ││┌srm       ENCODING
  │ │ │ │ │  │   │││  ┌rex
  │ │ │ │ │  │   │││  │┌rexb
  │ │ │ │ │  │   │││  ││┌rm
  │ │ │ │ │  │   │││  │││  ┌rexw
  │ │ │ │ │  │   │││  │││  │┌osz
  │ │ │ │ │  │   │││  │││  ││┌rex
  │ │ │ │ │  │   │││  │││  │││┌rexr
  │ │ │ │ │  │   │││  │││  ││││┌reg
  │3│2│2│2│2 │   │││  │││  │││││
  │0│8│6│4│2 │18 │││12│││ 7│││││ 0
  ├┐├┐├┐├┐├┐ ├─┐ ││├─┐││├─┐││││├─┐
  00000000000000000000000000000000*/
  uint32_t rde;
  union {
    struct {
      union {
        uint8_t opcode;
        uint8_t srm : 3;
      };
      uint8_t map : 4;
    };
    uint16_t dispatch;
  };
  union {
    uint8_t sib;
    struct {
      uint8_t base : 3;
      uint8_t index : 3;
      uint8_t scale : 2;
    };
  };
  bool osz : 1;   /* operand size override prefix */
  bool rexw : 1;  /* rex.w or rex.wb or etc. 64-bit override */
  bool rexb : 1;  /* rex.b or rex.wb or etc. see modrm table */
  bool rexr : 1;  /* rex.r or rex.wr or etc. see modrm table */
  bool rex : 1;   /* any rex prefix including rex */
  bool rexx : 1;  /* rex.x or rex.wx or etc. see sib table */
  bool rexrr : 1; /* evex */
  bool asz : 1;   /* address size override */
  int64_t disp;   /* displacement(%xxx) mostly sign-extended */
  uint64_t uimm0; /* $immediate mostly sign-extended */
  bool out_of_bytes : 1;
  bool is_intel_specific : 1;
  bool ild_f2 : 1;
  bool ild_f3 : 1;
  bool has_sib : 1;
  bool realmode : 1;
  bool amd3dnow : 1;
  bool lock : 1;
  union {
    uint8_t modrm; /* selects address register */
    struct {
      uint8_t rm : 3;
      uint8_t reg : 3;
      uint8_t mod : 2;
    };
  };
  uint8_t max_bytes;
  uint8_t rep : 2; /* 0, 2 (0xf2 repnz), 3 (0xf3 rep/repe) */
  uint8_t has_modrm : 2;
  bool imm_signed : 1;       /* internal */
  bool disp_unsigned : 1;    /* internal */
  uint8_t seg_ovd : 3;       /* XED_SEG_xx */
  uint8_t error : 5;         /* enum XedError */
  uint8_t mode : 2;          /* real,legacy,long */
  uint8_t hint : 3;          /* static branch prediction */
  uint8_t uimm1;             /* enter $x,$y */
  uint8_t disp_width;        /* in bits */
  uint8_t imm_width;         /* in bits */
  uint8_t mode_first_prefix; /* see xed_set_chip_modes() */
  uint8_t nrexes;
  uint8_t nprefixes;
  uint8_t nseg_prefixes;
  uint8_t ubit;       /* vex */
  uint8_t vexvalid;   /* vex */
  uint8_t vexdest3;   /* vex */
  uint8_t vexdest4;   /* vex */
  uint8_t vexdest210; /* vex */
  uint8_t vex_prefix; /* vex */
  uint8_t zeroing;    /* evex */
  uint8_t bcrc;       /* evex */
  uint8_t llrc;       /* evex */
  uint8_t vl;         /* evex */
  uint8_t mask;       /* evex */
  uint8_t imm1_bytes; /* evex */
  uint8_t pos_disp;
  uint8_t pos_imm;
  uint8_t pos_imm1;
  uint8_t pos_modrm;
  uint8_t pos_opcode;
  uint8_t pos_sib;
};

struct XedDecodedInst {
  unsigned char length;
  uint8_t bytes[15];
  struct XedOperands op;
};

#define xed_operands_set_mode(p, machine_mode) \
  do {                                         \
    struct XedOperands *__p = p;               \
    __p->realmode = false;                     \
    switch (machine_mode) {                    \
      default:                                 \
      case XED_MACHINE_MODE_LONG_64:           \
        __p->mode = XED_MODE_LONG;             \
        break;                                 \
      case XED_MACHINE_MODE_LEGACY_32:         \
      case XED_MACHINE_MODE_LONG_COMPAT_32:    \
        __p->mode = XED_MODE_LEGACY;           \
        break;                                 \
      case XED_MACHINE_MODE_REAL:              \
        __p->realmode = true;                  \
        __p->mode = XED_MODE_REAL;             \
        break;                                 \
      case XED_MACHINE_MODE_UNREAL:            \
        __p->realmode = true;                  \
        __p->mode = XED_MODE_LEGACY;           \
        break;                                 \
      case XED_MACHINE_MODE_LEGACY_16:         \
      case XED_MACHINE_MODE_LONG_COMPAT_16:    \
        __p->mode = XED_MODE_REAL;             \
        break;                                 \
    }                                          \
  } while (0)

extern const char kXedErrorNames[];
extern const uint8_t kXedEamode[2][3];

struct XedDecodedInst *xed_decoded_inst_zero_set_mode(struct XedDecodedInst *,
                                                      int);
int xed_instruction_length_decode(struct XedDecodedInst *, const void *,
                                  size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int xed_int_t;
typedef unsigned int xed_uint_t;
typedef unsigned int xed_uint_t;
typedef unsigned char xed_bits_t;
typedef intptr_t xed_addr_t;
typedef bool xed_bool_t;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/xed/x86isa.h */

#define COSMOPOLITAN_THIRD_PARTY_XED_X86ISA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define XED_CHIP_INVALID           1
#define XED_CHIP_I86               2
#define XED_CHIP_I86FP             3
#define XED_CHIP_I186              4
#define XED_CHIP_I186FP            5
#define XED_CHIP_I286REAL          6
#define XED_CHIP_I286              7
#define XED_CHIP_I2186FP           8
#define XED_CHIP_I386REAL          9
#define XED_CHIP_I386              10
#define XED_CHIP_I386FP            11
#define XED_CHIP_I486REAL          12
#define XED_CHIP_I486              13
#define XED_CHIP_PENTIUMREAL       14
#define XED_CHIP_PENTIUM           15
#define XED_CHIP_QUARK             16
#define XED_CHIP_PENTIUMMMXREAL    17
#define XED_CHIP_PENTIUMMMX        18
#define XED_CHIP_ALLREAL           19
#define XED_CHIP_PENTIUMPRO        20
#define XED_CHIP_PENTIUM2          21
#define XED_CHIP_PENTIUM3          22
#define XED_CHIP_PENTIUM4          23
#define XED_CHIP_P4PRESCOTT        24
#define XED_CHIP_P4PRESCOTT_NOLAHF 25
#define XED_CHIP_P4PRESCOTT_VTX    26
#define XED_CHIP_CORE2             27
#define XED_CHIP_PENRYN            28
#define XED_CHIP_PENRYN_E          29
#define XED_CHIP_NEHALEM           30
#define XED_CHIP_WESTMERE          31
#define XED_CHIP_BONNELL           32
#define XED_CHIP_SALTWELL          33
#define XED_CHIP_SILVERMONT        34
#define XED_CHIP_AMD               35
#define XED_CHIP_GOLDMONT          36
#define XED_CHIP_GOLDMONT_PLUS     37
#define XED_CHIP_TREMONT           38
#define XED_CHIP_SANDYBRIDGE       39
#define XED_CHIP_IVYBRIDGE         40
#define XED_CHIP_HASWELL           41
#define XED_CHIP_BROADWELL         42
#define XED_CHIP_SKYLAKE           43
#define XED_CHIP_SKYLAKE_SERVER    44
#define XED_CHIP_CASCADE_LAKE      45
#define XED_CHIP_KNL               46
#define XED_CHIP_KNM               47
#define XED_CHIP_CANNONLAKE        48
#define XED_CHIP_ICELAKE           49
#define XED_CHIP_ICELAKE_SERVER    50
#define XED_CHIP_FUTURE            51
#define XED_CHIP_ALL               52
#define XED_CHIP_LAST              53

#define XED_ISA_SET_INVALID               0
#define XED_ISA_SET_3DNOW                 1
#define XED_ISA_SET_ADOX_ADCX             2
#define XED_ISA_SET_AES                   3
#define XED_ISA_SET_AMD                   4
#define XED_ISA_SET_AVX                   5
#define XED_ISA_SET_AVX2                  6
#define XED_ISA_SET_AVX2GATHER            7
#define XED_ISA_SET_AVX512BW_128          8
#define XED_ISA_SET_AVX512BW_128N         9
#define XED_ISA_SET_AVX512BW_256          10
#define XED_ISA_SET_AVX512BW_512          11
#define XED_ISA_SET_AVX512BW_KOP          12
#define XED_ISA_SET_AVX512CD_128          13
#define XED_ISA_SET_AVX512CD_256          14
#define XED_ISA_SET_AVX512CD_512          15
#define XED_ISA_SET_AVX512DQ_128          16
#define XED_ISA_SET_AVX512DQ_128N         17
#define XED_ISA_SET_AVX512DQ_256          18
#define XED_ISA_SET_AVX512DQ_512          19
#define XED_ISA_SET_AVX512DQ_KOP          20
#define XED_ISA_SET_AVX512DQ_SCALAR       21
#define XED_ISA_SET_AVX512ER_512          22
#define XED_ISA_SET_AVX512ER_SCALAR       23
#define XED_ISA_SET_AVX512F_128           24
#define XED_ISA_SET_AVX512F_128N          25
#define XED_ISA_SET_AVX512F_256           26
#define XED_ISA_SET_AVX512F_512           27
#define XED_ISA_SET_AVX512F_KOP           28
#define XED_ISA_SET_AVX512F_SCALAR        29
#define XED_ISA_SET_AVX512PF_512          30
#define XED_ISA_SET_AVX512_4FMAPS_512     31
#define XED_ISA_SET_AVX512_4FMAPS_SCALAR  32
#define XED_ISA_SET_AVX512_4VNNIW_512     33
#define XED_ISA_SET_AVX512_BITALG_128     34
#define XED_ISA_SET_AVX512_BITALG_256     35
#define XED_ISA_SET_AVX512_BITALG_512     36
#define XED_ISA_SET_AVX512_GFNI_128       37
#define XED_ISA_SET_AVX512_GFNI_256       38
#define XED_ISA_SET_AVX512_GFNI_512       39
#define XED_ISA_SET_AVX512_IFMA_128       40
#define XED_ISA_SET_AVX512_IFMA_256       41
#define XED_ISA_SET_AVX512_IFMA_512       42
#define XED_ISA_SET_AVX512_VAES_128       43
#define XED_ISA_SET_AVX512_VAES_256       44
#define XED_ISA_SET_AVX512_VAES_512       45
#define XED_ISA_SET_AVX512_VBMI2_128      46
#define XED_ISA_SET_AVX512_VBMI2_256      47
#define XED_ISA_SET_AVX512_VBMI2_512      48
#define XED_ISA_SET_AVX512_VBMI_128       49
#define XED_ISA_SET_AVX512_VBMI_256       50
#define XED_ISA_SET_AVX512_VBMI_512       51
#define XED_ISA_SET_AVX512_VNNI_128       52
#define XED_ISA_SET_AVX512_VNNI_256       53
#define XED_ISA_SET_AVX512_VNNI_512       54
#define XED_ISA_SET_AVX512_VPCLMULQDQ_128 55
#define XED_ISA_SET_AVX512_VPCLMULQDQ_256 56
#define XED_ISA_SET_AVX512_VPCLMULQDQ_512 57
#define XED_ISA_SET_AVX512_VPOPCNTDQ_128  58
#define XED_ISA_SET_AVX512_VPOPCNTDQ_256  59
#define XED_ISA_SET_AVX512_VPOPCNTDQ_512  60
#define XED_ISA_SET_AVXAES                61
#define XED_ISA_SET_AVX_GFNI              62
#define XED_ISA_SET_BMI1                  63
#define XED_ISA_SET_BMI2                  64
#define XED_ISA_SET_CET                   65
#define XED_ISA_SET_CLDEMOTE              66
#define XED_ISA_SET_CLFLUSHOPT            67
#define XED_ISA_SET_CLFSH                 68
#define XED_ISA_SET_CLWB                  69
#define XED_ISA_SET_CLZERO                70
#define XED_ISA_SET_CMOV                  71
#define XED_ISA_SET_CMPXCHG16B            72
#define XED_ISA_SET_F16C                  73
#define XED_ISA_SET_FAT_NOP               74
#define XED_ISA_SET_FCMOV                 75
#define XED_ISA_SET_FMA                   76
#define XED_ISA_SET_FMA4                  77
#define XED_ISA_SET_FXSAVE                78
#define XED_ISA_SET_FXSAVE64              79
#define XED_ISA_SET_GFNI                  80
#define XED_ISA_SET_I186                  81
#define XED_ISA_SET_I286PROTECTED         82
#define XED_ISA_SET_I286REAL              83
#define XED_ISA_SET_I386                  84
#define XED_ISA_SET_I486                  85
#define XED_ISA_SET_I486REAL              86
#define XED_ISA_SET_I86                   87
#define XED_ISA_SET_INVPCID               88
#define XED_ISA_SET_LAHF                  89
#define XED_ISA_SET_LONGMODE              90
#define XED_ISA_SET_LZCNT                 91
#define XED_ISA_SET_MONITOR               92
#define XED_ISA_SET_MONITORX              93
#define XED_ISA_SET_MOVBE                 94
#define XED_ISA_SET_MOVDIR                95
#define XED_ISA_SET_MPX                   96
#define XED_ISA_SET_PAUSE                 97
#define XED_ISA_SET_PCLMULQDQ             98
#define XED_ISA_SET_PCONFIG               99
#define XED_ISA_SET_PENTIUMMMX            100
#define XED_ISA_SET_PENTIUMREAL           101
#define XED_ISA_SET_PKU                   102
#define XED_ISA_SET_POPCNT                103
#define XED_ISA_SET_PPRO                  104
#define XED_ISA_SET_PREFETCHW             105
#define XED_ISA_SET_PREFETCHWT1           106
#define XED_ISA_SET_PREFETCH_NOP          107
#define XED_ISA_SET_PT                    108
#define XED_ISA_SET_RDPID                 109
#define XED_ISA_SET_RDPMC                 110
#define XED_ISA_SET_RDRAND                111
#define XED_ISA_SET_RDSEED                112
#define XED_ISA_SET_RDTSCP                113
#define XED_ISA_SET_RDWRFSGS              114
#define XED_ISA_SET_RTM                   115
#define XED_ISA_SET_SGX                   116
#define XED_ISA_SET_SGX_ENCLV             117
#define XED_ISA_SET_SHA                   118
#define XED_ISA_SET_SMAP                  119
#define XED_ISA_SET_SMX                   120
#define XED_ISA_SET_SSE                   121
#define XED_ISA_SET_SSE2                  122
#define XED_ISA_SET_SSE2MMX               123
#define XED_ISA_SET_SSE3                  124
#define XED_ISA_SET_SSE3X87               125
#define XED_ISA_SET_SSE4                  126
#define XED_ISA_SET_SSE42                 127
#define XED_ISA_SET_SSE4A                 128
#define XED_ISA_SET_SSEMXCSR              129
#define XED_ISA_SET_SSE_PREFETCH          130
#define XED_ISA_SET_SSSE3                 131
#define XED_ISA_SET_SSSE3MMX              132
#define XED_ISA_SET_SVM                   133
#define XED_ISA_SET_TBM                   134
#define XED_ISA_SET_VAES                  135
#define XED_ISA_SET_VMFUNC                136
#define XED_ISA_SET_VPCLMULQDQ            137
#define XED_ISA_SET_VTX                   138
#define XED_ISA_SET_WAITPKG               139
#define XED_ISA_SET_WBNOINVD              140
#define XED_ISA_SET_X87                   141
#define XED_ISA_SET_XOP                   142
#define XED_ISA_SET_XSAVE                 143
#define XED_ISA_SET_XSAVEC                144
#define XED_ISA_SET_XSAVEOPT              145
#define XED_ISA_SET_XSAVES                146
#define XED_ISA_SET_LAST                  147

struct XedChipFeatures {
  uint64_t f[3];
};

#define xed_set_chip_modes(d, chip)    \
  do {                                 \
    struct XedDecodedInst *__d = d;    \
    switch (chip) {                    \
      case XED_CHIP_INVALID:           \
        break;                         \
      case XED_CHIP_I86:               \
      case XED_CHIP_I86FP:             \
      case XED_CHIP_I186:              \
      case XED_CHIP_I186FP:            \
      case XED_CHIP_I286REAL:          \
      case XED_CHIP_I286:              \
      case XED_CHIP_I2186FP:           \
      case XED_CHIP_I386REAL:          \
      case XED_CHIP_I386:              \
      case XED_CHIP_I386FP:            \
      case XED_CHIP_I486REAL:          \
      case XED_CHIP_I486:              \
      case XED_CHIP_QUARK:             \
      case XED_CHIP_PENTIUM:           \
      case XED_CHIP_PENTIUMREAL:       \
      case XED_CHIP_PENTIUMMMX:        \
      case XED_CHIP_PENTIUMMMXREAL:    \
        __d->op.mode_first_prefix = 1; \
        break;                         \
      default:                         \
        break;                         \
    }                                  \
    switch (chip) {                    \
      case XED_CHIP_INVALID:           \
      case XED_CHIP_ALL:               \
      case XED_CHIP_AMD:               \
        break;                         \
      default:                         \
        __d->op.is_intel_specific = 1; \
        break;                         \
    }                                  \
  } while (0)

extern const uint64_t kXedChipFeatures[XED_CHIP_LAST][3];

bool xed_test_chip_features(struct XedChipFeatures *, int);
void xed_get_chip_features(struct XedChipFeatures *, int);
bool xed_isa_set_is_valid_for_chip(int, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/blake2.h */

#define COSMOPOLITAN_LIBC_STR_BLAKE2_H_

#define BLAKE2B256_DIGEST_LENGTH 32
#define BLAKE2B_CBLOCK           128

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct Blake2b {
  uint64_t h[8];
  uint64_t t_low;
  uint64_t t_high;
  union {
    uint8_t bytes[BLAKE2B_CBLOCK];
    uint64_t words[16];
  } block;
  size_t block_used;
};

int BLAKE2B256_Init(struct Blake2b *);
int BLAKE2B256_Update(struct Blake2b *, const void *, size_t);
int BLAKE2B256_Process(struct Blake2b *, const uint64_t[BLAKE2B_CBLOCK / 8]);
int BLAKE2B256_Final(struct Blake2b *, uint8_t[BLAKE2B256_DIGEST_LENGTH]);
int BLAKE2B256(const void *, size_t, uint8_t[BLAKE2B256_DIGEST_LENGTH]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/highwayhash64.h */

#define COSMOPOLITAN_LIBC_STR_HIGHWAYHASH64_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t HighwayHash64(const void *, size_t, const uint64_t[4]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/langinfo.h */

#define COSMOPOLITAN_LIBC_STR_LANGINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define ABDAY_1 0x20000
#define ABDAY_2 0x20001
#define ABDAY_3 0x20002
#define ABDAY_4 0x20003
#define ABDAY_5 0x20004
#define ABDAY_6 0x20005
#define ABDAY_7 0x20006

#define DAY_1 0x20007
#define DAY_2 0x20008
#define DAY_3 0x20009
#define DAY_4 0x2000A
#define DAY_5 0x2000B
#define DAY_6 0x2000C
#define DAY_7 0x2000D

#define ABMON_1  0x2000E
#define ABMON_2  0x2000F
#define ABMON_3  0x20010
#define ABMON_4  0x20011
#define ABMON_5  0x20012
#define ABMON_6  0x20013
#define ABMON_7  0x20014
#define ABMON_8  0x20015
#define ABMON_9  0x20016
#define ABMON_10 0x20017
#define ABMON_11 0x20018
#define ABMON_12 0x20019

#define MON_1  0x2001A
#define MON_2  0x2001B
#define MON_3  0x2001C
#define MON_4  0x2001D
#define MON_5  0x2001E
#define MON_6  0x2001F
#define MON_7  0x20020
#define MON_8  0x20021
#define MON_9  0x20022
#define MON_10 0x20023
#define MON_11 0x20024
#define MON_12 0x20025

#define AM_STR 0x20026
#define PM_STR 0x20027

#define D_T_FMT    0x20028
#define D_FMT      0x20029
#define T_FMT      0x2002A
#define T_FMT_AMPM 0x2002B

#define ERA         0x2002C
#define ERA_D_FMT   0x2002E
#define ALT_DIGITS  0x2002F
#define ERA_D_T_FMT 0x20030
#define ERA_T_FMT   0x20031

#define CODESET 14

#define CRNCYSTR 0x4000F

#define RADIXCHAR 0x10000
#define THOUSEP   0x10001
#define YESEXPR   0x50000
#define NOEXPR    0x50001

#define _NL_LOCALE_NAME(cat) (((cat) << 16) | 0xffff)

#if defined(_GNU_SOURCE)
#define NL_LOCALE_NAME(cat) _NL_LOCALE_NAME(cat)
#endif

#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#define YESSTR 0x50002
#define NOSTR  0x50003
#endif

char *nl_langinfo(int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/locale.h */

#define COSMOPOLITAN_LIBC_STR_LOCALE_H_


/*!BEGIN libc/time/struct/tm.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_TM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct tm {
  int32_t tm_sec;
  int32_t tm_min;
  int32_t tm_hour;
  int32_t tm_mday; /* 1-indexed */
  int32_t tm_mon;  /* 0-indexed */
  int32_t tm_year; /* minus 1900 */
  int32_t tm_wday;
  int32_t tm_yday;
  int32_t tm_isdst;
  int64_t tm_gmtoff;
  const char *tm_zone;
};

struct tm *gmtime_r(const int64_t *, struct tm *);
struct tm *localtime_r(const int64_t *, struct tm *);
int64_t timegm(struct tm *);
int64_t mktime(struct tm *);
int64_t timelocal(struct tm *);
int64_t timeoff(struct tm *, long);
char *strptime(const char *, const char *, struct tm *);
size_t strftime(char *, size_t, const char *, const struct tm *)
    strftimeesque(3);
char *asctime(const struct tm *);
char *asctime_r(const struct tm *, char[hasatleast 64]);
char *iso8601(char[hasatleast 20], struct tm *);
size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define LC_CTYPE         0
#define LC_NUMERIC       1
#define LC_CTYPE_MASK    1
#define LC_TIME          2
#define LC_NUMERIC_MASK  2
#define LC_COLLATE       3
#define LC_MONETARY      4
#define LC_TIME_MASK     4
#define LC_MESSAGES      5
#define LC_ALL           6
#define LC_COLLATE_MASK  8
#define LC_MONETARY_MASK 16
#define LC_MESSAGES_MASK 32
#define LC_ALL_MASK      0x1fbf
#define LOCALE_NAME_MAX  23

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define LC_GLOBAL_LOCALE ((locale_t)-1)

struct __locale_map {
  const void *map;
  size_t map_size;
  char name[LOCALE_NAME_MAX + 1];
  const struct __locale_map *next;
};

struct __locale_struct {
  const struct __locale_map *cat[6];
};

typedef struct __locale_struct *locale_t;

char *nl_langinfo_l(int, locale_t);
char *setlocale(int, const char *);
double strtod_l(const char *, char **, locale_t);
double wcstod_l(const wchar_t *, wchar_t **, locale_t);
float strtof_l(const char *, char **, locale_t);
float wcstof_l(const wchar_t *, wchar_t **, locale_t);
int isdigit_l(int, locale_t);
int islower_l(int, locale_t);
int isupper_l(int, locale_t);
int iswalpha_l(wint_t, locale_t);
int iswblank_l(wint_t, locale_t);
int iswcntrl_l(wint_t, locale_t);
int iswdigit_l(wint_t, locale_t);
int iswlower_l(wint_t, locale_t);
int iswprint_l(wint_t, locale_t);
int iswpunct_l(wint_t, locale_t);
int iswspace_l(wint_t, locale_t);
int iswupper_l(wint_t, locale_t);
int iswxdigit_l(wint_t, locale_t);
int isxdigit_l(int, locale_t);
int strcoll_l(const char *, const char *, locale_t);
int tolower_l(int, locale_t);
int toupper_l(int, locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
locale_t duplocale(locale_t);
locale_t newlocale(int, const char *, locale_t);
locale_t uselocale(locale_t);
long double strtold_l(const char *, char **, locale_t);
long double wcstold_l(const wchar_t *, wchar_t **, locale_t);
long long strtoll_l(const char *, char **, int, locale_t);
long long wcstoll_l(const wchar_t *, wchar_t **, int, locale_t);
size_t strftime_l(char *, size_t, char const *, struct tm const *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t, locale_t);
unsigned long long strtoull_l(const char *, char **, int, locale_t);
unsigned long long wcstoull_l(const wchar_t *, wchar_t **, int, locale_t);
void freelocale(locale_t);
wint_t towlower_l(wint_t, locale_t);
wint_t towupper_l(wint_t, locale_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/nltypes.h */

#define COSMOPOLITAN_LIBC_STR_NLTYPES_H_

#define NL_SETD       1
#define NL_CAT_LOCALE 1

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int nl_item;
typedef void *nl_catd;

nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *);
int catclose(nl_catd);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/path.h */

#define COSMOPOLITAN_LIBC_STR_PATH_H_

#define _kPathAbs  1
#define _kPathDev  2
#define _kPathRoot 4
#define _kPathDos  8
#define _kPathWin  16
#define _kPathNt   32

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int _classifypath(const char *) libcesque nosideeffect;
bool _isabspath(const char *) libcesque strlenesque;
bool _isdirsep(int) libcesque pureconst;
char *_joinpaths(char *, size_t, const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/slice.h */

#define COSMOPOLITAN_LIBC_STR_SLICE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define SlicesEqual(a, n, b, m)       \
  ({                                  \
    size_t __n = (n);                 \
    __n == (m) && !memcmp(a, b, __n); \
  })

#define SlicesEqualCase(a, n, b, m)       \
  ({                                      \
    size_t __n = (n);                     \
    __n == (m) && !memcasecmp(a, b, __n); \
  })

int CompareSlices(const char *, size_t, const char *, size_t);
int CompareSlicesCase(const char *, size_t, const char *, size_t);
bool StartsWithIgnoreCase(const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/thompike.h */

#define COSMOPOLITAN_LIBC_STR_THOMPIKE_H_

#define ThomPikeCont(x)     (0200 == (0300 & (x)))
#define ThomPikeByte(x)     ((x) & (((1 << ThomPikeMsb(x)) - 1) | 3))
#define ThomPikeLen(x)      (7 - ThomPikeMsb(x))
#define ThomPikeMsb(x)      ((255 & (x)) < 252 ? bsr(255 & ~(x)) : 1)
#define ThomPikeMerge(x, y) ((x) << 6 | 077 & (y))



/*!BEGIN libc/str/tpenc.h */

#define COSMOPOLITAN_LIBC_STR_TPENC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t tpenc(int32_t) pureconst;

#if defined(__MNO_RED_ZONE__) && defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define tpenc(CODE)            \
  ({                           \
    long Edi, Buf;             \
    asm("call\ttpenc"          \
        : "=a"(Buf), "=D"(Edi) \
        : "1"((int)(CODE))     \
        : "rcx", "rdx", "cc"); \
    Buf;                       \
  })
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/undeflate.h */

#define COSMOPOLITAN_LIBC_STR_UNDEFLATE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DeflateState {
  uint8_t lenlens[19];
  uint32_t lencodes[19];
  uint32_t distcodes[32];
  uint32_t litcodes[288];
  uint8_t lens[288 + 32];
};

ssize_t undeflate(void *output, size_t outputsize, void *input,
                  size_t inputsize, struct DeflateState *ds);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/unicode.h */

#define COSMOPOLITAN_LIBC_STR_UNICODE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct lconv {
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_n_cs_precedes;
  char int_p_sep_by_space;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

int wcwidth(wchar_t) pureconst;
int wcswidth(const wchar_t *, size_t) strlenesque;
int wcsnwidth(const wchar_t *, size_t, size_t) strlenesque;
int strwidth(const char *, size_t) strlenesque;
int strnwidth(const char *, size_t, size_t) strlenesque;
int strwidth16(const char16_t *, size_t) strlenesque;
int strnwidth16(const char16_t *, size_t, size_t) strlenesque;
struct lconv *localeconv(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/utf16.h */

#define COSMOPOLITAN_LIBC_STR_UTF16_H_

#define UTF16_MASK 0xfc00
#define UTF16_MOAR 0xd800 /* 0xD800..0xDBFF */
#define UTF16_CONT 0xdc00 /* 0xDC00..0xDFFF */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define IsSurrogate(wc)     ((0xf800 & (wc)) == 0xd800)
#define IsHighSurrogate(wc) ((UTF16_MASK & (wc)) == UTF16_MOAR)
#define IsLowSurrogate(wc)  ((UTF16_MASK & (wc)) == UTF16_CONT)
#define IsUcs2(wc)          (((65535 & (wc)) >> 11) != 27)
#define IsUtf16Cont(wc)     IsLowSurrogate(wc) /* TODO: DELETE */
#define MergeUtf16(hi, lo)  ((((hi)-0xD800) << 10) + ((lo)-0xDC00) + 0x10000)
#define EncodeUtf16(wc)                                       \
  (LIKELY((0x0000 <= (wc) && (wc) <= 0xFFFF) ||               \
          (0xE000 <= (wc) && (wc) <= 0xFFFF))                 \
       ? (wc)                                                 \
   : 0x10000 <= (wc) && (wc) <= 0x10FFFF                      \
       ? (((((wc)-0x10000) >> 10) + 0xD800) |                 \
          (unsigned)((((wc)-0x10000) & 1023) + 0xDC00) << 16) \
       : 0xFFFD)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/errfuns.h */

#define COSMOPOLITAN_LIBC_SYSV_ERRFUNS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview Optimized error return paths.
 *
 * Saying this:
 *
 *     return einval();
 *
 * Instead of this:
 *
 *     errno = EINVAL;
 *     return -1;
 *
 * Allows the compiler to generate 11 fewer bytes of code each time.
 *
 * @return always -1
 * @see libc/sysv/errfuns.inc (for implementation)
 */

intptr_t einval(void) relegated;
intptr_t eperm(void) relegated;
intptr_t enoent(void) relegated;
intptr_t esrch(void) relegated;
intptr_t eintr(void) relegated;
intptr_t eio(void) relegated;
intptr_t enxio(void) relegated;
intptr_t e2big(void) relegated;
intptr_t enoexec(void) relegated;
intptr_t ebadf(void) relegated;
intptr_t echild(void) relegated;
intptr_t eagain(void) relegated;
intptr_t enomem(void) relegated;
intptr_t eacces(void) relegated;
intptr_t efault(void) relegated;
intptr_t enotblk(void) relegated;
intptr_t ebusy(void) relegated;
intptr_t eexist(void) relegated;
intptr_t exdev(void) relegated;
intptr_t enodev(void) relegated;
intptr_t enotdir(void) relegated;
intptr_t eisdir(void) relegated;
intptr_t enfile(void) relegated;
intptr_t emfile(void) relegated;
intptr_t enotty(void) relegated;
intptr_t enotsup(void) relegated;
intptr_t etxtbsy(void) relegated;
intptr_t efbig(void) relegated;
intptr_t enospc(void) relegated;
intptr_t espipe(void) relegated;
intptr_t erofs(void) relegated;
intptr_t emlink(void) relegated;
intptr_t epipe(void) relegated;
intptr_t edom(void) relegated;
intptr_t erange(void) relegated;
intptr_t edeadlk(void) relegated;
intptr_t enametoolong(void) relegated;
intptr_t enolck(void) relegated;
intptr_t enosys(void) relegated;
intptr_t enotempty(void) relegated;
intptr_t eloop(void) relegated;
intptr_t enomsg(void) relegated;
intptr_t eidrm(void) relegated;
intptr_t echrng(void) relegated;
intptr_t el2nsync(void) relegated;
intptr_t el3hlt(void) relegated;
intptr_t el3rst(void) relegated;
intptr_t elnrng(void) relegated;
intptr_t eunatch(void) relegated;
intptr_t enocsi(void) relegated;
intptr_t el2hlt(void) relegated;
intptr_t ebade(void) relegated;
intptr_t ebadr(void) relegated;
intptr_t exfull(void) relegated;
intptr_t enoano(void) relegated;
intptr_t ebadrqc(void) relegated;
intptr_t ebadslt(void) relegated;
intptr_t enostr(void) relegated;
intptr_t enodata(void) relegated;
intptr_t etime(void) relegated;
intptr_t enosr(void) relegated;
intptr_t enonet(void) relegated;
intptr_t enopkg(void) relegated;
intptr_t eremote(void) relegated;
intptr_t enolink(void) relegated;
intptr_t eadv(void) relegated;
intptr_t esrmnt(void) relegated;
intptr_t ecomm(void) relegated;
intptr_t eproto(void) relegated;
intptr_t emultihop(void) relegated;
intptr_t edotdot(void) relegated;
intptr_t ebadmsg(void) relegated;
intptr_t eoverflow(void) relegated;
intptr_t enotuniq(void) relegated;
intptr_t ebadfd(void) relegated;
intptr_t eremchg(void) relegated;
intptr_t elibacc(void) relegated;
intptr_t elibbad(void) relegated;
intptr_t elibscn(void) relegated;
intptr_t elibmax(void) relegated;
intptr_t elibexec(void) relegated;
intptr_t eilseq(void) relegated;
intptr_t erestart(void) relegated;
intptr_t estrpipe(void) relegated;
intptr_t eusers(void) relegated;
intptr_t enotsock(void) relegated;
intptr_t edestaddrreq(void) relegated;
intptr_t emsgsize(void) relegated;
intptr_t eprototype(void) relegated;
intptr_t enoprotoopt(void) relegated;
intptr_t eprotonosupport(void) relegated;
intptr_t esocktnosupport(void) relegated;
intptr_t eopnotsupp(void) relegated;
intptr_t epfnosupport(void) relegated;
intptr_t eafnosupport(void) relegated;
intptr_t eaddrinuse(void) relegated;
intptr_t eaddrnotavail(void) relegated;
intptr_t enetdown(void) relegated;
intptr_t enetunreach(void) relegated;
intptr_t enetreset(void) relegated;
intptr_t econnaborted(void) relegated;
intptr_t econnreset(void) relegated;
intptr_t enobufs(void) relegated;
intptr_t eisconn(void) relegated;
intptr_t enotconn(void) relegated;
intptr_t eshutdown(void) relegated;
intptr_t etoomanyrefs(void) relegated;
intptr_t etimedout(void) relegated;
intptr_t econnrefused(void) relegated;
intptr_t ehostdown(void) relegated;
intptr_t ehostunreach(void) relegated;
intptr_t ealready(void) relegated;
intptr_t einprogress(void) relegated;
intptr_t estale(void) relegated;
intptr_t euclean(void) relegated;
intptr_t enotnam(void) relegated;
intptr_t enavail(void) relegated;
intptr_t eisnam(void) relegated;
intptr_t eremoteio(void) relegated;
intptr_t edquot(void) relegated;
intptr_t enomedium(void) relegated;
intptr_t emediumtype(void) relegated;
intptr_t ecanceled(void) relegated;
intptr_t enokey(void) relegated;
intptr_t ekeyexpired(void) relegated;
intptr_t ekeyrevoked(void) relegated;
intptr_t ekeyrejected(void) relegated;
intptr_t eownerdead(void) relegated;
intptr_t enotrecoverable(void) relegated;
intptr_t erfkill(void) relegated;
intptr_t ehwpoison(void) relegated;

#if defined(__MNO_RED_ZONE__) && defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define __ERRFUN(FUNC)               \
  ({                                 \
    intptr_t NegOne;                 \
    asm volatile("call\t" FUNC       \
                 : "=a"(NegOne)      \
                 : /* no outputs */  \
                 : "rcx", "memory"); \
    NegOne;                          \
  })
#define einval()          __ERRFUN("einval")
#define eperm()           __ERRFUN("eperm")
#define enoent()          __ERRFUN("enoent")
#define esrch()           __ERRFUN("esrch")
#define eintr()           __ERRFUN("eintr")
#define eio()             __ERRFUN("eio")
#define enxio()           __ERRFUN("enxio")
#define e2big()           __ERRFUN("e2big")
#define enoexec()         __ERRFUN("enoexec")
#define ebadf()           __ERRFUN("ebadf")
#define echild()          __ERRFUN("echild")
#define eagain()          __ERRFUN("eagain")
#define enomem()          __ERRFUN("enomem")
#define eacces()          __ERRFUN("eacces")
#define efault()          __ERRFUN("efault")
#define enotblk()         __ERRFUN("enotblk")
#define ebusy()           __ERRFUN("ebusy")
#define eexist()          __ERRFUN("eexist")
#define exdev()           __ERRFUN("exdev")
#define enodev()          __ERRFUN("enodev")
#define enotdir()         __ERRFUN("enotdir")
#define eisdir()          __ERRFUN("eisdir")
#define enfile()          __ERRFUN("enfile")
#define emfile()          __ERRFUN("emfile")
#define enotty()          __ERRFUN("enotty")
#define enotsup()         __ERRFUN("enotsup")
#define etxtbsy()         __ERRFUN("etxtbsy")
#define efbig()           __ERRFUN("efbig")
#define enospc()          __ERRFUN("enospc")
#define espipe()          __ERRFUN("espipe")
#define erofs()           __ERRFUN("erofs")
#define emlink()          __ERRFUN("emlink")
#define epipe()           __ERRFUN("epipe")
#define edom()            __ERRFUN("edom")
#define erange()          __ERRFUN("erange")
#define edeadlk()         __ERRFUN("edeadlk")
#define enametoolong()    __ERRFUN("enametoolong")
#define enolck()          __ERRFUN("enolck")
#define enosys()          __ERRFUN("enosys")
#define enotempty()       __ERRFUN("enotempty")
#define eloop()           __ERRFUN("eloop")
#define enomsg()          __ERRFUN("enomsg")
#define eidrm()           __ERRFUN("eidrm")
#define echrng()          __ERRFUN("echrng")
#define el2nsync()        __ERRFUN("el2nsync")
#define el3hlt()          __ERRFUN("el3hlt")
#define el3rst()          __ERRFUN("el3rst")
#define elnrng()          __ERRFUN("elnrng")
#define eunatch()         __ERRFUN("eunatch")
#define enocsi()          __ERRFUN("enocsi")
#define el2hlt()          __ERRFUN("el2hlt")
#define ebade()           __ERRFUN("ebade")
#define ebadr()           __ERRFUN("ebadr")
#define exfull()          __ERRFUN("exfull")
#define enoano()          __ERRFUN("enoano")
#define ebadrqc()         __ERRFUN("ebadrqc")
#define ebadslt()         __ERRFUN("ebadslt")
#define enostr()          __ERRFUN("enostr")
#define enodata()         __ERRFUN("enodata")
#define etime()           __ERRFUN("etime")
#define enosr()           __ERRFUN("enosr")
#define enonet()          __ERRFUN("enonet")
#define enopkg()          __ERRFUN("enopkg")
#define eremote()         __ERRFUN("eremote")
#define enolink()         __ERRFUN("enolink")
#define eadv()            __ERRFUN("eadv")
#define esrmnt()          __ERRFUN("esrmnt")
#define ecomm()           __ERRFUN("ecomm")
#define eproto()          __ERRFUN("eproto")
#define emultihop()       __ERRFUN("emultihop")
#define edotdot()         __ERRFUN("edotdot")
#define ebadmsg()         __ERRFUN("ebadmsg")
#define eoverflow()       __ERRFUN("eoverflow")
#define enotuniq()        __ERRFUN("enotuniq")
#define ebadfd()          __ERRFUN("ebadfd")
#define eremchg()         __ERRFUN("eremchg")
#define elibacc()         __ERRFUN("elibacc")
#define elibbad()         __ERRFUN("elibbad")
#define elibscn()         __ERRFUN("elibscn")
#define elibmax()         __ERRFUN("elibmax")
#define elibexec()        __ERRFUN("elibexec")
#define eilseq()          __ERRFUN("eilseq")
#define erestart()        __ERRFUN("erestart")
#define estrpipe()        __ERRFUN("estrpipe")
#define eusers()          __ERRFUN("eusers")
#define enotsock()        __ERRFUN("enotsock")
#define edestaddrreq()    __ERRFUN("edestaddrreq")
#define emsgsize()        __ERRFUN("emsgsize")
#define eprototype()      __ERRFUN("eprototype")
#define enoprotoopt()     __ERRFUN("enoprotoopt")
#define eprotonosupport() __ERRFUN("eprotonosupport")
#define esocktnosupport() __ERRFUN("esocktnosupport")
#define eopnotsupp()      __ERRFUN("eopnotsupp")
#define epfnosupport()    __ERRFUN("epfnosupport")
#define eafnosupport()    __ERRFUN("eafnosupport")
#define eaddrinuse()      __ERRFUN("eaddrinuse")
#define eaddrnotavail()   __ERRFUN("eaddrnotavail")
#define enetdown()        __ERRFUN("enetdown")
#define enetunreach()     __ERRFUN("enetunreach")
#define enetreset()       __ERRFUN("enetreset")
#define econnaborted()    __ERRFUN("econnaborted")
#define econnreset()      __ERRFUN("econnreset")
#define enobufs()         __ERRFUN("enobufs")
#define eisconn()         __ERRFUN("eisconn")
#define enotconn()        __ERRFUN("enotconn")
#define eshutdown()       __ERRFUN("eshutdown")
#define etoomanyrefs()    __ERRFUN("etoomanyrefs")
#define etimedout()       __ERRFUN("etimedout")
#define econnrefused()    __ERRFUN("econnrefused")
#define ehostdown()       __ERRFUN("ehostdown")
#define ehostunreach()    __ERRFUN("ehostunreach")
#define ealready()        __ERRFUN("ealready")
#define einprogress()     __ERRFUN("einprogress")
#define estale()          __ERRFUN("estale")
#define euclean()         __ERRFUN("euclean")
#define enotnam()         __ERRFUN("enotnam")
#define enavail()         __ERRFUN("enavail")
#define eisnam()          __ERRFUN("eisnam")
#define eremoteio()       __ERRFUN("eremoteio")
#define edquot()          __ERRFUN("edquot")
#define enomedium()       __ERRFUN("enomedium")
#define emediumtype()     __ERRFUN("emediumtype")
#define ecanceled()       __ERRFUN("ecanceled")
#define enokey()          __ERRFUN("enokey")
#define ekeyexpired()     __ERRFUN("ekeyexpired")
#define ekeyrevoked()     __ERRFUN("ekeyrevoked")
#define ekeyrejected()    __ERRFUN("ekeyrejected")
#define eownerdead()      __ERRFUN("eownerdead")
#define enotrecoverable() __ERRFUN("enotrecoverable")
#define erfkill()         __ERRFUN("erfkill")
#define ehwpoison()       __ERRFUN("ehwpoison")
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/_posix.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS__POSIX_H_

/* The Open Group Base Specifications Issue 7, 2018 edition */
/* IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)  */

#define _POSIX_AIO_LISTIO_MAX               2
#define _POSIX_AIO_MAX                      1
#define _POSIX_ARG_MAX                      4096
#define _POSIX_CHILD_MAX                    25
#define _POSIX_DELAYTIMER_MAX               32
#define _POSIX_HOST_NAME_MAX                255
#define _POSIX_LINK_MAX                     8
#define _POSIX_LOGIN_NAME_MAX               9
#define _POSIX_MAX_CANON                    255
#define _POSIX_MAX_INPUT                    255
#define _POSIX_MQ_OPEN_MAX                  8
#define _POSIX_MQ_PRIO_MAX                  32
#define _POSIX_NAME_MAX                     14
#define _POSIX_NGROUPS_MAX                  8
#define _POSIX_OPEN_MAX                     20
#define _POSIX_PATH_MAX                     256
#define _POSIX_PIPE_BUF                     512
#define _POSIX_RE_DUP_MAX                   255
#define _POSIX_RTSIG_MAX                    8
#define _POSIX_SEM_NSEMS_MAX                256
#define _POSIX_SEM_VALUE_MAX                32767
#define _POSIX_SIGQUEUE_MAX                 32
#define _POSIX_SSIZE_MAX                    32767
#define _POSIX_SS_REPL_MAX                  4
#define _POSIX_STREAM_MAX                   8
#define _POSIX_SYMLINK_MAX                  255
#define _POSIX_SYMLOOP_MAX                  8
#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
#define _POSIX_THREAD_KEYS_MAX              128
#define _POSIX_THREAD_THREADS_MAX           64
#define _POSIX_TIMER_MAX                    32
#define _POSIX_TRACE_EVENT_NAME_MAX         30
#define _POSIX_TRACE_NAME_MAX               8
#define _POSIX_TRACE_SYS_MAX                8
#define _POSIX_TRACE_USER_EVENT_MAX         32
#define _POSIX_TTY_NAME_MAX                 9
#define _POSIX_TZNAME_MAX                   6

#define _POSIX2_BC_BASE_MAX        99
#define _POSIX2_BC_DIM_MAX         2048
#define _POSIX2_BC_SCALE_MAX       99
#define _POSIX2_BC_STRING_MAX      1000
#define _POSIX2_CHARCLASS_NAME_MAX 14
#define _POSIX2_COLL_WEIGHTS_MAX   2
#define _POSIX2_EXPR_NEST_MAX      32
#define _POSIX2_LINE_MAX           2048
#define _POSIX2_RE_DUP_MAX         255

#define _XOPEN_IOV_MAX  16
#define _XOPEN_NAME_MAX 255
#define _XOPEN_PATH_MAX 1024



/*!BEGIN libc/sysv/consts/af.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int AF_ALG;
extern const int AF_APPLETALK;
extern const int AF_ASH;
extern const int AF_ATMPVC;
extern const int AF_ATMSVC;
extern const int AF_AX25;
extern const int AF_BLUETOOTH;
extern const int AF_BRIDGE;
extern const int AF_CAIF;
extern const int AF_CAN;
extern const int AF_ECONET;
extern const int AF_FILE;
extern const int AF_IB;
extern const int AF_IEEE802154;
extern const int AF_INET6;
extern const int AF_INET;
extern const int AF_IPX;
extern const int AF_IRDA;
extern const int AF_ISDN;
extern const int AF_IUCV;
extern const int AF_KCM;
extern const int AF_KEY;
extern const int AF_LINK;
extern const int AF_LLC;
extern const int AF_LOCAL;
extern const int AF_MAX;
extern const int AF_MPLS;
extern const int AF_NETBEUI;
extern const int AF_NETLINK;
extern const int AF_NETROM;
extern const int AF_NFC;
extern const int AF_PACKET;
extern const int AF_PHONET;
extern const int AF_PPPOX;
extern const int AF_RDS;
extern const int AF_ROSE;
extern const int AF_ROUTE;
extern const int AF_RXRPC;
extern const int AF_SECURITY;
extern const int AF_SNA;
extern const int AF_TIPC;
extern const int AF_UNIX;
extern const int AF_UNSPEC;
extern const int AF_VSOCK;
extern const int AF_WANPIPE;
extern const int AF_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AF_ALG        SYMBOLIC(AF_ALG)
#define AF_LINK       SYMBOLIC(AF_LINK)
#define AF_APPLETALK  SYMBOLIC(AF_APPLETALK)
#define AF_ASH        SYMBOLIC(AF_ASH)
#define AF_ATMPVC     SYMBOLIC(AF_ATMPVC)
#define AF_ATMSVC     SYMBOLIC(AF_ATMSVC)
#define AF_AX25       SYMBOLIC(AF_AX25)
#define AF_BLUETOOTH  SYMBOLIC(AF_BLUETOOTH)
#define AF_BRIDGE     SYMBOLIC(AF_BRIDGE)
#define AF_CAIF       SYMBOLIC(AF_CAIF)
#define AF_CAN        SYMBOLIC(AF_CAN)
#define AF_ECONET     SYMBOLIC(AF_ECONET)
#define AF_FILE       SYMBOLIC(AF_FILE)
#define AF_IB         SYMBOLIC(AF_IB)
#define AF_IEEE802154 SYMBOLIC(AF_IEEE802154)
#define AF_INET       LITERALLY(2)
#define AF_INET6      SYMBOLIC(AF_INET6)
#define AF_IPX        SYMBOLIC(AF_IPX)
#define AF_IRDA       SYMBOLIC(AF_IRDA)
#define AF_ISDN       SYMBOLIC(AF_ISDN)
#define AF_IUCV       SYMBOLIC(AF_IUCV)
#define AF_KCM        SYMBOLIC(AF_KCM)
#define AF_KEY        SYMBOLIC(AF_KEY)
#define AF_LLC        SYMBOLIC(AF_LLC)
#define AF_LOCAL      SYMBOLIC(AF_LOCAL)
#define AF_MAX        SYMBOLIC(AF_MAX)
#define AF_MPLS       SYMBOLIC(AF_MPLS)
#define AF_NETBEUI    SYMBOLIC(AF_NETBEUI)
#define AF_NETLINK    SYMBOLIC(AF_NETLINK)
#define AF_NETROM     SYMBOLIC(AF_NETROM)
#define AF_NFC        SYMBOLIC(AF_NFC)
#define AF_PACKET     SYMBOLIC(AF_PACKET)
#define AF_PHONET     SYMBOLIC(AF_PHONET)
#define AF_PPPOX      SYMBOLIC(AF_PPPOX)
#define AF_RDS        SYMBOLIC(AF_RDS)
#define AF_ROSE       SYMBOLIC(AF_ROSE)
#define AF_ROUTE      SYMBOLIC(AF_ROUTE)
#define AF_RXRPC      SYMBOLIC(AF_RXRPC)
#define AF_SECURITY   SYMBOLIC(AF_SECURITY)
#define AF_SNA        SYMBOLIC(AF_SNA)
#define AF_TIPC       SYMBOLIC(AF_TIPC)
#define AF_UNIX       LITERALLY(1)
#define AF_UNSPEC     LITERALLY(0)
#define AF_VSOCK      SYMBOLIC(AF_VSOCK)
#define AF_WANPIPE    SYMBOLIC(AF_WANPIPE)
#define AF_X25        SYMBOLIC(AF_X25)



/*!BEGIN libc/sysv/consts/alg.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ALG_H_

#define ALG_SET_AEAD_ASSOCLEN SYMBOLIC(ALG_SET_AEAD_ASSOCLEN)
#define ALG_SET_AEAD_AUTHSIZE SYMBOLIC(ALG_SET_AEAD_AUTHSIZE)
#define ALG_SET_DRBG_ENTROPY  SYMBOLIC(ALG_SET_DRBG_ENTROPY)
#define ALG_SET_IV            SYMBOLIC(ALG_SET_IV)
#define ALG_SET_KEY           SYMBOLIC(ALG_SET_KEY)
#define ALG_SET_OP            SYMBOLIC(ALG_SET_OP)

#define ALG_OP_DECRYPT SYMBOLIC(ALG_OP_DECRYPT)
#define ALG_OP_ENCRYPT SYMBOLIC(ALG_OP_ENCRYPT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int ALG_SET_AEAD_ASSOCLEN;
extern const int ALG_SET_AEAD_AUTHSIZE;
extern const int ALG_SET_DRBG_ENTROPY;
extern const int ALG_SET_IV;
extern const int ALG_SET_KEY;
extern const int ALG_SET_OP;

extern const int ALG_OP_DECRYPT;
extern const int ALG_OP_ENCRYPT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/arphrd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ARPHRD_H_

#define ARPHRD_ETHER SYMBOLIC(ARPHRD_ETHER)
#define ARPHRD_FCFABRIC SYMBOLIC(ARPHRD_FCFABRIC)
#define ARPHRD_IEEE80211 SYMBOLIC(ARPHRD_IEEE80211)
#define ARPHRD_IEEE80211_PRISM SYMBOLIC(ARPHRD_IEEE80211_PRISM)
#define ARPHRD_IEEE80211_RADIOTAP SYMBOLIC(ARPHRD_IEEE80211_RADIOTAP)
#define ARPHRD_IEEE802154 SYMBOLIC(ARPHRD_IEEE802154)
#define ARPHRD_IEEE802_TR SYMBOLIC(ARPHRD_IEEE802_TR)
#define ARPHRD_LOCALTLK SYMBOLIC(ARPHRD_LOCALTLK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint16_t ARPHRD_ETHER;
extern const uint16_t ARPHRD_FCFABRIC;
extern const uint16_t ARPHRD_IEEE80211;
extern const uint16_t ARPHRD_IEEE80211_PRISM;
extern const uint16_t ARPHRD_IEEE80211_RADIOTAP;
extern const uint16_t ARPHRD_IEEE802154;
extern const uint16_t ARPHRD_IEEE802_TR;
extern const uint16_t ARPHRD_LOCALTLK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/at.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview AT_xxx constants for fcntl(), fopenat(), etc..
 * @see libc/sysv/consts/auxv.h for getauxval() constants
 */

extern const int AT_FDCWD;
extern const int AT_SYMLINK_FOLLOW;
extern const int AT_SYMLINK_NOFOLLOW;
extern const int AT_REMOVEDIR;
extern const int AT_EACCESS;
extern const int AT_EMPTY_PATH;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AT_FDCWD            SYMBOLIC(AT_FDCWD)
#define AT_SYMLINK_FOLLOW   SYMBOLIC(AT_SYMLINK_FOLLOW)
#define AT_SYMLINK_NOFOLLOW SYMBOLIC(AT_SYMLINK_NOFOLLOW)
#define AT_REMOVEDIR        SYMBOLIC(AT_REMOVEDIR)
#define AT_EACCESS          SYMBOLIC(AT_EACCESS)
#define AT_EMPTY_PATH       SYMBOLIC(AT_EMPTY_PATH)



/*!BEGIN libc/sysv/consts/audit.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AUDIT_H_

#define __AUDIT_ARCH_64BIT                 0x80000000
#define __AUDIT_ARCH_LE                    0x40000000
#define __AUDIT_ARCH_CONVENTION_MASK       0x30000000
#define __AUDIT_ARCH_CONVENTION_MIPS64_N32 0x20000000

#define AUDIT_ARCH_X86_64 (EM_X86_64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
#define AUDIT_ARCH_I386   (EM_386 | __AUDIT_ARCH_LE)



/*!BEGIN libc/sysv/consts/auxv.h */

#define COSMOPOLITAN_LIBC_CALLS_AUXV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned long AT_BASE;
extern const unsigned long AT_BASE_PLATFORM;
extern const unsigned long AT_CANARY;
extern const unsigned long AT_CANARYLEN;
extern const unsigned long AT_CLKTCK;
extern const unsigned long AT_DCACHEBSIZE;
extern const unsigned long AT_EGID;
extern const unsigned long AT_EHDRFLAGS;
extern const unsigned long AT_ENTRY;
extern const unsigned long AT_EUID;
extern const unsigned long AT_EXECFD;
extern const unsigned long AT_EXECFN;
extern const unsigned long AT_EXECPATH;
extern const unsigned long AT_FLAGS;
extern const unsigned long AT_GID;
extern const unsigned long AT_HWCAP2;
extern const unsigned long AT_HWCAP;
extern const unsigned long AT_ICACHEBSIZE;
extern const unsigned long AT_MINSIGSTKSZ;
extern const unsigned long AT_NCPUS;
extern const unsigned long AT_NOTELF;
extern const unsigned long AT_NO_AUTOMOUNT;
extern const unsigned long AT_OSRELDATE;
extern const unsigned long AT_PAGESIZES;
extern const unsigned long AT_PAGESIZESLEN;
extern const unsigned long AT_PAGESZ;
extern const unsigned long AT_PHDR;
extern const unsigned long AT_PHENT;
extern const unsigned long AT_PHNUM;
extern const unsigned long AT_PLATFORM;
extern const unsigned long AT_RANDOM;
extern const unsigned long AT_SECURE;
extern const unsigned long AT_STACKBASE;
extern const unsigned long AT_STACKPROT;
extern const unsigned long AT_SYSINFO_EHDR;
extern const unsigned long AT_TIMEKEEP;
extern const unsigned long AT_UCACHEBSIZE;
extern const unsigned long AT_UID;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AT_BASE          SYMBOLIC(AT_BASE)
#define AT_BASE_PLATFORM SYMBOLIC(AT_BASE_PLATFORM)
#define AT_CANARY        SYMBOLIC(AT_CANARY)
#define AT_CANARYLEN     SYMBOLIC(AT_CANARYLEN)
#define AT_CLKTCK        SYMBOLIC(AT_CLKTCK)
#define AT_DCACHEBSIZE   SYMBOLIC(AT_DCACHEBSIZE)
#define AT_EGID          SYMBOLIC(AT_EGID)
#define AT_EHDRFLAGS     SYMBOLIC(AT_EHDRFLAGS)
#define AT_ENTRY         SYMBOLIC(AT_ENTRY)
#define AT_EUID          SYMBOLIC(AT_EUID)
#define AT_EXECFD        SYMBOLIC(AT_EXECFD)
#define AT_EXECFN        SYMBOLIC(AT_EXECFN)
#define AT_EXECPATH      SYMBOLIC(AT_EXECPATH)
#define AT_FLAGS         SYMBOLIC(AT_FLAGS)
#define AT_GID           SYMBOLIC(AT_GID)
#define AT_HWCAP         SYMBOLIC(AT_HWCAP)
#define AT_HWCAP2        SYMBOLIC(AT_HWCAP2)
#define AT_ICACHEBSIZE   SYMBOLIC(AT_ICACHEBSIZE)
#define AT_MINSIGSTKSZ   SYMBOLIC(AT_MINSIGSTKSZ)
#define AT_NCPUS         SYMBOLIC(AT_NCPUS)
#define AT_NOTELF        SYMBOLIC(AT_NOTELF)
#define AT_NO_AUTOMOUNT  SYMBOLIC(AT_NO_AUTOMOUNT)
#define AT_OSRELDATE     SYMBOLIC(AT_OSRELDATE)
#define AT_PAGESIZES     SYMBOLIC(AT_PAGESIZES)
#define AT_PAGESIZESLEN  SYMBOLIC(AT_PAGESIZESLEN)
#define AT_PAGESZ        SYMBOLIC(AT_PAGESZ)
#define AT_PHDR          SYMBOLIC(AT_PHDR)
#define AT_PHENT         SYMBOLIC(AT_PHENT)
#define AT_PHNUM         SYMBOLIC(AT_PHNUM)
#define AT_PLATFORM      SYMBOLIC(AT_PLATFORM)
#define AT_RANDOM        SYMBOLIC(AT_RANDOM)
#define AT_SECURE        SYMBOLIC(AT_SECURE)
#define AT_STACKBASE     SYMBOLIC(AT_STACKBASE)
#define AT_STACKPROT     SYMBOLIC(AT_STACKPROT)
#define AT_SYSINFO_EHDR  SYMBOLIC(AT_SYSINFO_EHDR)
#define AT_TIMEKEEP      SYMBOLIC(AT_TIMEKEEP)
#define AT_UCACHEBSIZE   SYMBOLIC(AT_UCACHEBSIZE)
#define AT_UID           SYMBOLIC(AT_UID)



/*!BEGIN libc/sysv/consts/c.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CPIO_H_

#define C_IXOTH  0000001
#define C_IWOTH  0000002
#define C_IROTH  0000004
#define C_IXGRP  0000010
#define C_IWGRP  0000020
#define C_IRGRP  0000040
#define C_IXUSR  0000100
#define C_IWUSR  0000200
#define C_IRUSR  0000400
#define C_ISVTX  0001000
#define C_ISGID  0002000
#define C_ISUID  0004000
#define C_ISFIFO 0010000
#define C_ISCHR  0020000
#define C_ISDIR  0040000
#define C_ISBLK  0060000
#define C_ISREG  0100000
#define C_ISCTG  0110000
#define C_ISLNK  0120000
#define C_ISSOCK 0140000



/*!BEGIN libc/sysv/consts/cap.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CAP_H_

#define CAP_CHOWN              0
#define CAP_DAC_OVERRIDE       1
#define CAP_DAC_READ_SEARCH    2
#define CAP_FOWNER             3
#define CAP_FSETID             4
#define CAP_KILL               5
#define CAP_SETGID             6
#define CAP_SETUID             7
#define CAP_SETPCAP            8
#define CAP_LINUX_IMMUTABLE    9
#define CAP_NET_BIND_SERVICE   10
#define CAP_NET_BROADCAST      11
#define CAP_NET_ADMIN          12
#define CAP_NET_RAW            13
#define CAP_IPC_LOCK           14
#define CAP_IPC_OWNER          15
#define CAP_SYS_MODULE         16
#define CAP_SYS_RAWIO          17
#define CAP_SYS_CHROOT         18
#define CAP_SYS_PTRACE         19
#define CAP_SYS_PACCT          20
#define CAP_SYS_ADMIN          21
#define CAP_SYS_BOOT           22
#define CAP_SYS_NICE           23
#define CAP_SYS_RESOURCE       24
#define CAP_SYS_TIME           25
#define CAP_SYS_TTY_CONFIG     26
#define CAP_MKNOD              27
#define CAP_LEASE              28
#define CAP_AUDIT_WRITE        29
#define CAP_AUDIT_CONTROL      30
#define CAP_SETFCAP            31
#define CAP_MAC_OVERRIDE       32
#define CAP_MAC_ADMIN          33
#define CAP_SYSLOG             34
#define CAP_WAKE_ALARM         35
#define CAP_BLOCK_SUSPEND      36
#define CAP_AUDIT_READ         37
#define CAP_PERFMON            38
#define CAP_BPF                39
#define CAP_CHECKPOINT_RESTORE 40
#define CAP_LAST_CAP           CAP_CHECKPOINT_RESTORE



/*!BEGIN libc/sysv/consts/clock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int CLOCK_BOOTTIME;
extern const int CLOCK_BOOTTIME_ALARM;
extern const int CLOCK_MONOTONIC;
extern const int CLOCK_MONOTONIC_COARSE;
extern const int CLOCK_MONOTONIC_FAST;
extern const int CLOCK_MONOTONIC_PRECISE;
extern const int CLOCK_MONOTONIC_RAW;
extern const int CLOCK_PROCESS_CPUTIME_ID;
extern const int CLOCK_PROF;
extern const int CLOCK_REALTIME_ALARM;
extern const int CLOCK_REALTIME_COARSE;
extern const int CLOCK_REALTIME_FAST;
extern const int CLOCK_REALTIME_PRECISE;
extern const int CLOCK_SECOND;
extern const int CLOCK_TAI;
extern const int CLOCK_THREAD_CPUTIME_ID;
extern const int CLOCK_UPTIME;
extern const int CLOCK_UPTIME_FAST;
extern const int CLOCK_UPTIME_PRECISE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define CLOCK_REALTIME LITERALLY(0)

#define CLOCK_BOOTTIME           SYMBOLIC(CLOCK_BOOTTIME)
#define CLOCK_BOOTTIME_ALARM     SYMBOLIC(CLOCK_BOOTTIME_ALARM)
#define CLOCK_MONOTONIC          SYMBOLIC(CLOCK_MONOTONIC)
#define CLOCK_MONOTONIC_COARSE   SYMBOLIC(CLOCK_MONOTONIC_COARSE)
#define CLOCK_MONOTONIC_FAST     SYMBOLIC(CLOCK_MONOTONIC_FAST)
#define CLOCK_MONOTONIC_PRECISE  SYMBOLIC(CLOCK_MONOTONIC_PRECISE)
#define CLOCK_MONOTONIC_RAW      SYMBOLIC(CLOCK_MONOTONIC_RAW)
#define CLOCK_PROCESS_CPUTIME_ID SYMBOLIC(CLOCK_PROCESS_CPUTIME_ID)
#define CLOCK_PROF               SYMBOLIC(CLOCK_PROF)
#define CLOCK_REALTIME_ALARM     SYMBOLIC(CLOCK_REALTIME_ALARM)
#define CLOCK_REALTIME_COARSE    SYMBOLIC(CLOCK_REALTIME_COARSE)
#define CLOCK_REALTIME_FAST      SYMBOLIC(CLOCK_REALTIME_FAST)
#define CLOCK_REALTIME_PRECISE   SYMBOLIC(CLOCK_REALTIME_PRECISE)
#define CLOCK_SECOND             SYMBOLIC(CLOCK_SECOND)
#define CLOCK_TAI                SYMBOLIC(CLOCK_TAI)
#define CLOCK_THREAD_CPUTIME_ID  SYMBOLIC(CLOCK_THREAD_CPUTIME_ID)
#define CLOCK_UPTIME             SYMBOLIC(CLOCK_UPTIME)
#define CLOCK_UPTIME_FAST        SYMBOLIC(CLOCK_UPTIME_FAST)
#define CLOCK_UPTIME_PRECISE     SYMBOLIC(CLOCK_UPTIME_PRECISE)



/*!BEGIN libc/sysv/consts/clone.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CLONE_H_

#define CLONE_VM             0x00000100
#define CLONE_FS             0x00000200
#define CLONE_FILES          0x00000400
#define CLONE_SIGHAND        0x00000800
#define CLONE_PTRACE         0x00002000
#define CLONE_VFORK          0x00004000
#define CLONE_PARENT         0x00008000
#define CLONE_THREAD         0x00010000
#define CLONE_NEWNS          0x00020000
#define CLONE_SYSVSEM        0x00040000
#define CLONE_SETTLS         0x00080000
#define CLONE_PARENT_SETTID  0x00100000
#define CLONE_CHILD_CLEARTID 0x00200000
#define CLONE_DETACHED       0x00400000
#define CLONE_UNTRACED       0x00800000
#define CLONE_CHILD_SETTID   0x01000000
#define CLONE_STOPPED        0x02000000



/*!BEGIN libc/sysv/consts/close.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CLOSE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned int CLOSE_RANGE_UNSHARE;
extern const unsigned int CLOSE_RANGE_CLOEXEC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define CLOSE_RANGE_UNSHARE SYMBOLIC(CLOSE_RANGE_UNSHARE)
#define CLOSE_RANGE_CLOEXEC SYMBOLIC(CLOSE_RANGE_CLOEXEC)



/*!BEGIN libc/sysv/consts/dt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_DT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint8_t DT_UNKNOWN;
extern const uint8_t DT_FIFO;
extern const uint8_t DT_CHR;
extern const uint8_t DT_DIR;
extern const uint8_t DT_BLK;
extern const uint8_t DT_REG;
extern const uint8_t DT_LNK;
extern const uint8_t DT_SOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define DT_UNKNOWN LITERALLY(0)
#define DT_FIFO    LITERALLY(1)
#define DT_CHR     LITERALLY(2)
#define DT_DIR     LITERALLY(4)
#define DT_BLK     LITERALLY(6)
#define DT_REG     LITERALLY(8)
#define DT_LNK     LITERALLY(10)
#define DT_SOCK    LITERALLY(12)



/*!BEGIN libc/sysv/consts/endian.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ENDIAN_H_

#define __LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__
#define __BIG_ENDIAN    __ORDER_BIG_ENDIAN__
#define __PDP_ENDIAN    __ORDER_PDP_ENDIAN__
#define __BYTE_ORDER    __BYTE_ORDER__



/*!BEGIN libc/sysv/consts/epoll.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EPOLL_H_


/*!BEGIN libc/sysv/consts/o.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_O_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned O_ACCMODE;
extern const unsigned O_APPEND;
extern const unsigned O_ASYNC;
extern const unsigned O_CLOEXEC;
extern const unsigned O_COMPRESSED;
extern const unsigned O_CREAT;
extern const unsigned O_DIRECT;
extern const unsigned O_DIRECTORY;
extern const unsigned O_DSYNC;
extern const unsigned O_EXCL;
extern const unsigned O_EXEC;
extern const unsigned O_EXLOCK;
extern const unsigned O_INDEXED;
extern const unsigned O_LARGEFILE;
extern const unsigned O_NDELAY;
extern const unsigned O_NOATIME;
extern const unsigned O_NOCTTY;
extern const unsigned O_NOFOLLOW;
extern const unsigned O_NOFOLLOW_ANY;
extern const unsigned O_NONBLOCK;
extern const unsigned O_PATH;
extern const unsigned O_RANDOM;
extern const unsigned O_RDONLY;
extern const unsigned O_RDWR;
extern const unsigned O_RSYNC;
extern const unsigned O_SEARCH;
extern const unsigned O_SEQUENTIAL;
extern const unsigned O_SHLOCK;
extern const unsigned O_SPARSE;
extern const unsigned O_SYNC;
extern const unsigned O_TMPFILE;
extern const unsigned O_TRUNC;
extern const unsigned O_TTY_INIT;
extern const unsigned O_VERIFY;
extern const unsigned O_WRONLY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define O_RDONLY  LITERALLY(0)
#define O_WRONLY  LITERALLY(1)
#define O_RDWR    LITERALLY(2)
#define O_ACCMODE LITERALLY(3)

#define O_APPEND       SYMBOLIC(O_APPEND)
#define O_ASYNC        SYMBOLIC(O_ASYNC)
#define O_CLOEXEC      SYMBOLIC(O_CLOEXEC)
#define O_COMPRESSED   SYMBOLIC(O_COMPRESSED)
#define O_CREAT        SYMBOLIC(O_CREAT)
#define O_DIRECT       SYMBOLIC(O_DIRECT)
#define O_DIRECTORY    SYMBOLIC(O_DIRECTORY)
#define O_DSYNC        SYMBOLIC(O_DSYNC)
#define O_EXCL         SYMBOLIC(O_EXCL)
#define O_EXEC         SYMBOLIC(O_EXEC)
#define O_EXLOCK       SYMBOLIC(O_EXLOCK)
#define O_INDEXED      SYMBOLIC(O_INDEXED)
#define O_LARGEFILE    SYMBOLIC(O_LARGEFILE)
#define O_NDELAY       SYMBOLIC(O_NDELAY)
#define O_NOATIME      SYMBOLIC(O_NOATIME)
#define O_NOCTTY       SYMBOLIC(O_NOCTTY)
#define O_NOFOLLOW     SYMBOLIC(O_NOFOLLOW)
#define O_NOFOLLOW_ANY SYMBOLIC(O_NOFOLLOW_ANY)
#define O_NONBLOCK     SYMBOLIC(O_NONBLOCK)
#define O_PATH         SYMBOLIC(O_PATH)
#define O_RANDOM       SYMBOLIC(O_RANDOM)
#define O_RSYNC        SYMBOLIC(O_RSYNC)
#define O_SEARCH       SYMBOLIC(O_SEARCH)
#define O_SEQUENTIAL   SYMBOLIC(O_SEQUENTIAL)
#define O_SHLOCK       SYMBOLIC(O_SHLOCK)
#define O_SPARSE       SYMBOLIC(O_SPARSE)
#define O_SYNC         SYMBOLIC(O_SYNC)
#define O_TMPFILE      SYMBOLIC(O_TMPFILE)
#define O_TRUNC        SYMBOLIC(O_TRUNC)
#define O_TTY_INIT     SYMBOLIC(O_TTY_INIT)
#define O_VERIFY       SYMBOLIC(O_VERIFY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int EPOLL_CLOEXEC;

extern const int EPOLL_CTL_ADD;
extern const int EPOLL_CTL_DEL;
extern const int EPOLL_CTL_MOD;

extern const uint32_t EPOLLIN;
extern const uint32_t EPOLLPRI;
extern const uint32_t EPOLLOUT;
extern const uint32_t EPOLLERR;
extern const uint32_t EPOLLHUP;
extern const uint32_t EPOLLRDNORM;
extern const uint32_t EPOLLRDBAND;
extern const uint32_t EPOLLWRNORM;
extern const uint32_t EPOLLWRBAND;
extern const uint32_t EPOLLMSG;
extern const uint32_t EPOLLRDHUP;
extern const uint32_t EPOLLEXCLUSIVE;
extern const uint32_t EPOLLWAKEUP;
extern const uint32_t EPOLLONESHOT;
extern const uint32_t EPOLLET;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define EPOLL_CLOEXEC O_CLOEXEC

#define EPOLL_CTL_ADD LITERALLY(1)
#define EPOLL_CTL_DEL LITERALLY(2)
#define EPOLL_CTL_MOD LITERALLY(3)

#define EPOLLIN        LITERALLY(1)
#define EPOLLPRI       LITERALLY(2)
#define EPOLLOUT       LITERALLY(4)
#define EPOLLERR       LITERALLY(8)
#define EPOLLHUP       LITERALLY(0x10)
#define EPOLLRDNORM    LITERALLY(0x40)
#define EPOLLRDBAND    LITERALLY(0x80)
#define EPOLLWRNORM    LITERALLY(0x0100)
#define EPOLLWRBAND    LITERALLY(0x0200)
#define EPOLLMSG       LITERALLY(0x0400)
#define EPOLLRDHUP     LITERALLY(0x2000)
#define EPOLLEXCLUSIVE LITERALLY(0x10000000)
#define EPOLLWAKEUP    LITERALLY(0x20000000)
#define EPOLLONESHOT   LITERALLY(0x40000000)
#define EPOLLET        LITERALLY(0x80000000)



/*!BEGIN libc/sysv/consts/ex.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int EX_CANTCREAT;
extern const int EX_CONFIG;
extern const int EX_DATAERR;
extern const int EX_IOERR;
extern const int EX_NOHOST;
extern const int EX_NOINPUT;
extern const int EX_NOPERM;
extern const int EX_NOUSER;
extern const int EX_OK;
extern const int EX_OSERR;
extern const int EX_OSFILE;
extern const int EX_PROTOCOL;
extern const int EX_SOFTWARE;
extern const int EX_TEMPFAIL;
extern const int EX_UNAVAILABLE;
extern const int EX_USAGE;
extern const int EX__BASE;
extern const int EX__MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define EX_CANTCREAT LITERALLY(73)
#define EX_CONFIG LITERALLY(78)
#define EX_DATAERR LITERALLY(65)
#define EX_IOERR LITERALLY(74)
#define EX_NOHOST LITERALLY(68)
#define EX_NOINPUT LITERALLY(66)
#define EX_NOPERM LITERALLY(77)
#define EX_NOUSER LITERALLY(67)
#define EX_OK LITERALLY(0)
#define EX_OSERR LITERALLY(71)
#define EX_OSFILE LITERALLY(72)
#define EX_PROTOCOL LITERALLY(76)
#define EX_SOFTWARE LITERALLY(70)
#define EX_TEMPFAIL LITERALLY(75)
#define EX_UNAVAILABLE LITERALLY(69)
#define EX_USAGE LITERALLY(64)
#define EX__BASE LITERALLY(64)
#define EX__MAX LITERALLY(78)



/*!BEGIN libc/sysv/consts/exit.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EXIT_H_

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0



/*!BEGIN libc/sysv/consts/f.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_F_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int F_DUPFD;
extern const int F_DUPFD_CLOEXEC;
extern const int F_FULLFSYNC;
extern const int F_GETFD;
extern const int F_GETFL;
extern const int F_GETLEASE;
extern const int F_GETLK64;
extern const int F_GETLK;
extern const int F_GETOWN;
extern const int F_GETOWN_EX;
extern const int F_GETPIPE_SZ;
extern const int F_GETSIG;
extern const int F_LOCK;
extern const int F_NOCACHE;
extern const int F_NOTIFY;
extern const int F_OFD_GETLK;
extern const int F_OFD_SETLK;
extern const int F_OFD_SETLKW;
extern const int F_RDLCK;
extern const int F_SETFD;
extern const int F_SETFL;
extern const int F_SETLEASE;
extern const int F_SETLK64;
extern const int F_SETLK;
extern const int F_SETLKW64;
extern const int F_SETLKW;
extern const int F_SETOWN;
extern const int F_SETOWN_EX;
extern const int F_SETPIPE_SZ;
extern const int F_SETSIG;
extern const int F_TEST;
extern const int F_TLOCK;
extern const int F_ULOCK;
extern const int F_UNLCK;
extern const int F_WRLCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define F_DUPFD LITERALLY(0)
#define F_GETFD LITERALLY(1)
#define F_SETFD LITERALLY(2)
#define F_GETFL LITERALLY(3)
#define F_SETFL LITERALLY(4)

#define F_DUPFD_CLOEXEC SYMBOLIC(F_DUPFD_CLOEXEC)
#define F_FULLFSYNC     SYMBOLIC(F_FULLFSYNC)
#define F_GETLEASE      SYMBOLIC(F_GETLEASE)
#define F_GETLK         SYMBOLIC(F_GETLK)
#define F_GETLK64       SYMBOLIC(F_GETLK64)
#define F_GETOWN        SYMBOLIC(F_GETOWN)
#define F_GETOWN_EX     SYMBOLIC(F_GETOWN_EX)
#define F_GETPIPE_SZ    SYMBOLIC(F_GETPIPE_SZ)
#define F_GETSIG        SYMBOLIC(F_GETSIG)
#define F_LOCK          SYMBOLIC(F_LOCK)
#define F_NOCACHE       SYMBOLIC(F_NOCACHE)
#define F_NOTIFY        SYMBOLIC(F_NOTIFY)
#define F_OFD_GETLK     SYMBOLIC(F_OFD_GETLK)
#define F_OFD_SETLK     SYMBOLIC(F_OFD_SETLK)
#define F_OFD_SETLKW    SYMBOLIC(F_OFD_SETLKW)
#define F_RDLCK         SYMBOLIC(F_RDLCK)
#define F_SETLEASE      SYMBOLIC(F_SETLEASE)
#define F_SETLK         SYMBOLIC(F_SETLK)
#define F_SETLK64       SYMBOLIC(F_SETLK64)
#define F_SETLKW        SYMBOLIC(F_SETLKW)
#define F_SETLKW64      SYMBOLIC(F_SETLKW64)
#define F_SETOWN        SYMBOLIC(F_SETOWN)
#define F_SETOWN_EX     SYMBOLIC(F_SETOWN_EX)
#define F_SETPIPE_SZ    SYMBOLIC(F_SETPIPE_SZ)
#define F_SETSIG        SYMBOLIC(F_SETSIG)
#define F_TEST          SYMBOLIC(F_TEST)
#define F_TLOCK         SYMBOLIC(F_TLOCK)
#define F_ULOCK         SYMBOLIC(F_ULOCK)
#define F_UNLCK         SYMBOLIC(F_UNLCK)
#define F_WRLCK         SYMBOLIC(F_WRLCK)



/*!BEGIN libc/sysv/consts/falloc.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FALLOC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int FALLOC_FL_KEEP_SIZE;
extern const int FALLOC_FL_PUNCH_HOLE;
extern const int FALLOC_FL_NO_HIDE_STALE;
extern const int FALLOC_FL_COLLAPSE_RANGE;
extern const int FALLOC_FL_ZERO_RANGE;
extern const int FALLOC_FL_INSERT_RANGE;
extern const int FALLOC_FL_UNSHARE_RANGE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FALLOC_FL_KEEP_SIZE SYMBOLIC(FALLOC_FL_KEEP_SIZE)
#define FALLOC_FL_PUNCH_HOLE SYMBOLIC(FALLOC_FL_PUNCH_HOLE)
#define FALLOC_FL_NO_HIDE_STALE SYMBOLIC(FALLOC_FL_NO_HIDE_STALE)
#define FALLOC_FL_COLLAPSE_RANGE SYMBOLIC(FALLOC_FL_COLLAPSE_RANGE)
#define FALLOC_FL_ZERO_RANGE SYMBOLIC(FALLOC_FL_ZERO_RANGE)
#define FALLOC_FL_INSERT_RANGE SYMBOLIC(FALLOC_FL_INSERT_RANGE)
#define FALLOC_FL_UNSHARE_RANGE SYMBOLIC(FALLOC_FL_UNSHARE_RANGE)



/*!BEGIN libc/sysv/consts/fan.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FAN_H_

#define FAN_CLASS_NOTIF              0
#define FAN_ACCESS                   1
#define FAN_ACCESS_PERM              0x020000
#define FAN_ALLOW                    1
#define FAN_ALL_CLASS_BITS           12
#define FAN_ALL_EVENTS               59
#define FAN_ALL_INIT_FLAGS           63
#define FAN_ALL_MARK_FLAGS           255
#define FAN_ALL_OUTGOING_EVENTS      0x03403b
#define FAN_ALL_PERM_EVENTS          0x030000
#define FAN_CLASS_CONTENT            4
#define FAN_CLASS_PRE_CONTENT        8
#define FAN_CLOEXEC                  1
#define FAN_CLOSE                    24
#define FAN_CLOSE_NOWRITE            0x10
#define FAN_CLOSE_WRITE              8
#define FAN_DENY                     2
#define FAN_EVENT_METADATA_LEN       24
#define FAN_EVENT_ON_CHILD           0x08000000
#define FAN_MARK_ADD                 1
#define FAN_MARK_DONT_FOLLOW         4
#define FAN_MARK_FLUSH               0x80
#define FAN_MARK_IGNORED_MASK        0x20
#define FAN_MARK_IGNORED_SURV_MODIFY 0x40
#define FAN_MARK_MOUNT               0x10
#define FAN_MARK_ONLYDIR             8
#define FAN_MARK_REMOVE              2
#define FAN_MODIFY                   2
#define FAN_NOFD                     -1
#define FAN_NONBLOCK                 2
#define FAN_ONDIR                    0x40000000
#define FAN_OPEN                     0x20
#define FAN_OPEN_PERM                0x010000
#define FAN_Q_OVERFLOW               0x4000
#define FAN_UNLIMITED_MARKS          0x20
#define FAN_UNLIMITED_QUEUE          0x10



/*!BEGIN libc/sysv/consts/fd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int FD_CLOEXEC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FD_CLOEXEC LITERALLY(1)



/*!BEGIN libc/sysv/consts/fileno.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FILENO_H_

#define STDIN_FILENO LITERALLY(0)
#define STDOUT_FILENO LITERALLY(1)
#define STDERR_FILENO LITERALLY(2)



/*!BEGIN libc/sysv/consts/fs.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FS_H_

#define FS_IOC_GETFLAGS   0x80086601
#define FS_IOC_SETFLAGS   0x40086602
#define FS_IOC_GETVERSION 0x80087601
#define FS_IOC_SETVERSION 0x40087602
#define FS_IOC_FIEMAP     0xc020660b
#define FS_IOC_FSGETXATTR 0x801c581f
#define FS_IOC_FSSETXATTR 0x401c5820
#define FS_IOC_GETFSLABEL 0x81009431
#define FS_IOC_SETFSLABEL 0x41009432

#define FS_FL_USER_VISIBLE    0x0003DFFF /* user visible flags */
#define FS_FL_USER_MODIFIABLE 0x000380FF /* user modifiable flags */
#define FS_SECRM_FL           0x00000001 /* secure deletion */
#define FS_UNRM_FL            0x00000002 /* undelete */
#define FS_COMPR_FL           0x00000004 /* compress */
#define FS_SYNC_FL            0x00000008 /* synchronous */
#define FS_IMMUTABLE_FL       0x00000010
#define FS_APPEND_FL          0x00000020 /* append-only */
#define FS_NODUMP_FL          0x00000040
#define FS_NOATIME_FL         0x00000080
#define FS_DIRTY_FL           0x00000100
#define FS_COMPRBLK_FL        0x00000200
#define FS_NOCOMP_FL          0x00000400
#define FS_ENCRYPT_FL         0x00000800 /* encrypted file */
#define FS_BTREE_FL           0x00001000
#define FS_INDEX_FL           0x00001000 /* hash-indexed directory */
#define FS_IMAGIC_FL          0x00002000
#define FS_JOURNAL_DATA_FL    0x00004000
#define FS_NOTAIL_FL          0x00008000
#define FS_DIRSYNC_FL         0x00010000
#define FS_TOPDIR_FL          0x00020000
#define FS_HUGE_FILE_FL       0x00040000
#define FS_EXTENT_FL          0x00080000



/*!BEGIN libc/sysv/consts/futex.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FUTEX_H_

#define FUTEX_WAIT            SYMBOLIC(FUTEX_WAIT)
#define FUTEX_WAKE            SYMBOLIC(FUTEX_WAKE)
#define FUTEX_REQUEUE         SYMBOLIC(FUTEX_REQUEUE)
#define FUTEX_PRIVATE_FLAG    SYMBOLIC(FUTEX_PRIVATE_FLAG)
#define FUTEX_WAIT_PRIVATE    (FUTEX_WAIT | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAKE_PRIVATE    (FUTEX_WAKE | FUTEX_PRIVATE_FLAG)
#define FUTEX_REQUEUE_PRIVATE (FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int FUTEX_WAIT;
extern const int FUTEX_WAKE;
extern const int FUTEX_REQUEUE;
extern const int FUTEX_PRIVATE_FLAG;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/grnd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_GRND_H_

#define GRND_NONBLOCK 1
#define GRND_RANDOM   2



/*!BEGIN libc/sysv/consts/icmp6.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ICMP6_H_

#define ICMP6_DST_UNREACH SYMBOLIC(ICMP6_DST_UNREACH)
#define ICMP6_DST_UNREACH_ADDR SYMBOLIC(ICMP6_DST_UNREACH_ADDR)
#define ICMP6_DST_UNREACH_ADMIN SYMBOLIC(ICMP6_DST_UNREACH_ADMIN)
#define ICMP6_DST_UNREACH_BEYONDSCOPE SYMBOLIC(ICMP6_DST_UNREACH_BEYONDSCOPE)
#define ICMP6_DST_UNREACH_NOPORT SYMBOLIC(ICMP6_DST_UNREACH_NOPORT)
#define ICMP6_DST_UNREACH_NOROUTE SYMBOLIC(ICMP6_DST_UNREACH_NOROUTE)
#define ICMP6_ECHO_REPLY SYMBOLIC(ICMP6_ECHO_REPLY)
#define ICMP6_ECHO_REQUEST SYMBOLIC(ICMP6_ECHO_REQUEST)
#define ICMP6_FILTER SYMBOLIC(ICMP6_FILTER)
#define ICMP6_INFOMSG_MASK SYMBOLIC(ICMP6_INFOMSG_MASK)
#define ICMP6_PACKET_TOO_BIG SYMBOLIC(ICMP6_PACKET_TOO_BIG)
#define ICMP6_PARAMPROB_HEADER SYMBOLIC(ICMP6_PARAMPROB_HEADER)
#define ICMP6_PARAMPROB_NEXTHEADER SYMBOLIC(ICMP6_PARAMPROB_NEXTHEADER)
#define ICMP6_PARAMPROB_OPTION SYMBOLIC(ICMP6_PARAMPROB_OPTION)
#define ICMP6_PARAM_PROB SYMBOLIC(ICMP6_PARAM_PROB)
#define ICMP6_ROUTER_RENUMBERING SYMBOLIC(ICMP6_ROUTER_RENUMBERING)
#define ICMP6_RR_FLAGS_FORCEAPPLY SYMBOLIC(ICMP6_RR_FLAGS_FORCEAPPLY)
#define ICMP6_RR_FLAGS_PREVDONE SYMBOLIC(ICMP6_RR_FLAGS_PREVDONE)
#define ICMP6_RR_FLAGS_REQRESULT SYMBOLIC(ICMP6_RR_FLAGS_REQRESULT)
#define ICMP6_RR_FLAGS_SPECSITE SYMBOLIC(ICMP6_RR_FLAGS_SPECSITE)
#define ICMP6_RR_FLAGS_TEST SYMBOLIC(ICMP6_RR_FLAGS_TEST)
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME \
  SYMBOLIC(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME)
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME \
  SYMBOLIC(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME)
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO SYMBOLIC(ICMP6_RR_PCOUSE_RAFLAGS_AUTO)
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK SYMBOLIC(ICMP6_RR_PCOUSE_RAFLAGS_ONLINK)
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN \
  SYMBOLIC(ICMP6_RR_RESULT_FLAGS_FORBIDDEN)
#define ICMP6_RR_RESULT_FLAGS_OOB SYMBOLIC(ICMP6_RR_RESULT_FLAGS_OOB)
#define ICMP6_TIME_EXCEEDED SYMBOLIC(ICMP6_TIME_EXCEEDED)
#define ICMP6_TIME_EXCEED_REASSEMBLY SYMBOLIC(ICMP6_TIME_EXCEED_REASSEMBLY)
#define ICMP6_TIME_EXCEED_TRANSIT SYMBOLIC(ICMP6_TIME_EXCEED_TRANSIT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint8_t ICMP6_DST_UNREACH;
extern const uint8_t ICMP6_DST_UNREACH_ADDR;
extern const uint8_t ICMP6_DST_UNREACH_ADMIN;
extern const uint8_t ICMP6_DST_UNREACH_BEYONDSCOPE;
extern const uint8_t ICMP6_DST_UNREACH_NOPORT;
extern const uint8_t ICMP6_DST_UNREACH_NOROUTE;
extern const uint8_t ICMP6_ECHO_REPLY;
extern const uint8_t ICMP6_ECHO_REQUEST;
extern const uint8_t ICMP6_FILTER;
extern const uint8_t ICMP6_INFOMSG_MASK;
extern const uint8_t ICMP6_PACKET_TOO_BIG;
extern const uint8_t ICMP6_PARAMPROB_HEADER;
extern const uint8_t ICMP6_PARAMPROB_NEXTHEADER;
extern const uint8_t ICMP6_PARAMPROB_OPTION;
extern const uint8_t ICMP6_PARAM_PROB;
extern const uint8_t ICMP6_ROUTER_RENUMBERING;
extern const uint8_t ICMP6_RR_FLAGS_FORCEAPPLY;
extern const uint8_t ICMP6_RR_FLAGS_PREVDONE;
extern const uint8_t ICMP6_RR_FLAGS_REQRESULT;
extern const uint8_t ICMP6_RR_FLAGS_SPECSITE;
extern const uint8_t ICMP6_RR_FLAGS_TEST;
extern const uint8_t ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME;
extern const uint8_t ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME;
extern const uint8_t ICMP6_RR_PCOUSE_RAFLAGS_AUTO;
extern const uint8_t ICMP6_RR_PCOUSE_RAFLAGS_ONLINK;
extern const uint8_t ICMP6_RR_RESULT_FLAGS_FORBIDDEN;
extern const uint8_t ICMP6_RR_RESULT_FLAGS_OOB;
extern const uint8_t ICMP6_TIME_EXCEEDED;
extern const uint8_t ICMP6_TIME_EXCEED_REASSEMBLY;
extern const uint8_t ICMP6_TIME_EXCEED_TRANSIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/iff.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IFF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IFF_UP;
extern const int IFF_ALLMULTI;
extern const int IFF_AUTOMEDIA;
extern const int IFF_BROADCAST;
extern const int IFF_DEBUG;
extern const int IFF_DYNAMIC;
extern const int IFF_LOOPBACK;
extern const int IFF_MASTER;
extern const int IFF_MULTICAST;
extern const int IFF_NOARP;
extern const int IFF_NOTRAILERS;
extern const int IFF_POINTOPOINT;
extern const int IFF_PORTSEL;
extern const int IFF_PROMISC;
extern const int IFF_RUNNING;
extern const int IFF_SLAVE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IFF_UP          1
#define IFF_BROADCAST   2
#define IFF_DEBUG       4
#define IFF_LOOPBACK    8
#define IFF_ALLMULTI    IFF_ALLMULTI
#define IFF_AUTOMEDIA   IFF_AUTOMEDIA
#define IFF_DYNAMIC     IFF_DYNAMIC
#define IFF_MASTER      IFF_MASTER
#define IFF_MULTICAST   IFF_MULTICAST
#define IFF_NOARP       IFF_NOARP
#define IFF_NOTRAILERS  IFF_NOTRAILERS
#define IFF_POINTOPOINT IFF_POINTOPOINT
#define IFF_PORTSEL     IFF_PORTSEL
#define IFF_PROMISC     IFF_PROMISC
#define IFF_RUNNING     IFF_RUNNING
#define IFF_SLAVE       IFF_SLAVE



/*!BEGIN libc/sysv/consts/in.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IN_H_

#define IN_ACCESS        1
#define IN_ALL_EVENTS    0x0fff
#define IN_ATTRIB        4
#define IN_CLOEXEC       0x080000
#define IN_CLOSE         24
#define IN_CLOSE_NOWRITE 0x10
#define IN_CLOSE_WRITE   8
#define IN_CREATE        0x0100
#define IN_DELETE        0x0200
#define IN_DELETE_SELF   0x0400
#define IN_DONT_FOLLOW   0x02000000
#define IN_EXCL_UNLINK   0x04000000
#define IN_IGNORED       0x8000
#define IN_ISDIR         0x40000000
#define IN_MASK_ADD      0x20000000
#define IN_MODIFY        2
#define IN_MOVE          192
#define IN_MOVED_FROM    0x40
#define IN_MOVED_TO      0x80
#define IN_MOVE_SELF     0x0800
#define IN_NONBLOCK      0x0800
#define IN_ONESHOT       0x80000000
#define IN_ONLYDIR       0x01000000
#define IN_OPEN          0x20
#define IN_Q_OVERFLOW    0x4000
#define IN_UNMOUNT       0x2000



/*!BEGIN libc/sysv/consts/inaddr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_INADDR_H_

/**
 * @fileoverview Well-known Internet addresses.
 * These need to be hard-coded as little-endian, so htonl() is needed.
 */

#define INADDR_ANY       0x00000000u /* 0.0.0.0 */
#define INADDR_BROADCAST 0xFFFFFFFFu /* 255.255.255.255 */
#define INADDR_NONE      0xFFFFFFFFu /* 255.255.255.255 */
#define INADDR_LOOPBACK  0x7F000001u /* 127.0.0.1 */
#define INADDR_TESTNET1  0xC0000200u /* 192.0.2.0/24 (RFC5737§3) */
#define INADDR_TESTNET2  0xC6336400u /* 198.51.100.0/24 */
#define INADDR_TESTNET3  0xCB007100u /* 203.0.113.0/24 */

#define INADDR_ALLHOSTS_GROUP  0xE0000001u
#define INADDR_ALLRTRS_GROUP   0xE0000002u
#define INADDR_MAX_LOCAL_GROUP 0xE00000FFu
#define INADDR_UNSPEC_GROUP    0xE0000000u

#define IN_LOOPBACKNET 127



/*!BEGIN libc/sysv/consts/ioprio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IOPRIO_H_

#define IOPRIO_WHO_PROCESS 1
#define IOPRIO_WHO_PGRP    2
#define IOPRIO_WHO_USER    3

#define IOPRIO_CLASS_SHIFT 13
#define IOPRIO_CLASS_MASK  0x07
#define IOPRIO_PRIO_MASK   ((1UL << IOPRIO_CLASS_SHIFT) - 1)

#define IOPRIO_PRIO_CLASS(ioprio) \
  (((ioprio) >> IOPRIO_CLASS_SHIFT) & IOPRIO_CLASS_MASK)
#define IOPRIO_PRIO_DATA(ioprio) ((ioprio)&IOPRIO_PRIO_MASK)
#define IOPRIO_PRIO_VALUE(class, data)                     \
  ((((class) & IOPRIO_CLASS_MASK) << IOPRIO_CLASS_SHIFT) | \
   ((data)&IOPRIO_PRIO_MASK))

#define IOPRIO_CLASS_NONE 0
#define IOPRIO_CLASS_RT   1
#define IOPRIO_CLASS_BE   2
#define IOPRIO_CLASS_IDLE 3

#define IOPRIO_NR_LEVELS 8
#define IOPRIO_BE_NR     IOPRIO_NR_LEVELS

#define IOPRIO_NORM    4
#define IOPRIO_BE_NORM IOPRIO_NORM



/*!BEGIN libc/sysv/consts/iov.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IOV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IOV_MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IOV_MAX SYMBOLIC(IOV_MAX)



/*!BEGIN libc/sysv/consts/ip.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IP_H_

#define IP_ADD_MEMBERSHIP         SYMBOLIC(IP_ADD_MEMBERSHIP)
#define IP_ADD_SOURCE_MEMBERSHIP  SYMBOLIC(IP_ADD_SOURCE_MEMBERSHIP)
#define IP_BIND_ADDRESS_NO_PORT   SYMBOLIC(IP_BIND_ADDRESS_NO_PORT)
#define IP_BLOCK_SOURCE           SYMBOLIC(IP_BLOCK_SOURCE)
#define IP_CHECKSUM               SYMBOLIC(IP_CHECKSUM)
#define IP_DEFAULT_MULTICAST_LOOP SYMBOLIC(IP_DEFAULT_MULTICAST_LOOP)
#define IP_DEFAULT_MULTICAST_TTL  SYMBOLIC(IP_DEFAULT_MULTICAST_TTL)
#define IP_DROP_MEMBERSHIP        SYMBOLIC(IP_DROP_MEMBERSHIP)
#define IP_DROP_SOURCE_MEMBERSHIP SYMBOLIC(IP_DROP_SOURCE_MEMBERSHIP)
#define IP_FREEBIND               SYMBOLIC(IP_FREEBIND)
#define IP_HDRINCL                SYMBOLIC(IP_HDRINCL)
#define IP_IPSEC_POLICY           SYMBOLIC(IP_IPSEC_POLICY)
#define IP_MAX_MEMBERSHIPS        SYMBOLIC(IP_MAX_MEMBERSHIPS)
#define IP_MINTTL                 SYMBOLIC(IP_MINTTL)
#define IP_MSFILTER               SYMBOLIC(IP_MSFILTER)
#define IP_MTU                    SYMBOLIC(IP_MTU)
#define IP_MTU_DISCOVER           SYMBOLIC(IP_MTU_DISCOVER)
#define IP_MULTICAST_ALL          SYMBOLIC(IP_MULTICAST_ALL)
#define IP_MULTICAST_IF           SYMBOLIC(IP_MULTICAST_IF)
#define IP_MULTICAST_LOOP         SYMBOLIC(IP_MULTICAST_LOOP)
#define IP_MULTICAST_TTL          SYMBOLIC(IP_MULTICAST_TTL)
#define IP_NODEFRAG               SYMBOLIC(IP_NODEFRAG)
#define IP_OPTIONS                SYMBOLIC(IP_OPTIONS)
#define IP_ORIGDSTADDR            SYMBOLIC(IP_ORIGDSTADDR)
#define IP_PASSSEC                SYMBOLIC(IP_PASSSEC)
#define IP_PKTINFO                SYMBOLIC(IP_PKTINFO)
#define IP_PKTOPTIONS             SYMBOLIC(IP_PKTOPTIONS)
#define IP_PMTUDISC               SYMBOLIC(IP_PMTUDISC)
#define IP_PMTUDISC_DO            SYMBOLIC(IP_PMTUDISC_DO)
#define IP_PMTUDISC_DONT          SYMBOLIC(IP_PMTUDISC_DONT)
#define IP_PMTUDISC_INTERFACE     SYMBOLIC(IP_PMTUDISC_INTERFACE)
#define IP_PMTUDISC_OMIT          SYMBOLIC(IP_PMTUDISC_OMIT)
#define IP_PMTUDISC_PROBE         SYMBOLIC(IP_PMTUDISC_PROBE)
#define IP_PMTUDISC_WANT          SYMBOLIC(IP_PMTUDISC_WANT)
#define IP_RECVDSTADDR            SYMBOLIC(IP_RECVDSTADDR)
#define IP_RECVERR                SYMBOLIC(IP_RECVERR)
#define IP_RECVOPTS               SYMBOLIC(IP_RECVOPTS)
#define IP_RECVORIGDSTADDR        SYMBOLIC(IP_RECVORIGDSTADDR)
#define IP_RECVRETOPTS            SYMBOLIC(IP_RECVRETOPTS)
#define IP_RECVTOS                SYMBOLIC(IP_RECVTOS)
#define IP_RECVTTL                SYMBOLIC(IP_RECVTTL)
#define IP_RETOPTS                SYMBOLIC(IP_RETOPTS)
#define IP_ROUTER_ALERT           SYMBOLIC(IP_ROUTER_ALERT)
#define IP_TOS                    SYMBOLIC(IP_TOS)
#define IP_TRANSPARENT            SYMBOLIC(IP_TRANSPARENT)
#define IP_TTL                    SYMBOLIC(IP_TTL)
#define IP_UNBLOCK_SOURCE         SYMBOLIC(IP_UNBLOCK_SOURCE)
#define IP_UNICAST_IF             SYMBOLIC(IP_UNICAST_IF)
#define IP_XFRM_POLICY            SYMBOLIC(IP_XFRM_POLICY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IP_ADD_MEMBERSHIP;
extern const int IP_ADD_SOURCE_MEMBERSHIP;
extern const int IP_BIND_ADDRESS_NO_PORT;
extern const int IP_BLOCK_SOURCE;
extern const int IP_CHECKSUM;
extern const int IP_DEFAULT_MULTICAST_LOOP;
extern const int IP_DEFAULT_MULTICAST_TTL;
extern const int IP_DROP_MEMBERSHIP;
extern const int IP_DROP_SOURCE_MEMBERSHIP;
extern const int IP_FREEBIND;
extern const int IP_HDRINCL;
extern const int IP_IPSEC_POLICY;
extern const int IP_MAX_MEMBERSHIPS;
extern const int IP_MINTTL;
extern const int IP_MSFILTER;
extern const int IP_MTU;
extern const int IP_MTU_DISCOVER;
extern const int IP_MULTICAST_ALL;
extern const int IP_MULTICAST_IF;
extern const int IP_MULTICAST_LOOP;
extern const int IP_MULTICAST_TTL;
extern const int IP_NODEFRAG;
extern const int IP_OPTIONS;
extern const int IP_ORIGDSTADDR;
extern const int IP_PASSSEC;
extern const int IP_PKTINFO;
extern const int IP_PKTOPTIONS;
extern const int IP_PMTUDISC;
extern const int IP_PMTUDISC_DO;
extern const int IP_PMTUDISC_DONT;
extern const int IP_PMTUDISC_INTERFACE;
extern const int IP_PMTUDISC_OMIT;
extern const int IP_PMTUDISC_PROBE;
extern const int IP_PMTUDISC_WANT;
extern const int IP_RECVDSTADDR;
extern const int IP_RECVERR;
extern const int IP_RECVOPTS;
extern const int IP_RECVORIGDSTADDR;
extern const int IP_RECVRETOPTS;
extern const int IP_RECVTOS;
extern const int IP_RECVTTL;
extern const int IP_RETOPTS;
extern const int IP_ROUTER_ALERT;
extern const int IP_TOS;
extern const int IP_TRANSPARENT;
extern const int IP_TTL;
extern const int IP_UNBLOCK_SOURCE;
extern const int IP_UNICAST_IF;
extern const int IP_XFRM_POLICY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ipport.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPPORT_H_

/**
 * ARPA network ports.
 */
#define IPPORT_ECHO         7
#define IPPORT_DISCARD      9
#define IPPORT_SYSTAT       11
#define IPPORT_DAYTIME      13
#define IPPORT_NETSTAT      15
#define IPPORT_FTP          21
#define IPPORT_TELNET       23
#define IPPORT_SMTP         25
#define IPPORT_TIMESERVER   37
#define IPPORT_NAMESERVER   42
#define IPPORT_WHOIS        43
#define IPPORT_MTP          57
#define IPPORT_TFTP         69
#define IPPORT_RJE          77
#define IPPORT_FINGER       79
#define IPPORT_TTYLINK      87
#define IPPORT_SUPDUP       95
#define IPPORT_EXECSERVER   512
#define IPPORT_LOGINSERVER  513
#define IPPORT_CMDSERVER    514
#define IPPORT_EFSSERVER    520
#define IPPORT_BIFFUDP      512
#define IPPORT_WHOSERVER    513
#define IPPORT_ROUTESERVER  520
#define IPPORT_RESERVED     1024
#define IPPORT_USERRESERVED SYMBOLIC(IPPORT_USERRESERVED)

/**
 * Modern network ports.
 */
#define IPPORT_SSH         22
#define IPPORT_DOMAIN      53
#define IPPORT_HTTP        80
#define IPPORT_POP3        110
#define IPPORT_SFTP        115
#define IPPORT_NTP         123
#define IPPORT_IMAP2       143
#define IPPORT_NETBIOS_NS  137
#define IPPORT_NETBIOS_DGM 138
#define IPPORT_NETBIOS_SSN 139
#define IPPORT_BGP         179
#define IPPORT_IRC         194
#define IPPORT_HTTPS       443
#define IPPORT_PRINTER     515
#define IPPORT_NFS         2049
#define IPPORT_DISTCC      3632
#define IPPORT_SIP         5060
#define IPPORT_POSTGRESQL  5432
#define IPPORT_X11         6000
#define IPPORT_GIT         9418
#define IPPORT_IRCD        6667
#define IPPORT_IMAPS       993
#define IPPORT_POP3S       995

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IPPORT_USERRESERVED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ipproto.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPPROTO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IPPROTO_AH;
extern const int IPPROTO_BEETPH;
extern const int IPPROTO_COMP;
extern const int IPPROTO_DCCP;
extern const int IPPROTO_DSTOPTS;
extern const int IPPROTO_EGP;
extern const int IPPROTO_ENCAP;
extern const int IPPROTO_ESP;
extern const int IPPROTO_FRAGMENT;
extern const int IPPROTO_GRE;
extern const int IPPROTO_HOPOPTS;
extern const int IPPROTO_ICMP;
extern const int IPPROTO_ICMPV6;
extern const int IPPROTO_IDP;
extern const int IPPROTO_IGMP;
extern const int IPPROTO_IP;
extern const int IPPROTO_IPIP;
extern const int IPPROTO_IPV6;
extern const int IPPROTO_MAX;
extern const int IPPROTO_MH;
extern const int IPPROTO_MPLS;
extern const int IPPROTO_MTP;
extern const int IPPROTO_NONE;
extern const int IPPROTO_PIM;
extern const int IPPROTO_PUP;
extern const int IPPROTO_RAW;
extern const int IPPROTO_ROUTING;
extern const int IPPROTO_RSVP;
extern const int IPPROTO_SCTP;
extern const int IPPROTO_TCP;
extern const int IPPROTO_TP;
extern const int IPPROTO_UDP;
extern const int IPPROTO_UDPLITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IPPROTO_IP   LITERALLY(0)
#define IPPROTO_ICMP LITERALLY(1)
#define IPPROTO_TCP  LITERALLY(6)
#define IPPROTO_UDP  LITERALLY(17)
#define IPPROTO_RAW  LITERALLY(255)

#define IPPROTO_AH       SYMBOLIC(IPPROTO_AH)
#define IPPROTO_BEETPH   SYMBOLIC(IPPROTO_BEETPH)
#define IPPROTO_COMP     SYMBOLIC(IPPROTO_COMP)
#define IPPROTO_DCCP     SYMBOLIC(IPPROTO_DCCP)
#define IPPROTO_DSTOPTS  SYMBOLIC(IPPROTO_DSTOPTS)
#define IPPROTO_EGP      SYMBOLIC(IPPROTO_EGP)
#define IPPROTO_ENCAP    SYMBOLIC(IPPROTO_ENCAP)
#define IPPROTO_ESP      SYMBOLIC(IPPROTO_ESP)
#define IPPROTO_FRAGMENT SYMBOLIC(IPPROTO_FRAGMENT)
#define IPPROTO_GRE      SYMBOLIC(IPPROTO_GRE)
#define IPPROTO_HOPOPTS  SYMBOLIC(IPPROTO_HOPOPTS)
#define IPPROTO_ICMPV6   SYMBOLIC(IPPROTO_ICMPV6)
#define IPPROTO_IDP      SYMBOLIC(IPPROTO_IDP)
#define IPPROTO_IGMP     SYMBOLIC(IPPROTO_IGMP)
#define IPPROTO_IPIP     SYMBOLIC(IPPROTO_IPIP)
#define IPPROTO_IPV6     SYMBOLIC(IPPROTO_IPV6)
#define IPPROTO_MAX      SYMBOLIC(IPPROTO_MAX)
#define IPPROTO_MH       SYMBOLIC(IPPROTO_MH)
#define IPPROTO_MPLS     SYMBOLIC(IPPROTO_MPLS)
#define IPPROTO_MTP      SYMBOLIC(IPPROTO_MTP)
#define IPPROTO_NONE     SYMBOLIC(IPPROTO_NONE)
#define IPPROTO_PIM      SYMBOLIC(IPPROTO_PIM)
#define IPPROTO_PUP      SYMBOLIC(IPPROTO_PUP)
#define IPPROTO_ROUTING  SYMBOLIC(IPPROTO_ROUTING)
#define IPPROTO_RSVP     SYMBOLIC(IPPROTO_RSVP)
#define IPPROTO_SCTP     SYMBOLIC(IPPROTO_SCTP)
#define IPPROTO_TP       SYMBOLIC(IPPROTO_TP)
#define IPPROTO_UDPLITE  SYMBOLIC(IPPROTO_UDPLITE)



/*!BEGIN libc/sysv/consts/ipv6.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPV6_H_

#define IPV6_2292DSTOPTS SYMBOLIC(IPV6_2292DSTOPTS)
#define IPV6_2292HOPLIMIT SYMBOLIC(IPV6_2292HOPLIMIT)
#define IPV6_2292HOPOPTS SYMBOLIC(IPV6_2292HOPOPTS)
#define IPV6_2292PKTINFO SYMBOLIC(IPV6_2292PKTINFO)
#define IPV6_2292PKTOPTIONS SYMBOLIC(IPV6_2292PKTOPTIONS)
#define IPV6_2292RTHDR SYMBOLIC(IPV6_2292RTHDR)
#define IPV6_ADDRFORM SYMBOLIC(IPV6_ADDRFORM)
#define IPV6_ADD_MEMBERSHIP SYMBOLIC(IPV6_ADD_MEMBERSHIP)
#define IPV6_AUTHHDR SYMBOLIC(IPV6_AUTHHDR)
#define IPV6_AUTOFLOWLABEL SYMBOLIC(IPV6_AUTOFLOWLABEL)
#define IPV6_CHECKSUM SYMBOLIC(IPV6_CHECKSUM)
#define IPV6_DONTFRAG SYMBOLIC(IPV6_DONTFRAG)
#define IPV6_DROP_MEMBERSHIP SYMBOLIC(IPV6_DROP_MEMBERSHIP)
#define IPV6_DSTOPTS SYMBOLIC(IPV6_DSTOPTS)
#define IPV6_HDRINCL SYMBOLIC(IPV6_HDRINCL)
#define IPV6_HOPLIMIT SYMBOLIC(IPV6_HOPLIMIT)
#define IPV6_HOPOPTS SYMBOLIC(IPV6_HOPOPTS)
#define IPV6_IPSEC_POLICY SYMBOLIC(IPV6_IPSEC_POLICY)
#define IPV6_JOIN_ANYCAST SYMBOLIC(IPV6_JOIN_ANYCAST)
#define IPV6_JOIN_GROUP SYMBOLIC(IPV6_JOIN_GROUP)
#define IPV6_LEAVE_ANYCAST SYMBOLIC(IPV6_LEAVE_ANYCAST)
#define IPV6_LEAVE_GROUP SYMBOLIC(IPV6_LEAVE_GROUP)
#define IPV6_MINHOPCOUNT SYMBOLIC(IPV6_MINHOPCOUNT)
#define IPV6_MTU SYMBOLIC(IPV6_MTU)
#define IPV6_MTU_DISCOVER SYMBOLIC(IPV6_MTU_DISCOVER)
#define IPV6_MULTICAST_HOPS SYMBOLIC(IPV6_MULTICAST_HOPS)
#define IPV6_MULTICAST_IF SYMBOLIC(IPV6_MULTICAST_IF)
#define IPV6_MULTICAST_LOOP SYMBOLIC(IPV6_MULTICAST_LOOP)
#define IPV6_NEXTHOP SYMBOLIC(IPV6_NEXTHOP)
#define IPV6_ORIGDSTADDR SYMBOLIC(IPV6_ORIGDSTADDR)
#define IPV6_PATHMTU SYMBOLIC(IPV6_PATHMTU)
#define IPV6_PKTINFO SYMBOLIC(IPV6_PKTINFO)
#define IPV6_PMTUDISC_DO SYMBOLIC(IPV6_PMTUDISC_DO)
#define IPV6_PMTUDISC_DONT SYMBOLIC(IPV6_PMTUDISC_DONT)
#define IPV6_PMTUDISC_INTERFACE SYMBOLIC(IPV6_PMTUDISC_INTERFACE)
#define IPV6_PMTUDISC_OMIT SYMBOLIC(IPV6_PMTUDISC_OMIT)
#define IPV6_PMTUDISC_PROBE SYMBOLIC(IPV6_PMTUDISC_PROBE)
#define IPV6_PMTUDISC_WANT SYMBOLIC(IPV6_PMTUDISC_WANT)
#define IPV6_RECVDSTOPTS SYMBOLIC(IPV6_RECVDSTOPTS)
#define IPV6_RECVERR SYMBOLIC(IPV6_RECVERR)
#define IPV6_RECVHOPLIMIT SYMBOLIC(IPV6_RECVHOPLIMIT)
#define IPV6_RECVHOPOPTS SYMBOLIC(IPV6_RECVHOPOPTS)
#define IPV6_RECVORIGDSTADDR SYMBOLIC(IPV6_RECVORIGDSTADDR)
#define IPV6_RECVPATHMTU SYMBOLIC(IPV6_RECVPATHMTU)
#define IPV6_RECVPKTINFO SYMBOLIC(IPV6_RECVPKTINFO)
#define IPV6_RECVRTHDR SYMBOLIC(IPV6_RECVRTHDR)
#define IPV6_RECVTCLASS SYMBOLIC(IPV6_RECVTCLASS)
#define IPV6_ROUTER_ALERT SYMBOLIC(IPV6_ROUTER_ALERT)
#define IPV6_RTHDR SYMBOLIC(IPV6_RTHDR)
#define IPV6_RTHDRDSTOPTS SYMBOLIC(IPV6_RTHDRDSTOPTS)
#define IPV6_RTHDR_LOOSE SYMBOLIC(IPV6_RTHDR_LOOSE)
#define IPV6_RTHDR_STRICT SYMBOLIC(IPV6_RTHDR_STRICT)
#define IPV6_RTHDR_TYPE_0 SYMBOLIC(IPV6_RTHDR_TYPE_0)
#define IPV6_RXDSTOPTS SYMBOLIC(IPV6_RXDSTOPTS)
#define IPV6_RXHOPOPTS SYMBOLIC(IPV6_RXHOPOPTS)
#define IPV6_TCLASS SYMBOLIC(IPV6_TCLASS)
#define IPV6_UNICAST_HOPS SYMBOLIC(IPV6_UNICAST_HOPS)
#define IPV6_V6ONLY SYMBOLIC(IPV6_V6ONLY)
#define IPV6_XFRM_POLICY SYMBOLIC(IPV6_XFRM_POLICY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int IPV6_2292DSTOPTS;
extern const int IPV6_2292HOPLIMIT;
extern const int IPV6_2292HOPOPTS;
extern const int IPV6_2292PKTINFO;
extern const int IPV6_2292PKTOPTIONS;
extern const int IPV6_2292RTHDR;
extern const int IPV6_ADDRFORM;
extern const int IPV6_ADD_MEMBERSHIP;
extern const int IPV6_AUTHHDR;
extern const int IPV6_AUTOFLOWLABEL;
extern const int IPV6_CHECKSUM;
extern const int IPV6_DONTFRAG;
extern const int IPV6_DROP_MEMBERSHIP;
extern const int IPV6_DSTOPTS;
extern const int IPV6_HDRINCL;
extern const int IPV6_HOPLIMIT;
extern const int IPV6_HOPOPTS;
extern const int IPV6_IPSEC_POLICY;
extern const int IPV6_JOIN_ANYCAST;
extern const int IPV6_JOIN_GROUP;
extern const int IPV6_LEAVE_ANYCAST;
extern const int IPV6_LEAVE_GROUP;
extern const int IPV6_MINHOPCOUNT;
extern const int IPV6_MTU;
extern const int IPV6_MTU_DISCOVER;
extern const int IPV6_MULTICAST_HOPS;
extern const int IPV6_MULTICAST_IF;
extern const int IPV6_MULTICAST_LOOP;
extern const int IPV6_NEXTHOP;
extern const int IPV6_ORIGDSTADDR;
extern const int IPV6_PATHMTU;
extern const int IPV6_PKTINFO;
extern const int IPV6_PMTUDISC_DO;
extern const int IPV6_PMTUDISC_DONT;
extern const int IPV6_PMTUDISC_INTERFACE;
extern const int IPV6_PMTUDISC_OMIT;
extern const int IPV6_PMTUDISC_PROBE;
extern const int IPV6_PMTUDISC_WANT;
extern const int IPV6_RECVDSTOPTS;
extern const int IPV6_RECVERR;
extern const int IPV6_RECVHOPLIMIT;
extern const int IPV6_RECVHOPOPTS;
extern const int IPV6_RECVORIGDSTADDR;
extern const int IPV6_RECVPATHMTU;
extern const int IPV6_RECVPKTINFO;
extern const int IPV6_RECVRTHDR;
extern const int IPV6_RECVTCLASS;
extern const int IPV6_ROUTER_ALERT;
extern const int IPV6_RTHDR;
extern const int IPV6_RTHDRDSTOPTS;
extern const int IPV6_RTHDR_LOOSE;
extern const int IPV6_RTHDR_STRICT;
extern const int IPV6_RTHDR_TYPE_0;
extern const int IPV6_RXDSTOPTS;
extern const int IPV6_RXHOPOPTS;
extern const int IPV6_TCLASS;
extern const int IPV6_UNICAST_HOPS;
extern const int IPV6_V6ONLY;
extern const int IPV6_XFRM_POLICY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/itimer.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ITIMER_H_

#define ITIMER_REAL    0
#define ITIMER_VIRTUAL 1
#define ITIMER_PROF    2



/*!BEGIN libc/sysv/consts/kern.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_KERN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define KERN_SOH       "\001"
#define KERN_SOH_ASCII '\001'
#define KERN_EMERG     KERN_SOH "0"
#define KERN_ALERT     KERN_SOH "1"
#define KERN_CRIT      KERN_SOH "2"
#define KERN_ERR       KERN_SOH "3"
#define KERN_WARNING   KERN_SOH "4"
#define KERN_NOTICE    KERN_SOH "5"
#define KERN_INFO      KERN_SOH "6"
#define KERN_DEBUG     KERN_SOH "7"
#define KERN_DEFAULT   ""
#define KERN_CONT      KERN_SOH "c"

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/l.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_L_H_

#define L_SET  SEEK_SET
#define L_INCR SEEK_CUR
#define L_XTND SEEK_END



/*!BEGIN libc/sysv/consts/limits.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LIMITS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int PIPE_BUF;
extern const int _ARG_MAX;
extern const int _NAME_MAX;
extern const int _PATH_MAX;
extern const int _NSIG;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PIPE_BUF  SYMBOLIC(PIPE_BUF)
#define _ARG_MAX  SYMBOLIC(_ARG_MAX)
#define _NAME_MAX SYMBOLIC(_NAME_MAX)
#define _PATH_MAX SYMBOLIC(_PATH_MAX)
#define _NSIG     SYMBOLIC(_NSIG)



/*!BEGIN libc/sysv/consts/lio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LIO_H_

#define LIO_NOP SYMBOLIC(LIO_NOP)
#define LIO_NOWAIT SYMBOLIC(LIO_NOWAIT)
#define LIO_READ SYMBOLIC(LIO_READ)
#define LIO_WAIT SYMBOLIC(LIO_WAIT)
#define LIO_WRITE SYMBOLIC(LIO_WRITE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int LIO_NOP;
extern const int LIO_NOWAIT;
extern const int LIO_READ;
extern const int LIO_WAIT;
extern const int LIO_WRITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/lock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int LOCK_EX;
extern const int LOCK_NB;
extern const int LOCK_SH;
extern const int LOCK_UN;
extern const int LOCK_UNLOCK_CACHE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define LOCK_EX LITERALLY(2)
#define LOCK_NB SYMBOLIC(LOCK_NB)
#define LOCK_SH SYMBOLIC(LOCK_SH)
#define LOCK_UN SYMBOLIC(LOCK_UN)
#define LOCK_UNLOCK_CACHE SYMBOLIC(LOCK_UNLOCK_CACHE)



/*!BEGIN libc/sysv/consts/log.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LOG_H_

#define LOG_MASK(pri) (1 << (pri))
#define LOG_UPTO(pri) ((1 << ((pri) + 1)) - 1)

#define LOG_EMERG   0
#define LOG_ALERT   1
#define LOG_CRIT    2
#define LOG_ERR     3
#define LOG_WARNING 4
#define LOG_NOTICE  5
#define LOG_INFO    6
#define LOG_DEBUG   7

#define LOG_KERN     0000
#define LOG_USER     0010
#define LOG_MAIL     0020
#define LOG_DAEMON   0030
#define LOG_AUTH     0040
#define LOG_SYSLOG   0050
#define LOG_LPR      0060
#define LOG_NEWS     0070
#define LOG_UUCP     0100
#define LOG_CRON     0110
#define LOG_AUTHPRIV 0120
#define LOG_FTP      0130

#define LOG_PID    1
#define LOG_CONS   2
#define LOG_ODELAY 4
#define LOG_NDELAY 8
#define LOG_NOWAIT 16
#define LOG_PERROR 32

#define LOG_LOCAL0 128
#define LOG_LOCAL1 136
#define LOG_LOCAL2 144
#define LOG_LOCAL3 152
#define LOG_LOCAL4 160
#define LOG_LOCAL5 168
#define LOG_LOCAL6 176
#define LOG_LOCAL7 184

#define LOG_NFACILITIES 24
#define LOG_FACMASK     0x03f8
#define LOG_FAC(p)      ((LOG_FACMASK & (p)) >> 3)

#define LOG_PRIMASK       7
#define LOG_PRI(p)        (LOG_PRIMASK & (p))
#define LOG_MAKEPRI(f, p) (((f) << 3) | (p))



/*!BEGIN libc/sysv/consts/loglevel.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LOGLEVEL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define LOGLEVEL_SCHED   -2
#define LOGLEVEL_DEFAULT -1
#define LOGLEVEL_EMERG   0
#define LOGLEVEL_ALERT   1
#define LOGLEVEL_CRIT    2
#define LOGLEVEL_ERR     3
#define LOGLEVEL_WARNING 4
#define LOGLEVEL_NOTICE  5
#define LOGLEVEL_INFO    6
#define LOGLEVEL_DEBUG   7

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/madv.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MADV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned MADV_DODUMP;
extern const unsigned MADV_DOFORK;
extern const unsigned MADV_DONTDUMP;
extern const unsigned MADV_DONTFORK;
extern const unsigned MADV_DONTNEED;
extern const unsigned MADV_FREE;
extern const unsigned MADV_HUGEPAGE;
extern const unsigned MADV_HWPOISON;
extern const unsigned MADV_MERGEABLE;
extern const unsigned MADV_NOHUGEPAGE;
extern const unsigned MADV_NORMAL;
extern const unsigned MADV_RANDOM;
extern const unsigned MADV_REMOVE;
extern const unsigned MADV_SEQUENTIAL;
extern const unsigned MADV_UNMERGEABLE;
extern const unsigned MADV_WILLNEED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MADV_NORMAL     LITERALLY(0)
#define MADV_RANDOM     LITERALLY(1)
#define MADV_SEQUENTIAL LITERALLY(2)
#define MADV_WILLNEED   LITERALLY(3)

#define MADV_DODUMP      SYMBOLIC(MADV_DODUMP)
#define MADV_DOFORK      SYMBOLIC(MADV_DOFORK)
#define MADV_DONTDUMP    SYMBOLIC(MADV_DONTDUMP)
#define MADV_DONTFORK    SYMBOLIC(MADV_DONTFORK)
#define MADV_DONTNEED    SYMBOLIC(MADV_DONTNEED)
#define MADV_FREE        SYMBOLIC(MADV_FREE)
#define MADV_HUGEPAGE    SYMBOLIC(MADV_HUGEPAGE)
#define MADV_HWPOISON    SYMBOLIC(MADV_HWPOISON)
#define MADV_MERGEABLE   SYMBOLIC(MADV_MERGEABLE)
#define MADV_NOHUGEPAGE  SYMBOLIC(MADV_NOHUGEPAGE)
#define MADV_REMOVE      SYMBOLIC(MADV_REMOVE)
#define MADV_UNMERGEABLE SYMBOLIC(MADV_UNMERGEABLE)



/*!BEGIN libc/sysv/consts/map.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MAP_32BIT;
extern const int MAP_ANON;
extern const int MAP_ANONYMOUS;
extern const int MAP_CONCEAL;
extern const int MAP_DENYWRITE;
extern const int MAP_EXECUTABLE;
extern const int MAP_FILE;
extern const int MAP_FIXED;
extern const int MAP_FIXED_NOREPLACE;
extern const int MAP_GROWSDOWN;
extern const int MAP_HASSEMAPHORE;
extern const int MAP_HUGETLB;
extern const int MAP_HUGE_MASK;
extern const int MAP_HUGE_SHIFT;
extern const int MAP_INHERIT;
extern const int MAP_LOCKED;
extern const int MAP_NONBLOCK;
extern const int MAP_NORESERVE;
extern const int MAP_NOSYNC;
extern const int MAP_POPULATE;
extern const int MAP_PRIVATE;
extern const int MAP_SHARED;
extern const int MAP_SHARED_VALIDATE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MAP_FILE    0
#define MAP_SHARED  1
#define MAP_PRIVATE 2
#define MAP_STACK   6
#define MAP_TYPE    15
#define MAP_FIXED   16

#define MAP_32BIT           SYMBOLIC(MAP_32BIT)
#define MAP_ANONYMOUS       SYMBOLIC(MAP_ANONYMOUS)
#define MAP_CONCEAL         SYMBOLIC(MAP_CONCEAL)
#define MAP_DENYWRITE       SYMBOLIC(MAP_DENYWRITE)
#define MAP_EXECUTABLE      SYMBOLIC(MAP_EXECUTABLE)
#define MAP_FIXED_NOREPLACE SYMBOLIC(MAP_FIXED_NOREPLACE)
#define MAP_GROWSDOWN       SYMBOLIC(MAP_GROWSDOWN)
#define MAP_HASSEMAPHORE    SYMBOLIC(MAP_HASSEMAPHORE)
#define MAP_HUGETLB         SYMBOLIC(MAP_HUGETLB)
#define MAP_HUGE_MASK       SYMBOLIC(MAP_HUGE_MASK)
#define MAP_HUGE_SHIFT      SYMBOLIC(MAP_HUGE_SHIFT)
#define MAP_INHERIT         SYMBOLIC(MAP_INHERIT)
#define MAP_LOCKED          SYMBOLIC(MAP_LOCKED)
#define MAP_NONBLOCK        SYMBOLIC(MAP_NONBLOCK)
#define MAP_NORESERVE       SYMBOLIC(MAP_NORESERVE)
#define MAP_NOSYNC          SYMBOLIC(MAP_NOSYNC)
#define MAP_POPULATE        SYMBOLIC(MAP_POPULATE)
#define MAP_SHARED_VALIDATE SYMBOLIC(MAP_SHARED_VALIDATE)

#define MAP_ANON   MAP_ANONYMOUS
#define MAP_NOCORE MAP_CONCEAL



/*!BEGIN libc/sysv/consts/mcast.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MCAST_H_

#define MCAST_BLOCK_SOURCE SYMBOLIC(MCAST_BLOCK_SOURCE)
#define MCAST_EXCLUDE SYMBOLIC(MCAST_EXCLUDE)
#define MCAST_INCLUDE SYMBOLIC(MCAST_INCLUDE)
#define MCAST_JOIN_GROUP SYMBOLIC(MCAST_JOIN_GROUP)
#define MCAST_JOIN_SOURCE_GROUP SYMBOLIC(MCAST_JOIN_SOURCE_GROUP)
#define MCAST_LEAVE_GROUP SYMBOLIC(MCAST_LEAVE_GROUP)
#define MCAST_LEAVE_SOURCE_GROUP SYMBOLIC(MCAST_LEAVE_SOURCE_GROUP)
#define MCAST_MSFILTER SYMBOLIC(MCAST_MSFILTER)
#define MCAST_UNBLOCK_SOURCE SYMBOLIC(MCAST_UNBLOCK_SOURCE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MCAST_BLOCK_SOURCE;
extern const int MCAST_EXCLUDE;
extern const int MCAST_INCLUDE;
extern const int MCAST_JOIN_GROUP;
extern const int MCAST_JOIN_SOURCE_GROUP;
extern const int MCAST_LEAVE_GROUP;
extern const int MCAST_LEAVE_SOURCE_GROUP;
extern const int MCAST_MSFILTER;
extern const int MCAST_UNBLOCK_SOURCE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/mfd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MFD_H_

#define MFD_CLOEXEC       1
#define MFD_ALLOW_SEALING 2



/*!BEGIN libc/sysv/consts/mlock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MCL_CURRENT;
extern const int MCL_FUTURE;
extern const int MCL_ONFAULT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MCL_CURRENT LITERALLY(1)
#define MCL_FUTURE  LITERALLY(2)
#define MCL_ONFAULT SYMBOLIC(MCL_ONFAULT)



/*!BEGIN libc/sysv/consts/modem.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MODEM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t TIOCMGET;
extern const uint64_t TIOCMSET;
extern const uint64_t TIOCMBIC;
extern const uint64_t TIOCMBIS;

extern const int TIOCM_CAR;
extern const int TIOCM_CD;
extern const int TIOCM_CTS;
extern const int TIOCM_DSR;
extern const int TIOCM_DTR;
extern const int TIOCM_LE;
extern const int TIOCM_RI;
extern const int TIOCM_RNG;
extern const int TIOCM_RTS;
extern const int TIOCM_SR;
extern const int TIOCM_ST;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TIOCMGET SYMBOLIC(TIOCMGET)
#define TIOCMSET SYMBOLIC(TIOCMSET)
#define TIOCMBIC SYMBOLIC(TIOCMBIC)
#define TIOCMBIS SYMBOLIC(TIOCMBIS)

#define TIOCM_LE  LITERALLY(0x01)
#define TIOCM_DTR LITERALLY(0x02)
#define TIOCM_RTS LITERALLY(0x04)
#define TIOCM_ST  LITERALLY(0x08)
#define TIOCM_SR  LITERALLY(0x10)
#define TIOCM_CTS LITERALLY(0x20)
#define TIOCM_CAR LITERALLY(0x40)
#define TIOCM_CD  LITERALLY(0x40)
#define TIOCM_RI  LITERALLY(0x80)
#define TIOCM_RNG LITERALLY(0x80)
#define TIOCM_DSR LITERALLY(0x0100)



/*!BEGIN libc/sysv/consts/mount.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MOUNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned long MS_RDONLY;
extern const int MNT_RDONLY;
extern const unsigned long MS_NOSUID;
extern const int MNT_NOSUID;
extern const unsigned long MS_NODEV;
extern const int MNT_NODEV;
extern const unsigned long MS_NOEXEC;
extern const int MNT_NOEXEC;
extern const unsigned long MS_SYNCHRONOUS;
extern const int MNT_SYNCHRONOUS;
extern const unsigned long MS_REMOUNT;
extern const int MNT_UPDATE;
extern const unsigned long MS_MANDLOCK;
extern const unsigned long MS_DIRSYNC;
extern const unsigned long MS_NOATIME;
extern const int MNT_NOATIME;
extern const unsigned long MS_NODIRATIME;
extern const unsigned long MS_BIND;
extern const unsigned long MS_MOVE;
extern const unsigned long MS_REC;
extern const unsigned long MS_SILENT;
extern const unsigned long MS_POSIXACL;
extern const unsigned long MS_UNBINDABLE;
extern const unsigned long MS_PRIVATE;
extern const unsigned long MS_SLAVE;
extern const unsigned long MS_SHARED;
extern const unsigned long MS_RELATIME;
extern const int MNT_RELATIME;
extern const unsigned long MS_KERNMOUNT;
extern const unsigned long MS_I_VERSION;
extern const unsigned long MS_STRICTATIME;
extern const int MNT_STRICTATIME;
extern const unsigned long MS_LAZYTIME;
extern const unsigned long MS_ACTIVE;
extern const unsigned long MS_NOUSER;
extern const unsigned long MS_RMT_MASK;
extern const unsigned long MS_MGC_VAL;
extern const unsigned long MS_MGC_MSK;
extern const int MNT_ASYNC;
extern const int MNT_RELOAD;
extern const int MNT_SUIDDIR;
extern const int MNT_NOCLUSTERR;
extern const int MNT_NOCLUSTERW;
extern const int MNT_SNAPSHOT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MS_RDONLY       LITERALLY(0x00000001)
#define MNT_RDONLY      LITERALLY(0x00000001)
#define MS_NOSUID       SYMBOLIC(MS_NOSUID)
#define MNT_NOSUID      SYMBOLIC(MNT_NOSUID)
#define MS_NODEV        SYMBOLIC(MS_NODEV)
#define MNT_NODEV       SYMBOLIC(MNT_NODEV)
#define MS_NOEXEC       SYMBOLIC(MS_NOEXEC)
#define MNT_NOEXEC      SYMBOLIC(MNT_NOEXEC)
#define MS_SYNCHRONOUS  SYMBOLIC(MS_SYNCHRONOUS)
#define MNT_SYNCHRONOUS SYMBOLIC(MNT_SYNCHRONOUS)
#define MS_REMOUNT      SYMBOLIC(MS_REMOUNT)
#define MNT_UPDATE      SYMBOLIC(MNT_UPDATE)
#define MS_MANDLOCK     SYMBOLIC(MS_MANDLOCK)
#define MS_DIRSYNC      SYMBOLIC(MS_DIRSYNC)
#define MS_NOATIME      SYMBOLIC(MS_NOATIME)
#define MNT_NOATIME     SYMBOLIC(MNT_NOATIME)
#define MS_NODIRATIME   SYMBOLIC(MS_NODIRATIME)
#define MS_BIND         SYMBOLIC(MS_BIND)
#define MS_MOVE         SYMBOLIC(MS_MOVE)
#define MS_REC          SYMBOLIC(MS_REC)
#define MS_SILENT       SYMBOLIC(MS_SILENT)
#define MS_POSIXACL     SYMBOLIC(MS_POSIXACL)
#define MS_UNBINDABLE   SYMBOLIC(MS_UNBINDABLE)
#define MS_PRIVATE      SYMBOLIC(MS_PRIVATE)
#define MS_SLAVE        SYMBOLIC(MS_SLAVE)
#define MS_SHARED       SYMBOLIC(MS_SHARED)
#define MS_RELATIME     SYMBOLIC(MS_RELATIME)
#define MNT_RELATIME    SYMBOLIC(MNT_RELATIME)
#define MS_KERNMOUNT    SYMBOLIC(MS_KERNMOUNT)
#define MS_I_VERSION    SYMBOLIC(MS_I_VERSION)
#define MS_STRICTATIME  SYMBOLIC(MS_STRICTATIME)
#define MNT_STRICTATIME SYMBOLIC(MNT_STRICTATIME)
#define MS_LAZYTIME     SYMBOLIC(MS_LAZYTIME)
#define MS_ACTIVE       SYMBOLIC(MS_ACTIVE)
#define MS_NOUSER       SYMBOLIC(MS_NOUSER)
#define MS_RMT_MASK     SYMBOLIC(MS_RMT_MASK)
#define MS_MGC_VAL      SYMBOLIC(MS_MGC_VAL)
#define MS_MGC_MSK      SYMBOLIC(MS_MGC_MSK)
#define MNT_ASYNC       SYMBOLIC(MNT_ASYNC)
#define MNT_RELOAD      SYMBOLIC(MNT_RELOAD)
#define MNT_SUIDDIR     SYMBOLIC(MNT_SUIDDIR)
#define MNT_NOCLUSTERR  SYMBOLIC(MNT_NOCLUSTERR)
#define MNT_NOCLUSTERW  SYMBOLIC(MNT_NOCLUSTERW)
#define MNT_SNAPSHOT    SYMBOLIC(MNT_SNAPSHOT)



/*!BEGIN libc/sysv/consts/mremap.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MREMAP_H_

#define MREMAP_MAYMOVE 1
#define MREMAP_FIXED   2



/*!BEGIN libc/sysv/consts/msg.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MSG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MSG_BATCH;
extern const int MSG_BCAST;
extern const int MSG_CMSG_CLOEXEC;
extern const int MSG_CONFIRM;
extern const int MSG_CTRUNC;
extern const int MSG_DONTROUTE;
extern const int MSG_DONTWAIT;
extern const int MSG_EOF;
extern const int MSG_EOR;
extern const int MSG_ERRQUEUE;
extern const int MSG_EXCEPT;
extern const int MSG_FASTOPEN;
extern const int MSG_FIN;
extern const int MSG_INFO;
extern const int MSG_MCAST;
extern const int MSG_MORE;
extern const int MSG_NOERROR;
extern const int MSG_NOSIGNAL;
extern const int MSG_NOTIFICATION;
extern const int MSG_OOB;
extern const int MSG_PARITY_ERROR;
extern const int MSG_PEEK;
extern const int MSG_PROXY;
extern const int MSG_RST;
extern const int MSG_STAT;
extern const int MSG_SYN;
extern const int MSG_TRUNC;
extern const int MSG_WAITALL;
extern const int MSG_WAITFORONE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MSG_BATCH        SYMBOLIC(MSG_BATCH)
#define MSG_BCAST        SYMBOLIC(MSG_BCAST)
#define MSG_CMSG_CLOEXEC SYMBOLIC(MSG_CMSG_CLOEXEC)
#define MSG_CONFIRM      SYMBOLIC(MSG_CONFIRM)
#define MSG_CTRUNC       SYMBOLIC(MSG_CTRUNC)
#define MSG_DONTROUTE    LITERALLY(4)
#define MSG_DONTWAIT     SYMBOLIC(MSG_DONTWAIT)
#define MSG_EOF          SYMBOLIC(MSG_EOF)
#define MSG_EOR          SYMBOLIC(MSG_EOR)
#define MSG_ERRQUEUE     SYMBOLIC(MSG_ERRQUEUE)
#define MSG_EXCEPT       SYMBOLIC(MSG_EXCEPT)
#define MSG_FASTOPEN     SYMBOLIC(MSG_FASTOPEN)
#define MSG_FIN          SYMBOLIC(MSG_FIN)
#define MSG_INFO         SYMBOLIC(MSG_INFO)
#define MSG_MCAST        SYMBOLIC(MSG_MCAST)
#define MSG_MORE         SYMBOLIC(MSG_MORE)
#define MSG_NOERROR      SYMBOLIC(MSG_NOERROR)
#define MSG_NOSIGNAL     SYMBOLIC(MSG_NOSIGNAL)
#define MSG_NOTIFICATION SYMBOLIC(MSG_NOTIFICATION)
#define MSG_OOB          LITERALLY(1)
#define MSG_PARITY_ERROR SYMBOLIC(MSG_PARITY_ERROR)
#define MSG_PEEK         LITERALLY(2)
#define MSG_PROXY        SYMBOLIC(MSG_PROXY)
#define MSG_RST          SYMBOLIC(MSG_RST)
#define MSG_STAT         SYMBOLIC(MSG_STAT)
#define MSG_SYN          SYMBOLIC(MSG_SYN)
#define MSG_TRUNC        SYMBOLIC(MSG_TRUNC)
#define MSG_WAITALL      SYMBOLIC(MSG_WAITALL)
#define MSG_WAITFORONE   SYMBOLIC(MSG_WAITFORONE)



/*!BEGIN libc/sysv/consts/msync.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MSYNC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MS_SYNC;
extern const int MS_ASYNC;
extern const int MS_INVALIDATE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MS_SYNC       SYMBOLIC(MS_SYNC)
#define MS_ASYNC      LITERALLY(1)
#define MS_INVALIDATE SYMBOLIC(MS_INVALIDATE)



/*!BEGIN libc/sysv/consts/nrlinux.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_NRLINUX_H_

#define __NR_linux_exit                    0x003c
#define __NR_linux_exit_group              0x00e7
#define __NR_linux_read                    0x0000
#define __NR_linux_write                   0x0001
#define __NR_linux_open                    0x0002
#define __NR_linux_close                   0x0003
#define __NR_linux_stat                    0x0004
#define __NR_linux_fstat                   0x0005
#define __NR_linux_lstat                   0x0006
#define __NR_linux_poll                    0x0007
#define __NR_linux_ppoll                   0x010f
#define __NR_linux_brk                     0x000c
#define __NR_linux_sigreturn               0x000f
#define __NR_linux_lseek                   0x0008
#define __NR_linux_mmap                    0x0009
#define __NR_linux_msync                   0x001a
#define __NR_linux_mprotect                0x000a
#define __NR_linux_munmap                  0x000b
#define __NR_linux_sigaction               0x000d
#define __NR_linux_sigprocmask             0x000e
#define __NR_linux_ioctl                   0x0010
#define __NR_linux_pread                   0x0011
#define __NR_linux_pwrite                  0x0012
#define __NR_linux_readv                   0x0013
#define __NR_linux_writev                  0x0014
#define __NR_linux_access                  0x0015
#define __NR_linux_pipe                    0x0016
#define __NR_linux_select                  0x0017
#define __NR_linux_pselect6                0x010e
#define __NR_linux_sched_yield             0x0018
#define __NR_linux_mremap                  0x0019
#define __NR_linux_mincore                 0x001b
#define __NR_linux_madvise                 0x001c
#define __NR_linux_shmget                  0x001d
#define __NR_linux_shmat                   0x001e
#define __NR_linux_shmctl                  0x001f
#define __NR_linux_dup                     0x0020
#define __NR_linux_dup2                    0x0021
#define __NR_linux_pause                   0x0022
#define __NR_linux_nanosleep               0x0023
#define __NR_linux_getitimer               0x0024
#define __NR_linux_setitimer               0x0026
#define __NR_linux_alarm                   0x0025
#define __NR_linux_getpid                  0x0027
#define __NR_linux_sendfile                0x0028
#define __NR_linux_socket                  0x0029
#define __NR_linux_connect                 0x002a
#define __NR_linux_accept                  0x002b
#define __NR_linux_sendto                  0x002c
#define __NR_linux_recvfrom                0x002d
#define __NR_linux_sendmsg                 0x002e
#define __NR_linux_recvmsg                 0x002f
#define __NR_linux_shutdown                0x0030
#define __NR_linux_bind                    0x0031
#define __NR_linux_listen                  0x0032
#define __NR_linux_getsockname             0x0033
#define __NR_linux_getpeername             0x0034
#define __NR_linux_socketpair              0x0035
#define __NR_linux_setsockopt              0x0036
#define __NR_linux_getsockopt              0x0037
#define __NR_linux_fork                    0x0039
#define __NR_linux_vfork                   0x003a
#define __NR_linux_execve                  0x003b
#define __NR_linux_wait4                   0x003d
#define __NR_linux_kill                    0x003e
#define __NR_linux_clone                   0x0038
#define __NR_linux_tkill                   0x00c8
#define __NR_linux_futex                   0x00ca
#define __NR_linux_set_robust_list         0x0111
#define __NR_linux_get_robust_list         0x0112
#define __NR_linux_uname                   0x003f
#define __NR_linux_semget                  0x0040
#define __NR_linux_semop                   0x0041
#define __NR_linux_semctl                  0x0042
#define __NR_linux_shmdt                   0x0043
#define __NR_linux_msgget                  0x0044
#define __NR_linux_msgsnd                  0x0045
#define __NR_linux_msgrcv                  0x0046
#define __NR_linux_msgctl                  0x0047
#define __NR_linux_fcntl                   0x0048
#define __NR_linux_flock                   0x0049
#define __NR_linux_fsync                   0x004a
#define __NR_linux_fdatasync               0x004b
#define __NR_linux_truncate                0x004c
#define __NR_linux_ftruncate               0x004d
#define __NR_linux_getcwd                  0x004f
#define __NR_linux_chdir                   0x0050
#define __NR_linux_fchdir                  0x0051
#define __NR_linux_rename                  0x0052
#define __NR_linux_mkdir                   0x0053
#define __NR_linux_rmdir                   0x0054
#define __NR_linux_creat                   0x0055
#define __NR_linux_link                    0x0056
#define __NR_linux_unlink                  0x0057
#define __NR_linux_symlink                 0x0058
#define __NR_linux_readlink                0x0059
#define __NR_linux_chmod                   0x005a
#define __NR_linux_fchmod                  0x005b
#define __NR_linux_chown                   0x005c
#define __NR_linux_fchown                  0x005d
#define __NR_linux_lchown                  0x005e
#define __NR_linux_umask                   0x005f
#define __NR_linux_gettimeofday            0x0060
#define __NR_linux_getrlimit               0x0061
#define __NR_linux_getrusage               0x0062
#define __NR_linux_sysinfo                 0x0063
#define __NR_linux_times                   0x0064
#define __NR_linux_ptrace                  0x0065
#define __NR_linux_syslog                  0x0067
#define __NR_linux_getuid                  0x0066
#define __NR_linux_getgid                  0x0068
#define __NR_linux_getppid                 0x006e
#define __NR_linux_getpgrp                 0x006f
#define __NR_linux_setsid                  0x0070
#define __NR_linux_getsid                  0x007c
#define __NR_linux_getpgid                 0x0079
#define __NR_linux_setpgid                 0x006d
#define __NR_linux_geteuid                 0x006b
#define __NR_linux_getegid                 0x006c
#define __NR_linux_getgroups               0x0073
#define __NR_linux_setgroups               0x0074
#define __NR_linux_setreuid                0x0071
#define __NR_linux_setregid                0x0072
#define __NR_linux_setuid                  0x0069
#define __NR_linux_setgid                  0x006a
#define __NR_linux_setresuid               0x0075
#define __NR_linux_setresgid               0x0077
#define __NR_linux_getresuid               0x0076
#define __NR_linux_getresgid               0x0078
#define __NR_linux_sigpending              0x007f
#define __NR_linux_sigsuspend              0x0082
#define __NR_linux_sigaltstack             0x0083
#define __NR_linux_mknod                   0x0085
#define __NR_linux_mknodat                 0x0103
#define __NR_linux_statfs                  0x0089
#define __NR_linux_fstatfs                 0x008a
#define __NR_linux_getpriority             0x008c
#define __NR_linux_setpriority             0x008d
#define __NR_linux_mlock                   0x0095
#define __NR_linux_munlock                 0x0096
#define __NR_linux_mlockall                0x0097
#define __NR_linux_munlockall              0x0098
#define __NR_linux_setrlimit               0x00a0
#define __NR_linux_chroot                  0x00a1
#define __NR_linux_sync                    0x00a2
#define __NR_linux_acct                    0x00a3
#define __NR_linux_settimeofday            0x00a4
#define __NR_linux_mount                   0x00a5
#define __NR_linux_reboot                  0x00a9
#define __NR_linux_quotactl                0x00b3
#define __NR_linux_setfsuid                0x007a
#define __NR_linux_setfsgid                0x007b
#define __NR_linux_capget                  0x007d
#define __NR_linux_capset                  0x007e
#define __NR_linux_sigtimedwait            0x0080
#define __NR_linux_rt_sigqueueinfo         0x0081
#define __NR_linux_personality             0x0087
#define __NR_linux_ustat                   0x0088
#define __NR_linux_sysfs                   0x008b
#define __NR_linux_sched_setparam          0x008e
#define __NR_linux_sched_getparam          0x008f
#define __NR_linux_sched_setscheduler      0x0090
#define __NR_linux_sched_getscheduler      0x0091
#define __NR_linux_sched_get_priority_max  0x0092
#define __NR_linux_sched_get_priority_min  0x0093
#define __NR_linux_sched_rr_get_interval   0x0094
#define __NR_linux_vhangup                 0x0099
#define __NR_linux_modify_ldt              0x009a
#define __NR_linux_pivot_root              0x009b
#define __NR_linux__sysctl                 0x009c
#define __NR_linux_prctl                   0x009d
#define __NR_linux_arch_prctl              0x009e
#define __NR_linux_adjtimex                0x009f
#define __NR_linux_umount2                 0x00a6
#define __NR_linux_swapon                  0x00a7
#define __NR_linux_swapoff                 0x00a8
#define __NR_linux_sethostname             0x00aa
#define __NR_linux_setdomainname           0x00ab
#define __NR_linux_iopl                    0x00ac
#define __NR_linux_ioperm                  0x00ad
#define __NR_linux_init_module             0x00af
#define __NR_linux_delete_module           0x00b0
#define __NR_linux_gettid                  0x00ba
#define __NR_linux_readahead               0x00bb
#define __NR_linux_setxattr                0x00bc
#define __NR_linux_fsetxattr               0x00be
#define __NR_linux_getxattr                0x00bf
#define __NR_linux_fgetxattr               0x00c1
#define __NR_linux_listxattr               0x00c2
#define __NR_linux_flistxattr              0x00c4
#define __NR_linux_removexattr             0x00c5
#define __NR_linux_fremovexattr            0x00c7
#define __NR_linux_lsetxattr               0x00bd
#define __NR_linux_lgetxattr               0x00c0
#define __NR_linux_llistxattr              0x00c3
#define __NR_linux_lremovexattr            0x00c6
#define __NR_linux_sched_setaffinity       0x00cb
#define __NR_linux_sched_getaffinity       0x00cc
#define __NR_linux_io_setup                0x00ce
#define __NR_linux_io_destroy              0x00cf
#define __NR_linux_io_getevents            0x00d0
#define __NR_linux_io_submit               0x00d1
#define __NR_linux_io_cancel               0x00d2
#define __NR_linux_lookup_dcookie          0x00d4
#define __NR_linux_epoll_create            0x00d5
#define __NR_linux_epoll_wait              0x00e8
#define __NR_linux_epoll_ctl               0x00e9
#define __NR_linux_getdents                0x00d9
#define __NR_linux_set_tid_address         0x00da
#define __NR_linux_restart_syscall         0x00db
#define __NR_linux_semtimedop              0x00dc
#define __NR_linux_fadvise                 0x00dd
#define __NR_linux_timer_create            0x00de
#define __NR_linux_timer_settime           0x00df
#define __NR_linux_timer_gettime           0x00e0
#define __NR_linux_timer_getoverrun        0x00e1
#define __NR_linux_timer_delete            0x00e2
#define __NR_linux_clock_settime           0x00e3
#define __NR_linux_clock_gettime           0x00e4
#define __NR_linux_clock_getres            0x00e5
#define __NR_linux_clock_nanosleep         0x00e6
#define __NR_linux_tgkill                  0x00ea
#define __NR_linux_mbind                   0x00ed
#define __NR_linux_set_mempolicy           0x00ee
#define __NR_linux_get_mempolicy           0x00ef
#define __NR_linux_mq_open                 0x00f0
#define __NR_linux_mq_unlink               0x00f1
#define __NR_linux_mq_timedsend            0x00f2
#define __NR_linux_mq_timedreceive         0x00f3
#define __NR_linux_mq_notify               0x00f4
#define __NR_linux_mq_getsetattr           0x00f5
#define __NR_linux_kexec_load              0x00f6
#define __NR_linux_waitid                  0x00f7
#define __NR_linux_add_key                 0x00f8
#define __NR_linux_request_key             0x00f9
#define __NR_linux_keyctl                  0x00fa
#define __NR_linux_ioprio_set              0x00fb
#define __NR_linux_ioprio_get              0x00fc
#define __NR_linux_inotify_init            0x00fd
#define __NR_linux_inotify_add_watch       0x00fe
#define __NR_linux_inotify_rm_watch        0x00ff
#define __NR_linux_openat                  0x0101
#define __NR_linux_mkdirat                 0x0102
#define __NR_linux_fchownat                0x0104
#define __NR_linux_utime                   0x0084
#define __NR_linux_utimes                  0x00eb
#define __NR_linux_futimesat               0x0105
#define __NR_linux_fstatat                 0x0106
#define __NR_linux_unlinkat                0x0107
#define __NR_linux_renameat                0x0108
#define __NR_linux_linkat                  0x0109
#define __NR_linux_symlinkat               0x010a
#define __NR_linux_readlinkat              0x010b
#define __NR_linux_fchmodat                0x010c
#define __NR_linux_faccessat               0x010d
#define __NR_linux_unshare                 0x0110
#define __NR_linux_splice                  0x0113
#define __NR_linux_tee                     0x0114
#define __NR_linux_sync_file_range         0x0115
#define __NR_linux_vmsplice                0x0116
#define __NR_linux_migrate_pages           0x0100
#define __NR_linux_move_pages              0x0117
#define __NR_linux_preadv                  0x0127
#define __NR_linux_pwritev                 0x0128
#define __NR_linux_utimensat               0x0118
#define __NR_linux_fallocate               0x011d
#define __NR_linux_accept4                 0x0120
#define __NR_linux_dup3                    0x0124
#define __NR_linux_pipe2                   0x0125
#define __NR_linux_epoll_pwait             0x0119
#define __NR_linux_epoll_create1           0x0123
#define __NR_linux_perf_event_open         0x012a
#define __NR_linux_inotify_init1           0x0126
#define __NR_linux_rt_tgsigqueueinfo       0x0129
#define __NR_linux_signalfd                0x011a
#define __NR_linux_signalfd4               0x0121
#define __NR_linux_eventfd                 0x011c
#define __NR_linux_eventfd2                0x0122
#define __NR_linux_timerfd_create          0x011b
#define __NR_linux_timerfd_settime         0x011e
#define __NR_linux_timerfd_gettime         0x011f
#define __NR_linux_recvmmsg                0x012b
#define __NR_linux_fanotify_init           0x012c
#define __NR_linux_fanotify_mark           0x012d
#define __NR_linux_prlimit                 0x012e
#define __NR_linux_name_to_handle_at       0x012f
#define __NR_linux_open_by_handle_at       0x0130
#define __NR_linux_clock_adjtime           0x0131
#define __NR_linux_syncfs                  0x0132
#define __NR_linux_sendmmsg                0x0133
#define __NR_linux_setns                   0x0134
#define __NR_linux_getcpu                  0x0135
#define __NR_linux_process_vm_readv        0x0136
#define __NR_linux_process_vm_writev       0x0137
#define __NR_linux_kcmp                    0x0138
#define __NR_linux_finit_module            0x0139
#define __NR_linux_sched_setattr           0x013a
#define __NR_linux_sched_getattr           0x013b
#define __NR_linux_renameat2               0x013c
#define __NR_linux_seccomp                 0x013d
#define __NR_linux_getrandom               0x013e
#define __NR_linux_memfd_create            0x013f
#define __NR_linux_kexec_file_load         0x0140
#define __NR_linux_bpf                     0x0141
#define __NR_linux_execveat                0x0142
#define __NR_linux_userfaultfd             0x0143
#define __NR_linux_membarrier              0x0144
#define __NR_linux_mlock2                  0x0145
#define __NR_linux_copy_file_range         0x0146
#define __NR_linux_preadv2                 0x0147
#define __NR_linux_pwritev2                0x0148
#define __NR_linux_pkey_mprotect           0x0149
#define __NR_linux_pkey_alloc              0x014a
#define __NR_linux_pkey_free               0x014b
#define __NR_linux_statx                   0x014c
#define __NR_linux_io_pgetevents           0x014d
#define __NR_linux_rseq                    0x014e
#define __NR_linux_pidfd_send_signal       0x01a8
#define __NR_linux_io_uring_setup          0x01a9
#define __NR_linux_io_uring_enter          0x01aa
#define __NR_linux_io_uring_register       0x01ab
#define __NR_linux_open_tree               0x01ac
#define __NR_linux_move_mount              0x01ad
#define __NR_linux_fsopen                  0x01ae
#define __NR_linux_fsconfig                0x01af
#define __NR_linux_fsmount                 0x01b0
#define __NR_linux_fspick                  0x01b1
#define __NR_linux_pidfd_open              0x01b2
#define __NR_linux_clone3                  0x01b3
#define __NR_linux_close_range             0x01b4
#define __NR_linux_openat2                 0x01b5
#define __NR_linux_pidfd_getfd             0x01b6
#define __NR_linux_faccessat2              0x01b7
#define __NR_linux_process_madvise         0x01b8
#define __NR_linux_epoll_pwait2            0x01b9
#define __NR_linux_mount_setattr           0x01ba
#define __NR_linux_quotactl_fd             0x01bb
#define __NR_linux_landlock_create_ruleset 0x01bc
#define __NR_linux_landlock_add_rule       0x01bd
#define __NR_linux_landlock_restrict_self  0x01be
#define __NR_linux_memfd_secret            0x01bf
#define __NR_linux_process_mrelease        0x01c0
#define __NR_linux_futex_waitv             0x01c1
#define __NR_linux_set_mempolicy_home_node 0x01c2



/*!BEGIN libc/sysv/consts/ok.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_OK_H_

#define F_OK SYMBOLIC(F_OK)
#define R_OK SYMBOLIC(R_OK)
#define W_OK SYMBOLIC(W_OK)
#define X_OK SYMBOLIC(X_OK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int F_OK;
extern const int R_OK;
extern const int W_OK;
extern const int X_OK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/personality.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PERSONALITY_H_

#define ADDR_COMPAT_LAYOUT 0x0200000
#define READ_IMPLIES_EXEC  0x0400000
#define ADDR_LIMIT_3GB     0x8000000
#define FDPIC_FUNCPTRS     0x0080000
#define STICKY_TIMEOUTS    0x4000000
#define MMAP_PAGE_ZERO     0x0100000
#define ADDR_LIMIT_32BIT   0x0800000
#define WHOLE_SECONDS      0x2000000
#define ADDR_NO_RANDOMIZE  0x0040000
#define SHORT_INODE        0x1000000
#define UNAME26            0x0020000



/*!BEGIN libc/sysv/consts/pf.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PF_H_

#define PF_ALG SYMBOLIC(PF_ALG)
#define PF_APPLETALK SYMBOLIC(PF_APPLETALK)
#define PF_ASH SYMBOLIC(PF_ASH)
#define PF_ATMPVC SYMBOLIC(PF_ATMPVC)
#define PF_ATMSVC SYMBOLIC(PF_ATMSVC)
#define PF_AX25 SYMBOLIC(PF_AX25)
#define PF_BLUETOOTH SYMBOLIC(PF_BLUETOOTH)
#define PF_BRIDGE SYMBOLIC(PF_BRIDGE)
#define PF_CAIF SYMBOLIC(PF_CAIF)
#define PF_CAN SYMBOLIC(PF_CAN)
#define PF_ECONET SYMBOLIC(PF_ECONET)
#define PF_FILE SYMBOLIC(PF_FILE)
#define PF_IB SYMBOLIC(PF_IB)
#define PF_IEEE802154 SYMBOLIC(PF_IEEE802154)
#define PF_INET SYMBOLIC(PF_INET)
#define PF_INET6 SYMBOLIC(PF_INET6)
#define PF_IPX SYMBOLIC(PF_IPX)
#define PF_IRDA SYMBOLIC(PF_IRDA)
#define PF_ISDN SYMBOLIC(PF_ISDN)
#define PF_IUCV SYMBOLIC(PF_IUCV)
#define PF_KCM SYMBOLIC(PF_KCM)
#define PF_KEY SYMBOLIC(PF_KEY)
#define PF_LLC SYMBOLIC(PF_LLC)
#define PF_LOCAL SYMBOLIC(PF_LOCAL)
#define PF_MAX SYMBOLIC(PF_MAX)
#define PF_MPLS SYMBOLIC(PF_MPLS)
#define PF_NETBEUI SYMBOLIC(PF_NETBEUI)
#define PF_NETLINK SYMBOLIC(PF_NETLINK)
#define PF_NETROM SYMBOLIC(PF_NETROM)
#define PF_NFC SYMBOLIC(PF_NFC)
#define PF_PACKET SYMBOLIC(PF_PACKET)
#define PF_PHONET SYMBOLIC(PF_PHONET)
#define PF_PPPOX SYMBOLIC(PF_PPPOX)
#define PF_RDS SYMBOLIC(PF_RDS)
#define PF_ROSE SYMBOLIC(PF_ROSE)
#define PF_ROUTE SYMBOLIC(PF_ROUTE)
#define PF_RXRPC SYMBOLIC(PF_RXRPC)
#define PF_SECURITY SYMBOLIC(PF_SECURITY)
#define PF_SNA SYMBOLIC(PF_SNA)
#define PF_TIPC SYMBOLIC(PF_TIPC)
#define PF_UNIX SYMBOLIC(PF_UNIX)
#define PF_UNSPEC SYMBOLIC(PF_UNSPEC)
#define PF_VSOCK SYMBOLIC(PF_VSOCK)
#define PF_WANPIPE SYMBOLIC(PF_WANPIPE)
#define PF_X25 SYMBOLIC(PF_X25)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int PF_ALG;
extern const int PF_APPLETALK;
extern const int PF_ASH;
extern const int PF_ATMPVC;
extern const int PF_ATMSVC;
extern const int PF_AX25;
extern const int PF_BLUETOOTH;
extern const int PF_BRIDGE;
extern const int PF_CAIF;
extern const int PF_CAN;
extern const int PF_ECONET;
extern const int PF_FILE;
extern const int PF_IB;
extern const int PF_IEEE802154;
extern const int PF_INET6;
extern const int PF_INET;
extern const int PF_IPX;
extern const int PF_IRDA;
extern const int PF_ISDN;
extern const int PF_IUCV;
extern const int PF_KCM;
extern const int PF_KEY;
extern const int PF_LLC;
extern const int PF_LOCAL;
extern const int PF_MAX;
extern const int PF_MPLS;
extern const int PF_NETBEUI;
extern const int PF_NETLINK;
extern const int PF_NETROM;
extern const int PF_NFC;
extern const int PF_PACKET;
extern const int PF_PHONET;
extern const int PF_PPPOX;
extern const int PF_RDS;
extern const int PF_ROSE;
extern const int PF_ROUTE;
extern const int PF_RXRPC;
extern const int PF_SECURITY;
extern const int PF_SNA;
extern const int PF_TIPC;
extern const int PF_UNIX;
extern const int PF_UNSPEC;
extern const int PF_VSOCK;
extern const int PF_WANPIPE;
extern const int PF_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/poll.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_POLL_H_

#define POLLERR    SYMBOLIC(POLLERR)
#define POLLHUP    SYMBOLIC(POLLHUP)
#define POLLIN     SYMBOLIC(POLLIN)
#define POLLNVAL   SYMBOLIC(POLLNVAL)
#define POLLOUT    SYMBOLIC(POLLOUT)
#define POLLPRI    SYMBOLIC(POLLPRI)
#define POLLRDBAND SYMBOLIC(POLLRDBAND)
#define POLLRDHUP  SYMBOLIC(POLLRDHUP)
#define POLLRDNORM SYMBOLIC(POLLRDNORM)
#define POLLWRBAND SYMBOLIC(POLLWRBAND)
#define POLLWRNORM SYMBOLIC(POLLWRNORM)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int16_t POLLERR;
extern const int16_t POLLHUP;
extern const int16_t POLLIN;
extern const int16_t POLLNVAL;
extern const int16_t POLLOUT;
extern const int16_t POLLPRI;
extern const int16_t POLLRDBAND;
extern const int16_t POLLRDHUP;
extern const int16_t POLLRDNORM;
extern const int16_t POLLWRBAND;
extern const int16_t POLLWRNORM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/posix.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_POSIX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int POSIX_FADV_DONTNEED;
extern const int POSIX_FADV_NOREUSE;
extern const int POSIX_FADV_NORMAL;
extern const int POSIX_FADV_RANDOM;
extern const int POSIX_FADV_SEQUENTIAL;
extern const int POSIX_FADV_WILLNEED;
extern const int POSIX_MADV_DONTNEED;
extern const int POSIX_MADV_NORMAL;
extern const int POSIX_MADV_RANDOM;
extern const int POSIX_MADV_SEQUENTIAL;
extern const int POSIX_MADV_WILLNEED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define POSIX_FADV_DONTNEED   SYMBOLIC(POSIX_FADV_DONTNEED)
#define POSIX_FADV_NOREUSE    SYMBOLIC(POSIX_FADV_NOREUSE)
#define POSIX_FADV_NORMAL     SYMBOLIC(POSIX_FADV_NORMAL)
#define POSIX_FADV_RANDOM     SYMBOLIC(POSIX_FADV_RANDOM)
#define POSIX_FADV_SEQUENTIAL SYMBOLIC(POSIX_FADV_SEQUENTIAL)
#define POSIX_FADV_WILLNEED   SYMBOLIC(POSIX_FADV_WILLNEED)
#define POSIX_MADV_DONTNEED   SYMBOLIC(POSIX_MADV_DONTNEED)
#define POSIX_MADV_NORMAL     SYMBOLIC(POSIX_MADV_NORMAL)
#define POSIX_MADV_RANDOM     SYMBOLIC(POSIX_MADV_RANDOM)
#define POSIX_MADV_SEQUENTIAL SYMBOLIC(POSIX_MADV_SEQUENTIAL)
#define POSIX_MADV_WILLNEED   SYMBOLIC(POSIX_MADV_WILLNEED)



/*!BEGIN libc/sysv/consts/pr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PR_H_

#define PR_GET_SECCOMP        21
#define PR_SET_SECCOMP        22
#define SECCOMP_MODE_DISABLED 0
#define SECCOMP_MODE_STRICT   1
#define SECCOMP_MODE_FILTER   2

#define PR_CAPBSET_READ 23
#define PR_CAPBSET_DROP 24

#define PR_SET_NO_NEW_PRIVS 38
#define PR_GET_NO_NEW_PRIVS 39

#define PR_SET_NAME 15
#define PR_GET_NAME 16

#define PR_GET_TSC     25
#define PR_SET_TSC     26
#define PR_TSC_ENABLE  1
#define PR_TSC_SIGSEGV 2

#define PR_GET_FPEXC        11
#define PR_SET_FPEXC        12
#define PR_FP_EXC_SW_ENABLE 0x80
#define PR_FP_EXC_DIV       0x010000
#define PR_FP_EXC_OVF       0x020000
#define PR_FP_EXC_UND       0x040000
#define PR_FP_EXC_RES       0x080000
#define PR_FP_EXC_INV       0x100000
#define PR_FP_EXC_DISABLED  0
#define PR_FP_EXC_NONRECOV  1
#define PR_FP_EXC_ASYNC     2
#define PR_FP_EXC_PRECISE   3

#define PR_MCE_KILL_CLEAR           0
#define PR_MCE_KILL_LATE            0
#define PR_SPEC_NOT_AFFECTED        0
#define PR_SPEC_STORE_BYPASS        0
#define PR_CAP_AMBIENT_IS_SET       1
#define PR_FPEMU_NOPRINT            1
#define PR_MCE_KILL_EARLY           1
#define PR_MCE_KILL_SET             1
#define PR_SET_MM_START_CODE        1
#define PR_SET_PDEATHSIG            1
#define PR_SPEC_PRCTL               1
#define PR_CAP_AMBIENT_RAISE        2
#define PR_FPEMU_SIGFPE             2
#define PR_GET_PDEATHSIG            2
#define PR_MCE_KILL_DEFAULT         2
#define PR_SET_MM_END_CODE          2
#define PR_SPEC_ENABLE              2
#define PR_CAP_AMBIENT_LOWER        3
#define PR_GET_DUMPABLE             3
#define PR_SET_MM_START_DATA        3
#define PR_CAP_AMBIENT_CLEAR_ALL    4
#define PR_SET_DUMPABLE             4
#define PR_SET_MM_END_DATA          4
#define PR_SPEC_DISABLE             4
#define PR_SET_MM_START_STACK       5
#define PR_SET_MM_START_BRK         6
#define PR_GET_KEEPCAPS             7
#define PR_SET_MM_BRK               7
#define PR_SET_KEEPCAPS             8
#define PR_SET_MM_ARG_START         8
#define PR_SPEC_FORCE_DISABLE       8
#define PR_GET_FPEMU                9
#define PR_SET_MM_ARG_END           9
#define PR_SET_FPEMU                10
#define PR_SET_MM_ENV_START         10
#define PR_GET_FPEXC                11
#define PR_SET_MM_ENV_END           11
#define PR_SET_FPEXC                12
#define PR_SET_MM_AUXV              12
#define PR_SET_MM_EXE_FILE          13
#define PR_SET_MM_MAP               14
#define PR_SET_MM_MAP_SIZE          15
#define PR_GET_TSC                  25
#define PR_SET_TSC                  26
#define PR_GET_SECUREBITS           27
#define PR_SET_SECUREBITS           28
#define PR_SET_TIMERSLACK           29
#define PR_GET_TIMERSLACK           30
#define PR_TASK_PERF_EVENTS_DISABLE 31
#define PR_TASK_PERF_EVENTS_ENABLE  0x20
#define PR_MCE_KILL                 33
#define PR_MCE_KILL_GET             34
#define PR_SET_MM                   35
#define PR_SET_CHILD_SUBREAPER      36
#define PR_GET_CHILD_SUBREAPER      37
#define PR_GET_TID_ADDRESS          40
#define PR_SET_THP_DISABLE          41
#define PR_GET_THP_DISABLE          42
#define PR_MPX_ENABLE_MANAGEMENT    43
#define PR_MPX_DISABLE_MANAGEMENT   44
#define PR_CAP_AMBIENT              47
#define PR_GET_SPECULATION_CTRL     52
#define PR_SET_SPECULATION_CTRL     53
#define PR_SET_PTRACER              0x59616d61
#define PR_SET_PTRACER_ANY          -1



/*!BEGIN libc/sysv/consts/prio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PRIO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int PRIO_MAX;
extern const int PRIO_MIN;
extern const int PRIO_PGRP;
extern const int PRIO_PROCESS;
extern const int PRIO_USER;
extern const int NZERO;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PRIO_PROCESS LITERALLY(0)
#define PRIO_PGRP    LITERALLY(1)
#define PRIO_USER    LITERALLY(2)
#define PRIO_MIN     LITERALLY(-20)
#define PRIO_MAX     LITERALLY(20)
#define NZERO        LITERALLY(20)



/*!BEGIN libc/sysv/consts/prot.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PROT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int PROT_NONE;
extern const int PROT_READ;
extern const int PROT_WRITE;
extern const int PROT_EXEC;
extern const int PROT_GROWSDOWN;
extern const int PROT_GROWSUP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PROT_NONE 0
#define PROT_READ 1
#define PROT_WRITE 2
#define PROT_EXEC 4
#define PROT_GROWSDOWN SYMBOLIC(PROT_GROWSDOWN)
#define PROT_GROWSUP SYMBOLIC(PROT_GROWSUP)



/*!BEGIN libc/sysv/consts/pt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PT_H_


/*!BEGIN libc/sysv/consts/ptrace.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PTRACE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int PTRACE_TRACEME;
extern const int PTRACE_PEEKTEXT;
extern const int PTRACE_PEEKDATA;
extern const int PTRACE_PEEKUSER;
extern const int PTRACE_POKETEXT;
extern const int PTRACE_POKEDATA;
extern const int PTRACE_POKEUSER;
extern const int PTRACE_CONT;
extern const int PTRACE_KILL;
extern const int PTRACE_SINGLESTEP;
extern const int PTRACE_GETREGS;
extern const int PTRACE_SETREGS;
extern const int PTRACE_GETFPREGS;
extern const int PTRACE_SETFPREGS;
extern const int PTRACE_ATTACH;
extern const int PTRACE_DETACH;
extern const int PTRACE_GETFPXREGS;
extern const int PTRACE_SETFPXREGS;
extern const int PTRACE_SYSCALL;
extern const int PTRACE_GETEVENTMSG;
extern const int PTRACE_GETSIGINFO;
extern const int PTRACE_SETOPTIONS;
extern const int PTRACE_SETSIGINFO;
extern const int PTRACE_GETREGSET;
extern const int PTRACE_GETSIGMASK;
extern const int PTRACE_INTERRUPT;
extern const int PTRACE_LISTEN;
extern const int PTRACE_PEEKSIGINFO;
extern const int PTRACE_SECCOMP_GET_FILTER;
extern const int PTRACE_SEIZE;
extern const int PTRACE_SETREGSET;
extern const int PTRACE_SETSIGMASK;
extern const int PTRACE_O_TRACESYSGOOD;
extern const int PTRACE_O_TRACEFORK;
extern const int PTRACE_O_TRACEVFORK;
extern const int PTRACE_O_TRACECLONE;
extern const int PTRACE_O_TRACEEXEC;
extern const int PTRACE_O_TRACEVFORKDONE;
extern const int PTRACE_O_TRACEEXIT;
extern const int PTRACE_O_TRACESECCOMP;
extern const int PTRACE_O_MASK;
extern const int PTRACE_EVENT_FORK;
extern const int PTRACE_EVENT_VFORK;
extern const int PTRACE_EVENT_CLONE;
extern const int PTRACE_EVENT_EXEC;
extern const int PTRACE_EVENT_VFORK_DONE;
extern const int PTRACE_EVENT_EXIT;
extern const int PTRACE_EVENT_STOP;
extern const int PTRACE_EVENT_SECCOMP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PTRACE_TRACEME            SYMBOLIC(PTRACE_TRACEME)
#define PTRACE_PEEKTEXT           SYMBOLIC(PTRACE_PEEKTEXT)
#define PTRACE_PEEKDATA           SYMBOLIC(PTRACE_PEEKDATA)
#define PTRACE_PEEKUSER           SYMBOLIC(PTRACE_PEEKUSER)
#define PTRACE_POKETEXT           SYMBOLIC(PTRACE_POKETEXT)
#define PTRACE_POKEDATA           SYMBOLIC(PTRACE_POKEDATA)
#define PTRACE_POKEUSER           SYMBOLIC(PTRACE_POKEUSER)
#define PTRACE_CONT               SYMBOLIC(PTRACE_CONT)
#define PTRACE_KILL               SYMBOLIC(PTRACE_KILL)
#define PTRACE_SINGLESTEP         SYMBOLIC(PTRACE_SINGLESTEP)
#define PTRACE_GETREGS            SYMBOLIC(PTRACE_GETREGS)
#define PTRACE_SETREGS            SYMBOLIC(PTRACE_SETREGS)
#define PTRACE_GETFPREGS          SYMBOLIC(PTRACE_GETFPREGS)
#define PTRACE_SETFPREGS          SYMBOLIC(PTRACE_SETFPREGS)
#define PTRACE_ATTACH             SYMBOLIC(PTRACE_ATTACH)
#define PTRACE_DETACH             SYMBOLIC(PTRACE_DETACH)
#define PTRACE_GETFPXREGS         SYMBOLIC(PTRACE_GETFPXREGS)
#define PTRACE_SETFPXREGS         SYMBOLIC(PTRACE_SETFPXREGS)
#define PTRACE_SYSCALL            SYMBOLIC(PTRACE_SYSCALL)
#define PTRACE_GETEVENTMSG        SYMBOLIC(PTRACE_GETEVENTMSG)
#define PTRACE_GETSIGINFO         SYMBOLIC(PTRACE_GETSIGINFO)
#define PTRACE_SETOPTIONS         SYMBOLIC(PTRACE_SETOPTIONS)
#define PTRACE_SETSIGINFO         SYMBOLIC(PTRACE_SETSIGINFO)
#define PTRACE_GETREGSET          SYMBOLIC(PTRACE_GETREGSET)
#define PTRACE_GETSIGMASK         SYMBOLIC(PTRACE_GETSIGMASK)
#define PTRACE_INTERRUPT          SYMBOLIC(PTRACE_INTERRUPT)
#define PTRACE_LISTEN             SYMBOLIC(PTRACE_LISTEN)
#define PTRACE_PEEKSIGINFO        SYMBOLIC(PTRACE_PEEKSIGINFO)
#define PTRACE_SECCOMP_GET_FILTER SYMBOLIC(PTRACE_SECCOMP_GET_FILTER)
#define PTRACE_SEIZE              SYMBOLIC(PTRACE_SEIZE)
#define PTRACE_SETREGSET          SYMBOLIC(PTRACE_SETREGSET)
#define PTRACE_SETSIGMASK         SYMBOLIC(PTRACE_SETSIGMASK)
#define PTRACE_O_TRACESYSGOOD     SYMBOLIC(PTRACE_O_TRACESYSGOOD)
#define PTRACE_O_TRACEFORK        SYMBOLIC(PTRACE_O_TRACEFORK)
#define PTRACE_O_TRACEVFORK       SYMBOLIC(PTRACE_O_TRACEVFORK)
#define PTRACE_O_TRACECLONE       SYMBOLIC(PTRACE_O_TRACECLONE)
#define PTRACE_O_TRACEEXEC        SYMBOLIC(PTRACE_O_TRACEEXEC)
#define PTRACE_O_TRACEVFORKDONE   SYMBOLIC(PTRACE_O_TRACEVFORKDONE)
#define PTRACE_O_TRACEEXIT        SYMBOLIC(PTRACE_O_TRACEEXIT)
#define PTRACE_O_TRACESECCOMP     SYMBOLIC(PTRACE_O_TRACESECCOMP)
#define PTRACE_O_MASK             SYMBOLIC(PTRACE_O_MASK)
#define PTRACE_EVENT_FORK         SYMBOLIC(PTRACE_EVENT_FORK)
#define PTRACE_EVENT_VFORK        SYMBOLIC(PTRACE_EVENT_VFORK)
#define PTRACE_EVENT_CLONE        SYMBOLIC(PTRACE_EVENT_CLONE)
#define PTRACE_EVENT_EXEC         SYMBOLIC(PTRACE_EVENT_EXEC)
#define PTRACE_EVENT_VFORK_DONE   SYMBOLIC(PTRACE_EVENT_VFORK_DONE)
#define PTRACE_EVENT_EXIT         SYMBOLIC(PTRACE_EVENT_EXIT)
#define PTRACE_EVENT_STOP         SYMBOLIC(PTRACE_EVENT_STOP)
#define PTRACE_EVENT_SECCOMP      SYMBOLIC(PTRACE_EVENT_SECCOMP)


#define PT_ATTACH      PTRACE_ATTACH
#define PT_CONTINUE    PTRACE_CONT
#define PT_DETACH      PTRACE_DETACH
#define PT_GETEVENTMSG PTRACE_GETEVENTMSG
#define PT_GETFPREGS   PTRACE_GETFPREGS
#define PT_GETFPXREGS  PTRACE_GETFPXREGS
#define PT_GETREGS     PTRACE_GETREGS
#define PT_GETSIGINFO  PTRACE_GETSIGINFO
#define PT_KILL        PTRACE_KILL
#define PT_READ_D      PTRACE_PEEKDATA
#define PT_READ_I      PTRACE_PEEKTEXT
#define PT_READ_U      PTRACE_PEEKUSER
#define PT_SETFPREGS   PTRACE_SETFPREGS
#define PT_SETFPXREGS  PTRACE_SETFPXREGS
#define PT_SETOPTIONS  PTRACE_SETOPTIONS
#define PT_SETREGS     PTRACE_SETREGS
#define PT_SETSIGINFO  PTRACE_SETSIGINFO
#define PT_STEP        PTRACE_SINGLESTEP
#define PT_SYSCALL     PTRACE_SYSCALL
#define PT_WRITE_D     PTRACE_POKEDATA
#define PT_WRITE_I     PTRACE_POKETEXT
#define PT_WRITE_U     PTRACE_POKEUSER



/*!BEGIN libc/sysv/consts/pty.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PTY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int TIOCPKT;
extern const int TIOCPKT_DATA;
extern const int TIOCPKT_DOSTOP;
extern const int TIOCPKT_FLUSHREAD;
extern const int TIOCPKT_FLUSHWRITE;
extern const int TIOCPKT_IOCTL;
extern const int TIOCPKT_NOSTOP;
extern const int TIOCPKT_START;
extern const int TIOCPKT_STOP;
extern const int TIOCSPTLCK;
extern const int PTMGET;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TIOCPKT            SYMBOLIC(TIOCPKT)
#define TIOCSPTLCK         SYMBOLIC(TIOCSPTLCK)
#define PTMGET             SYMBOLIC(PTMGET)
#define TIOCPKT_DATA       LITERALLY(0x00)
#define TIOCPKT_DOSTOP     LITERALLY(0x01)
#define TIOCPKT_FLUSHREAD  LITERALLY(0x02)
#define TIOCPKT_FLUSHWRITE LITERALLY(0x04)
#define TIOCPKT_IOCTL      LITERALLY(0x08)
#define TIOCPKT_NOSTOP     LITERALLY(0x10)
#define TIOCPKT_START      LITERALLY(0x20)
#define TIOCPKT_STOP       LITERALLY(0x40)



/*!BEGIN libc/sysv/consts/read.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_READ_H_

#define READ_10 SYMBOLIC(READ_10)
#define READ_12 SYMBOLIC(READ_12)
#define READ_6 SYMBOLIC(READ_6)
#define READ_BLOCK_LIMITS SYMBOLIC(READ_BLOCK_LIMITS)
#define READ_BUFFER SYMBOLIC(READ_BUFFER)
#define READ_CAPACITY SYMBOLIC(READ_CAPACITY)
#define READ_DEFECT_DATA SYMBOLIC(READ_DEFECT_DATA)
#define READ_ELEMENT_STATUS SYMBOLIC(READ_ELEMENT_STATUS)
#define READ_LONG SYMBOLIC(READ_LONG)
#define READ_POSITION SYMBOLIC(READ_POSITION)
#define READ_REVERSE SYMBOLIC(READ_REVERSE)
#define READ_TOC SYMBOLIC(READ_TOC)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long READ_10;
extern const long READ_12;
extern const long READ_6;
extern const long READ_BLOCK_LIMITS;
extern const long READ_BUFFER;
extern const long READ_CAPACITY;
extern const long READ_DEFECT_DATA;
extern const long READ_ELEMENT_STATUS;
extern const long READ_LONG;
extern const long READ_POSITION;
extern const long READ_REVERSE;
extern const long READ_TOC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/reboot.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_REBOOT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int RB_AUTOBOOT;
extern const int RB_POWER_OFF;
extern const int RB_POWERDOWN;
extern const int RB_POWEROFF;
extern const int RB_HALT_SYSTEM;
extern const int RB_HALT;
extern const int RB_SW_SUSPEND;
extern const int RB_KEXEC;
extern const int RB_ENABLE_CAD;
extern const int RB_DISABLE_CAD;
extern const int RB_NOSYNC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define RB_AUTOBOOT    SYMBOLIC(RB_AUTOBOOT)
#define RB_POWER_OFF   SYMBOLIC(RB_POWER_OFF)
#define RB_POWERDOWN   SYMBOLIC(RB_POWERDOWN)
#define RB_POWEROFF    SYMBOLIC(RB_POWEROFF)
#define RB_HALT_SYSTEM SYMBOLIC(RB_HALT_SYSTEM)
#define RB_HALT        SYMBOLIC(RB_HALT)
#define RB_SW_SUSPEND  SYMBOLIC(RB_SW_SUSPEND)
#define RB_KEXEC       SYMBOLIC(RB_KEXEC)
#define RB_ENABLE_CAD  SYMBOLIC(RB_ENABLE_CAD)
#define RB_DISABLE_CAD SYMBOLIC(RB_DISABLE_CAD)
#define RB_NOSYNC      SYMBOLIC(RB_NOSYNC)



/*!BEGIN libc/sysv/consts/rlim.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RLIM_H_

#define RLIM_INFINITY SYMBOLIC(RLIM_INFINITY)
#define RLIM_NLIMITS SYMBOLIC(RLIM_NLIMITS)
#define RLIM_SAVED_CUR SYMBOLIC(RLIM_SAVED_CUR)
#define RLIM_SAVED_MAX SYMBOLIC(RLIM_SAVED_MAX)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t RLIM_INFINITY;
extern const uint64_t RLIM_NLIMITS;
extern const uint64_t RLIM_SAVED_CUR;
extern const uint64_t RLIM_SAVED_MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rlimit.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RLIMIT_H_

#define RLIMIT_AS         SYMBOLIC(RLIMIT_AS)
#define RLIMIT_CORE       SYMBOLIC(RLIMIT_CORE)
#define RLIMIT_CPU        SYMBOLIC(RLIMIT_CPU)
#define RLIMIT_DATA       SYMBOLIC(RLIMIT_DATA)
#define RLIMIT_FSIZE      SYMBOLIC(RLIMIT_FSIZE)
#define RLIMIT_LOCKS      SYMBOLIC(RLIMIT_LOCKS)
#define RLIMIT_MEMLOCK    SYMBOLIC(RLIMIT_MEMLOCK)
#define RLIMIT_MSGQUEUE   SYMBOLIC(RLIMIT_MSGQUEUE)
#define RLIMIT_NICE       SYMBOLIC(RLIMIT_NICE)
#define RLIMIT_NOFILE     SYMBOLIC(RLIMIT_NOFILE)
#define RLIMIT_NPROC      SYMBOLIC(RLIMIT_NPROC)
#define RLIMIT_NPTS       SYMBOLIC(RLIMIT_NPTS)
#define RLIMIT_RSS        SYMBOLIC(RLIMIT_RSS)
#define RLIMIT_RTPRIO     SYMBOLIC(RLIMIT_RTPRIO)
#define RLIMIT_RTTIME     SYMBOLIC(RLIMIT_RTTIME)
#define RLIMIT_SBSIZE     SYMBOLIC(RLIMIT_SBSIZE)
#define RLIMIT_SIGPENDING SYMBOLIC(RLIMIT_SIGPENDING)
#define RLIMIT_STACK      SYMBOLIC(RLIMIT_STACK)
#define RLIMIT_SWAP       SYMBOLIC(RLIMIT_SWAP)
#define RLIMIT_VMEM       SYMBOLIC(RLIMIT_VMEM)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t RLIMIT_AS;
extern const uint64_t RLIMIT_CORE;
extern const uint64_t RLIMIT_CPU;
extern const uint64_t RLIMIT_DATA;
extern const uint64_t RLIMIT_FSIZE;
extern const uint64_t RLIMIT_LOCKS;
extern const uint64_t RLIMIT_MEMLOCK;
extern const uint64_t RLIMIT_MSGQUEUE;
extern const uint64_t RLIMIT_NICE;
extern const uint64_t RLIMIT_NOFILE;
extern const uint64_t RLIMIT_NPROC;
extern const uint64_t RLIMIT_NPTS;
extern const uint64_t RLIMIT_RSS;
extern const uint64_t RLIMIT_RTPRIO;
extern const uint64_t RLIMIT_RTTIME;
extern const uint64_t RLIMIT_SBSIZE;
extern const uint64_t RLIMIT_SIGPENDING;
extern const uint64_t RLIMIT_STACK;
extern const uint64_t RLIMIT_SWAP;
extern const uint64_t RLIMIT_VMEM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rusage.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RUSAGE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int RUSAGE_BOTH;
extern const int RUSAGE_CHILDREN;
extern const int RUSAGE_SELF;
extern const int RUSAGE_THREAD;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define RUSAGE_BOTH     SYMBOLIC(RUSAGE_BOTH)
#define RUSAGE_CHILDREN SYMBOLIC(RUSAGE_CHILDREN)
#define RUSAGE_SELF     LITERALLY(0)
#define RUSAGE_THREAD   SYMBOLIC(RUSAGE_THREAD)



/*!BEGIN libc/sysv/consts/s.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_S_H_

#define S_IFIFO  0010000 /* pipe */
#define S_IFCHR  0020000 /* character device */
#define S_IFDIR  0040000 /* directory */
#define S_IFBLK  0060000 /* block device */
#define S_IFREG  0100000 /* regular file */
#define S_IFLNK  0120000 /* symbolic link */
#define S_IFSOCK 0140000 /* socket */
#define S_IFMT   0170000 /* mask of file types above */

#define S_ISVTX  0001000 /* THE STICKY BIT */
#define S_ISGID  0002000 /* the setgid bit */
#define S_ISUID  0004000 /* the setuid bit */
#define S_IXUSR  0000100 /* user  --x; just use octal */
#define S_IWUSR  0000200 /* user  -w-; just use octal */
#define S_IRUSR  0000400 /* user  r--; just use octal */
#define S_IRWXU  0000700 /* user  rwx; just use octal */
#define S_IXGRP  0000010 /* group --x; just use octal */
#define S_IWGRP  0000020 /* group -w-; just use octal */
#define S_IRGRP  0000040 /* group r--; just use octal */
#define S_IRWXG  0000070 /* group rwx; just use octal */
#define S_IXOTH  0000001 /* other --x; just use octal */
#define S_IWOTH  0000002 /* other -w-; just use octal */
#define S_IROTH  0000004 /* other r--; just use octal */
#define S_IRWXO  0000007 /* other rwx; just use octal */
#define S_IREAD  0000400 /* just use octal */
#define S_IEXEC  0000100 /* just use octal */
#define S_IWRITE 0000200 /* just use octal */

#define S_ISDIR(mode)  (((mode)&S_IFMT) == S_IFDIR)
#define S_ISCHR(mode)  (((mode)&S_IFMT) == S_IFCHR)
#define S_ISBLK(mode)  (((mode)&S_IFMT) == S_IFBLK)
#define S_ISREG(mode)  (((mode)&S_IFMT) == S_IFREG)
#define S_ISFIFO(mode) (((mode)&S_IFMT) == S_IFIFO)
#define S_ISLNK(mode)  (((mode)&S_IFMT) == S_IFLNK)
#define S_ISSOCK(mode) (((mode)&S_IFMT) == S_IFSOCK)



/*!BEGIN libc/sysv/consts/sa.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SA_H_

#define SA_NOCLDSTOP SYMBOLIC(SA_NOCLDSTOP)
#define SA_NOCLDWAIT SYMBOLIC(SA_NOCLDWAIT)
#define SA_NODEFER   SYMBOLIC(SA_NODEFER)
#define SA_NOMASK    SYMBOLIC(SA_NOMASK)
#define SA_ONESHOT   SYMBOLIC(SA_ONESHOT)
#define SA_ONSTACK   SYMBOLIC(SA_ONSTACK)
#define SA_RESETHAND SYMBOLIC(SA_RESETHAND)
#define SA_RESTART   SYMBOLIC(SA_RESTART)
#define SA_SIGINFO   SYMBOLIC(SA_SIGINFO)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const uint64_t SA_NOCLDSTOP;
extern const uint64_t SA_NOCLDWAIT;
extern const uint64_t SA_NODEFER;
extern const uint64_t SA_NOMASK;
extern const uint64_t SA_ONESHOT;
extern const uint64_t SA_ONSTACK;
extern const uint64_t SA_RESETHAND;
extern const uint64_t SA_RESTART;
extern const uint64_t SA_SIGINFO;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sched.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SCHED_H_

#define SCHED_BATCH         SYMBOLIC(SCHED_BATCH)
#define SCHED_DEADLINE      SYMBOLIC(SCHED_DEADLINE)
#define SCHED_FIFO          SYMBOLIC(SCHED_FIFO)
#define SCHED_IDLE          SYMBOLIC(SCHED_IDLE)
#define SCHED_NORMAL        SCHED_OTHER
#define SCHED_OTHER         SYMBOLIC(SCHED_OTHER)
#define SCHED_RESET_ON_FORK SYMBOLIC(SCHED_RESET_ON_FORK)
#define SCHED_RR            SYMBOLIC(SCHED_RR)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SCHED_BATCH;
extern const int SCHED_DEADLINE;
extern const int SCHED_FIFO;
extern const int SCHED_IDLE;
extern const int SCHED_OTHER;
extern const int SCHED_RESET_ON_FORK;
extern const int SCHED_RR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/scm.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SCM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SCM_TIMESTAMP;
extern const int SCM_CREDENTIALS;
extern const int SCM_TIMESTAMPING;
extern const int SCM_TIMESTAMPNS;
extern const int SCM_WIFI_STATUS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SCM_RIGHTS       LITERALLY(1)
#define SCM_TIMESTAMP    SYMBOLIC(SCM_TIMESTAMP)
#define SCM_CREDENTIALS  SYMBOLIC(SCM_CREDENTIALS)
#define SCM_TIMESTAMPING SYMBOLIC(SCM_TIMESTAMPING)
#define SCM_TIMESTAMPNS  SYMBOLIC(SCM_TIMESTAMPNS)
#define SCM_WIFI_STATUS  SYMBOLIC(SCM_WIFI_STATUS)



/*!BEGIN libc/sysv/consts/sf.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sf_hdtr {
  struct iovec *headers;
  int hdr_cnt;
  struct iovec *trailers;
  int trl_cnt;
};

extern const int SF_MNOWAIT;
extern const int SF_NODISKIO;
extern const int SF_SYNC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SF_MNOWAIT  SYMBOLIC(SF_MNOWAIT)
#define SF_NODISKIO SYMBOLIC(SF_NODISKIO)
#define SF_SYNC     SYMBOLIC(SF_SYNC)



/*!BEGIN libc/sysv/consts/shm.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SHM_H_

#define SHM_DEST SYMBOLIC(SHM_DEST)
#define SHM_EXEC SYMBOLIC(SHM_EXEC)
#define SHM_HUGETLB SYMBOLIC(SHM_HUGETLB)
#define SHM_INFO SYMBOLIC(SHM_INFO)
#define SHM_LOCK SYMBOLIC(SHM_LOCK)
#define SHM_LOCKED SYMBOLIC(SHM_LOCKED)
#define SHM_NORESERVE SYMBOLIC(SHM_NORESERVE)
#define SHM_R SYMBOLIC(SHM_R)
#define SHM_RDONLY SYMBOLIC(SHM_RDONLY)
#define SHM_REMAP SYMBOLIC(SHM_REMAP)
#define SHM_RND SYMBOLIC(SHM_RND)
#define SHM_STAT SYMBOLIC(SHM_STAT)
#define SHM_UNLOCK SYMBOLIC(SHM_UNLOCK)
#define SHM_W SYMBOLIC(SHM_W)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SHM_DEST;
extern const int SHM_EXEC;
extern const int SHM_HUGETLB;
extern const int SHM_INFO;
extern const int SHM_LOCK;
extern const int SHM_LOCKED;
extern const int SHM_NORESERVE;
extern const int SHM_R;
extern const int SHM_RDONLY;
extern const int SHM_REMAP;
extern const int SHM_RND;
extern const int SHM_STAT;
extern const int SHM_UNLOCK;
extern const int SHM_W;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/shut.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SHUT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SHUT_RD;
extern const int SHUT_RDWR;
extern const int SHUT_WR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SHUT_RD LITERALLY(0)
#define SHUT_RDWR LITERALLY(2)
#define SHUT_WR LITERALLY(1)



/*!BEGIN libc/sysv/consts/sicode.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SICODE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int32_t SI_USER;
extern const int32_t SI_QUEUE;
extern const int32_t SI_TIMER;
extern const int32_t SI_MESGQ;
extern const int32_t SI_ASYNCIO;
extern const int32_t SI_TKILL;
extern const int32_t SI_ASYNCNL;
extern const int32_t SI_KERNEL;
extern const int32_t SI_NOINFO;
extern const int32_t CLD_EXITED;
extern const int32_t CLD_KILLED;
extern const int32_t CLD_DUMPED;
extern const int32_t CLD_TRAPPED;
extern const int32_t CLD_STOPPED;
extern const int32_t CLD_CONTINUED;
extern const int32_t TRAP_BRKPT;
extern const int32_t TRAP_TRACE;
extern const int32_t SEGV_MAPERR;
extern const int32_t SEGV_ACCERR;
extern const int32_t SEGV_PKUERR;
extern const int32_t FPE_INTDIV;
extern const int32_t FPE_INTOVF;
extern const int32_t FPE_FLTDIV;
extern const int32_t FPE_FLTOVF;
extern const int32_t FPE_FLTUND;
extern const int32_t FPE_FLTRES;
extern const int32_t FPE_FLTINV;
extern const int32_t FPE_FLTSUB;
extern const int32_t ILL_ILLOPC;
extern const int32_t ILL_ILLOPN;
extern const int32_t ILL_ILLADR;
extern const int32_t ILL_ILLTRP;
extern const int32_t ILL_PRVOPC;
extern const int32_t ILL_PRVREG;
extern const int32_t ILL_COPROC;
extern const int32_t ILL_BADSTK;
extern const int32_t BUS_ADRALN;
extern const int32_t BUS_ADRERR;
extern const int32_t BUS_OBJERR;
extern const int32_t BUS_MCEERR_AR;
extern const int32_t BUS_MCEERR_AO;
extern const int32_t BUS_OOMERR;
extern const int32_t POLL_IN;
extern const int32_t POLL_OUT;
extern const int32_t POLL_MSG;
extern const int32_t POLL_ERR;
extern const int32_t POLL_PRI;
extern const int32_t POLL_HUP;
extern const int32_t SYS_SECCOMP;
extern const int32_t SYS_USER_DISPATCH;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define CLD_EXITED    LITERALLY(1)
#define CLD_KILLED    LITERALLY(2)
#define CLD_DUMPED    LITERALLY(3)
#define CLD_TRAPPED   LITERALLY(4)
#define CLD_STOPPED   LITERALLY(5)
#define CLD_CONTINUED LITERALLY(6)
#define TRAP_BRKPT    LITERALLY(1)
#define TRAP_TRACE    LITERALLY(2)
#define SEGV_MAPERR   LITERALLY(1)
#define SEGV_ACCERR   LITERALLY(2)
#define ILL_ILLOPC    LITERALLY(1)
#define ILL_PRVREG    LITERALLY(6)
#define ILL_COPROC    LITERALLY(7)
#define ILL_BADSTK    LITERALLY(8)
#define BUS_ADRALN    LITERALLY(1)
#define BUS_ADRERR    LITERALLY(2)
#define BUS_OBJERR    LITERALLY(3)
#define POLL_IN       LITERALLY(1)
#define POLL_OUT      LITERALLY(2)
#define POLL_MSG      LITERALLY(3)
#define POLL_ERR      LITERALLY(4)
#define POLL_PRI      LITERALLY(5)
#define POLL_HUP      LITERALLY(6)

#define SI_USER           SYMBOLIC(SI_USER)
#define SI_QUEUE          SYMBOLIC(SI_QUEUE)
#define SI_TIMER          SYMBOLIC(SI_TIMER)
#define SI_MESGQ          SYMBOLIC(SI_MESGQ)
#define SI_ASYNCIO        SYMBOLIC(SI_ASYNCIO)
#define SI_TKILL          SYMBOLIC(SI_TKILL)
#define SI_ASYNCNL        SYMBOLIC(SI_ASYNCNL)
#define SI_KERNEL         SYMBOLIC(SI_KERNEL)
#define SI_NOINFO         SYMBOLIC(SI_NOINFO)
#define SEGV_PKUERR       SYMBOLIC(SEGV_PKUERR)
#define FPE_INTDIV        SYMBOLIC(FPE_INTDIV)
#define FPE_INTOVF        SYMBOLIC(FPE_INTOVF)
#define FPE_FLTDIV        SYMBOLIC(FPE_FLTDIV)
#define FPE_FLTOVF        SYMBOLIC(FPE_FLTOVF)
#define FPE_FLTUND        SYMBOLIC(FPE_FLTUND)
#define FPE_FLTRES        SYMBOLIC(FPE_FLTRES)
#define FPE_FLTINV        SYMBOLIC(FPE_FLTINV)
#define FPE_FLTSUB        SYMBOLIC(FPE_FLTSUB)
#define ILL_ILLOPN        SYMBOLIC(ILL_ILLOPN)
#define ILL_ILLADR        SYMBOLIC(ILL_ILLADR)
#define ILL_ILLTRP        SYMBOLIC(ILL_ILLTRP)
#define ILL_PRVOPC        SYMBOLIC(ILL_PRVOPC)
#define BUS_OOMERR        SYMBOLIC(BUS_OOMERR)
#define BUS_MCEERR_AR     SYMBOLIC(BUS_MCEERR_AR)
#define BUS_MCEERR_AO     SYMBOLIC(BUS_MCEERR_AO)
#define SYS_SECCOMP       SYMBOLIC(SYS_SECCOMP)
#define SYS_USER_DISPATCH SYMBOLIC(SYS_USER_DISPATCH)



/*!BEGIN libc/sysv/consts/so.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int LOCAL_PEERCRED;
extern const int SO_ACCEPTCONN;
extern const int SO_ATTACH_BPF;
extern const int SO_ATTACH_FILTER;
extern const int SO_ATTACH_REUSEPORT_CBPF;
extern const int SO_ATTACH_REUSEPORT_EBPF;
extern const int SO_BINDTODEVICE;
extern const int SO_BPF_EXTENSIONS;
extern const int SO_BROADCAST;
extern const int SO_BSDCOMPAT;
extern const int SO_BUSY_POLL;
extern const int SO_CNX_ADVICE;
extern const int SO_DEBUG;
extern const int SO_DETACH_BPF;
extern const int SO_DETACH_FILTER;
extern const int SO_DOMAIN;
extern const int SO_DONTROUTE;
extern const int SO_ERROR;
extern const int SO_EXCLUSIVEADDRUSE;
extern const int SO_GET_FILTER;
extern const int SO_INCOMING_CPU;
extern const int SO_KEEPALIVE;
extern const int SO_LINGER;
extern const int SO_LOCK_FILTER;
extern const int SO_MARK;
extern const int SO_MAX_PACING_RATE;
extern const int SO_NOFCS;
extern const int SO_NO_CHECK;
extern const int SO_OOBINLINE;
extern const int SO_PASSCRED;
extern const int SO_PASSSEC;
extern const int SO_PEEK_OFF;
extern const int SO_PEERCRED;
extern const int SO_PEERNAME;
extern const int SO_PEERSEC;
extern const int SO_PRIORITY;
extern const int SO_PROTOCOL;
extern const int SO_RCVBUF;
extern const int SO_RCVBUFFORCE;
extern const int SO_RCVLOWAT;
extern const int SO_RCVTIMEO;
extern const int SO_REUSEADDR;
extern const int SO_REUSEPORT;
extern const int SO_RXQ_OVFL;
extern const int SO_SECURITY_AUTHENTICATION;
extern const int SO_SECURITY_ENCRYPTION_NETWORK;
extern const int SO_SECURITY_ENCRYPTION_TRANSPORT;
extern const int SO_SELECT_ERR_QUEUE;
extern const int SO_SETFIB;
extern const int SO_SNDBUF;
extern const int SO_SNDBUFFORCE;
extern const int SO_SNDLOWAT;
extern const int SO_SNDTIMEO;
extern const int SO_TIMESTAMP;
extern const int SO_TIMESTAMPING;
extern const int SO_TIMESTAMPNS;
extern const int SO_TYPE;
extern const int SO_USELOOPBACK;
extern const int SO_WIFI_STATUS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SO_DEBUG LITERALLY(1)

#define LOCAL_PEERCRED           SYMBOLIC(LOCAL_PEERCRED)
#define SO_ACCEPTCONN            SYMBOLIC(SO_ACCEPTCONN)
#define SO_ATTACH_BPF            SYMBOLIC(SO_ATTACH_BPF)
#define SO_ATTACH_FILTER         SYMBOLIC(SO_ATTACH_FILTER)
#define SO_ATTACH_REUSEPORT_CBPF SYMBOLIC(SO_ATTACH_REUSEPORT_CBPF)
#define SO_ATTACH_REUSEPORT_EBPF SYMBOLIC(SO_ATTACH_REUSEPORT_EBPF)
#define SO_BINDTODEVICE          SYMBOLIC(SO_BINDTODEVICE)
#define SO_BPF_EXTENSIONS        SYMBOLIC(SO_BPF_EXTENSIONS)
#define SO_BROADCAST             SYMBOLIC(SO_BROADCAST)
#define SO_BSDCOMPAT             SYMBOLIC(SO_BSDCOMPAT)
#define SO_BUSY_POLL             SYMBOLIC(SO_BUSY_POLL)
#define SO_CNX_ADVICE            SYMBOLIC(SO_CNX_ADVICE)
#define SO_DETACH_BPF            SYMBOLIC(SO_DETACH_BPF)
#define SO_DETACH_FILTER         SYMBOLIC(SO_DETACH_FILTER)
#define SO_DOMAIN                SYMBOLIC(SO_DOMAIN)
#define SO_DONTROUTE             SYMBOLIC(SO_DONTROUTE)
#define SO_ERROR                 SYMBOLIC(SO_ERROR)
#define SO_EXCLUSIVEADDRUSE      SYMBOLIC(SO_EXCLUSIVEADDRUSE)
#define SO_GET_FILTER            SYMBOLIC(SO_GET_FILTER)
#define SO_INCOMING_CPU          SYMBOLIC(SO_INCOMING_CPU)
#define SO_KEEPALIVE             SYMBOLIC(SO_KEEPALIVE)
#define SO_LINGER                SYMBOLIC(SO_LINGER)
#define SO_LOCK_FILTER           SYMBOLIC(SO_LOCK_FILTER)
#define SO_MARK                  SYMBOLIC(SO_MARK)
#define SO_MAX_PACING_RATE       SYMBOLIC(SO_MAX_PACING_RATE)
#define SO_NOFCS                 SYMBOLIC(SO_NOFCS)
#define SO_NO_CHECK              SYMBOLIC(SO_NO_CHECK)
#define SO_OOBINLINE             SYMBOLIC(SO_OOBINLINE)
#define SO_PASSCRED              SYMBOLIC(SO_PASSCRED)
#define SO_PASSSEC               SYMBOLIC(SO_PASSSEC)
#define SO_PEEK_OFF              SYMBOLIC(SO_PEEK_OFF)
#define SO_PEERCRED              SYMBOLIC(SO_PEERCRED)
#define SO_PEERNAME              SYMBOLIC(SO_PEERNAME)
#define SO_PEERSEC               SYMBOLIC(SO_PEERSEC)
#define SO_PRIORITY              SYMBOLIC(SO_PRIORITY)
#define SO_PROTOCOL              SYMBOLIC(SO_PROTOCOL)
#define SO_RCVBUF                SYMBOLIC(SO_RCVBUF)
#define SO_RCVBUFFORCE           SYMBOLIC(SO_RCVBUFFORCE)
#define SO_RCVLOWAT              SYMBOLIC(SO_RCVLOWAT)
#define SO_RCVTIMEO              SYMBOLIC(SO_RCVTIMEO)
#define SO_REUSEADDR             SYMBOLIC(SO_REUSEADDR)
#define SO_REUSEPORT             SYMBOLIC(SO_REUSEPORT)
#define SO_RXQ_OVFL              SYMBOLIC(SO_RXQ_OVFL)
#define SO_SELECT_ERR_QUEUE      SYMBOLIC(SO_SELECT_ERR_QUEUE)
#define SO_SETFIB                SYMBOLIC(SO_SETFIB)
#define SO_SNDBUF                SYMBOLIC(SO_SNDBUF)
#define SO_SNDBUFFORCE           SYMBOLIC(SO_SNDBUFFORCE)
#define SO_SNDLOWAT              SYMBOLIC(SO_SNDLOWAT)
#define SO_SNDTIMEO              SYMBOLIC(SO_SNDTIMEO)
#define SO_TIMESTAMP             SYMBOLIC(SO_TIMESTAMP)
#define SO_TIMESTAMPING          SYMBOLIC(SO_TIMESTAMPING)
#define SO_TIMESTAMPNS           SYMBOLIC(SO_TIMESTAMPNS)
#define SO_TYPE                  SYMBOLIC(SO_TYPE)
#define SO_USELOOPBACK           SYMBOLIC(SO_USELOOPBACK)
#define SO_WIFI_STATUS           SYMBOLIC(SO_WIFI_STATUS)

#define SO_SECURITY_AUTHENTICATION     SYMBOLIC(SO_SECURITY_AUTHENTICATION)
#define SO_SECURITY_ENCRYPTION_NETWORK SYMBOLIC(SO_SECURITY_ENCRYPTION_NETWORK)
#define SO_SECURITY_ENCRYPTION_TRANSPORT \
  SYMBOLIC(SO_SECURITY_ENCRYPTION_TRANSPORT)



/*!BEGIN libc/sysv/consts/sock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SOCK_CLOEXEC;
extern const int SOCK_DCCP;
extern const int SOCK_DGRAM;
extern const int SOCK_NONBLOCK;
extern const int SOCK_PACKET;
extern const int SOCK_RAW;
extern const int SOCK_RDM;
extern const int SOCK_SEQPACKET;
extern const int SOCK_STREAM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SOCK_CLOEXEC SYMBOLIC(SOCK_CLOEXEC)
#define SOCK_DCCP SYMBOLIC(SOCK_DCCP)
#define SOCK_DGRAM LITERALLY(2)
#define SOCK_NONBLOCK SYMBOLIC(SOCK_NONBLOCK)
#define SOCK_PACKET SYMBOLIC(SOCK_PACKET)
#define SOCK_RAW LITERALLY(3)
#define SOCK_RDM LITERALLY(4)
#define SOCK_SEQPACKET LITERALLY(5)
#define SOCK_STREAM LITERALLY(1)



/*!BEGIN libc/sysv/consts/sol.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SOL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int SOL_AAL;
extern const int SOL_ALG;
extern const int SOL_ATM;
extern const int SOL_BLUETOOTH;
extern const int SOL_CAIF;
extern const int SOL_DCCP;
extern const int SOL_DECNET;
extern const int SOL_ICMPV6;
extern const int SOL_IP;
extern const int SOL_IPV6;
extern const int SOL_IRDA;
extern const int SOL_IUCV;
extern const int SOL_KCM;
extern const int SOL_LLC;
extern const int SOL_NETBEUI;
extern const int SOL_NETLINK;
extern const int SOL_NFC;
extern const int SOL_PACKET;
extern const int SOL_PNPIPE;
extern const int SOL_PPPOL2TP;
extern const int SOL_RAW;
extern const int SOL_RDS;
extern const int SOL_RXRPC;
extern const int SOL_SOCKET;
extern const int SOL_TCP;
extern const int SOL_TIPC;
extern const int SOL_UDP;
extern const int SOL_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SOL_IP  LITERALLY(0)
#define SOL_TCP LITERALLY(6)
#define SOL_UDP LITERALLY(17)

#define SOL_AAL       SYMBOLIC(SOL_AAL)
#define SOL_ALG       SYMBOLIC(SOL_ALG)
#define SOL_ATM       SYMBOLIC(SOL_ATM)
#define SOL_BLUETOOTH SYMBOLIC(SOL_BLUETOOTH)
#define SOL_CAIF      SYMBOLIC(SOL_CAIF)
#define SOL_DCCP      SYMBOLIC(SOL_DCCP)
#define SOL_DECNET    SYMBOLIC(SOL_DECNET)
#define SOL_ICMPV6    SYMBOLIC(SOL_ICMPV6)
#define SOL_IPV6      SYMBOLIC(SOL_IPV6)
#define SOL_IRDA      SYMBOLIC(SOL_IRDA)
#define SOL_IUCV      SYMBOLIC(SOL_IUCV)
#define SOL_KCM       SYMBOLIC(SOL_KCM)
#define SOL_LLC       SYMBOLIC(SOL_LLC)
#define SOL_NETBEUI   SYMBOLIC(SOL_NETBEUI)
#define SOL_NETLINK   SYMBOLIC(SOL_NETLINK)
#define SOL_NFC       SYMBOLIC(SOL_NFC)
#define SOL_PACKET    SYMBOLIC(SOL_PACKET)
#define SOL_PNPIPE    SYMBOLIC(SOL_PNPIPE)
#define SOL_PPPOL2TP  SYMBOLIC(SOL_PPPOL2TP)
#define SOL_RAW       SYMBOLIC(SOL_RAW)
#define SOL_RDS       SYMBOLIC(SOL_RDS)
#define SOL_RXRPC     SYMBOLIC(SOL_RXRPC)
#define SOL_SOCKET    SYMBOLIC(SOL_SOCKET)
#define SOL_TIPC      SYMBOLIC(SOL_TIPC)
#define SOL_X25       SYMBOLIC(SOL_X25)



/*!BEGIN libc/sysv/consts/splice.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SPLICE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned int SPLICE_F_GIFT;
extern const unsigned int SPLICE_F_MORE;
extern const unsigned int SPLICE_F_MOVE;
extern const unsigned int SPLICE_F_NONBLOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SPLICE_F_GIFT SYMBOLIC(SPLICE_F_GIFT)
#define SPLICE_F_MORE SYMBOLIC(SPLICE_F_MORE)
#define SPLICE_F_MOVE SYMBOLIC(SPLICE_F_MOVE)
#define SPLICE_F_NONBLOCK SYMBOLIC(SPLICE_F_NONBLOCK)



/*!BEGIN libc/sysv/consts/ss.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const size_t SIGSTKSZ;
extern const size_t MINSIGSTKSZ;
extern const int SS_DISABLE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SIGSTKSZ    STACKSIZE
#define MINSIGSTKSZ 32768
#define SS_ONSTACK  1
#define SS_DISABLE  SS_DISABLE



/*!BEGIN libc/sysv/consts/st.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ST_H_

#define ST_APPEND SYMBOLIC(ST_APPEND)
#define ST_IMMUTABLE SYMBOLIC(ST_IMMUTABLE)
#define ST_MANDLOCK SYMBOLIC(ST_MANDLOCK)
#define ST_NOATIME SYMBOLIC(ST_NOATIME)
#define ST_NODEV SYMBOLIC(ST_NODEV)
#define ST_NODIRATIME SYMBOLIC(ST_NODIRATIME)
#define ST_NOEXEC SYMBOLIC(ST_NOEXEC)
#define ST_NOSUID SYMBOLIC(ST_NOSUID)
#define ST_RDONLY SYMBOLIC(ST_RDONLY)
#define ST_RELATIME SYMBOLIC(ST_RELATIME)
#define ST_SYNCHRONOUS SYMBOLIC(ST_SYNCHRONOUS)
#define ST_WRITE SYMBOLIC(ST_WRITE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned long ST_APPEND;
extern const unsigned long ST_IMMUTABLE;
extern const unsigned long ST_MANDLOCK;
extern const unsigned long ST_NOATIME;
extern const unsigned long ST_NODEV;
extern const unsigned long ST_NODIRATIME;
extern const unsigned long ST_NOEXEC;
extern const unsigned long ST_NOSUID;
extern const unsigned long ST_RDONLY;
extern const unsigned long ST_RELATIME;
extern const unsigned long ST_SYNCHRONOUS;
extern const unsigned long ST_WRITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/tcp.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TCP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int TCP_CC_INFO;
extern const int TCP_CONGESTION;
extern const int TCP_COOKIE_TRANSACTIONS;
extern const int TCP_CORK;
extern const int TCP_DEFER_ACCEPT;
extern const int TCP_FASTOPEN;
extern const int TCP_FASTOPEN_CONNECT;
extern const int TCP_INFO;
extern const int TCP_KEEPCNT;
extern const int TCP_KEEPIDLE;
extern const int TCP_KEEPINTVL;
extern const int TCP_LINGER2;
extern const int TCP_MAXSEG;
extern const int TCP_MD5SIG;
extern const int TCP_MD5SIG_MAXKEYLEN;
extern const int TCP_NODELAY;
extern const int TCP_NOTSENT_LOWAT;
extern const int TCP_QUEUE_SEQ;
extern const int TCP_QUICKACK;
extern const int TCP_REPAIR;
extern const int TCP_REPAIR_OPTIONS;
extern const int TCP_REPAIR_QUEUE;
extern const int TCP_SAVED_SYN;
extern const int TCP_SAVE_SYN;
extern const int TCP_SYNCNT;
extern const int TCP_THIN_DUPACK;
extern const int TCP_THIN_LINEAR_TIMEOUTS;
extern const int TCP_TIMESTAMP;
extern const int TCP_ULP;
extern const int TCP_USER_TIMEOUT;
extern const int TCP_WINDOW_CLAMP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TCP_CC_INFO              SYMBOLIC(TCP_CC_INFO)
#define TCP_CONGESTION           SYMBOLIC(TCP_CONGESTION)
#define TCP_COOKIE_TRANSACTIONS  SYMBOLIC(TCP_COOKIE_TRANSACTIONS)
#define TCP_CORK                 SYMBOLIC(TCP_CORK)
#define TCP_DEFER_ACCEPT         SYMBOLIC(TCP_DEFER_ACCEPT)
#define TCP_FASTOPEN             SYMBOLIC(TCP_FASTOPEN)
#define TCP_FASTOPEN_CONNECT     SYMBOLIC(TCP_FASTOPEN_CONNECT)
#define TCP_INFO                 SYMBOLIC(TCP_INFO)
#define TCP_KEEPCNT              SYMBOLIC(TCP_KEEPCNT)
#define TCP_KEEPIDLE             SYMBOLIC(TCP_KEEPIDLE)
#define TCP_KEEPINTVL            SYMBOLIC(TCP_KEEPINTVL)
#define TCP_LINGER2              SYMBOLIC(TCP_LINGER2)
#define TCP_MAXSEG               SYMBOLIC(TCP_MAXSEG)
#define TCP_MD5SIG               SYMBOLIC(TCP_MD5SIG)
#define TCP_MD5SIG_MAXKEYLEN     SYMBOLIC(TCP_MD5SIG_MAXKEYLEN)
#define TCP_NODELAY              LITERALLY(1)
#define TCP_NOTSENT_LOWAT        SYMBOLIC(TCP_NOTSENT_LOWAT)
#define TCP_QUEUE_SEQ            SYMBOLIC(TCP_QUEUE_SEQ)
#define TCP_QUICKACK             SYMBOLIC(TCP_QUICKACK)
#define TCP_REPAIR               SYMBOLIC(TCP_REPAIR)
#define TCP_REPAIR_OPTIONS       SYMBOLIC(TCP_REPAIR_OPTIONS)
#define TCP_REPAIR_QUEUE         SYMBOLIC(TCP_REPAIR_QUEUE)
#define TCP_SAVED_SYN            SYMBOLIC(TCP_SAVED_SYN)
#define TCP_SAVE_SYN             SYMBOLIC(TCP_SAVE_SYN)
#define TCP_SYNCNT               SYMBOLIC(TCP_SYNCNT)
#define TCP_THIN_DUPACK          SYMBOLIC(TCP_THIN_DUPACK)
#define TCP_THIN_LINEAR_TIMEOUTS SYMBOLIC(TCP_THIN_LINEAR_TIMEOUTS)
#define TCP_TIMESTAMP            SYMBOLIC(TCP_TIMESTAMP)
#define TCP_ULP                  SYMBOLIC(TCP_ULP)
#define TCP_USER_TIMEOUT         SYMBOLIC(TCP_USER_TIMEOUT)
#define TCP_WINDOW_CLAMP         SYMBOLIC(TCP_WINDOW_CLAMP)



/*!BEGIN libc/sysv/consts/tcpopt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TCPOPT_H_

#define TCPOPT_EOL            0
#define TCPOPT_NOP            1
#define TCPOPT_MAXSEG         2
#define TCPOPT_WINDOW         3
#define TCPOPT_SACK_PERMITTED 4
#define TCPOPT_SACK           5
#define TCPOPT_TIMESTAMP      8

#define TCPOLEN_SACK_PERMITTED 2
#define TCPOLEN_WINDOW         3
#define TCPOLEN_MAXSEG         4
#define TCPOLEN_TIMESTAMP      10



/*!BEGIN libc/sysv/consts/th.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TH_H_

#define TH_FIN  1
#define TH_SYN  2
#define TH_RST  4
#define TH_PUSH 8
#define TH_URG  32
#define TH_ACK  16



/*!BEGIN libc/sysv/consts/timer.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TIMER_H_

#define TIMER_ABSTIME 1



/*!BEGIN libc/sysv/consts/unmount.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MOUNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int MNT_FORCE;
extern const int MNT_DETACH;
extern const int MNT_EXPIRE;
extern const int UMOUNT_NOFOLLOW;
extern const int MNT_BYFSID;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MNT_FORCE       SYMBOLIC(MNT_FORCE)
#define MNT_DETACH      SYMBOLIC(MNT_DETACH)
#define MNT_EXPIRE      SYMBOLIC(MNT_EXPIRE)
#define UMOUNT_NOFOLLOW SYMBOLIC(UMOUNT_NOFOLLOW)
#define MNT_BYFSID      SYMBOLIC(MNT_BYFSID)



/*!BEGIN libc/sysv/consts/utime.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_UTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int UTIME_NOW;
extern const int UTIME_OMIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define UTIME_NOW  SYMBOLIC(UTIME_NOW)
#define UTIME_OMIT SYMBOLIC(UTIME_OMIT)



/*!BEGIN libc/sysv/consts/waitid.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_WAITID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int WEXITED;
extern const int WSTOPPED;
extern const int WNOWAIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define WEXITED  SYMBOLIC(WEXITED)
#define WSTOPPED SYMBOLIC(WSTOPPED)
#define WNOWAIT  SYMBOLIC(WNOWAIT)



/*!BEGIN libc/sysv/consts/xopen.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_XOPEN_H_

#define _XOPEN_IOV_MAX  0x10
#define _XOPEN_ENH_I18N 1
#define _XOPEN_UNIX     1
#define _XOPEN_NAME_MAX 63
#define _XOPEN_PATH_MAX 255
#define _XOPEN_VERSION  700
#define _XOPEN_SOURCE   700



/*!BEGIN libc/thread/spawn.h */

#define COSMOPOLITAN_LIBC_THREAD_SPAWN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct spawn {
  int ptid;
  int *ctid;
  char *stk;
  char *tls;
  char *tib;
};

int _spawn(int (*)(void *, int), void *, struct spawn *) hidden;
int _join(struct spawn *) hidden;
char *_mktls(char **) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/thread/thread.h */

#define COSMOPOLITAN_LIBC_THREAD_THREAD_H_

#define CTHREAD_CREATE_DETACHED 1
#define CTHREAD_CREATE_JOINABLE 0

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

enum cthread_state {
  cthread_started = 0,
  cthread_joining = 1,
  cthread_finished = 2,
  cthread_detached = 4,
};

struct FtraceTls {  /* 16 */
  bool once;        /*  0 */
  bool noreentry;   /*  1 */
  int skew;         /*  4 */
  int64_t lastaddr; /*  8 */
};

struct cthread_descriptor_t {
  struct cthread_descriptor_t *self;  /* 0x00 */
  struct FtraceTls ftrace;            /* 0x08 */
  void *garbages;                     /* 0x10 */
  locale_t locale;                    /* 0x20 */
  int64_t __pad2;                     /* 0x28 */
  struct cthread_descriptor_t *self2; /* 0x30 */
  int32_t tid;                        /* 0x38 */
  int32_t err;                        /* 0x3c */
};

typedef struct cthread_descriptor_t *cthread_t;

typedef union cthread_sem_t {
  struct {
    uint64_t count;
  } linux;
} cthread_sem_t;

typedef struct cthread_attr_t {
  size_t stacksize, guardsize;
  int mode;
} cthread_attr_t;

cthread_t cthread_self(void);
int cthread_attr_init(cthread_attr_t *);
int cthread_attr_destroy(cthread_attr_t *);
int cthread_attr_setstacksize(cthread_attr_t *, size_t);
size_t thread_attr_getstacksize(const cthread_attr_t *);
int cthread_attr_setguardsize(cthread_attr_t *, size_t);
size_t cthread_attr_getguardsize(const cthread_attr_t *);
int cthread_attr_setdetachstate(cthread_attr_t *, int);
int cthread_attr_getdetachstate(const cthread_attr_t *);
int cthread_sem_init(cthread_sem_t *, int);
int cthread_sem_destroy(cthread_sem_t *);
int cthread_sem_wait(cthread_sem_t *, int, const struct timespec *);
int cthread_sem_signal(cthread_sem_t *);
int cthread_memory_wait32(int *, int, const struct timespec *);
int cthread_memory_wake32(int *, int);
void cthread_zombies_add(cthread_t);
void cthread_zombies_reap(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/time/struct/utimbuf.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_UTIMBUF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct utimbuf {
  int64_t actime;  /* access time */
  int64_t modtime; /* modified time */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/time/time.h */

#define COSMOPOLITAN_LIBC_TIME_TIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

hidden extern const char kWeekdayNameShort[7][4];
hidden extern const char kWeekdayName[7][10];
hidden extern const char kMonthNameShort[12][4];
hidden extern const char kMonthName[12][10];
hidden extern const unsigned short kMonthYearDay[2][12];

extern char *tzname[2];
extern long CLOCKS_PER_SEC;
extern long timezone;
extern int daylight;

char *ctime(const int64_t *);
char *ctime_r(const int64_t *, char[hasatleast 64]);
double difftime(int64_t, int64_t) dontthrow pureconst;
extern long double (*nowl)(void);
int usleep(uint32_t);
int utime(const char *, const struct utimbuf *);
int64_t clock(void);
int64_t posix2time(int64_t) pureconst;
int64_t time(int64_t *);
int64_t time2posix(int64_t) pureconst;
long double ConvertTicksToNanos(uint64_t);
long double dsleep(long double);
long double dtime(int);
struct tm *gmtime(const int64_t *);
struct tm *localtime(const int64_t *);
unsigned alarm(unsigned);
unsigned sleep(unsigned);
void RefreshTime(void);
void tzset(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/tinymath/emod.h */

#define COSMOPOLITAN_LIBC_TINYMATH_EMOD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Returns Euclidean floating-point division remainder.
 *
 * @return (𝑥 mod 𝑦) ∈ [0.,𝑦)
 * @see fmod()
 */
#define emod(x, y)                            \
  ({                                          \
    double __x = x;                           \
    double __y = y;                           \
    __x - fabs(__y) * floor(__x / fabs(__y)); \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/tinymath/emodl.h */

#define COSMOPOLITAN_LIBC_TINYMATH_EMODL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Returns Euclidean floating-point division remainder.
 *
 * @return (𝑥 mod 𝑦) ∈ [0.,𝑦)
 * @see fmodl()
 */
#define emodl(x, y)                              \
  ({                                             \
    long double __x = x;                         \
    long double __y = y;                         \
    __x - fabsl(__y) * floorl(__x / fabsl(__y)); \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/x/x.h */

#define COSMOPOLITAN_LIBC_X_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis                                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  Standard Library veneers for folks not building embedded RTOS */

#define _XPNN   paramsnonnull()
#define _XRET   dontthrow nocallback dontdiscard returnsnonnull
#define _XMAL   returnspointerwithnoaliases _XRET
#define _XMALPG returnsaligned((PAGESIZE)) _XMAL

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » system calls                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int xsigaction(int, void *, uint64_t, uint64_t, struct sigaction *);
int xwrite(int, const void *, uint64_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » memory                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void xdie(void) wontreturn;
char *xdtoa(double) _XMAL;
char *xdtoaf(float) _XMAL;
char *xdtoal(long double) _XMAL;
char *xasprintf(const char *, ...) printfesque(1) paramsnonnull((1)) _XMAL;
char *xvasprintf(const char *, va_list) _XPNN _XMAL;
char *xgetline(struct FILE *) _XPNN mallocesque;
void *xmalloc(size_t) attributeallocsize((1)) _XMAL;
void *xrealloc(void *, size_t)
    attributeallocsize((2)) dontthrow nocallback dontdiscard;
void *xcalloc(size_t, size_t) attributeallocsize((1, 2)) _XMAL;
void *xvalloc(size_t) attributeallocsize((1)) _XMALPG;
void *xmemalign(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) _XMAL;
void *xmemalignzero(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) _XMAL;
char *xstrdup(const char *) _XPNN _XMAL;
char *xstrndup(const char *, size_t) _XPNN _XMAL;
char *xstrcat(const char *, ...) paramsnonnull((1)) nullterminated() _XMAL;
char *xstrmul(const char *, size_t) paramsnonnull((1)) _XMAL;
char *xinet_ntop(int, const void *) _XPNN _XMAL;
void *xunbinga(size_t, const char16_t *) attributeallocalign((1)) _XMAL _XRET;
void *xunbing(const char16_t *) _XMAL _XRET;
char16_t *utf8toutf16(const char *, size_t, size_t *) dontdiscard;
char *utf16toutf8(const char16_t *, size_t, size_t *) dontdiscard;
wchar_t *utf8toutf32(const char *, size_t, size_t *) dontdiscard;
wchar_t *utf16to32(const char16_t *, size_t, size_t *) dontdiscard;
char *xhomedir(void) dontdiscard;
char *xstripext(const char *) dontdiscard;
char *xstripexts(const char *) dontdiscard;
void *xload(bool *, void **, const void *, size_t, size_t);
void *xloadzd(bool *, void **, const void *, size_t, size_t, size_t, size_t,
              uint32_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » files                                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int rmrf(const char *);
int makedirs(const char *, unsigned);
char *xbasename(const char *) paramsnonnull() _XMAL;
char *xdirname(const char *) paramsnonnull() _XMAL;
char *xjoinpaths(const char *, const char *) paramsnonnull() _XMAL;
char *xreadlink(const char *) paramsnonnull() _XMAL;
char *xreadlinkat(int, const char *) paramsnonnull() _XMAL;
void xfixpath(void);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » time                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *xiso8601i(int) mallocesque;
char *xiso8601tv(struct timeval *) mallocesque;
char *xiso8601ts(struct timespec *) mallocesque;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » input / output                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void *xslurp(const char *, size_t *)
    paramsnonnull((1)) returnspointerwithnoaliases
    returnsaligned((PAGESIZE)) dontdiscard;
int xbarf(const char *, const void *, size_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » safety                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define xstrcat(...) (xstrcat)(__VA_ARGS__, NULL)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » processes                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int xspawn(struct rusage *);
int xvspawn(void (*)(void *), void *, struct rusage *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » generic typing                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __STDC_VERSION__ + 0 >= 201112

#define xiso8601(TS) \
  _Generic(*(TS), struct timeval : xiso8601tv, default : xiso8601ts)(TS)

#endif /* C11 */

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » link-time optimizations                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define xasprintf(FMT, ...) (xasprintf)(PFLINK(FMT), ##__VA_ARGS__)
#define xvasprintf(FMT, VA) (xvasprintf)(PFLINK(FMT), VA)
#define xsigaction(SIG, HANDLER, FLAGS, MASK, OLD) \
  ({                                               \
    __SIGACTION_YOINK(SIG);                        \
    xsigaction(SIG, HANDLER, FLAGS, MASK, OLD);    \
  })
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN net/http/csscolor.h */

#define COSMOPOLITAN_NET_HTTP_CSSCOLOR_H_

#define ALICEBLUE            0xFFFFF8F0u
#define ANTIQUEWHITE         0xFFD7EBFAu
#define ANTIQUEWHITE1        0xFFDBEFFFu
#define ANTIQUEWHITE2        0xFFCCDFEEu
#define ANTIQUEWHITE3        0xFFB0C0CDu
#define ANTIQUEWHITE4        0xFF78838Bu
#define AQUAMARINE           0xFFD4FF7Fu
#define AQUAMARINE1          0xFFD4FF7Fu
#define AQUAMARINE2          0xFFC6EE76u
#define AQUAMARINE3          0xFFAACD66u
#define AQUAMARINE4          0xFF748B45u
#define AZURE                0xFFFFFFF0u
#define AZURE1               0xFFFFFFF0u
#define AZURE2               0xFFEEEEE0u
#define AZURE3               0xFFCDCDC1u
#define AZURE4               0xFF8B8B83u
#define BEIGE                0xFFDCF5F5u
#define BISQUE               0xFFC4E4FFu
#define BISQUE1              0xFFC4E4FFu
#define BISQUE2              0xFFB7D5EEu
#define BISQUE3              0xFF9EB7CDu
#define BISQUE4              0xFF6B7D8Bu
#define BLACK                0xFF000000u
#define BLANCHEDALMOND       0xFFCDEBFFu
#define BLUE                 0xFFFF0000u
#define BLUE1                0xFFFF0000u
#define BLUE2                0xFFEE0000u
#define BLUE3                0xFFCD0000u
#define BLUE4                0xFF8B0000u
#define BLUEVIOLET           0xFFE22B8Au
#define BROWN                0xFF2A2AA5u
#define BROWN1               0xFF4040FFu
#define BROWN2               0xFF3B3BEEu
#define BROWN3               0xFF3333CDu
#define BROWN4               0xFF23238Bu
#define BURLYWOOD            0xFF87B8DEu
#define BURLYWOOD1           0xFF9BD3FFu
#define BURLYWOOD2           0xFF91C5EEu
#define BURLYWOOD3           0xFF7DAACDu
#define BURLYWOOD4           0xFF55738Bu
#define CADETBLUE            0xFFA09E5Fu
#define CADETBLUE1           0xFFFFF598u
#define CADETBLUE2           0xFFEEE58Eu
#define CADETBLUE3           0xFFCDC57Au
#define CADETBLUE4           0xFF8B8653u
#define CHARTREUSE           0xFF00FF7Fu
#define CHARTREUSE1          0xFF00FF7Fu
#define CHARTREUSE2          0xFF00EE76u
#define CHARTREUSE3          0xFF00CD66u
#define CHARTREUSE4          0xFF008B45u
#define CHOCOLATE            0xFF1E69D2u
#define CHOCOLATE1           0xFF247FFFu
#define CHOCOLATE2           0xFF2176EEu
#define CHOCOLATE3           0xFF1D66CDu
#define CHOCOLATE4           0xFF13458Bu
#define CORAL                0xFF507FFFu
#define CORAL1               0xFF5672FFu
#define CORAL2               0xFF506AEEu
#define CORAL3               0xFF455BCDu
#define CORAL4               0xFF2F3E8Bu
#define CORNFLOWERBLUE       0xFFED9564u
#define CORNSILK             0xFFDCF8FFu
#define CORNSILK1            0xFFDCF8FFu
#define CORNSILK2            0xFFCDE8EEu
#define CORNSILK3            0xFFB1C8CDu
#define CORNSILK4            0xFF78888Bu
#define CYAN                 0xFFFFFF00u
#define CYAN1                0xFFFFFF00u
#define CYAN2                0xFFEEEE00u
#define CYAN3                0xFFCDCD00u
#define CYAN4                0xFF8B8B00u
#define DARKBLUE             0xFF8B0000u
#define DARKCYAN             0xFF8B8B00u
#define DARKGOLDENROD        0xFF0B86B8u
#define DARKGOLDENROD1       0xFF0FB9FFu
#define DARKGOLDENROD2       0xFF0EADEEu
#define DARKGOLDENROD3       0xFF0C95CDu
#define DARKGOLDENROD4       0xFF08658Bu
#define DARKGRAY             0xFFA9A9A9u
#define DARKGREEN            0xFF006400u
#define DARKGREY             0xFFA9A9A9u
#define DARKKHAKI            0xFF6BB7BDu
#define DARKMAGENTA          0xFF8B008Bu
#define DARKOLIVEGREEN       0xFF2F6B55u
#define DARKOLIVEGREEN1      0xFF70FFCAu
#define DARKOLIVEGREEN2      0xFF68EEBCu
#define DARKOLIVEGREEN3      0xFF5ACDA2u
#define DARKOLIVEGREEN4      0xFF3D8B6Eu
#define DARKORANGE           0xFF008CFFu
#define DARKORANGE1          0xFF007FFFu
#define DARKORANGE2          0xFF0076EEu
#define DARKORANGE3          0xFF0066CDu
#define DARKORANGE4          0xFF00458Bu
#define DARKORCHID           0xFFCC3299u
#define DARKORCHID1          0xFFFF3EBFu
#define DARKORCHID2          0xFFEE3AB2u
#define DARKORCHID3          0xFFCD329Au
#define DARKORCHID4          0xFF8B2268u
#define DARKRED              0xFF00008Bu
#define DARKSALMON           0xFF7A96E9u
#define DARKSEAGREEN         0xFF8FBC8Fu
#define DARKSEAGREEN1        0xFFC1FFC1u
#define DARKSEAGREEN2        0xFFB4EEB4u
#define DARKSEAGREEN3        0xFF9BCD9Bu
#define DARKSEAGREEN4        0xFF698B69u
#define DARKSLATEBLUE        0xFF8B3D48u
#define DARKSLATEGRAY        0xFF4F4F2Fu
#define DARKSLATEGRAY1       0xFFFFFF97u
#define DARKSLATEGRAY2       0xFFEEEE8Du
#define DARKSLATEGRAY3       0xFFCDCD79u
#define DARKSLATEGRAY4       0xFF8B8B52u
#define DARKSLATEGREY        0xFF4F4F2Fu
#define DARKTURQUOISE        0xFFD1CE00u
#define DARKVIOLET           0xFFD30094u
#define DEEPPINK             0xFF9314FFu
#define DEEPPINK1            0xFF9314FFu
#define DEEPPINK2            0xFF8912EEu
#define DEEPPINK3            0xFF7610CDu
#define DEEPPINK4            0xFF500A8Bu
#define DEEPSKYBLUE          0xFFFFBF00u
#define DEEPSKYBLUE1         0xFFFFBF00u
#define DEEPSKYBLUE2         0xFFEEB200u
#define DEEPSKYBLUE3         0xFFCD9A00u
#define DEEPSKYBLUE4         0xFF8B6800u
#define DIMGRAY              0xFF696969u
#define DIMGREY              0xFF696969u
#define DODGERBLUE           0xFFFF901Eu
#define DODGERBLUE1          0xFFFF901Eu
#define DODGERBLUE2          0xFFEE861Cu
#define DODGERBLUE3          0xFFCD7418u
#define DODGERBLUE4          0xFF8B4E10u
#define FIREBRICK            0xFF2222B2u
#define FIREBRICK1           0xFF3030FFu
#define FIREBRICK2           0xFF2C2CEEu
#define FIREBRICK3           0xFF2626CDu
#define FIREBRICK4           0xFF1A1A8Bu
#define FLORALWHITE          0xFFF0FAFFu
#define FORESTGREEN          0xFF228B22u
#define GAINSBORO            0xFFDCDCDCu
#define GHOSTWHITE           0xFFFFF8F8u
#define GOLD                 0xFF00D7FFu
#define GOLD1                0xFF00D7FFu
#define GOLD2                0xFF00C9EEu
#define GOLD3                0xFF00ADCDu
#define GOLD4                0xFF00758Bu
#define GOLDENROD            0xFF20A5DAu
#define GOLDENROD1           0xFF25C1FFu
#define GOLDENROD2           0xFF22B4EEu
#define GOLDENROD3           0xFF1D9BCDu
#define GOLDENROD4           0xFF14698Bu
#define GRAY                 0xFFBEBEBEu
#define GRAY0                0xFF000000u
#define GRAY1                0xFF030303u
#define GRAY10               0xFF1A1A1Au
#define GRAY100              0xFFFFFFFFu
#define GRAY11               0xFF1C1C1Cu
#define GRAY12               0xFF1F1F1Fu
#define GRAY13               0xFF212121u
#define GRAY14               0xFF242424u
#define GRAY15               0xFF262626u
#define GRAY16               0xFF292929u
#define GRAY17               0xFF2B2B2Bu
#define GRAY18               0xFF2E2E2Eu
#define GRAY19               0xFF303030u
#define GRAY2                0xFF050505u
#define GRAY20               0xFF333333u
#define GRAY21               0xFF363636u
#define GRAY22               0xFF383838u
#define GRAY23               0xFF3B3B3Bu
#define GRAY24               0xFF3D3D3Du
#define GRAY25               0xFF404040u
#define GRAY26               0xFF424242u
#define GRAY27               0xFF454545u
#define GRAY28               0xFF474747u
#define GRAY29               0xFF4A4A4Au
#define GRAY3                0xFF080808u
#define GRAY30               0xFF4D4D4Du
#define GRAY31               0xFF4F4F4Fu
#define GRAY32               0xFF525252u
#define GRAY33               0xFF545454u
#define GRAY34               0xFF575757u
#define GRAY35               0xFF595959u
#define GRAY36               0xFF5C5C5Cu
#define GRAY37               0xFF5E5E5Eu
#define GRAY38               0xFF616161u
#define GRAY39               0xFF636363u
#define GRAY4                0xFF0A0A0Au
#define GRAY40               0xFF666666u
#define GRAY41               0xFF696969u
#define GRAY42               0xFF6B6B6Bu
#define GRAY43               0xFF6E6E6Eu
#define GRAY44               0xFF707070u
#define GRAY45               0xFF737373u
#define GRAY46               0xFF757575u
#define GRAY47               0xFF787878u
#define GRAY48               0xFF7A7A7Au
#define GRAY49               0xFF7D7D7Du
#define GRAY5                0xFF0D0D0Du
#define GRAY50               0xFF7F7F7Fu
#define GRAY51               0xFF828282u
#define GRAY52               0xFF858585u
#define GRAY53               0xFF878787u
#define GRAY54               0xFF8A8A8Au
#define GRAY55               0xFF8C8C8Cu
#define GRAY56               0xFF8F8F8Fu
#define GRAY57               0xFF919191u
#define GRAY58               0xFF949494u
#define GRAY59               0xFF969696u
#define GRAY6                0xFF0F0F0Fu
#define GRAY60               0xFF999999u
#define GRAY61               0xFF9C9C9Cu
#define GRAY62               0xFF9E9E9Eu
#define GRAY63               0xFFA1A1A1u
#define GRAY64               0xFFA3A3A3u
#define GRAY65               0xFFA6A6A6u
#define GRAY66               0xFFA8A8A8u
#define GRAY67               0xFFABABABu
#define GRAY68               0xFFADADADu
#define GRAY69               0xFFB0B0B0u
#define GRAY7                0xFF121212u
#define GRAY70               0xFFB3B3B3u
#define GRAY71               0xFFB5B5B5u
#define GRAY72               0xFFB8B8B8u
#define GRAY73               0xFFBABABAu
#define GRAY74               0xFFBDBDBDu
#define GRAY75               0xFFBFBFBFu
#define GRAY76               0xFFC2C2C2u
#define GRAY77               0xFFC4C4C4u
#define GRAY78               0xFFC7C7C7u
#define GRAY79               0xFFC9C9C9u
#define GRAY8                0xFF141414u
#define GRAY80               0xFFCCCCCCu
#define GRAY81               0xFFCFCFCFu
#define GRAY82               0xFFD1D1D1u
#define GRAY83               0xFFD4D4D4u
#define GRAY84               0xFFD6D6D6u
#define GRAY85               0xFFD9D9D9u
#define GRAY86               0xFFDBDBDBu
#define GRAY87               0xFFDEDEDEu
#define GRAY88               0xFFE0E0E0u
#define GRAY89               0xFFE3E3E3u
#define GRAY9                0xFF171717u
#define GRAY90               0xFFE5E5E5u
#define GRAY91               0xFFE8E8E8u
#define GRAY92               0xFFEBEBEBu
#define GRAY93               0xFFEDEDEDu
#define GRAY94               0xFFF0F0F0u
#define GRAY95               0xFFF2F2F2u
#define GRAY96               0xFFF5F5F5u
#define GRAY97               0xFFF7F7F7u
#define GRAY98               0xFFFAFAFAu
#define GRAY99               0xFFFCFCFCu
#define GREEN                0xFF00FF00u
#define GREEN1               0xFF00FF00u
#define GREEN2               0xFF00EE00u
#define GREEN3               0xFF00CD00u
#define GREEN4               0xFF008B00u
#define GREENYELLOW          0xFF2FFFADu
#define GREY                 0xFFBEBEBEu
#define GREY0                0xFF000000u
#define GREY1                0xFF030303u
#define GREY10               0xFF1A1A1Au
#define GREY100              0xFFFFFFFFu
#define GREY11               0xFF1C1C1Cu
#define GREY12               0xFF1F1F1Fu
#define GREY13               0xFF212121u
#define GREY14               0xFF242424u
#define GREY15               0xFF262626u
#define GREY16               0xFF292929u
#define GREY17               0xFF2B2B2Bu
#define GREY18               0xFF2E2E2Eu
#define GREY19               0xFF303030u
#define GREY2                0xFF050505u
#define GREY20               0xFF333333u
#define GREY21               0xFF363636u
#define GREY22               0xFF383838u
#define GREY23               0xFF3B3B3Bu
#define GREY24               0xFF3D3D3Du
#define GREY25               0xFF404040u
#define GREY26               0xFF424242u
#define GREY27               0xFF454545u
#define GREY28               0xFF474747u
#define GREY29               0xFF4A4A4Au
#define GREY3                0xFF080808u
#define GREY30               0xFF4D4D4Du
#define GREY31               0xFF4F4F4Fu
#define GREY32               0xFF525252u
#define GREY33               0xFF545454u
#define GREY34               0xFF575757u
#define GREY35               0xFF595959u
#define GREY36               0xFF5C5C5Cu
#define GREY37               0xFF5E5E5Eu
#define GREY38               0xFF616161u
#define GREY39               0xFF636363u
#define GREY4                0xFF0A0A0Au
#define GREY40               0xFF666666u
#define GREY41               0xFF696969u
#define GREY42               0xFF6B6B6Bu
#define GREY43               0xFF6E6E6Eu
#define GREY44               0xFF707070u
#define GREY45               0xFF737373u
#define GREY46               0xFF757575u
#define GREY47               0xFF787878u
#define GREY48               0xFF7A7A7Au
#define GREY49               0xFF7D7D7Du
#define GREY5                0xFF0D0D0Du
#define GREY50               0xFF7F7F7Fu
#define GREY51               0xFF828282u
#define GREY52               0xFF858585u
#define GREY53               0xFF878787u
#define GREY54               0xFF8A8A8Au
#define GREY55               0xFF8C8C8Cu
#define GREY56               0xFF8F8F8Fu
#define GREY57               0xFF919191u
#define GREY58               0xFF949494u
#define GREY59               0xFF969696u
#define GREY6                0xFF0F0F0Fu
#define GREY60               0xFF999999u
#define GREY61               0xFF9C9C9Cu
#define GREY62               0xFF9E9E9Eu
#define GREY63               0xFFA1A1A1u
#define GREY64               0xFFA3A3A3u
#define GREY65               0xFFA6A6A6u
#define GREY66               0xFFA8A8A8u
#define GREY67               0xFFABABABu
#define GREY68               0xFFADADADu
#define GREY69               0xFFB0B0B0u
#define GREY7                0xFF121212u
#define GREY70               0xFFB3B3B3u
#define GREY71               0xFFB5B5B5u
#define GREY72               0xFFB8B8B8u
#define GREY73               0xFFBABABAu
#define GREY74               0xFFBDBDBDu
#define GREY75               0xFFBFBFBFu
#define GREY76               0xFFC2C2C2u
#define GREY77               0xFFC4C4C4u
#define GREY78               0xFFC7C7C7u
#define GREY79               0xFFC9C9C9u
#define GREY8                0xFF141414u
#define GREY80               0xFFCCCCCCu
#define GREY81               0xFFCFCFCFu
#define GREY82               0xFFD1D1D1u
#define GREY83               0xFFD4D4D4u
#define GREY84               0xFFD6D6D6u
#define GREY85               0xFFD9D9D9u
#define GREY86               0xFFDBDBDBu
#define GREY87               0xFFDEDEDEu
#define GREY88               0xFFE0E0E0u
#define GREY89               0xFFE3E3E3u
#define GREY9                0xFF171717u
#define GREY90               0xFFE5E5E5u
#define GREY91               0xFFE8E8E8u
#define GREY92               0xFFEBEBEBu
#define GREY93               0xFFEDEDEDu
#define GREY94               0xFFF0F0F0u
#define GREY95               0xFFF2F2F2u
#define GREY96               0xFFF5F5F5u
#define GREY97               0xFFF7F7F7u
#define GREY98               0xFFFAFAFAu
#define GREY99               0xFFFCFCFCu
#define HONEYDEW             0xFFF0FFF0u
#define HONEYDEW1            0xFFF0FFF0u
#define HONEYDEW2            0xFFE0EEE0u
#define HONEYDEW3            0xFFC1CDC1u
#define HONEYDEW4            0xFF838B83u
#define HOTPINK              0xFFB469FFu
#define HOTPINK1             0xFFB46EFFu
#define HOTPINK2             0xFFA76AEEu
#define HOTPINK3             0xFF9060CDu
#define HOTPINK4             0xFF623A8Bu
#define INDIANRED            0xFF5C5CCDu
#define INDIANRED1           0xFF6A6AFFu
#define INDIANRED2           0xFF6363EEu
#define INDIANRED3           0xFF5555CDu
#define INDIANRED4           0xFF3A3A8Bu
#define IVORY                0xFFF0FFFFu
#define IVORY1               0xFFF0FFFFu
#define IVORY2               0xFFE0EEEEu
#define IVORY3               0xFFC1CDCDu
#define IVORY4               0xFF838B8Bu
#define KHAKI                0xFF8CE6F0u
#define KHAKI1               0xFF8FF6FFu
#define KHAKI2               0xFF85E6EEu
#define KHAKI3               0xFF73C6CDu
#define KHAKI4               0xFF4E868Bu
#define LAVENDER             0xFFFAE6E6u
#define LAVENDERBLUSH        0xFFF5F0FFu
#define LAVENDERBLUSH1       0xFFF5F0FFu
#define LAVENDERBLUSH2       0xFFE5E0EEu
#define LAVENDERBLUSH3       0xFFC5C1CDu
#define LAVENDERBLUSH4       0xFF86838Bu
#define LAWNGREEN            0xFF00FC7Cu
#define LEMONCHIFFON         0xFFCDFAFFu
#define LEMONCHIFFON1        0xFFCDFAFFu
#define LEMONCHIFFON2        0xFFBFE9EEu
#define LEMONCHIFFON3        0xFFA5C9CDu
#define LEMONCHIFFON4        0xFF70898Bu
#define LIGHTBLUE            0xFFE6D8ADu
#define LIGHTBLUE1           0xFFFFEFBFu
#define LIGHTBLUE2           0xFFEEDFB2u
#define LIGHTBLUE3           0xFFCDC09Au
#define LIGHTBLUE4           0xFF8B8368u
#define LIGHTCORAL           0xFF8080F0u
#define LIGHTCYAN            0xFFFFFFE0u
#define LIGHTCYAN1           0xFFFFFFE0u
#define LIGHTCYAN2           0xFFEEEED1u
#define LIGHTCYAN3           0xFFCDCDB4u
#define LIGHTCYAN4           0xFF8B8B7Au
#define LIGHTGOLDENROD       0xFF82DDEEu
#define LIGHTGOLDENROD1      0xFF8BECFFu
#define LIGHTGOLDENROD2      0xFF82DCEEu
#define LIGHTGOLDENROD3      0xFF70BECDu
#define LIGHTGOLDENROD4      0xFF4C818Bu
#define LIGHTGOLDENRODYELLOW 0xFFD2FAFAu
#define LIGHTGRAY            0xFFD3D3D3u
#define LIGHTGREEN           0xFF90EE90u
#define LIGHTGREY            0xFFD3D3D3u
#define LIGHTPINK            0xFFC1B6FFu
#define LIGHTPINK1           0xFFB9AEFFu
#define LIGHTPINK2           0xFFADA2EEu
#define LIGHTPINK3           0xFF958CCDu
#define LIGHTPINK4           0xFF655F8Bu
#define LIGHTSALMON          0xFF7AA0FFu
#define LIGHTSALMON1         0xFF7AA0FFu
#define LIGHTSALMON2         0xFF7295EEu
#define LIGHTSALMON3         0xFF6281CDu
#define LIGHTSALMON4         0xFF42578Bu
#define LIGHTSEAGREEN        0xFFAAB220u
#define LIGHTSKYBLUE         0xFFFACE87u
#define LIGHTSKYBLUE1        0xFFFFE2B0u
#define LIGHTSKYBLUE2        0xFFEED3A4u
#define LIGHTSKYBLUE3        0xFFCDB68Du
#define LIGHTSKYBLUE4        0xFF8B7B60u
#define LIGHTSLATEBLUE       0xFFFF7084u
#define LIGHTSLATEGRAY       0xFF998877u
#define LIGHTSLATEGREY       0xFF998877u
#define LIGHTSTEELBLUE       0xFFDEC4B0u
#define LIGHTSTEELBLUE1      0xFFFFE1CAu
#define LIGHTSTEELBLUE2      0xFFEED2BCu
#define LIGHTSTEELBLUE3      0xFFCDB5A2u
#define LIGHTSTEELBLUE4      0xFF8B7B6Eu
#define LIGHTYELLOW          0xFFE0FFFFu
#define LIGHTYELLOW1         0xFFE0FFFFu
#define LIGHTYELLOW2         0xFFD1EEEEu
#define LIGHTYELLOW3         0xFFB4CDCDu
#define LIGHTYELLOW4         0xFF7A8B8Bu
#define LIMEGREEN            0xFF32CD32u
#define LINEN                0xFFE6F0FAu
#define MAGENTA              0xFFFF00FFu
#define MAGENTA1             0xFFFF00FFu
#define MAGENTA2             0xFFEE00EEu
#define MAGENTA3             0xFFCD00CDu
#define MAGENTA4             0xFF8B008Bu
#define MAROON               0xFF6030B0u
#define MAROON1              0xFFB334FFu
#define MAROON2              0xFFA730EEu
#define MAROON3              0xFF9029CDu
#define MAROON4              0xFF621C8Bu
#define MEDIUMAQUAMARINE     0xFFAACD66u
#define MEDIUMBLUE           0xFFCD0000u
#define MEDIUMORCHID         0xFFD355BAu
#define MEDIUMORCHID1        0xFFFF66E0u
#define MEDIUMORCHID2        0xFFEE5FD1u
#define MEDIUMORCHID3        0xFFCD52B4u
#define MEDIUMORCHID4        0xFF8B377Au
#define MEDIUMPURPLE         0xFFDB7093u
#define MEDIUMPURPLE1        0xFFFF82ABu
#define MEDIUMPURPLE2        0xFFEE799Fu
#define MEDIUMPURPLE3        0xFFCD6889u
#define MEDIUMPURPLE4        0xFF8B475Du
#define MEDIUMSEAGREEN       0xFF71B33Cu
#define MEDIUMSLATEBLUE      0xFFEE687Bu
#define MEDIUMSPRINGGREEN    0xFF9AFA00u
#define MEDIUMTURQUOISE      0xFFCCD148u
#define MEDIUMVIOLETRED      0xFF8515C7u
#define MIDNIGHTBLUE         0xFF701919u
#define MINTCREAM            0xFFFAFFF5u
#define MISTYROSE            0xFFE1E4FFu
#define MISTYROSE1           0xFFE1E4FFu
#define MISTYROSE2           0xFFD2D5EEu
#define MISTYROSE3           0xFFB5B7CDu
#define MISTYROSE4           0xFF7B7D8Bu
#define MOCCASIN             0xFFB5E4FFu
#define NAVAJOWHITE          0xFFADDEFFu
#define NAVAJOWHITE1         0xFFADDEFFu
#define NAVAJOWHITE2         0xFFA1CFEEu
#define NAVAJOWHITE3         0xFF8BB3CDu
#define NAVAJOWHITE4         0xFF5E798Bu
#define NAVY                 0xFF800000u
#define NAVYBLUE             0xFF800000u
#define OLDLACE              0xFFE6F5FDu
#define OLIVEDRAB            0xFF238E6Bu
#define OLIVEDRAB1           0xFF3EFFC0u
#define OLIVEDRAB2           0xFF3AEEB3u
#define OLIVEDRAB3           0xFF32CD9Au
#define OLIVEDRAB4           0xFF228B69u
#define ORANGE               0xFF00A5FFu
#define ORANGE1              0xFF00A5FFu
#define ORANGE2              0xFF009AEEu
#define ORANGE3              0xFF0085CDu
#define ORANGE4              0xFF005A8Bu
#define ORANGERED            0xFF0045FFu
#define ORANGERED1           0xFF0045FFu
#define ORANGERED2           0xFF0040EEu
#define ORANGERED3           0xFF0037CDu
#define ORANGERED4           0xFF00258Bu
#define ORCHID               0xFFD670DAu
#define ORCHID1              0xFFFA83FFu
#define ORCHID2              0xFFE97AEEu
#define ORCHID3              0xFFC969CDu
#define ORCHID4              0xFF89478Bu
#define PALEGOLDENROD        0xFFAAE8EEu
#define PALEGREEN            0xFF98FB98u
#define PALEGREEN1           0xFF9AFF9Au
#define PALEGREEN2           0xFF90EE90u
#define PALEGREEN3           0xFF7CCD7Cu
#define PALEGREEN4           0xFF548B54u
#define PALETURQUOISE        0xFFEEEEAFu
#define PALETURQUOISE1       0xFFFFFFBBu
#define PALETURQUOISE2       0xFFEEEEAEu
#define PALETURQUOISE3       0xFFCDCD96u
#define PALETURQUOISE4       0xFF8B8B66u
#define PALEVIOLETRED        0xFF9370DBu
#define PALEVIOLETRED1       0xFFAB82FFu
#define PALEVIOLETRED2       0xFF9F79EEu
#define PALEVIOLETRED3       0xFF8968CDu
#define PALEVIOLETRED4       0xFF5D478Bu
#define PAPAYAWHIP           0xFFD5EFFFu
#define PEACHPUFF            0xFFB9DAFFu
#define PEACHPUFF1           0xFFB9DAFFu
#define PEACHPUFF2           0xFFADCBEEu
#define PEACHPUFF3           0xFF95AFCDu
#define PEACHPUFF4           0xFF65778Bu
#define PERU                 0xFF3F85CDu
#define PINK                 0xFFCBC0FFu
#define PINK1                0xFFC5B5FFu
#define PINK2                0xFFB8A9EEu
#define PINK3                0xFF9E91CDu
#define PINK4                0xFF6C638Bu
#define PLUM                 0xFFDDA0DDu
#define PLUM1                0xFFFFBBFFu
#define PLUM2                0xFFEEAEEEu
#define PLUM3                0xFFCD96CDu
#define PLUM4                0xFF8B668Bu
#define POWDERBLUE           0xFFE6E0B0u
#define PURPLE               0xFFF020A0u
#define PURPLE1              0xFFFF309Bu
#define PURPLE2              0xFFEE2C91u
#define PURPLE3              0xFFCD267Du
#define PURPLE4              0xFF8B1A55u
#define RED                  0xFF0000FFu
#define RED1                 0xFF0000FFu
#define RED2                 0xFF0000EEu
#define RED3                 0xFF0000CDu
#define RED4                 0xFF00008Bu
#define ROSYBROWN            0xFF8F8FBCu
#define ROSYBROWN1           0xFFC1C1FFu
#define ROSYBROWN2           0xFFB4B4EEu
#define ROSYBROWN3           0xFF9B9BCDu
#define ROSYBROWN4           0xFF69698Bu
#define ROYALBLUE            0xFFE16941u
#define ROYALBLUE1           0xFFFF7648u
#define ROYALBLUE2           0xFFEE6E43u
#define ROYALBLUE3           0xFFCD5F3Au
#define ROYALBLUE4           0xFF8B4027u
#define SADDLEBROWN          0xFF13458Bu
#define SALMON               0xFF7280FAu
#define SALMON1              0xFF698CFFu
#define SALMON2              0xFF6282EEu
#define SALMON3              0xFF5470CDu
#define SALMON4              0xFF394C8Bu
#define SANDYBROWN           0xFF60A4F4u
#define SEAGREEN             0xFF578B2Eu
#define SEAGREEN1            0xFF9FFF54u
#define SEAGREEN2            0xFF94EE4Eu
#define SEAGREEN3            0xFF80CD43u
#define SEAGREEN4            0xFF578B2Eu
#define SEASHELL             0xFFEEF5FFu
#define SEASHELL1            0xFFEEF5FFu
#define SEASHELL2            0xFFDEE5EEu
#define SEASHELL3            0xFFBFC5CDu
#define SEASHELL4            0xFF82868Bu
#define SIENNA               0xFF2D52A0u
#define SIENNA1              0xFF4782FFu
#define SIENNA2              0xFF4279EEu
#define SIENNA3              0xFF3968CDu
#define SIENNA4              0xFF26478Bu
#define SKYBLUE              0xFFEBCE87u
#define SKYBLUE1             0xFFFFCE87u
#define SKYBLUE2             0xFFEEC07Eu
#define SKYBLUE3             0xFFCDA66Cu
#define SKYBLUE4             0xFF8B704Au
#define SLATEBLUE            0xFFCD5A6Au
#define SLATEBLUE1           0xFFFF6F83u
#define SLATEBLUE2           0xFFEE677Au
#define SLATEBLUE3           0xFFCD5969u
#define SLATEBLUE4           0xFF8B3C47u
#define SLATEGRAY            0xFF908070u
#define SLATEGRAY1           0xFFFFE2C6u
#define SLATEGRAY2           0xFFEED3B9u
#define SLATEGRAY3           0xFFCDB69Fu
#define SLATEGRAY4           0xFF8B7B6Cu
#define SLATEGREY            0xFF908070u
#define SNOW                 0xFFFAFAFFu
#define SNOW1                0xFFFAFAFFu
#define SNOW2                0xFFE9E9EEu
#define SNOW3                0xFFC9C9CDu
#define SNOW4                0xFF89898Bu
#define SPRINGGREEN          0xFF7FFF00u
#define SPRINGGREEN1         0xFF7FFF00u
#define SPRINGGREEN2         0xFF76EE00u
#define SPRINGGREEN3         0xFF66CD00u
#define SPRINGGREEN4         0xFF458B00u
#define STEELBLUE            0xFFB48246u
#define STEELBLUE1           0xFFFFB863u
#define STEELBLUE2           0xFFEEAC5Cu
#define STEELBLUE3           0xFFCD944Fu
#define STEELBLUE4           0xFF8B6436u
#define TAN                  0xFF8CB4D2u
#define TAN1                 0xFF4FA5FFu
#define TAN2                 0xFF499AEEu
#define TAN3                 0xFF3F85CDu
#define TAN4                 0xFF2B5A8Bu
#define THISTLE              0xFFD8BFD8u
#define THISTLE1             0xFFFFE1FFu
#define THISTLE2             0xFFEED2EEu
#define THISTLE3             0xFFCDB5CDu
#define THISTLE4             0xFF8B7B8Bu
#define TOMATO               0xFF4763FFu
#define TOMATO1              0xFF4763FFu
#define TOMATO2              0xFF425CEEu
#define TOMATO3              0xFF394FCDu
#define TOMATO4              0xFF26368Bu
#define TURQUOISE            0xFFD0E040u
#define TURQUOISE1           0xFFFFF500u
#define TURQUOISE2           0xFFEEE500u
#define TURQUOISE3           0xFFCDC500u
#define TURQUOISE4           0xFF8B8600u
#define VIOLET               0xFFEE82EEu
#define VIOLETRED            0xFF9020D0u
#define VIOLETRED1           0xFF963EFFu
#define VIOLETRED2           0xFF8C3AEEu
#define VIOLETRED3           0xFF7832CDu
#define VIOLETRED4           0xFF52228Bu
#define WHEAT                0xFFB3DEF5u
#define WHEAT1               0xFFBAE7FFu
#define WHEAT2               0xFFAED8EEu
#define WHEAT3               0xFF96BACDu
#define WHEAT4               0xFF667E8Bu
#define WHITE                0xFFFFFFFFu
#define WHITESMOKE           0xFFF5F5F5u
#define YELLOW               0xFF00FFFFu
#define YELLOW1              0xFF00FFFFu
#define YELLOW2              0xFF00EEEEu
#define YELLOW3              0xFF00CDCDu
#define YELLOW4              0xFF008B8Bu
#define YELLOWGREEN          0xFF32CD9Au



/*!BEGIN net/http/escape.h */

#define COSMOPOLITAN_NET_HTTP_ESCAPE_H_

#define kControlWs 1
#define kControlC0 2
#define kControlC1 4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const char kEscapeAuthority[256];
extern const char kEscapeIp[256];
extern const char kEscapePath[256];
extern const char kEscapeSegment[256];
extern const char kEscapeParam[256];
extern const char kEscapeFragment[256];

char *EscapeHtml(const char *, size_t, size_t *);
char *EscapeUrl(const char *, size_t, size_t *, const char[256]);
char *EscapeUser(const char *, size_t, size_t *);
char *EscapePass(const char *, size_t, size_t *);
char *EscapeIp(const char *, size_t, size_t *);
char *EscapeHost(const char *, size_t, size_t *);
char *EscapePath(const char *, size_t, size_t *);
char *EscapeParam(const char *, size_t, size_t *);
char *EscapeFragment(const char *, size_t, size_t *);
char *EscapeSegment(const char *, size_t, size_t *);
char *EscapeJsStringLiteral(char **, size_t *, const char *, size_t, size_t *);

ssize_t HasControlCodes(const char *, size_t, int);
char *Underlong(const char *, size_t, size_t *);
char *DecodeLatin1(const char *, size_t, size_t *);
char *EncodeLatin1(const char *, size_t, size_t *, int);
char *EncodeHttpHeaderValue(const char *, size_t, size_t *);
char *VisualizeControlCodes(const char *, size_t, size_t *);
char *IndentLines(const char *, size_t, size_t *, size_t);
char *EncodeBase64(const char *, size_t, size_t *);
char *DecodeBase64(const char *, size_t, size_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN net/http/http.h */

#define COSMOPOLITAN_LIBC_HTTP_HTTP_H_

#define kHttpRequest  0
#define kHttpResponse 1

#define kHttpGet     1
#define kHttpHead    2
#define kHttpPost    3
#define kHttpPut     4
#define kHttpDelete  5
#define kHttpOptions 6
#define kHttpConnect 7
#define kHttpTrace   8
#define kHttpCopy    9
#define kHttpLock    10
#define kHttpMerge   11
#define kHttpMkcol   12
#define kHttpMove    13
#define kHttpNotify  14
#define kHttpPatch   15
#define kHttpReport  16
#define kHttpUnlock  17

#define kHttpStateStart   0
#define kHttpStateMethod  1
#define kHttpStateUri     2
#define kHttpStateVersion 3
#define kHttpStateStatus  4
#define kHttpStateMessage 5
#define kHttpStateName    6
#define kHttpStateColon   7
#define kHttpStateValue   8
#define kHttpStateCr      9
#define kHttpStateLf1     10
#define kHttpStateLf2     11

#define kHttpClientStateHeaders      0
#define kHttpClientStateBody         1
#define kHttpClientStateBodyChunked  2
#define kHttpClientStateBodyLengthed 3

#define kHttpStateChunkStart   0
#define kHttpStateChunkSize    1
#define kHttpStateChunkExt     2
#define kHttpStateChunkLf1     3
#define kHttpStateChunk        4
#define kHttpStateChunkCr2     5
#define kHttpStateChunkLf2     6
#define kHttpStateTrailerStart 7
#define kHttpStateTrailer      8
#define kHttpStateTrailerLf1   9
#define kHttpStateTrailerLf2   10

#define kHttpHost                          0
#define kHttpCacheControl                  1
#define kHttpConnection                    2
#define kHttpAccept                        3
#define kHttpAcceptLanguage                4
#define kHttpAcceptEncoding                5
#define kHttpUserAgent                     6
#define kHttpReferer                       7
#define kHttpXForwardedFor                 8
#define kHttpOrigin                        9
#define kHttpUpgradeInsecureRequests       10
#define kHttpPragma                        11
#define kHttpCookie                        12
#define kHttpDnt                           13
#define kHttpSecGpc                        14
#define kHttpFrom                          15
#define kHttpIfModifiedSince               16
#define kHttpXRequestedWith                17
#define kHttpXForwardedHost                18
#define kHttpXForwardedProto               19
#define kHttpXCsrfToken                    20
#define kHttpSaveData                      21
#define kHttpRange                         22
#define kHttpContentLength                 23
#define kHttpContentType                   24
#define kHttpVary                          25
#define kHttpDate                          26
#define kHttpServer                        27
#define kHttpExpires                       28
#define kHttpContentEncoding               29
#define kHttpLastModified                  30
#define kHttpEtag                          31
#define kHttpAllow                         32
#define kHttpContentRange                  33
#define kHttpAcceptCharset                 34
#define kHttpAccessControlAllowCredentials 35
#define kHttpAccessControlAllowHeaders     36
#define kHttpAccessControlAllowMethods     37
#define kHttpAccessControlAllowOrigin      38
#define kHttpAccessControlMaxAge           39
#define kHttpAccessControlMethod           40
#define kHttpAccessControlRequestHeaders   41
#define kHttpAccessControlRequestMethod    42
#define kHttpAccessControlRequestMethods   43
#define kHttpAge                           44
#define kHttpAuthorization                 45
#define kHttpContentBase                   46
#define kHttpContentDescription            47
#define kHttpContentDisposition            48
#define kHttpContentLanguage               49
#define kHttpContentLocation               50
#define kHttpContentMd5                    51
#define kHttpExpect                        52
#define kHttpIfMatch                       53
#define kHttpIfNoneMatch                   54
#define kHttpIfRange                       55
#define kHttpIfUnmodifiedSince             56
#define kHttpKeepAlive                     57
#define kHttpLink                          58
#define kHttpLocation                      59
#define kHttpMaxForwards                   60
#define kHttpProxyAuthenticate             61
#define kHttpProxyAuthorization            62
#define kHttpProxyConnection               63
#define kHttpPublic                        64
#define kHttpRetryAfter                    65
#define kHttpTe                            66
#define kHttpTrailer                       67
#define kHttpTransferEncoding              68
#define kHttpUpgrade                       69
#define kHttpWarning                       70
#define kHttpWwwAuthenticate               71
#define kHttpVia                           72
#define kHttpStrictTransportSecurity       73
#define kHttpXFrameOptions                 74
#define kHttpXContentTypeOptions           75
#define kHttpAltSvc                        76
#define kHttpReferrerPolicy                77
#define kHttpXXssProtection                78
#define kHttpAcceptRanges                  79
#define kHttpSetCookie                     80
#define kHttpSecChUa                       81
#define kHttpSecChUaMobile                 82
#define kHttpSecFetchSite                  83
#define kHttpSecFetchMode                  84
#define kHttpSecFetchUser                  85
#define kHttpSecFetchDest                  86
#define kHttpHeadersMax                    87

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct HttpSlice {
  short a, b;
};

struct HttpHeader {
  struct HttpSlice k;
  struct HttpSlice v;
};

struct HttpHeaders {
  unsigned n;
  struct HttpHeader *p;
};

struct HttpMessage {
  int i, a, status;
  unsigned char t;
  unsigned char type;
  unsigned char method;
  unsigned char version;
  struct HttpSlice k;
  struct HttpSlice uri;
  struct HttpSlice scratch;
  struct HttpSlice message;
  struct HttpSlice headers[kHttpHeadersMax];
  struct HttpSlice xmethod;
  struct HttpHeaders xheaders;
};

struct HttpUnchunker {
  int t;
  size_t i;
  size_t j;
  ssize_t m;
};

extern const char kHttpToken[256];
extern const char kHttpMethod[18][8];
extern const bool kHttpRepeatable[kHttpHeadersMax];

const char *GetHttpReason(int);
const char *GetHttpHeaderName(int);
int GetHttpHeader(const char *, size_t);
int GetHttpMethod(const char *, size_t);
void InitHttpMessage(struct HttpMessage *, int);
void DestroyHttpMessage(struct HttpMessage *);
int ParseHttpMessage(struct HttpMessage *, const char *, size_t);
bool HeaderHas(struct HttpMessage *, const char *, int, const char *, size_t);
int64_t ParseContentLength(const char *, size_t);
char *FormatHttpDateTime(char[hasatleast 30], struct tm *);
bool ParseHttpRange(const char *, size_t, long, long *, long *);
int64_t ParseHttpDateTime(const char *, size_t);
bool IsValidHttpToken(const char *, size_t);
bool IsValidCookieValue(const char *, size_t);
bool IsAcceptablePath(const char *, size_t);
bool IsAcceptableHost(const char *, size_t);
bool IsAcceptablePort(const char *, size_t);
bool IsReasonablePath(const char *, size_t);
int64_t ParseIp(const char *, size_t);
int ParseForwarded(const char *, size_t, uint32_t *, uint16_t *);
bool IsMimeType(const char *, size_t, const char *);
ssize_t Unchunk(struct HttpUnchunker *, char *, size_t, size_t *);
const char *FindContentType(const char *, size_t);
char *FoldHeader(struct HttpMessage *, char *, int, size_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN net/http/ip.h */

#define COSMOPOLITAN_NET_HTTP_IP_H_

#define kIpUnknown    0
#define kIpMulticast  1
#define kIpLoopback   2
#define kIpPrivate    3
#define kIpTestnet    4
#define kIpAfrinic    5
#define kIpLacnic     6
#define kIpApnic      7
#define kIpArin       8
#define kIpRipe       9
#define kIpDod        10
#define kIpAtt        11
#define kIpApple      12
#define kIpFord       13
#define kIpCogent     14
#define kIpPrudential 15
#define kIpUsps       16
#define kIpComcast    17
#define kIpFuture     18
#define kIpAnonymous  19

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool IsDodIp(uint32_t);
bool IsArinIp(uint32_t);
bool IsRipeIp(uint32_t);
bool IsApnicIp(uint32_t);
bool IsLacnicIp(uint32_t);
bool IsPublicIp(uint32_t);
bool IsPrivateIp(uint32_t);
bool IsAfrinicIp(uint32_t);
bool IsTestnetIp(uint32_t);
bool IsLoopbackIp(uint32_t);
bool IsMulticastIp(uint32_t);
bool IsAnonymousIp(uint32_t);
int CategorizeIp(uint32_t);
const char *GetIpCategoryName(int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN net/http/url.h */

#define COSMOPOLITAN_NET_HTTP_URL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct UrlView {
  size_t n;
  char *p;
};

struct UrlParams {
  size_t n;
  struct UrlParam {
    struct UrlView key;
    struct UrlView val;
  } * p;
};

struct Url {
  struct UrlView scheme; /* must be [A-Za-z][-+.0-9A-Za-z]* or empty */
  struct UrlView user;   /* depends on host non-absence */
  struct UrlView pass;   /* depends on user non-absence */
  struct UrlView host;   /* or reg_name */
  struct UrlView port;   /* depends on host non-absence */
  struct UrlView path;   /* or opaque_part */
  struct UrlParams params;
  struct UrlView fragment;
};

char *EncodeUrl(struct Url *, size_t *);
char *ParseUrl(const char *, size_t, struct Url *);
char *ParseParams(const char *, size_t, struct UrlParams *);
char *ParseRequestUri(const char *, size_t, struct Url *);
char *ParseHost(const char *, size_t, struct Url *);
char *EscapeUrlView(char *, struct UrlView *, const char[256]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/dlmalloc/dlmalloc.h */

#define COSMOPOLITAN_THIRD_PARTY_DLMALLOC_DLMALLOC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
  malloc(size_t n)
  Returns a pointer to a newly allocated chunk of at least n bytes, or
  null if no space is available, in which case errno is set to ENOMEM
  on ANSI C systems.

  If n is zero, malloc returns a minimum-sized chunk. (The minimum
  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
  systems.)  Note that size_t is an unsigned type, so calls with
  arguments that would be negative if signed are interpreted as
  requests for huge amounts of space, which will often fail. The
  maximum supported value of n differs across systems, but is in all
  cases less than the maximum representable value of a size_t.
*/
void* dlmalloc(size_t);

/*
  free(void* p)
  Releases the chunk of memory pointed to by p, that had been previously
  allocated using malloc or a related routine such as realloc.
  It has no effect if p is null. If p was not malloced or already
  freed, free(p) will by default cuase the current program to abort.
*/
void dlfree(void*);

/*
  calloc(size_t n_elements, size_t element_size);
  Returns a pointer to n_elements * element_size bytes, with all locations
  set to zero.
*/
void* dlcalloc(size_t, size_t);

/*
  realloc(void* p, size_t n)
  Returns a pointer to a chunk of size n that contains the same data
  as does chunk p up to the minimum of (n, p's size) bytes, or null
  if no space is available.

  The returned pointer may or may not be the same as p. The algorithm
  prefers extending p in most cases when possible, otherwise it
  employs the equivalent of a malloc-copy-free sequence.

  If p is null, realloc is equivalent to malloc.

  If space is not available, realloc returns null, errno is set (if on
  ANSI) and p is NOT freed.

  if n is for fewer bytes than already held by p, the newly unused
  space is lopped off and freed if possible.  realloc with a size
  argument of zero (re)allocates a minimum-sized chunk.

  The old unix realloc convention of allowing the last-free'd chunk
  to be used as an argument to realloc is not supported.
*/
void* dlrealloc(void*, size_t);

/*
  realloc_in_place(void* p, size_t n)
  Resizes the space allocated for p to size n, only if this can be
  done without moving p (i.e., only if there is adjacent space
  available if n is greater than p's current allocated size, or n is
  less than or equal to p's size). This may be used instead of plain
  realloc if an alternative allocation strategy is needed upon failure
  to expand space; for example, reallocation of a buffer that must be
  memory-aligned or cleared. You can use realloc_in_place to trigger
  these alternatives only when needed.

  Returns p if successful; otherwise null.
*/
void* dlrealloc_in_place(void*, size_t);

/*
  memalign(size_t alignment, size_t n);
  Returns a pointer to a newly allocated chunk of n bytes, aligned
  in accord with the alignment argument.

  The alignment argument should be a power of two. If the argument is
  not a power of two, the nearest greater power is used.
  8-byte alignment is guaranteed by normal malloc calls, so don't
  bother calling memalign with an argument of 8 or less.

  Overreliance on memalign is a sure way to fragment space.
*/
void* dlmemalign(size_t, size_t);

/*
  int posix_memalign(void** pp, size_t alignment, size_t n);
  Allocates a chunk of n bytes, aligned in accord with the alignment
  argument. Differs from memalign only in that it (1) assigns the
  allocated memory to *pp rather than returning it, (2) fails and
  returns EINVAL if the alignment is not a power of two (3) fails and
  returns ENOMEM if memory cannot be allocated.
*/
int dlposix_memalign(void**, size_t, size_t);

/*
  valloc(size_t n);
  Equivalent to memalign(pagesize, n), where pagesize is the page
  size of the system. If the pagesize is unknown, 4096 is used.
*/
void* dlvalloc(size_t);

/*
  mallopt(int parameter_number, int parameter_value)
  Sets tunable parameters The format is to provide a
  (parameter-number, parameter-value) pair.  mallopt then sets the
  corresponding parameter to the argument value if it can (i.e., so
  long as the value is meaningful), and returns 1 if successful else
  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,
  normally defined in malloc.h.  None of these are use in this malloc,
  so setting them has no effect. But this malloc also supports other
  options in mallopt:

  Symbol            param #  default    allowed param values
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1U disables trimming)
  M_GRANULARITY        -2     page size   any power of 2 >= page size
  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
*/
int dlmallopt(int, int);

/*
  malloc_footprint();
  Returns the number of bytes obtained from the system.  The total
  number of bytes allocated by malloc, realloc etc., is less than this
  value. Unlike mallinfo, this function returns only a precomputed
  result, so can be called frequently to monitor memory consumption.
  Even if locks are otherwise defined, this function does not use them,
  so results might not be up to date.
*/
size_t dlmalloc_footprint(void);

/*
  malloc_max_footprint();
  Returns the maximum number of bytes obtained from the system. This
  value will be greater than current footprint if deallocated space
  has been reclaimed by the system. The peak number of bytes allocated
  by malloc, realloc etc., is less than this value. Unlike mallinfo,
  this function returns only a precomputed result, so can be called
  frequently to monitor memory consumption.  Even if locks are
  otherwise defined, this function does not use them, so results might
  not be up to date.
*/
size_t dlmalloc_max_footprint(void);

/*
  malloc_footprint_limit();
  Returns the number of bytes that the heap is allowed to obtain from
  the system, returning the last value returned by
  malloc_set_footprint_limit, or the maximum size_t value if
  never set. The returned value reflects a permission. There is no
  guarantee that this number of bytes can actually be obtained from
  the system.
*/
size_t dlmalloc_footprint_limit(void);

/*
  malloc_set_footprint_limit();
  Sets the maximum number of bytes to obtain from the system, causing
  failure returns from malloc and related functions upon attempts to
  exceed this value. The argument value may be subject to page
  rounding to an enforceable limit; this actual value is returned.
  Using an argument of the maximum possible size_t effectively
  disables checks. If the argument is less than or equal to the
  current malloc_footprint, then all future allocations that require
  additional system memory will fail. However, invocation cannot
  retroactively deallocate existing used memory.
*/
size_t dlmalloc_set_footprint_limit(size_t bytes);

/*
  malloc_inspect_all(void(*handler)(void *start,
                                    void *end,
                                    size_t used_bytes,
                                    void* callback_arg),
                      void* arg);
  Traverses the heap and calls the given handler for each managed
  region, skipping all bytes that are (or may be) used for bookkeeping
  purposes.  Traversal does not include include chunks that have been
  directly memory mapped. Each reported region begins at the start
  address, and continues up to but not including the end address.  The
  first used_bytes of the region contain allocated data. If
  used_bytes is zero, the region is unallocated. The handler is
  invoked with the given callback argument. If locks are defined, they
  are held during the entire traversal. It is a bad idea to invoke
  other malloc functions from within the handler.

  For example, to count the number of in-use chunks with size greater
  than 1000, you could write:
  static int count = 0;
  void count_chunks(void* start, void* end, size_t used, void* arg) {
    if (used >= 1000) ++count;
  }
  then:
    malloc_inspect_all(count_chunks, NULL);

  malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
*/
void dlmalloc_inspect_all(void (*handler)(void*, void*, size_t, void*),
                          void* arg);

/*
  mallinfo()
  Returns (by copy) a struct containing various summary statistics:

  arena:     current total non-mmapped bytes allocated from system
  ordblks:   the number of free chunks
  smblks:    always zero.
  hblks:     current number of mmapped regions
  hblkhd:    total bytes held in mmapped regions
  usmblks:   the maximum total allocated space. This will be greater
                than current total if trimming has occurred.
  fsmblks:   always zero
  uordblks:  current total allocated space (normal or mmapped)
  fordblks:  total free space
  keepcost:  the maximum number of bytes that could ideally be released
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)

  Because these fields are ints, but internal bookkeeping may
  be kept as longs, the reported values may wrap around zero and
  thus be inaccurate.
*/

struct mallinfo dlmallinfo(void);

/*
  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);

  independent_calloc is similar to calloc, but instead of returning a
  single cleared space, it returns an array of pointers to n_elements
  independent elements that can hold contents of size elem_size, each
  of which starts out cleared, and can be independently freed,
  realloc'ed etc. The elements are guaranteed to be adjacently
  allocated (this is not guaranteed to occur with multiple callocs or
  mallocs), which may also improve cache locality in some
  applications.

  The "chunks" argument is optional (i.e., may be null, which is
  probably the most typical usage). If it is null, the returned array
  is itself dynamically allocated and should also be freed when it is
  no longer needed. Otherwise, the chunks array must be of at least
  n_elements in length. It is filled in with the pointers to the
  chunks.

  In either case, independent_calloc returns this pointer array, or
  null if the allocation failed.  If n_elements is zero and "chunks"
  is null, it returns a chunk representing an array with zero elements
  (which should be freed if not wanted).

  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.

  independent_calloc simplifies and speeds up implementations of many
  kinds of pools.  It may also be useful when constructing large data
  structures that initially have a fixed number of fixed-sized nodes,
  but the number is not known at compile time, and some of the nodes
  may later need to be freed. For example:

  struct Node { int item; struct Node* next; };

  struct Node* build_list() {
    struct Node** pool;
    int n = read_number_of_nodes_needed();
    if (n <= 0) return 0;
    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
    if (pool == 0) die();
    // organize into a linked list...
    struct Node* first = pool[0];
    for (i = 0; i < n-1; ++i)
      pool[i]->next = pool[i+1];
    free(pool);     // Can now free the array (or not, if it is needed later)
    return first;
  }
*/
void** dlindependent_calloc(size_t, size_t, void**);

/*
  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);

  independent_comalloc allocates, all at once, a set of n_elements
  chunks with sizes indicated in the "sizes" array.    It returns
  an array of pointers to these elements, each of which can be
  independently freed, realloc'ed etc. The elements are guaranteed to
  be adjacently allocated (this is not guaranteed to occur with
  multiple callocs or mallocs), which may also improve cache locality
  in some applications.

  The "chunks" argument is optional (i.e., may be null). If it is null
  the returned array is itself dynamically allocated and should also
  be freed when it is no longer needed. Otherwise, the chunks array
  must be of at least n_elements in length. It is filled in with the
  pointers to the chunks.

  In either case, independent_comalloc returns this pointer array, or
  null if the allocation failed.  If n_elements is zero and chunks is
  null, it returns a chunk representing an array with zero elements
  (which should be freed if not wanted).

  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.

  independent_comallac differs from independent_calloc in that each
  element may have a different size, and also that it does not
  automatically clear elements.

  independent_comalloc can be used to speed up allocation in cases
  where several structs or objects must always be allocated at the
  same time.  For example:

  struct Head { ... }
  struct Foot { ... }

  void send_message(char* msg) {
    int msglen = strlen(msg);
    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
    void* chunks[3];
    if (independent_comalloc(3, sizes, chunks) == 0)
      die();
    struct Head* head = (struct Head*)(chunks[0]);
    char*        body = (char*)(chunks[1]);
    struct Foot* foot = (struct Foot*)(chunks[2]);
    // ...
  }

  In general though, independent_comalloc is worth using only for
  larger values of n_elements. For small values, you probably won't
  detect enough difference from series of malloc calls to bother.

  Overuse of independent_comalloc can increase overall memory usage,
  since it cannot reuse existing noncontiguous small chunks that
  might be available for some of the elements.
*/
void** dlindependent_comalloc(size_t, size_t*, void**);

/*
  bulk_free(void* array[], size_t n_elements)
  Frees and clears (sets to null) each non-null pointer in the given
  array.  This is likely to be faster than freeing them one-by-one.
  If footers are used, pointers that have been allocated in different
  mspaces are not freed or cleared, and the count of all such pointers
  is returned.  For large arrays of pointers with poor locality, it
  may be worthwhile to sort this array before calling bulk_free.
*/
size_t dlbulk_free(void**, size_t n_elements);

/*
  pvalloc(size_t n);
  Equivalent to valloc(minimum-page-that-holds(n)), that is,
  round up n to nearest pagesize.
 */
void* dlpvalloc(size_t);

/*
  malloc_trim(size_t pad);

  If possible, gives memory back to the system (via negative arguments
  to sbrk) if there is unused memory at the `high' end of the malloc
  pool or in unused MMAP segments. You can call this after freeing
  large blocks of memory to potentially reduce the system-level memory
  requirements of a program. However, it cannot guarantee to reduce
  memory. Under some allocation patterns, some large free blocks of
  memory will be locked between two used chunks, so they cannot be
  given back to the system.

  The `pad' argument to malloc_trim represents the amount of free
  trailing space to leave untrimmed. If this argument is zero, only
  the minimum amount of memory to maintain internal data structures
  will be left. Non-zero arguments can be supplied to maintain enough
  trailing space to service future expected allocations without having
  to re-obtain memory from the system.

  Malloc_trim returns 1 if it actually released any memory, else 0.
*/
int dlmalloc_trim(size_t);

/*
  malloc_stats();
  Prints on stderr the amount of space obtained from the system (both
  via sbrk and mmap), the maximum amount (which may be more than
  current if malloc_trim and/or munmap got called), and the current
  number of bytes allocated via malloc (or realloc, etc) but not yet
  freed. Note that this is the number of bytes allocated, not the
  number requested. It will be larger than the number requested
  because of alignment and bookkeeping overhead. Because it includes
  alignment wastage as being in use, this figure may be greater than
  zero even when no user-level chunks are allocated.

  The reported current and maximum system memory can be inaccurate if
  a program makes other calls to system memory allocation functions
  (normally sbrk) outside of malloc.

  malloc_stats prints only the most commonly interesting statistics.
  More information can be obtained by calling mallinfo.

  malloc_stats is not compiled if NO_MALLOC_STATS is defined.
*/
void dlmalloc_stats(void);

/*
  malloc_usable_size(void* p);

  Returns the number of bytes you can actually use in
  an allocated chunk, which may be more than you requested (although
  often not) due to alignment and minimum size constraints.
  You can use this many bytes without worrying about
  overwriting other allocated objects. This is not a particularly great
  programming practice. malloc_usable_size can be more useful in
  debugging and assertions, for example:

  p = malloc(n);
  assert(malloc_usable_size(p) >= 256);
*/
size_t dlmalloc_usable_size(const void*);

/*
  mspace is an opaque type representing an independent
  region of space that supports mspace_malloc, etc.
*/
typedef void* mspace;

/*
  create_mspace creates and returns a new independent space with the
  given initial capacity, or, if 0, the default granularity size.  It
  returns null if there is no system memory available to create the
  space.  If argument locked is non-zero, the space uses a separate
  lock to control access. The capacity of the space will grow
  dynamically as needed to service mspace_malloc requests.  You can
  control the sizes of incremental increases of this space by
  compiling with a different DEFAULT_GRANULARITY or dynamically
  setting with mallopt(M_GRANULARITY, value).
*/
mspace create_mspace(size_t capacity, int locked);

/*
  destroy_mspace destroys the given space, and attempts to return all
  of its memory back to the system, returning the total number of
  bytes freed. After destruction, the results of access to all memory
  used by the space become undefined.
*/
size_t destroy_mspace(mspace msp);

/*
  create_mspace_with_base uses the memory supplied as the initial base
  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
  space is used for bookkeeping, so the capacity must be at least this
  large. (Otherwise 0 is returned.) When this initial space is
  exhausted, additional memory will be obtained from the system.
  Destroying this space will deallocate all additionally allocated
  space (if possible) but not the initial base.
*/
mspace create_mspace_with_base(void* base, size_t capacity, int locked);

/*
  mspace_track_large_chunks controls whether requests for large chunks
  are allocated in their own untracked mmapped regions, separate from
  others in this mspace. By default large chunks are not tracked,
  which reduces fragmentation. However, such chunks are not
  necessarily released to the system upon destroy_mspace.  Enabling
  tracking by setting to true may increase fragmentation, but avoids
  leakage when relying on destroy_mspace to release all memory
  allocated using this space.  The function returns the previous
  setting.
*/
int mspace_track_large_chunks(mspace msp, int enable);

/*
  mspace_mallinfo behaves as mallinfo, but reports properties of
  the given space.
*/
struct mallinfo mspace_mallinfo(mspace msp);

/*
  An alias for mallopt.
*/
int mspace_mallopt(int, int);

/*
  The following operate identically to their malloc counterparts
  but operate only for the given mspace argument
*/
void* mspace_malloc(mspace msp, size_t bytes);
void mspace_free(mspace msp, void* mem);
void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
void* mspace_realloc(mspace msp, void* mem, size_t newsize);
void* mspace_realloc_in_place(mspace msp, void* mem, size_t newsize);
void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
void** mspace_independent_calloc(mspace msp, size_t n_elements,
                                 size_t elem_size, void* chunks[]);
void** mspace_independent_comalloc(mspace msp, size_t n_elements,
                                   size_t sizes[], void* chunks[]);
size_t mspace_bulk_free(mspace msp, void**, size_t n_elements);
size_t mspace_usable_size(const void* mem);
void mspace_malloc_stats(mspace msp);
int mspace_trim(mspace msp, size_t pad);
size_t mspace_footprint(mspace msp);
size_t mspace_max_footprint(mspace msp);
size_t mspace_footprint_limit(mspace msp);
size_t mspace_set_footprint_limit(mspace msp, size_t bytes);
void mspace_inspect_all(mspace msp,
                        void (*handler)(void*, void*, size_t, void*),
                        void* arg);

void dlmalloc_abort(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/gdtoa/gdtoa.h */

#define COSMOPOLITAN_THIRD_PARTY_GDTOA_GDTOA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Configures g_*fmt()
 *
 * @param ic
 * 	0 ==> Infinity or NaN
 * 	1 ==> infinity or nan
 * 	2 ==> INFINITY or NAN
 * 	3 ==> Inf or NaN
 * 	4 ==> inf or nan
 * 	5 ==> INF or NAN
 * @param ic determines if NaNs are rendered as NaN(...)
 * 	0 ==> no
 * 	1 ==> yes
 * 	2 ==> no for default NaN values; yes otherwise
 * @param ns determines sign of NaN values reported
 * 	0 ==> distinguish NaN and -NaN
 * 	1 ==> report both as NaN
 */
#define NIK(ic, nb, ns) (ic + 6 * (nb + 3 * ns))

enum {
  /* return values from strtodg */
  STRTOG_Zero = 0,
  STRTOG_Normal = 1,
  STRTOG_Denormal = 2,
  STRTOG_Infinite = 3,
  STRTOG_NaN = 4,
  STRTOG_NaNbits = 5,
  STRTOG_NoNumber = 6,
  STRTOG_Retmask = 7,
  /* The following may be or-ed into one of the above values. */
  STRTOG_Neg = 0x08,    /* does not affect STRTOG_Inexlo or STRTOG_Inexhi */
  STRTOG_Inexlo = 0x10, /* returned result rounded toward zero */
  STRTOG_Inexhi = 0x20, /* returned result rounded away from zero */
  STRTOG_Inexact = 0x30,
  STRTOG_Underflow = 0x40,
  STRTOG_Overflow = 0x80
};

typedef struct FPI {
  int nbits;
  int emin;
  int emax;
  int rounding;
  int sudden_underflow;
  int int_max;
} FPI;

enum {
  /* FPI.rounding values: same as FLT_ROUNDS */
  FPI_Round_zero = 0,
  FPI_Round_near = 1,
  FPI_Round_up = 2,
  FPI_Round_down = 3
};

char *dtoa(double, int, int, int *, int *, char **);
char *gdtoa(const FPI *, int, unsigned *, int *, int, int, int *, char **);
void freedtoa(char *);

double atof(const char *);
float strtof(const char *, char **);
double strtod(const char *, char **);
int strtodg(const char *, char **, const FPI *, int *, unsigned *);
long double strtold(const char *, char **);

char *g_ddfmt(char *, double *, int, size_t);
char *g_ddfmt_p(char *, double *, int, size_t, int);
char *g_dfmt(char *, double *, int, size_t);
char *g_dfmt_p(char *, double *, int, size_t, int);
char *g_ffmt(char *, float *, int, size_t);
char *g_ffmt_p(char *, float *, int, size_t, int);
char *g_Qfmt(char *, void *, int, size_t);
char *g_Qfmt_p(char *, void *, int, size_t, int);
char *g_xfmt(char *, void *, int, size_t);
char *g_xfmt_p(char *, void *, int, size_t, int);
char *g_xLfmt(char *, void *, int, size_t);
char *g_xLfmt_p(char *, void *, int, size_t, int);

int strtoId(const char *, char **, double *, double *);
int strtoIdd(const char *, char **, double *, double *);
int strtoIf(const char *, char **, float *, float *);
int strtoIQ(const char *, char **, void *, void *);
int strtoIx(const char *, char **, void *, void *);
int strtoIxL(const char *, char **, void *, void *);
int strtord(const char *, char **, int, double *);
int strtordd(const char *, char **, int, double *);
int strtorf(const char *, char **, int, float *);
int strtorQ(const char *, char **, int, void *);
int strtorx(const char *, char **, int, void *);
int strtorxL(const char *, char **, int, void *);

#if 1
int strtodI(const char *, char **, double *);
int strtopd(const char *, char **, double *);
int strtopdd(const char *, char **, double *);
int strtopf(const char *, char **, float *);
int strtopQ(const char *, char **, void *);
int strtopx(const char *, char **, void *);
int strtopxL(const char *, char **, void *);
#else
#define strtopd(s, se, x)  strtord(s, se, 1, x)
#define strtopdd(s, se, x) strtordd(s, se, 1, x)
#define strtopf(s, se, x)  strtorf(s, se, 1, x)
#define strtopQ(s, se, x)  strtorQ(s, se, 1, x)
#define strtopx(s, se, x)  strtorx(s, se, 1, x)
#define strtopxL(s, se, x) strtorxL(s, se, 1, x)
#endif

float wcstof(const wchar_t *, wchar_t **);
double wcstod(const wchar_t *, wchar_t **);
long double wcstold(const wchar_t *, wchar_t **);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/gdtoa/lock.h */

#define COSMOPOLITAN_THIRD_PARTY_GDTOA_LOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int __gdtoa_lock(void);
int __gdtoa_unlock(void);
int __gdtoa_lock1(void);
int __gdtoa_unlock1(void);

#ifdef _NOPL0
#define __gdtoa_lock()    _NOPL0("__threadcalls", __gdtoa_lock)
#define __gdtoa_unlock()  _NOPL0("__threadcalls", __gdtoa_unlock)
#define __gdtoa_lock1()   _NOPL0("__threadcalls", __gdtoa_lock1)
#define __gdtoa_unlock1() _NOPL0("__threadcalls", __gdtoa_unlock1)
#else
#define __gdtoa_lock()    (__threaded ? __gdtoa_lock() : 0)
#define __gdtoa_unlock()  (__threaded ? __gdtoa_unlock() : 0)
#define __gdtoa_lock1()   (__threaded ? __gdtoa_lock1() : 0)
#define __gdtoa_unlock1() (__threaded ? __gdtoa_unlock1() : 0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/getopt/getopt.h */

#define COSMOPOLITAN_THIRD_PARTY_GETOPT_GETOPT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern char *optarg;
extern int optind, opterr, optopt, optreset;
int getopt(int nargc, char *const nargv[], const char *ostr);

#define no_argument 0
#define required_argument 1
#define optional_argument 2
struct option {
  const char *name;
  int has_arg;
  int *flag;
  int val;
};
int getopt_long(int nargc, char *const *nargv, const char *options,
                const struct option *long_options, int *idx);
int getopt_long_only(int nargc, char *const *nargv, const char *options,
                     const struct option *long_options, int *idx);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/crypt.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_CRYPT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct crypt_data {
  int initialized;
  char __buf[256];
};

char *crypt(const char *, const char *);
char *crypt_r(const char *, const char *, struct crypt_data *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/fnmatch.h */

#define COSMOPOLITAN_THIRD_PARTY_REGEX_FNMATCH_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define FNM_PATHNAME    0x1
#define FNM_NOESCAPE    0x2
#define FNM_PERIOD      0x4
#define FNM_LEADING_DIR 0x8
#define FNM_CASEFOLD    0x10
#define FNM_FILE_NAME   FNM_PATHNAME

#define FNM_NOMATCH 1
#define FNM_NOSYS   (-1)

int fnmatch(const char *, const char *, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/ftw.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_FTW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define FTW_F   1 /* file */
#define FTW_D   2 /* directory */
#define FTW_DNR 3 /* directory that cannot be read */
#define FTW_NS  4 /* not a symbolic link and stat failed */
#define FTW_SL  5 /* symbolic link */
#define FTW_DP  6 /* directory and FTW_DEPTH was specified */
#define FTW_SLN 7 /* symbolic link pointing to nonexistent file */

#define FTW_PHYS  1
#define FTW_MOUNT 2
#define FTW_CHDIR 4
#define FTW_DEPTH 8

struct FTW {
  int base;
  int level;
};

int ftw(const char *, int (*)(const char *, const struct stat *, int), int);
int nftw(const char *,
         int (*)(const char *, const struct stat *, int, struct FTW *), int,
         int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/glob.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_GLOB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define GLOB_ERR      0x01
#define GLOB_MARK     0x02
#define GLOB_NOSORT   0x04
#define GLOB_DOOFFS   0x08 /* reserves null slots at start of gl_pathv */
#define GLOB_NOCHECK  0x10 /* just yield pattern if GLOB_NOMATCH happens */
#define GLOB_APPEND   0x20 /* enables us to call glob() multiple times */
#define GLOB_NOESCAPE 0x40 /* don't allow things like \*\?\[\] escaping */
#define GLOB_PERIOD   0x80

#define GLOB_TILDE       0x1000
#define GLOB_TILDE_CHECK 0x4000

#define GLOB_NOSPACE 1
#define GLOB_ABORTED 2
#define GLOB_NOMATCH 3
#define GLOB_NOSYS   4

typedef struct {
  size_t gl_pathc;
  char **gl_pathv;
  size_t gl_offs;
  int __dummy1;
  void *__dummy2[5];
} glob_t;

int glob(const char *, int, int (*)(const char *, int), glob_t *);
void globfree(glob_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/passwd.h */

#define COSMOPOLITAN_LIBC_PASSWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct FILE;

struct passwd {
  char *pw_name;
  char *pw_passwd;
  uint32_t pw_uid;
  uint32_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};

void setpwent(void);
void endpwent(void);
struct passwd *getpwent(void);
struct passwd *getpwuid(uint32_t);
struct passwd *getpwnam(const char *);
int getpwuid_r(uint32_t, struct passwd *, char *, size_t, struct passwd **);
int getpwnam_r(const char *, struct passwd *, char *, size_t, struct passwd **);
struct passwd *fgetpwent(struct FILE *);
int putpwent(const struct passwd *, struct FILE *);

struct group {
  char *gr_name;
  char *gr_passwd;
  int32_t gr_gid;
  char **gr_mem;
};

struct group *getgrgid(gid_t);
struct group *getgrnam(const char *);
int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);
int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);
struct group *getgrent(void);
void endgrent(void);
void setgrent(void);
struct group *fgetgrent(struct FILE *);
int putgrent(const struct group *, struct FILE *);
int getgrouplist(const char *, gid_t, gid_t *, int *);
int setgroups(size_t, const int32_t *);
int initgroups(const char *, int32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/tempnam.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_TEMPNAM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

char *tempnam(const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/zlib/puff.h */

#define COSMOPOLITAN_THIRD_PARTY_ZLIB_PUFF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int puff(unsigned char *dest, unsigned long *destlen,
         const unsigned char *source, unsigned long *sourcelen);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/zlib/zconf.h */

#define COSMOPOLITAN_THIRD_PARTY_ZLIB_ZCONF_H_

#define STDC
#define STDC99
#define MAX_MEM_LEVEL 9
#define DEF_MEM_LEVEL 8
#define MAX_WBITS     15 /* 32K LZ77 window */

#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef unsigned char Byte;
typedef unsigned long uInt;  /* 16 bits or more */
typedef unsigned long uLong; /* 32 bits or more */
typedef Byte Bytef;
typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;
typedef void const *voidpc;
typedef void *voidpf;
typedef void *voidp;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/zlib/zlib.h */

#define COSMOPOLITAN_THIRD_PARTY_ZLIB_ZLIB_H_

/**
 * @fileoverview zlib
 *
 * The 'zlib' compression library provides in-memory
 * compression and decompression functions, including integrity checks
 * of the uncompressed data. This version of the library supports only
 * one compression method (deflation) but other algorithms will be added
 * later and will have the same stream interface.
 *
 * Compression can be done in a single step if the buffers are large enough,
 * or can be done by repeated calls of the compression function.  In the latter
 * case, the application must provide more input and/or consume the output
 * (providing more output space) before each call.
 *
 * The compressed data format used by default by the in-memory functions is
 * the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
 * around a deflate stream, which is itself documented in RFC 1951.
 *
 * The library also supports reading and writing files in gzip (.gz) format
 * with an interface similar to that of stdio using the functions that start
 * with "gz".  The gzip format is different from the zlib format.  gzip is a
 * gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
 *
 * This library can optionally read and write gzip and raw deflate streams in
 * memory as well.
 *
 * The zlib format was designed to be compact and fast for use in memory
 * and on communications channels.  The gzip format was designed for single-
 * file compression on file systems, has a larger header than zlib to maintain
 * directory information, and uses a different, slower check method than zlib.
 *
 * The library does not install any signal handler.  The decoder checks
 * the consistency of the compressed data, so the library should never crash
 * even in the case of corrupted input.
 */

#define ZLIB_VERSION         "1.2.11"
#define ZLIB_VERNUM          0x12b0
#define ZLIB_VER_MAJOR       1
#define ZLIB_VER_MINOR       2
#define ZLIB_VER_REVISION    11
#define ZLIB_VER_SUBREVISION 0

/**
 * The application must update next_in and avail_in when avail_in has
 * dropped to zero. It must update next_out and avail_out when avail_out
 * has dropped to zero. The application must initialize zalloc, zfree
 * and opaque before calling the init function. All other fields are set
 * by the compression library and must not be updated by the
 * application.
 *
 * The opaque value provided by the application will be passed as the
 * first parameter for calls of zalloc and zfree. This can be useful for
 * custom memory management. The compression library attaches no meaning
 * to the opaque value.
 *
 * zalloc must return Z_NULL if there is not enough memory for the
 * object. If zlib is used in a multi-threaded application, zalloc and
 * zfree must be thread safe. In that case, zlib is thread-safe. When
 * zalloc and zfree are Z_NULL on entry to the initialization function,
 * they are set to internal routines that use the standard library
 * functions malloc() and free().
 *
 * On 16-bit systems, the functions zalloc and zfree must be able to
 * allocate exactly 65536 bytes, but will not be required to allocate
 * more than this if the symbol MAXSEG_64K is defined (see zconf.h).
 * WARNING: On MSDOS, pointers returned by zalloc for objects of exactly
 * 65536 bytes *must* have their offset normalized to zero. The default
 * allocation function provided by this library ensures this (see
 * zutil.c). To reduce memory requirements and avoid any allocation of
 * 64K objects, at the expense of compression ratio, compile the library
 * with -DMAX_WBITS=14 (see zconf.h).
 *
 * The fields total_in and total_out can be used for statistics or
 * progress reports. After compression, total_in holds the total size of
 * the uncompressed data and may be saved for use by the decompressor
 * (particularly if the decompressor wants to decompress everything in a
 * single step).
 */
#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6

/**
 * Allowed flush values; see deflate() and inflate() below for details.
 */
#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO         (-1)
#define Z_STREAM_ERROR  (-2)
#define Z_DATA_ERROR    (-3)
#define Z_MEM_ERROR     (-4)
#define Z_BUF_ERROR     (-5)
#define Z_VERSION_ERROR (-6)

/**
 * Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal
 * events.
 */
#define Z_NO_COMPRESSION      0
#define Z_BEST_SPEED          1
#define Z_BEST_COMPRESSION    9
#define Z_DEFAULT_COMPRESSION (-1)

/**
 * Compression levels.
 */
#define Z_FILTERED         1
#define Z_HUFFMAN_ONLY     2
#define Z_RLE              3
#define Z_FIXED            4
#define Z_DEFAULT_STRATEGY 0

/**
 * Compression strategy; see deflateInit2() below for details
 */
#define Z_BINARY  0
#define Z_TEXT    1
#define Z_ASCII   Z_TEXT /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN 2

/**
 * Possible values of the data_type field for deflate()
 */
#define Z_DEFLATED 8

/* The deflate compression method (the only one supported in this version) */
#define Z_NULL 0 /* for initializing zalloc, zfree, opaque */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);
typedef void (*free_func)(voidpf opaque, voidpf address);

struct DeflateState;

typedef struct z_stream_s {
  const Bytef *next_in;       /* next input byte */
  uInt avail_in;              /* number of bytes available at next_in */
  uLong total_in;             /* total number of input bytes read so far */
  Bytef *next_out;            /* next output byte will go here */
  uInt avail_out;             /* remaining free space at next_out */
  uLong total_out;            /* total number of bytes output so far */
  const char *msg;            /* last error message, NULL if no error */
  struct DeflateState *state; /* not visible by applications */
  alloc_func zalloc;          /* used to allocate the internal state */
  free_func zfree;            /* used to free the internal state */
  voidpf opaque;  /* private data object passed to zalloc and zfree */
  int data_type;  /* best guess about the data type: binary or text
                     for deflate, or the decoding state for inflate */
  uLong adler;    /* Adler-32 or CRC-32 value of the uncompressed data */
  uLong reserved; /* reserved for future use */
} z_stream;

typedef z_stream *z_streamp;

/**
 * gzip header information passed to and from zlib routines. See RFC
 * 1952 for more details on the meanings of these fields.
 */
typedef struct gz_header_s {
  int text;       /* true if compressed data believed to be text */
  uLong time;     /* modification time */
  int xflags;     /* extra flags (not used when writing a gzip file) */
  int os;         /* operating system */
  Bytef *extra;   /* pointer to extra field or Z_NULL if none */
  uInt extra_len; /* extra field length (valid if extra != Z_NULL) */
  uInt extra_max; /* space at extra (only when reading header) */
  Bytef *name;    /* pointer to zero-terminated file name or Z_NULL */
  uInt name_max;  /* space at name (only when reading header) */
  Bytef *comment; /* pointer to zero-terminated comment or Z_NULL */
  uInt comm_max;  /* space at comment (only when reading header) */
  int hcrc;       /* true if there was or will be a header crc */
  int done;       /* true when done reading gzip header (not used
                     when writing a gzip file) */
} gz_header;

typedef gz_header *gz_headerp;

#define zlib_version zlibVersion()

/**
 * The application can compare zlibVersion and ZLIB_VERSION for consistency.
 * If the first character differs, the library code actually used is not
 * compatible with the zlib.h header file used by the application.  This check
 * is automatically made by deflateInit and inflateInit.
 */
const char *zlibVersion(void);

/**
 * Initializes the internal stream state for compression.  The fields
 * zalloc, zfree and opaque must be initialized before by the caller.  If
 * zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
 * allocation functions.
 *
 * The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
 * 1 gives best speed, 9 gives best compression, 0 gives no compression at all
 * (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
 * requests a default compromise between speed and compression (currently
 * equivalent to level 6).
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if level is not a valid compression level. msg
 *     is set to null if there is no error message. deflateInit does not
 *     perform any compression: this will be done by deflate().
 */
int deflateInit(z_streamp strm, int level);

/**
 * deflate compresses as much data as possible, and stops when the input
 * buffer becomes empty or the output buffer becomes full. It may
 * introduce some output latency (reading input without producing any
 * output) except when forced to flush.
 *
 * The detailed semantics are as follows. deflate performs one or both
 * of the following actions:
 *
 * - Compress more input starting at next_in and update next_in and
 *  avail_in accordingly. If not all input can be processed (because
 *  there is not enough room in the output buffer), next_in and avail_in
 *  are updated and processing will resume at this point for the next
 *  call of deflate().
 *
 * - Generate more output starting at next_out and update next_out and
 *  avail_out accordingly. This action is forced if the parameter flush
 *  is non zero. Forcing flush frequently degrades the compression
 *  ratio, so this parameter should be set only when necessary. Some
 *  output may be provided even if flush is zero.
 *
 * Before the call of deflate(), the application should ensure that at
 * least one of the actions is possible, by providing more input and/or
 * consuming more output, and updating avail_in or avail_out
 * accordingly; avail_out should never be zero before the call. The
 * application can consume the compressed output when it wants, for
 * example when the output buffer is full (avail_out == 0), or after
 * each call of deflate(). If deflate returns Z_OK and with zero
 * avail_out, it must be called again after making room in the output
 * buffer because there might be more output pending. See
 * deflatePending(), which can be used if desired to determine whether
 * or not there is more ouput in that case.
 *
 * Normally the parameter flush is set to Z_NO_FLUSH, which allows
 * deflate to decide how much data to accumulate before producing
 * output, in order to maximize compression.
 *
 * If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
 * flushed to the output buffer and the output is aligned on a byte
 * boundary, so that the decompressor can get all input data available
 * so far. (In particular avail_in is zero after the call if enough
 * output space has been provided before the call.) Flushing may degrade
 * compression for some compression algorithms and so it should be used
 * only when necessary. This completes the current deflate block and
 * follows it with an empty stored block that is three bits plus filler
 * bits to the next byte, followed by four bytes (00 00 ff ff).
 *
 * If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to
 * the output buffer, but the output is not aligned to a byte boundary.
 * All of the input data so far will be available to the decompressor,
 * as for Z_SYNC_FLUSH. This completes the current deflate block and
 * follows it with an empty fixed codes block that is 10 bits long. This
 * assures that enough bytes are output in order for the decompressor to
 * finish the block before the empty fixed codes block.
 *
 * If flush is set to Z_BLOCK, a deflate block is completed and emitted,
 * as for Z_SYNC_FLUSH, but the output is not aligned on a byte
 * boundary, and up to seven bits of the current block are held to be
 * written as the next byte after the next deflate block is completed.
 * In this case, the decompressor may not be provided enough bits at
 * this point in order to complete decompression of the data provided so
 * far to the compressor. It may need to wait for the next block to be
 * emitted. This is for advanced applications that need to control the
 * emission of deflate blocks.
 *
 * If flush is set to Z_FULL_FLUSH, all output is flushed as with
 * Z_SYNC_FLUSH, and the compression state is reset so that
 * decompression can restart from this point if previous compressed data
 * has been damaged or if random access is desired. Using Z_FULL_FLUSH
 * too often can seriously degrade compression.
 *
 * If deflate returns with avail_out == 0, this function must be called
 * again with the same value of the flush parameter and more output
 * space (updated avail_out), until the flush is complete (deflate
 * returns with non-zero avail_out). In the case of a Z_FULL_FLUSH or
 * Z_SYNC_FLUSH, make sure that avail_out is greater than six to avoid
 * repeated flush markers due to avail_out == 0 on return.
 *
 * If the parameter flush is set to Z_FINISH, pending input is
 * processed, pending output is flushed and deflate returns with
 * Z_STREAM_END if there was enough output space. If deflate returns
 * with Z_OK or Z_BUF_ERROR, this function must be called again with
 * Z_FINISH and more output space (updated avail_out) but no more input
 * data, until it returns with Z_STREAM_END or an error. After deflate
 * has returned Z_STREAM_END, the only possible operations on the stream
 * are deflateReset or deflateEnd.
 *
 * Z_FINISH can be used in the first deflate call after deflateInit if
 * all the compression is to be done in a single step. In order to
 * complete in one call, avail_out must be at least the value returned
 * by deflateBound (see below). Then deflate is guaranteed to return
 * Z_STREAM_END. If not enough output space is provided, deflate will
 * not return Z_STREAM_END, and it must be called again as described
 * above.
 *
 * deflate() sets strm->adler to the Adler-32 checksum of all input read
 * so far (that is, total_in bytes). If a gzip stream is being
 * generated, then strm->adler will be the CRC-32 checksum of the input
 * read so far. (See deflateInit2 below.)
 *
 * deflate() may update strm->data_type if it can make a good guess about
 * the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
 * considered binary.  This field is only for information purposes and does not
 * affect the compression algorithm in any manner.
 *
 * @return Z_OK if some progress has been made (more input processed or
 *     more output produced), Z_STREAM_END if all input has been
 *     consumed and all output has been produced (only when flush is set
 *     to Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent
 *     (for example if next_in or next_out was Z_NULL or the state was
 *     inadvertently written over by the application), or Z_BUF_ERROR if
 *     no progress is possible (for example avail_in or avail_out was
 *     zero). Note that Z_BUF_ERROR is not fatal, and deflate() can be
 *     called again with more input and more output space to continue
 *     compressing.
 */
int deflate(z_streamp strm, int flush);

/**
 * All dynamically allocated data structures for this stream are freed.
 * This function discards any unprocessed input and does not flush any
 * pending output.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if the stream state was
 *     inconsistent, Z_DATA_ERROR if the stream was freed prematurely
 *     (some input or output was discarded). In the error case, msg may
 *     be set but then points to a static string (which must not be
 *     deallocated).
 */
int deflateEnd(z_streamp strm);

/**
 * Initializes the internal stream state for decompression. The fields
 * next_in, avail_in, zalloc, zfree and opaque must be initialized
 * before by the caller. In the current version of inflate, the provided
 * input is not read or consumed. The allocation of a sliding window
 * will be deferred to the first call of inflate (if the decompression
 * does not complete on the first call). If zalloc and zfree are set to
 * Z_NULL, inflateInit updates them to use default allocation functions.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if the parameters are invalid, such as a null
 *     pointer to the structure. msg is set to null if there is no error
 *     message. inflateInit does not perform any decompression. Actual
 *     decompression will be done by inflate(). So next_in, and
 *     avail_in, next_out, and avail_out are unused and unchanged. The
 *     current implementation of inflateInit() does not process any
 *     header information -- that is deferred until inflate() is called.
 */
int inflateInit(z_streamp strm);

/**
 * inflate decompresses as much data as possible, and stops when the input
 * buffer becomes empty or the output buffer becomes full.  It may introduce
 * some output latency (reading input without producing any output) except when
 * forced to flush.
 *
 * The detailed semantics are as follows.  inflate performs one or both of the
 * following actions:
 *
 * - Decompress more input starting at next_in and update next_in and
 *   avail_in accordingly. If not all input can be processed (because
 *   there is not enough room in the output buffer), then next_in and
 *   avail_in are updated accordingly, and processing will resume at
 *   this point for the next call of inflate().
 *
 * - Generate more output starting at next_out and update next_out and
 *   avail_out accordingly. inflate() provides as much output as
 *   possible, until there is no more input data or no more space in the
 *   output buffer (see below about the flush parameter).
 *
 * Before the call of inflate(), the application should ensure that at
 * least one of the actions is possible, by providing more input and/or
 * consuming more output, and updating the next_* and avail_* values
 * accordingly. If the caller of inflate() does not provide both
 * available input and available output space, it is possible that there
 * will be no progress made. The application can consume the
 * uncompressed output when it wants, for example when the output buffer
 * is full (avail_out == 0), or after each call of inflate(). If inflate
 * returns Z_OK and with zero avail_out, it must be called again after
 * making room in the output buffer because there might be more output
 * pending.
 *
 * The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
 * Z_FINISH, Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate()
 * flush as much output as possible to the output buffer. Z_BLOCK
 * requests that inflate() stop if and when it gets to the next deflate
 * block boundary. When decoding the zlib or gzip format, this will
 * cause inflate() to return immediately after the header and before the
 * first block. When doing a raw inflate, inflate() will go ahead and
 * process the first block, and will return when it gets to the end of
 * that block, or when it runs out of data.
 *
 * The Z_BLOCK option assists in appending to or combining deflate
 * streams. To assist in this, on return inflate() always sets
 * strm->data_type to the number of unused bits in the last byte taken
 * from strm->next_in, plus 64 if inflate() is currently decoding the
 * last block in the deflate stream, plus 128 if inflate() returned
 * immediately after decoding an end-of-block code or decoding the
 * complete header up to just before the first byte of the deflate
 * stream. The end-of-block will not be indicated until all of the
 * uncompressed data from that block has been written to strm->next_out.
 * The number of unused bits may in general be greater than seven,
 * except when bit 7 of data_type is set, in which case the number of
 * unused bits will be less than eight. data_type is set as noted here
 * every time inflate() returns for all flush options, and so can be
 * used to determine the amount of currently consumed input in bits.
 *
 * The Z_TREES option behaves as Z_BLOCK does, but it also returns when
 * the end of each deflate block header is reached, before any actual
 * data in that block is decoded. This allows the caller to determine
 * the length of the deflate block header for later use in random access
 * within a deflate block. 256 is added to the value of strm->data_type
 * when inflate() returns immediately after reaching the end of the
 * deflate block header.
 *
 * inflate() should normally be called until it returns Z_STREAM_END or
 * an error. However if all decompression is to be performed in a single
 * step (a single call of inflate), the parameter flush should be set to
 * Z_FINISH. In this case all pending input is processed and all pending
 * output is flushed; avail_out must be large enough to hold all of the
 * uncompressed data for the operation to complete. (The size of the
 * uncompressed data may have been saved by the compressor for this
 * purpose.) The use of Z_FINISH is not required to perform an inflation
 * in one step. However it may be used to inform inflate that a faster
 * approach can be used for the single inflate() call. Z_FINISH also
 * informs inflate to not maintain a sliding window if the stream
 * completes, which reduces inflate's memory footprint. If the stream
 * does not complete, either because not all of the stream is provided
 * or not enough output space is provided, then a sliding window will be
 * allocated and inflate() can be called again to continue the operation
 * as if Z_NO_FLUSH had been used.
 *
 * In this implementation, inflate() always flushes as much output as
 * possible to the output buffer, and always uses the faster approach on
 * the first call. So the effects of the flush parameter in this
 * implementation are on the return value of inflate() as noted below,
 * when inflate() returns early when Z_BLOCK or Z_TREES is used, and
 * when inflate() avoids the allocation of memory for a sliding window
 * when Z_FINISH is used.
 *
 * If a preset dictionary is needed after this call (see
 * inflateSetDictionary below), inflate sets strm->adler to the Adler-32
 * checksum of the dictionary chosen by the compressor and returns
 * Z_NEED_DICT; otherwise it sets strm->adler to the Adler-32 checksum
 * of all output produced so far (that is, total_out bytes) and returns
 * Z_OK, Z_STREAM_END or an error code as described below. At the end of
 * the stream, inflate() checks that its computed Adler-32 checksum is
 * equal to that saved by the compressor and returns Z_STREAM_END only
 * if the checksum is correct.
 *
 * inflate() can decompress and check either zlib-wrapped or
 * gzip-wrapped deflate data. The header type is detected automatically,
 * if requested when initializing with inflateInit2(). Any information
 * contained in the gzip header is not retained unless
 * inflateGetHeader() is used. When processing gzip-wrapped deflate
 * data, strm->adler32 is set to the CRC-32 of the output produced so
 * far. The CRC-32 is checked against the gzip trailer, as is the
 * uncompressed length, modulo 2^32.
 *
 * @return Z_OK if some progress has been made (more input processed or
 *     more output produced), Z_STREAM_END if the end of the compressed
 *     data has been reached and all uncompressed output has been
 *     produced, Z_NEED_DICT if a preset dictionary is needed at this
 *     point, Z_DATA_ERROR if the input data was corrupted (input stream
 *     not conforming to the zlib format or incorrect check value, in
 *     which case strm->msg points to a string with a more specific
 *     error), Z_STREAM_ERROR if the stream structure was inconsistent
 *     (for example next_in or next_out was Z_NULL, or the state was
 *     inadvertently written over by the application), Z_MEM_ERROR if
 *     there was not enough memory, Z_BUF_ERROR if no progress was
 *     possible or if there was not enough room in the output buffer
 *     when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
 *     inflate() can be called again with more input and more output
 *     space to continue decompressing. If Z_DATA_ERROR is returned, the
 *     application may then call inflateSync() to look for a good
 *     compression block if a partial recovery of the data is to be
 *     attempted.
 */
int inflate(z_streamp strm, int flush);

/**
 * All dynamically allocated data structures for this stream are freed.
 * This function discards any unprocessed input and does not flush any
 * pending output.
 *
 * @return Z_OK or Z_STREAM_ERROR if stream state inconsistent
 */
int inflateEnd(z_streamp strm);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » special functions                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  the following functions are needed only in some special applications */

/**
 * This is another version of deflateInit with more compression options.
 * The fields next_in, zalloc, zfree and opaque must be initialized
 * before by the caller.
 *
 * The method parameter is the compression method. It must be Z_DEFLATED
 * in this version of the library.
 *
 * The windowBits parameter is the base two logarithm of the window size
 * (the size of the history buffer). It should be in the range 8..15 for
 * this version of the library. Larger values of this parameter result
 * in better compression at the expense of memory usage. The default
 * value is 15 if deflateInit is used instead.
 *
 * For the current implementation of deflate(), a windowBits value of 8
 * (a window size of 256 bytes) is not supported. As a result, a request
 * for 8 will result in 9 (a 512-byte window). In that case, providing 8
 * to inflateInit2() will result in an error when the zlib header with 9
 * is checked against the initialization of inflate(). The remedy is to
 * not use 8 with deflateInit2() with this initialization, or at least
 * in that case use 9 with inflateInit2().
 *
 * windowBits can also be -8..-15 for raw deflate. In this case,
 * -windowBits determines the window size. deflate() will then generate
 * raw deflate data with no zlib header or trailer, and will not compute
 * a check value.
 *
 * windowBits can also be greater than 15 for optional gzip encoding.
 * Add 16 to windowBits to write a simple gzip header and trailer around
 * the compressed data instead of a zlib wrapper. The gzip header will
 * have no file name, no extra data, no comment, no modification time
 * (set to zero), no header crc, and the operating system will be set to
 * the appropriate value, if the operating system was determined at
 * compile time. If a gzip stream is being written, strm->adler is a
 * CRC-32 instead of an Adler-32.
 *
 * For raw deflate or gzip encoding, a request for a 256-byte window is
 * rejected as invalid, since only the zlib header provides a means of
 * transmitting the window size to the decompressor.
 *
 * The memLevel parameter specifies how much memory should be allocated
 * for the internal compression state. memLevel=1 uses minimum memory
 * but is slow and reduces compression ratio; memLevel=9 uses maximum
 * memory for optimal speed. The default value is 8. See zconf.h for
 * total memory usage as a function of windowBits and memLevel.
 *
 * The strategy parameter is used to tune the compression algorithm. Use
 * the value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data
 * produced by a filter (or predictor), Z_HUFFMAN_ONLY to force Huffman
 * encoding only (no string match), or Z_RLE to limit match distances to
 * one (run-length encoding). Filtered data consists mostly of small
 * values with a somewhat random distribution. In this case, the
 * compression algorithm is tuned to compress them better. The effect of
 * Z_FILTERED is to force more Huffman coding and less string matching;
 * it is somewhat intermediate between Z_DEFAULT_STRATEGY and
 * Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
 * Z_HUFFMAN_ONLY, but give better compression for PNG image data. The
 * strategy parameter only affects the compression ratio but not the
 * correctness of the compressed output even if it is not set
 * appropriately. Z_FIXED prevents the use of dynamic Huffman codes,
 * allowing for a simpler decoder for special applications.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if any parameter is invalid (such as an invalid
 *     method). msg is set to null if there is no error message.
 *     deflateInit2 does not perform any compression: this will be done
 *     by deflate().
 */
int deflateInit2(z_streamp strm, int level, int method, int windowBits,
                 int memLevel, int strategy);

/**
 * Initializes the compression dictionary from the given byte sequence
 * without producing any compressed output. When using the zlib format,
 * this function must be called immediately after deflateInit,
 * deflateInit2 or deflateReset, and before any call of deflate. When
 * doing raw deflate, this function must be called either before any
 * call of deflate, or immediately after the completion of a deflate
 * block, i.e. after all input has been consumed and all output has been
 * delivered when using any of the flush options Z_BLOCK,
 * Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The compressor and
 * decompressor must use exactly the same dictionary (see
 * inflateSetDictionary).
 *
 * The dictionary should consist of strings (byte sequences) that are
 * likely to be encountered later in the data to be compressed, with the
 * most commonly used strings preferably put towards the end of the
 * dictionary. Using a dictionary is most useful when the data to be
 * compressed is short and can be predicted with good accuracy; the data
 * can then be compressed better than with the default empty dictionary.
 *
 * Depending on the size of the compression data structures selected by
 * deflateInit or deflateInit2, a part of the dictionary may in effect
 * be discarded, for example if the dictionary is larger than the window
 * size provided in deflateInit or deflateInit2. Thus the strings most
 * likely to be useful should be put at the end of the dictionary, not
 * at the front. In addition, the current implementation of deflate will
 * use at most the window size minus 262 bytes of the provided
 * dictionary.
 *
 * Upon return of this function, strm->adler is set to the Adler-32
 * value of the dictionary; the decompressor may later use this value to
 * determine which dictionary has been used by the compressor. (The
 * Adler-32 value applies to the whole dictionary even if only a subset
 * of the dictionary is actually used by the compressor.) If a raw
 * deflate was requested, then the Adler-32 value is not computed and
 * strm->adler is not set.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if a parameter is invalid
 *     (e.g. dictionary being Z_NULL) or the stream state is
 *     inconsistent (for example if deflate has already been called for
 *     this stream or if not at a block boundary for raw deflate).
 *     deflateSetDictionary does not perform any compression: this will
 *     be done by deflate().
 */
int deflateSetDictionary(z_streamp strm, const Bytef *dictionary,
                         uInt dictLength);

/**
 * Returns the sliding dictionary being maintained by deflate.  dictLength is
 * set to the number of bytes in the dictionary, and that many bytes are copied
 * to dictionary.  dictionary must have enough space, where 32768 bytes is
 * always enough.  If deflateGetDictionary() is called with dictionary equal to
 * Z_NULL, then only the dictionary length is returned, and nothing is copied.
 * Similary, if dictLength is Z_NULL, then it is not set.
 *
 * deflateGetDictionary() may return a length less than the window size, even
 * when more than the window size in input has been provided. It may return up
 * to 258 bytes less in that case, due to how zlib's implementation of deflate
 * manages the sliding window and lookahead for matches, where matches can be
 * up to 258 bytes long. If the application needs the last window-size bytes of
 * input, then that would need to be saved by the application outside of zlib.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state is
 *     inconsistent.
 */
int deflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength);

/**
 * Sets destination stream as a complete copy of the source stream.
 *
 * This function can be useful when several compression strategies will be
 * tried, for example when there are several ways of pre-processing the input
 * data with a filter.  The streams that will be discarded should then be freed
 * by calling deflateEnd.  Note that deflateCopy duplicates the internal
 * compression state which can be quite large, so this strategy is slow and can
 * consume lots of memory.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_STREAM_ERROR if the source stream state was inconsistent (such
 *     as zalloc being Z_NULL). msg is left unchanged in both source and
 *     destination.
 */
int deflateCopy(z_streamp dest, z_streamp source);

/**
 * This function is equivalent to deflateEnd followed by deflateInit, but
 * does not free and reallocate the internal compression state.  The stream
 * will leave the compression level and any other attributes that may have been
 * set unchanged.
 *
 * deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
 * stream state was inconsistent (such as zalloc or state being Z_NULL).
 */
int deflateReset(z_streamp strm);

/**
 * Dynamically update the compression level and compression strategy.  The
 * interpretation of level and strategy is as in deflateInit2().  This can be
 * used to switch between compression and straight copy of the input data, or
 * to switch to a different kind of input data requiring a different strategy.
 * If the compression approach (which is a function of the level) or the
 * strategy is changed, and if any input has been consumed in a previous
 * deflate() call, then the input available so far is compressed with the old
 * level and strategy using deflate(strm, Z_BLOCK).  There are three approaches
 * for the compression levels 0, 1..3, and 4..9 respectively.  The new level
 * and strategy will take effect at the next call of deflate().
 *
 * If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
 * not have enough output space to complete, then the parameter change will not
 * take effect.  In this case, deflateParams() can be called again with the
 * same parameters and more output space to try again.
 *
 * In order to assure a change in the parameters on the first try, the
 * deflate stream should be flushed using deflate() with Z_BLOCK or other flush
 * request until strm.avail_out is not zero, before calling deflateParams().
 * Then no more input data should be provided before the deflateParams() call.
 * If this is done, the old level and strategy will be applied to the data
 * compressed before deflateParams(), and the new level and strategy will be
 * applied to the the data compressed after deflateParams().
 *
 * deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
 * state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
 * there was not enough output space to complete the compression of the
 * available input data before a change in the strategy or approach.  Note that
 * in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
 * value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
 * retried with more output space.
 */
int deflateParams(z_streamp strm, int level, int strategy);

/**
 * Fine tune deflate's internal compression parameters. This should only
 * be used by someone who understands the algorithm used by zlib's
 * deflate for searching for the best matching string, and even then
 * only by the most fanatic optimizer trying to squeeze out the last
 * compressed bit for their specific input data. Read the deflate.c
 * source code for the meaning of the max_lazy, good_length,
 * nice_length, and max_chain parameters.
 *
 * deflateTune() can be called after deflateInit() or deflateInit2(), and
 * returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */
int deflateTune(z_streamp strm, int good_length, int max_lazy, int nice_length,
                int max_chain);

/**
 * deflateBound() returns an upper bound on the compressed size after
 * deflation of sourceLen bytes. It must be called after deflateInit()
 * or deflateInit2(), and after deflateSetHeader(), if used. This would
 * be used to allocate an output buffer for deflation in a single pass,
 * and so would be called before deflate(). If that first deflate() call
 * is provided the sourceLen input bytes, an output buffer allocated to
 * the size returned by deflateBound(), and the flush value Z_FINISH,
 * then deflate() is guaranteed to return Z_STREAM_END. Note that it is
 * possible for the compressed size to be larger than the value returned
 * by deflateBound() if flush options other than Z_FINISH or Z_NO_FLUSH
 * are used.
 */
uLong deflateBound(z_streamp strm, uLong sourceLen);

/**
 * deflatePending() returns the number of bytes and bits of output that
 * have been generated, but not yet provided in the available output.
 * The bytes not provided would be due to the available output space
 * having being consumed. The number of bits of output not provided are
 * between 0 and 7, where they await more bits to join them in order to
 * fill out a full byte. If pending or bits are Z_NULL, then those
 * values are not set.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int deflatePending(z_streamp strm, unsigned *pending, int *bits);

/**
 * deflatePrime() inserts bits in the deflate output stream.  The intent
 * is that this function is used to start off the deflate output with the bits
 * leftover from a previous deflate stream when appending to it.  As such, this
 * function can only be used for raw deflate, and must be used before the first
 * deflate() call after a deflateInit2() or deflateReset().  bits must be less
 * than or equal to 16, and that many of the least significant bits of value
 * will be inserted in the output.
 *
 * @return Z_OK if success, Z_BUF_ERROR if there was not enough room in
 *     the internal buffer to insert the bits, or Z_STREAM_ERROR if the
 *     source stream state was inconsistent.
 */
int deflatePrime(z_streamp strm, int bits, int value);

/**
 * Provides gzip header information for when a gzip stream is requested
 * by deflateInit2(). deflateSetHeader() may be called after
 * deflateInit2() or deflateReset() and before the first call of
 * deflate(). The text, time, os, extra field, name, and comment
 * information in the provided gz_header structure are written to the
 * gzip header (xflag is ignored -- the extra flags are set according to
 * the compression level). The caller must assure that, if not Z_NULL,
 * name and comment are terminated with a zero byte, and that if extra
 * is not Z_NULL, that extra_len bytes are available there. If hcrc is
 * true, a gzip header crc is included. Note that the current versions
 * of the command-line version of gzip (up through version 1.3.x) do not
 * support header crc's, and will report that it is a "multi-part gzip
 * file" and give up.
 *
 * If deflateSetHeader is not used, the default gzip header has text
 * false, the time set to zero, and os set to 255, with no extra, name,
 * or comment fields. The gzip header is returned to the default state
 * by deflateReset().
 *
 * deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the
 * source stream state was inconsistent.
 */
int deflateSetHeader(z_streamp strm, gz_headerp head);

/**
 * This is another version of inflateInit with an extra parameter. The
 * fields next_in, avail_in, zalloc, zfree and opaque must be
 * initialized before by the caller.
 *
 * The windowBits parameter is the base two logarithm of the maximum
 * window size (the size of the history buffer). It should be in the
 * range 8..15 for this version of the library. The default value is 15
 * if inflateInit is used instead. windowBits must be greater than or
 * equal to the windowBits value provided to deflateInit2() while
 * compressing, or it must be equal to 15 if deflateInit2() was not
 * used. If a compressed stream with a larger window size is given as
 * input, inflate() will return with the error code Z_DATA_ERROR instead
 * of trying to allocate a larger window.
 *
 * windowBits can also be zero to request that inflate use the window
 * size in the zlib header of the compressed stream.
 *
 * windowBits can also be -8..-15 for raw inflate. In this case,
 * -windowBits determines the window size. inflate() will then process
 * raw deflate data, not looking for a zlib or gzip header, not
 * generating a check value, and not looking for any check values for
 * comparison at the end of the stream. This is for use with other
 * formats that use the deflate compressed data format such as zip.
 * Those formats provide their own check values. If a custom format is
 * developed using the raw deflate format for compressed data, it is
 * recommended that a check value such as an Adler-32 or a CRC-32 be
 * applied to the uncompressed data as is done in the zlib, gzip, and
 * zip formats. For most applications, the zlib format should be used as
 * is. Note that comments above on the use in deflateInit2() applies to
 * the magnitude of windowBits.
 *
 * windowBits can also be greater than 15 for optional gzip decoding.
 * Add 32 to windowBits to enable zlib and gzip decoding with automatic
 * header detection, or add 16 to decode only the gzip format (the zlib
 * format will return a Z_DATA_ERROR). If a gzip stream is being
 * decoded, strm->adler is a CRC-32 instead of an Adler-32. Unlike the
 * gunzip utility and gzread() (see below), inflate() will not
 * automatically decode concatenated gzip streams. inflate() will return
 * Z_STREAM_END at the end of the gzip stream. The state would need to
 * be reset to continue decoding a subsequent gzip stream.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if the parameters are invalid, such as a null
 *     pointer to the structure. msg is set to null if there is no error
 *     message. inflateInit2 does not perform any decompression apart
 *     from possibly reading the zlib header if present: actual
 *     decompression will be done by inflate(). (So next_in and avail_in
 *     may be modified, but next_out and avail_out are unused and
 *     unchanged.) The current implementation of inflateInit2() does not
 *     process any header information -- that is deferred until
 *     inflate() is called.
 */
int inflateInit2(z_streamp strm, int windowBits);

/**
 * Initializes the decompression dictionary from the given uncompressed
 * byte sequence. This function must be called immediately after a call
 * of inflate, if that call returned Z_NEED_DICT. The dictionary chosen
 * by the compressor can be determined from the Adler-32 value returned
 * by that call of inflate. The compressor and decompressor must use
 * exactly the same dictionary (see deflateSetDictionary). For raw
 * inflate, this function can be called at any time to set the
 * dictionary. If the provided dictionary is smaller than the window and
 * there is already data in the window, then the provided dictionary
 * will amend what's there. The application must insure that the
 * dictionary that was used for compression is provided.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if a parameter is invalid
 *     (e.g. dictionary being Z_NULL) or the stream state is
 *     inconsistent, Z_DATA_ERROR if the given dictionary doesn't match
 *     the expected one (incorrect Adler-32 value). inflateSetDictionary
 *     does not perform any decompression: this will be done by
 *     subsequent calls of inflate().
 */
int inflateSetDictionary(z_streamp strm, const Bytef *dictionary,
                         uInt dictLength);

/**
 * Returns the sliding dictionary being maintained by inflate.  dictLength is
 * set to the number of bytes in the dictionary, and that many bytes are copied
 * to dictionary.  dictionary must have enough space, where 32768 bytes is
 * always enough.  If inflateGetDictionary() is called with dictionary equal to
 * Z_NULL, then only the dictionary length is returned, and nothing is copied.
 * Similary, if dictLength is Z_NULL, then it is not set.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state is
 *     inconsistent.
 */
int inflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength);

/**
 * Skips invalid compressed data until a possible full flush point (see
 * above for the description of deflate with Z_FULL_FLUSH) can be found,
 * or until all available input is skipped. No output is provided.
 *
 * inflateSync searches for a 00 00 FF FF pattern in the compressed
 * data. All full flush points have this pattern, but not all
 * occurrences of this pattern are full flush points.
 *
 * @return Z_OK if a possible full flush point has been found,
 *     Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no
 *     flush point has been found, or Z_STREAM_ERROR if the stream
 *     structure was inconsistent. In the success case, the application
 *     may save the current current value of total_in which indicates
 *     where valid compressed data was found. In the error case, the
 *     application may repeatedly call inflateSync, providing more input
 *     each time, until success or end of the input data.
 */
int inflateSync(z_streamp strm);

/**
 * Sets the destination stream as a complete copy of the source stream.
 *
 * This function can be useful when randomly accessing a large stream.
 * The first pass through the stream can periodically record the inflate
 * state, allowing restarting inflate at those points when randomly
 * accessing the stream.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_STREAM_ERROR if the source stream state was inconsistent (such
 *     as zalloc being Z_NULL). msg is left unchanged in both source and
 *     destination.
 */
int inflateCopy(z_streamp dest, z_streamp source);

/**
 * This function is equivalent to inflateEnd followed by inflateInit,
 * but does not free and reallocate the internal decompression state.  The
 * stream will keep attributes that may have been set by inflateInit2.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent (such as zalloc or state being Z_NULL).
 */
int inflateReset(z_streamp strm);

/**
 * This function is the same as inflateReset, but it also permits changing
 * the wrap and window size requests.  The windowBits parameter is interpreted
 * the same as it is for inflateInit2.  If the window size is changed, then the
 * memory allocated for the window is freed, and the window will be reallocated
 * by inflate() if needed.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent (such as zalloc or state being Z_NULL), or if
 *     the windowBits parameter is invalid.
 */
int inflateReset2(z_streamp strm, int windowBits);

/**
 * This function inserts bits in the inflate input stream.  The intent is
 * that this function is used to start inflating at a bit position in the
 * middle of a byte.  The provided bits will be used before any bytes are used
 * from next_in.  This function should only be used with raw inflate, and
 * should be used before the first inflate() call after inflateInit2() or
 * inflateReset().  bits must be less than or equal to 16, and that many of the
 * least significant bits of value will be inserted in the input.
 *
 * If bits is negative, then the input stream bit buffer is emptied.  Then
 * inflatePrime() can be called again to put bits in the buffer.  This is used
 * to clear out bits leftover after feeding inflate a block description prior
 * to feeding inflate codes.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int inflatePrime(z_streamp strm, int bits, int value);

/**
 * Returns two values, one in the lower 16 bits of the return value, and
 * the other in the remaining upper bits, obtained by shifting the
 * return value down 16 bits. If the upper value is -1 and the lower
 * value is zero, then inflate() is currently decoding information
 * outside of a block. If the upper value is -1 and the lower value is
 * non-zero, then inflate is in the middle of a stored block, with the
 * lower value equaling the number of bytes from the input remaining to
 * copy. If the upper value is not -1, then it is the number of bits
 * back from the current bit position in the input of the code (literal
 * or length/distance pair) currently being processed. In that case the
 * lower value is the number of bytes already emitted for that code.
 *
 * A code is being processed if inflate is waiting for more input to
 * complete decoding of the code, or if it has completed decoding but is
 * waiting for more output space to write the literal or match data.
 *
 * inflateMark() is used to mark locations in the input data for random
 * access, which may be at bit positions, and to note those cases where
 * the output of a code may span boundaries of random access blocks. The
 * current location in the input stream can be determined from avail_in
 * and data_type as noted in the description for the Z_BLOCK flush
 * parameter for inflate.
 *
 * @return the value noted above, or -65536 if the provided source
 *     stream state was inconsistent.
 */
long inflateMark(z_streamp strm);

/**
 * inflateGetHeader() requests that gzip header information be stored in
 * the provided gz_header structure. inflateGetHeader() may be called
 * after inflateInit2() or inflateReset(), and before the first call of
 * inflate(). As inflate() processes the gzip stream, head->done is zero
 * until the header is completed, at which time head->done is set to
 * one. If a zlib stream is being decoded, then head->done is set to -1
 * to indicate that there will be no gzip header information
 * forthcoming. Note that Z_BLOCK or Z_TREES can be used to force
 * inflate() to return immediately after header processing is complete
 * and before any actual data is decompressed.
 *
 * The text, time, xflags, and os fields are filled in with the gzip
 * header contents. hcrc is set to true if there is a header CRC. (The
 * header CRC was valid if done is set to one.) If extra is not Z_NULL,
 * then extra_max contains the maximum number of bytes to write to
 * extra. Once done is true, extra_len contains the actual extra field
 * length, and extra contains the extra field, or that field truncated
 * if extra_max is less than extra_len. If name is not Z_NULL, then up
 * to name_max characters are written there, terminated with a zero
 * unless the length is greater than name_max. If comment is not Z_NULL,
 * then up to comm_max characters are written there, terminated with a
 * zero unless the length is greater than comm_max. When any of extra,
 * name, or comment are not Z_NULL and the respective field is not
 * present in the header, then that field is set to Z_NULL to signal its
 * absence. This allows the use of deflateSetHeader() with the returned
 * structure to duplicate the header. However if those fields are set to
 * allocated memory, then the application will need to save those
 * pointers elsewhere so that they can be eventually freed.
 *
 * If inflateGetHeader is not used, then the header information is
 * simply discarded. The header is always checked for validity,
 * including the header CRC if present. inflateReset() will reset the
 * process to discard the header information. The application would need
 * to call inflateGetHeader() again to retrieve the header from the next
 * gzip stream.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int inflateGetHeader(z_streamp strm, gz_headerp head);

/**
 * Initialize internal stream state for decompression using
 * inflateBack() calls. The fields zalloc, zfree and opaque in strm must
 * be initialized before the call. If zalloc and zfree are Z_NULL, then
 * the default library- derived memory allocation routines are used.
 * windowBits is the base two logarithm of the window size, in the range
 * 8..15. window is a caller supplied buffer of that size. Except for
 * special applications where it is assured that deflate was used with
 * small window sizes, windowBits must be 15 and a 32K byte window must
 * be supplied to be able to decompress general deflate streams.
 *
 * See inflateBack() for the usage of these routines.
 *
 * @return Z_OK on success, Z_STREAM_ERROR if any of the parameters are
 *     invalid, or Z_MEM_ERROR if the internal state could not be
 *     allocated.
 */
int inflateBackInit(z_streamp strm, int windowBits, unsigned char *window);

typedef unsigned (*in_func)(void *, const unsigned char **);
typedef int (*out_func)(void *, unsigned char *, unsigned);

/**
 * inflateBack() does a raw inflate with a single call using a call-back
 * interface for input and output. This is potentially more efficient
 * than inflate() for file i/o applications, in that it avoids copying
 * between the output and the sliding window by simply making the window
 * itself the output buffer. inflate() can be faster on modern CPUs when
 * used with large buffers. inflateBack() trusts the application to not
 * change the output buffer passed by the output function, at least
 * until inflateBack() returns.
 *
 * inflateBackInit() must be called first to allocate the internal state
 * and to initialize the state with the user-provided window buffer.
 * inflateBack() may then be used multiple times to inflate a complete,
 * raw deflate stream with each call. inflateBackEnd() is then called to
 * free the allocated state.
 *
 * A raw deflate stream is one with no zlib or gzip header or trailer.
 * This routine would normally be used in a utility that reads zip or
 * gzip files and writes out uncompressed files. The utility would
 * decode the header and process the trailer on its own, hence this
 * routine expects only the raw deflate stream to decompress. This is
 * different from the default behavior of inflate(), which expects a
 * zlib header and trailer around the deflate stream.
 *
 * inflateBack() uses two subroutines supplied by the caller that are
 * then called by inflateBack() for input and output. inflateBack()
 * calls those routines until it reads a complete deflate stream and
 * writes out all of the uncompressed data, or until it encounters an
 * error. The function's parameters and return types are defined above
 * in the in_func and out_func typedefs. inflateBack() will call
 * in(in_desc, &buf) which should return the number of bytes of provided
 * input, and a pointer to that input in buf. If there is no input
 * available, in() must return zero -- buf is ignored in that case --
 * and inflateBack() will return a buffer error. inflateBack() will call
 * out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
 * out() should return zero on success, or non-zero on failure. If out()
 * returns non-zero, inflateBack() will return with an error. Neither
 * in() nor out() are permitted to change the contents of the window
 * provided to inflateBackInit(), which is also the buffer that out()
 * uses to write from. The length written by out() will be at most the
 * window size. Any non-zero amount of input may be provided by in().
 *
 * For convenience, inflateBack() can be provided input on the first
 * call by setting strm->next_in and strm->avail_in. If that input is
 * exhausted, then in() will be called. Therefore strm->next_in must be
 * initialized before calling inflateBack(). If strm->next_in is Z_NULL,
 * then in() will be called immediately for input. If strm->next_in is
 * not Z_NULL, then strm->avail_in must also be initialized, and then if
 * strm->avail_in is not zero, input will initially be taken from
 * strm->next_in[0 .. strm->avail_in - 1].
 *
 * The in_desc and out_desc parameters of inflateBack() is passed as the
 * first parameter of in() and out() respectively when they are called.
 * These descriptors can be optionally used to pass any information that
 * the caller- supplied in() and out() functions need to do their job.
 *
 * On return, inflateBack() will set strm->next_in and strm->avail_in to
 * pass back any unused input that was provided by the last in() call.
 * The return values of inflateBack() can be Z_STREAM_END on success,
 * Z_BUF_ERROR if in() or out() returned an error, Z_DATA_ERROR if there
 * was a format error in the deflate stream (in which case strm->msg is
 * set to indicate the nature of the error), or Z_STREAM_ERROR if the
 * stream was not properly initialized. In the case of Z_BUF_ERROR, an
 * input or output error can be distinguished using strm->next_in which
 * will be Z_NULL only if in() returned an error. If strm->next_in is
 * not Z_NULL, then the Z_BUF_ERROR was due to out() returning non-zero.
 * (in() will always be called before out(), so strm->next_in is assured
 * to be defined if out() returns non-zero.) Note that inflateBack()
 * cannot return Z_OK.
 */
int inflateBack(z_streamp strm, in_func in, void *in_desc, out_func out,
                void *out_desc);

/**
 * All memory allocated by inflateBackInit() is freed.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state was
 *     inconsistent.
 */
int inflateBackEnd(z_streamp strm);

/*
 * Return flags indicating compile-time options.
 *
 * Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
 *   1.0: size of uInt
 *   3.2: size of uLong
 *   5.4: size of voidpf (pointer)
 *   7.6: size of off_t
 *
 * Compiler, assembler, and debug options:
 *   8: ZLIB_DEBUG
 *   9: ASMV or ASMINF -- use ASM code
 *   10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
 *   11: 0 (reserved)
 *
 * One-time table building (smaller code, but not thread-safe if true):
 *   12: BUILDFIXED -- build static block decoding tables when needed
 *   13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
 *   14,15: 0 (reserved)
 *
 * Library content (indicates missing functionality):
 *
 *   16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
 *   deflate code when not needed)
 *
 *   17: NO_GZIP -- deflate can't write gzip streams, and inflate can't
 *   detect and decode gzip streams (to avoid linking crc code)
 *
 *   18-19: 0 (reserved)
 *
 * Operation variations (changes in library functionality):
 *   20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
 *   21: FASTEST -- deflate algorithm with only one, lowest compression level
 *   22,23: 0 (reserved)
 *
 * The sprintf variant used by gzprintf (zero is best):
 *   24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
 *   25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
 *   26: 0 = returns value, 1 = void -- 1 means inferred string length returned
 *
 * Remainder is:
 *   27-31: 0 (reserved)
 */
uLong zlibCompileFlags(void);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » utility functions                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  The following utility functions are implemented on top of the basic
  stream-oriented functions. To simplify the interface, some default
  options are assumed (compression level and memory usage, standard
  memory allocation functions). The source code of these utility
  functions can be modified if you need special options. */

/**
 * Compresses source buffer into the destination buffer. sourceLen is
 * the byte length of the source buffer. Upon entry, destLen is the
 * total size of the destination buffer, which must be at least the
 * value returned by compressBound(sourceLen). Upon exit, destLen is the
 * actual size of the compressed data. compress() is equivalent to
 * compress2() with a level parameter of Z_DEFAULT_COMPRESSION.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer.
 */
int compress(Bytef *dest, uLongf *destLen, const Bytef *source,
             uLong sourceLen);

/**
 * Compresses source buffer into the destination buffer. The level
 * parameter has the same meaning as in deflateInit. sourceLen is the
 * byte length of the source buffer. Upon entry, destLen is the total
 * size of the destination buffer, which must be at least the value
 * returned by compressBound(sourceLen). Upon exit, destLen is the
 * actual size of the compressed data.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer,
 *     Z_STREAM_ERROR if the level parameter is invalid.
 */
int compress2(Bytef *dest, uLongf *destLen, const Bytef *source,
              uLong sourceLen, int level);

/**
 * Returns an upper bound on the compressed size after compress() or
 * compress2() on sourceLen bytes. It would be used before a compress()
 * or compress2() call to allocate the destination buffer.
 */
uLong compressBound(uLong sourceLen);

/**
 * Decompresses the source buffer into the destination buffer.  sourceLen is
 * the byte length of the source buffer.  Upon entry, destLen is the total size
 * of the destination buffer, which must be large enough to hold the entire
 * uncompressed data.  (The size of the uncompressed data must have been saved
 * previously by the compressor and transmitted to the decompressor by some
 * mechanism outside the scope of this compression library.) Upon exit, destLen
 * is the actual size of the uncompressed data.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer, or
 *     Z_DATA_ERROR if the input data was corrupted or incomplete. In
 *     the case where there is not enough room, uncompress() will fill
 *     the output buffer with the uncompressed data up to that point.
 */
int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,
               uLong sourceLen);

/**
 * Same as uncompress, except that sourceLen is a pointer, where the
 * length of the source is *sourceLen.  On return, *sourceLen is the number of
 * source bytes consumed.
 */
int uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,
                uLong *sourceLen);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » gzip                                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  This library supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio, using the functions that
  start with "gz". The gzip format is different from the zlib format.
  gzip is a gzip wrapper, documented in RFC 1952, wrapped around a
  deflate stream. */

typedef struct gzFile_s *gzFile; /* semi-opaque gzip file descriptor */

/**
 * Opens a gzip (.gz) file for reading or writing.
 *
 * The mode parameter is as in fopen ("rb" or "wb") but can also include
 * a compression level ("wb9") or a strategy: 'f' for filtered data as
 * in "wb6f", 'h' for Huffman-only compression as in "wb1h", 'R' for
 * run-length encoding as in "wb1R", or 'F' for fixed code compression
 * as in "wb9F". (See the description of deflateInit2 for more
 * information about the strategy parameter.) 'T' will request
 * transparent writing or appending with no compression and not using
 * the gzip format.
 *
 * "a" can be used instead of "w" to request that the gzip stream that
 * will be written be appended to the file. "+" will result in an error,
 * since reading and writing to the same gzip file is not supported. The
 * addition of "x" when writing will create the file exclusively, which
 * fails if the file already exists. On systems that support it, the
 * addition of "e" when reading or writing will set the flag to close
 * the file on an execve() call.
 *
 * These functions, as well as gzip, will read and decode a sequence of
 * gzip streams in a file. The append function of gzopen() can be used
 * to create such a file. (Also see gzflush() for another way to do
 * this.) When appending, gzopen does not test whether the file begins
 * with a gzip stream, nor does it look for the end of the gzip streams
 * to begin appending. gzopen will simply append a gzip stream to the
 * existing file.
 *
 * gzopen can be used to read a file which is not in gzip format; in
 * this case gzread will directly read from the file without
 * decompression. When reading, this will be detected automatically by
 * looking for the magic two- byte gzip header.
 *
 * @return Z_OK if the file could not be opened, if there was insufficient
 *     memory to allocate the gzFile state, or if an invalid mode was
 *     specified (an 'r', 'w', or 'a' was not provided, or '+' was
 *     provided). errno can be checked to determine if the reason gzopen
 *     failed was that the file could not be opened.
 */
gzFile gzopen(const char *path, const char *mode);

/**
 * Associates gzFile with the file descriptor.
 *
 * File descriptors are obtained from calls like open, dup, creat, pipe
 * or fileno (if the file has been previously opened with fopen). The
 * mode parameter is as in gzopen.
 *
 * The next call of gzclose on the returned gzFile will also close the file
 * descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
 * fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
 * mode);.  The duplicated descriptor should be saved to avoid a leak, since
 * gzdopen does not close fd if it fails.  If you are using fileno() to get the
 * file descriptor from a FILE *, then you will have to use dup() to avoid
 * double-close()ing the file descriptor.  Both gzclose() and fclose() will
 * close the associated file descriptor, so they need to have different file
 * descriptors.
 *
 * @return Z_OK if there was insufficient memory to allocate the gzFile
 *     state, if an invalid mode was specified (an 'r', 'w', or 'a' was
 *     not provided, or '+' was provided), or if fd is -1. The file
 *     descriptor is not used until the next gz* read, write, seek, or
 *     close operation, so gzdopen will not detect if fd is invalid
 *     (unless fd is -1).
 */
gzFile gzdopen(int fd, const char *mode);

/**
 * Sets internal buffer size used by this library's functions. The
 * default buffer size is 8192 bytes. This function must be called after
 * gzopen() or gzdopen(), and before any other calls that read or write
 * the file. The buffer memory allocation is always deferred to the
 * first read or write. Three times that size in buffer space is
 * allocated. A larger buffer size of, for example, 64K or 128K bytes
 * will noticeably increase the speed of decompression (reading).
 *
 * The new buffer size also affects the maximum length for gzprintf().
 *
 * @return Z_OK on success, or -1 on failure, such as being called too
 *     late.
 */
int gzbuffer(gzFile file, unsigned size);

/**
 * Dynamically update the compression level or strategy.  See the description
 * of deflateInit2 for the meaning of these parameters.  Previously provided
 * data is flushed before the parameter change.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if the file was not opened for
 *     writing, Z_ERRNO if there is an error writing the flushed data,
 *     or Z_MEM_ERROR if there is a memory allocation error.
 */
int gzsetparams(gzFile file, int level, int strategy);

/**
 * Reads given number of uncompressed bytes from the compressed file. If
 * the input file is not in gzip format, gzread copies the given number
 * of bytes into the buffer directly from the file.
 *
 * After reaching the end of a gzip stream in the input, gzread will continue
 * to read, looking for another gzip stream.  Any number of gzip streams may be
 * concatenated in the input file, and will all be decompressed by gzread().
 * If something other than a gzip stream is encountered after a gzip stream,
 * that remaining trailing garbage is ignored (and no error is returned).
 *
 * gzread can be used to read a gzip file that is being concurrently written.
 * Upon reaching the end of the input, gzread will return with the available
 * data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
 * gzclearerr can be used to clear the end of file indicator in order to permit
 * gzread to be tried again.  Z_OK indicates that a gzip stream was completed
 * on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
 * middle of a gzip stream.  Note that gzread does not return -1 in the event
 * of an incomplete gzip stream.  This error is deferred until gzclose(), which
 * will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
 * stream.  Alternatively, gzerror can be used before gzclose to detect this
 * case.
 *
 * @return Z_OK number of uncompressed bytes actually read, less than
 *     len for end of file, or -1 for error. If len is too large to fit
 *     in an int, then nothing is read, -1 is returned, and the error
 *     state is set to Z_STREAM_ERROR.
 */
int gzread(gzFile file, voidp buf, unsigned len);

/**
 * Read up to nitems items of size size from file to buf, otherwise operating
 * as gzread() does.  This duplicates the interface of stdio's fread(), with
 * size_t request and return types.  If the library defines size_t, then
 * size_t is identical to size_t.  If not, then size_t is an unsigned
 * integer type that can contain a pointer.
 *
 * gzfread() returns the number of full items read of size size, or zero if
 * the end of the file was reached and a full item could not be read, or if
 * there was an error.  gzerror() must be consulted if zero is returned in
 * order to determine if there was an error.  If the multiplication of size and
 * nitems overflows, i.e. the product does not fit in a size_t, then nothing
 * is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
 *
 * In the event that the end of file is reached and only a partial item is
 * available at the end, i.e. the remaining uncompressed data length is not a
 * multiple of size, then the final partial item is nevetheless read into buf
 * and the end-of-file flag is set.  The length of the partial item read is not
 * provided, but could be inferred from the result of gztell().  This behavior
 * is the same as the behavior of fread() implementations in common libraries,
 * but it prevents the direct use of gzfread() to read a concurrently written
 * file, reseting and retrying on end-of-file, when size is not 1.
 */
size_t gzfread(voidp buf, size_t size, size_t nitems, gzFile file);

/**
 * Writes given number of uncompressed bytes into the compressed file.
 * gzwrite returns the number of uncompressed bytes written or 0 in case
 * of error.
 */
int gzwrite(gzFile file, voidpc buf, unsigned len);

/**
 * Writes nitems items of size size from buf to file, duplicating the
 * interface of stdio's fwrite(), with size_t request and return types.
 * If the library defines size_t, then size_t is identical to size_t. If
 * not, then size_t is an unsigned integer type that can contain a
 * pointer.
 *
 * gzfwrite() returns the number of full items written of size size, or zero
 * if there was an error.  If the multiplication of size and nitems overflows,
 * i.e. the product does not fit in a size_t, then nothing is written, zero
 * is returned, and the error state is set to Z_STREAM_ERROR.
 */
size_t gzfwrite(voidpc buf, size_t size, size_t nitems, gzFile file);

/**
 * Converts, formats, and writes the arguments to the compressed file
 * under control of the format string, as in fprintf. gzprintf returns
 * the number of uncompressed bytes actually written, or a negative zlib
 * error code in case of error. The number of uncompressed bytes written
 * is limited to 8191, or one less than the buffer size given to
 * gzbuffer(). The caller should assure that this limit is not exceeded.
 * If it is exceeded, then gzprintf() will return an error (0) with
 * nothing written. In this case, there may also be a buffer overflow
 * with unpredictable consequences, which is possible only if zlib was
 * compiled with the insecure functions sprintf() or vsprintf() because
 * the secure snprintf() or vsnprintf() functions were not available.
 * This can be determined using zlibCompileFlags().
 */
int gzprintf(gzFile file, const char *format, ...);

/**
 * Writes the given null-terminated string to the compressed file, excluding
 * the terminating null character.
 *
 * @return Z_OK number of characters written, or -1 in case of error.
 */
int gzputs(gzFile file, const char *s);

/**
 * Reads bytes from the compressed file until len-1 characters are read,
 * or a newline character is read and transferred to buf, or an
 * end-of-file condition is encountered. If any characters are read or
 * if len == 1, the string is terminated with a null character. If no
 * characters are read due to an end-of-file or len < 1, then the buffer
 * is left untouched.
 *
 * @return buf which is a null-terminated string, or it returns NULL for
 *     end-of-file or in case of error. If there was an error, the
 *     contents at buf are indeterminate.
 */
char *gzgets(gzFile file, char *buf, int len);

/**
 * Writes character converted to an unsigned char into compressed file.
 * @return value that was written, or -1 on error
 */
int gzputc(gzFile file, int c);

/**
 * Reads one byte from the compressed file. gzgetc returns this byte or
 * -1 in case of end of file or error. This is implemented as a macro
 * for speed. As such, it does not do all of the checking the other
 * functions do. I.e. it does not check to see if file is NULL, nor
 * whether the structure file points to has been clobbered or not.
 */
int gzgetc(gzFile file);

/**
 * Pushes one character back onto the stream to be read as the first
 * character on the next read. At least one character of push-back is
 * allowed. gzungetc() returns the character pushed, or -1 on failure.
 * gzungetc() will fail if c is -1, and may fail if a character has been
 * pushed but not read yet. If gzungetc is used immediately after gzopen
 * or gzdopen, at least the output buffer size of pushed characters is
 * allowed. (See gzbuffer above.) The pushed character will be discarded
 * if the stream is repositioned with gzseek() or gzrewind().
 */
int gzungetc(int c, gzFile file);

/**
 * Flushes all pending output into the compressed file. The parameter
 * flush is as in the deflate() function. The return value is the zlib
 * error number (see function gzerror below). gzflush is only permitted
 * when writing.
 *
 * If the flush parameter is Z_FINISH, the remaining data is written and
 * the gzip stream is completed in the output. If gzwrite() is called
 * again, a new gzip stream will be started in the output. gzread() is
 * able to read such concatenated gzip streams.
 *
 * gzflush should be called only when strictly necessary because it will
 * degrade compression if called too often.
 */
int gzflush(gzFile file, int flush);

/**
 * Sets starting position for the next gzread or gzwrite on the given
 * compressed file. The offset represents a number of bytes in the
 * uncompressed data stream. The whence parameter is defined as in
 * lseek(2); the value SEEK_END is not supported.
 *
 * If the file is opened for reading, this function is emulated but can be
 * extremely slow.  If the file is opened for writing, only forward seeks are
 * supported; gzseek then compresses a sequence of zeroes up to the new
 * starting position.
 *
 * @return resulting offset location as measured in bytes from the
 *     beginning of the uncompressed stream, or -1 in case of error, in
 *     particular if the file is opened for writing and the new starting
 *     position would be before the current position.
 */
ssize_t gzseek(gzFile file, int64_t offset, int whence);

/**
 * Rewinds file.
 *
 * This function is supported only for reading.
 *
 * @note gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
 */
int gzrewind(gzFile file);

/**
 * Returns starting position for the next gzread or gzwrite on the given
 * compressed file. This position represents a number of bytes in the
 * uncompressed data stream, and is zero when starting, even if
 * appending or reading a gzip stream from the middle of a file using
 * gzdopen().
 *
 * @note gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
 */
ssize_t gztell(gzFile file);

/**
 * Returns current offset in the file being read or written. This offset
 * includes the count of bytes that precede the gzip stream, for example
 * when appending or when using gzdopen() for reading. When reading, the
 * offset does not include as yet unused buffered input. This
 * information can be used for a progress indicator. On error,
 * gzoffset() returns -1.
 */
ssize_t gzoffset(gzFile file);

/**
 * Returns true (1) if the end-of-file indicator has been set while
 * reading, false (0) otherwise. Note that the end-of-file indicator is
 * set only if the read tried to go past the end of the input, but came
 * up short. Therefore, just like feof(), gzeof() may return false even
 * if there is no more data to read, in the event that the last read
 * request was for the exact number of bytes remaining in the input
 * file. This will happen if the input file size is an exact multiple of
 * the buffer size.
 *
 * If gzeof() returns true, then the read functions will return no more
 * data, unless the end-of-file indicator is reset by gzclearerr() and
 * the input file has grown since the previous end of file was detected.
 */
int gzeof(gzFile file);

/**
 * Returns true (1) if file is being copied directly while reading, or
 * false (0) if file is a gzip stream being decompressed.
 *
 * If the input file is empty, gzdirect() will return true, since the
 * input does not contain a gzip stream.
 *
 * If gzdirect() is used immediately after gzopen() or gzdopen() it will
 * cause buffers to be allocated to allow reading the file to determine
 * if it is a gzip file. Therefore if gzbuffer() is used, it should be
 * called before gzdirect().
 *
 * When writing, gzdirect() returns true (1) if transparent writing was
 * requested ("wT" for the gzopen() mode), or false (0) otherwise.
 * (Note: gzdirect() is not needed when writing. Transparent writing
 * must be explicitly requested, so the application already knows the
 * answer. When linking statically, using gzdirect() will include all of
 * the zlib code for gzip file reading and decompression, which may not
 * be desired.)
 */
int gzdirect(gzFile file);

/**
 * Flushes all pending output if necessary, closes the compressed file
 * and deallocates the (de)compression state. Note that once file is
 * closed, you cannot call gzerror with file, since its structures have
 * been deallocated. gzclose must not be called more than once on the
 * same file, just as free must not be called more than once on the same
 * allocation.
 *
 * @return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a file
 *     operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
 *     last read ended in the middle of a gzip stream, or Z_OK on
 *     success.
 */
int gzclose(gzFile file);

/**
 * Same as gzclose(), but gzclose_r() is only for use when reading, and
 * gzclose_w() is only for use when writing or appending. The advantage
 * to using these instead of gzclose() is that they avoid linking in
 * zlib compression or decompression code that is not used when only
 * reading or only writing respectively. If gzclose() is used, then both
 * compression and decompression code will be included the application
 * when linking to a static zlib library.
 */
int gzclose_r(gzFile file);
int gzclose_w(gzFile file);

/**
 * Returns the error message for the last error which occurred on the given
 * compressed file.  errnum is set to zlib error number.  If an error occurred
 * in the file system and not in the compression library, errnum is set to
 * Z_ERRNO and the application may consult errno to get the exact error code.
 *
 * The application must not modify the returned string.  Future calls to
 * this function may invalidate the previously returned string.  If file is
 * closed, then the string previously returned by gzerror will no longer be
 * available.
 *
 * gzerror() should be used to distinguish errors from end-of-file for those
 * functions above that do not distinguish those cases in their return values.
 */
const char *gzerror(gzFile file, int *errnum);

/**
 * Clears the error and end-of-file flags for file.  This is analogous to the
 * clearerr() function in stdio.  This is useful for continuing to read a gzip
 * file that is being written concurrently.
 */
void gzclearerr(gzFile file);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » checksums                                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/**
 * Updates running Adler-32 checksum with the bytes buf[0..len-1] and
 * return the updated checksum. If buf is Z_NULL, this function returns
 * the required initial value for the checksum.
 */
uLong adler32(uLong adler, const Bytef *buf, uInt len);

/**
 * Same as adler32(), but with a size_t length.
 */
uLong adler32_z(uLong adler, const Bytef *buf, size_t len);

/**
 * Combine two Adler-32 checksums into one. For two sequences of bytes,
 * seq1 and seq2 with lengths len1 and len2, Adler-32 checksums were
 * calculated for each, adler1 and adler2. adler32_combine() returns the
 * Adler-32 checksum of seq1 and seq2 concatenated, requiring only
 * adler1, adler2, and len2. Note that the off_t type (like off_t) is a
 * signed integer. If len2 is negative, the result has no meaning or
 * utility.
 */
uLong adler32_combine(uLong adler1, uLong adler2, int64_t len2);

/**
 * Update a running CRC-32 with the bytes buf[0..len-1] and return the
 * updated CRC-32.  If buf is Z_NULL, this function returns the required
 * initial value for the crc.  Pre- and post-conditioning (one's complement) is
 * performed within this function so it shouldn't be done by the application.
 *
 * Usage example:
 *
 *     uLong crc = crc32(0L, Z_NULL, 0);
 *     while (read_buffer(buffer, length) != EOF) {
 *       crc = crc32(crc, buffer, length);
 *     }
 *     if (crc != original_crc) error();
 */
uLong crc32(uLong crc, const Bytef *buf, uInt len);

/**
 * Combine two CRC-32 check values into one. For two sequences of bytes,
 * seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
 * calculated for each, crc1 and crc2. crc32_combine() returns the
 * CRC-32 check value of seq1 and seq2 concatenated, requiring only
 * crc1, crc2, and len2.
 */
uLong crc32_combine(uLong crc1, uLong crc2, int64_t len2);

/**
 * gzgetc() macro and its supporting function and exposed data
 * structure. Note that the real internal state is much larger than the
 * exposed structure. This abbreviated structure exposes just enough for
 * the gzgetc() macro. The user should not mess with these exposed
 * elements, since their names or behavior could change in the future,
 * perhaps even capriciously. They can only be used by the gzgetc()
 * macro. You have been warned.
 */
struct gzFile_s {
  unsigned have;
  unsigned char *next;
  int64_t pos;
};

int gzgetc_(gzFile file); /* backward compatibility */
#ifdef Z_PREFIX_SET
#undef z_gzgetc
#define z_gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#elif defined(Z_CR_PREFIX_SET)
#undef gzgetc
#define gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (Cr_z_gzgetc)(g))
#else
#define gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#endif

/* undocumented functions */
const char *zError(int);
int inflateSyncPoint(z_streamp);
int inflateUndermine(z_streamp, int);
int inflateValidate(z_streamp, int);
unsigned long inflateCodesUsed(z_streamp);
int inflateResetKeep(z_streamp);
int deflateResetKeep(z_streamp);
int gzvprintf(gzFile file, const char *format, va_list va);
void inflate_fast_chunk(z_streamp strm, unsigned start);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/regex/regex.h */

#define COSMOPOLITAN_LIBC_REGEX_REGEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if 0
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § regular expressions                                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#endif

#define REG_EXTENDED 1
#define REG_ICASE    2
#define REG_NEWLINE  4
#define REG_NOSUB    8

#define REG_NOTBOL 1 /* ^ should not match beginning of string */
#define REG_NOTEOL 2 /* $ should not match end of string */

#define REG_OK       0
#define REG_NOMATCH  1
#define REG_BADPAT   2
#define REG_ECOLLATE 3
#define REG_ECTYPE   4
#define REG_EESCAPE  5
#define REG_ESUBREG  6
#define REG_EBRACK   7
#define REG_EPAREN   8
#define REG_EBRACE   9
#define REG_BADBR    10
#define REG_ERANGE   11
#define REG_ESPACE   12
#define REG_BADRPT   13

#define REG_ENOSYS -1

typedef long regoff_t;

struct PosixRegex {
  size_t re_nsub;
  void *__opaque, *__padding[4];
  size_t __nsub2;
  char __padding2;
};

struct PosixRegexMatch {
  regoff_t rm_so;
  regoff_t rm_eo;
};

typedef struct PosixRegex regex_t;
typedef struct PosixRegexMatch regmatch_t;

int regcomp(regex_t *, const char *, int);
int regexec(const regex_t *, const char *, size_t, regmatch_t *, int);
size_t regerror(int, const regex_t *, char *, size_t);
void regfree(regex_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#endif /* COSMOPOLITAN_H_ */
